<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>01.Swagger2--学习笔记</title>
    <link href="/2020/07/12/Swagger--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/12/Swagger--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Swagger2–学习笔记-包含Swagger视频"><a href="#Swagger2–学习笔记-包含Swagger视频" class="headerlink" title="Swagger2–学习笔记(包含Swagger视频)"></a>Swagger2–学习笔记(包含Swagger视频)</h1><h2 id="Lesson1-Swagger2概述"><a href="#Lesson1-Swagger2概述" class="headerlink" title="Lesson1 Swagger2概述"></a>Lesson1 Swagger2概述</h2><h3 id="NO1-1-Swagger2简介"><a href="#NO1-1-Swagger2简介" class="headerlink" title="NO1.1 Swagger2简介"></a>NO1.1 Swagger2简介</h3><p>Swagger2文档生成工具，是我们写代码的时候，解决前后端交互同步的一个重要工具。</p><ul><li><p>Swagger2：</p><ul><li>介绍：公司中前后端有时候交互的同步，并不是很理想，通过Swagger2规范，你只需要按照它的规范去定义接口及接口相关的信息；再通过Swagger2衍生出来的一系列项目和工具，就可以做到生成各种格式的接口文档，生成多种语言的客户端和服务端的代码，以及在线接口调试页面等等；</li><li>优点：<ul><li>支持多语言；<code>如，Java、PHP等等</code>；</li><li>可以直接运行，达到在线测试API接口；</li><li>RESTful API文档的在线生成，可以保持API文档和API定义的同步更新；</li></ul></li></ul></li></ul><ul><li><p>入门案例：</p><ul><li><p>基本步骤：</p><ul><li><p>创建基于SpringBoot的Maven项目，然后导入Swagger2依赖；</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>编写一个controller；</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> </span>&#123;<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"hello"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessage</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"hello world"</span>;&#125;&#125;</code></pre></li><li><p>编写一个Swagger2的配置类，配置类中使用注解@EnableSwagger2，该注解的作用就是开启Swagger2；</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableSwagger</span>2  <span class="hljs-comment">//开启Swagger2</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConf</span> </span>&#123;&#125;</code></pre></li><li><p>开启项目跑起来，输入<code>http://localhost:8080/swagger-ui.html</code>，就可以访问到swagger2的文档页面了。</p><p><img src="Swagger--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Image-swa1.png" srcset="/img/loading.gif" alt="image-20200712150113887"></p></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson2-Swagger2基础"><a href="#Lesson2-Swagger2基础" class="headerlink" title="Lesson2 Swagger2基础"></a>Lesson2 Swagger2基础</h2><h3 id="NO2-1-Swagger2配置"><a href="#NO2-1-Swagger2配置" class="headerlink" title="NO2.1 Swagger2配置"></a>NO2.1 Swagger2配置</h3><ul><li><p>Swagger2详细配置：</p><ul><li><p>配置Swagger2的UI界面信息：</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableSwagger</span>2  <span class="hljs-comment">//开启Swagger2</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConf</span> </span>&#123;        <span class="hljs-comment">//核心配置信息</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">getDocket</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)            .apiInfo(apiInfo());  <span class="hljs-comment">//配置Swagger2的ui界面的一些信息</span>    &#125;<span class="hljs-comment">//返回一个ApiInfo对象，该对象中就包含了Swagger2的ui界面的一些配置信息</span><span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfo(<span class="hljs-string">"marrycode"</span>,  <span class="hljs-comment">//标题</span><span class="hljs-string">"xxgc_hui"</span>, <span class="hljs-comment">//描述信息</span><span class="hljs-string">"1.0"</span>,  <span class="hljs-comment">//版本号</span><span class="hljs-string">"http://www.baidu.com"</span>,  <span class="hljs-comment">//一个url</span><span class="hljs-keyword">new</span> Contact(<span class="hljs-string">"作者"</span>,<span class="hljs-string">"url"</span>,<span class="hljs-string">"邮箱"</span>),  <span class="hljs-comment">//作者信息，需要new一个Contact对象</span><span class="hljs-string">""</span>,  <span class="hljs-comment">//这个可以写空字符串</span><span class="hljs-string">""</span>,  <span class="hljs-comment">//这个可以写空字符串</span><span class="hljs-keyword">new</span> ArrayList());  <span class="hljs-comment">//这两个可以new一个List即可</span>&#125;&#125;</code></pre></li><li><p>配置Swagger2的接口扫描：</p><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@EnableSwagger2</span>  <span class="hljs-comment">//开启Swagger2</span>public class SwaggerConf &#123;        <span class="hljs-comment">//返回一个ApiInfo对象，该对象中就包含了Swagger2的ui界面的一些配置信息</span><span class="hljs-selector-tag">private</span> <span class="hljs-selector-tag">ApiInfo</span> <span class="hljs-selector-tag">apiInfo</span>()&#123;<span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">ApiInfo</span>(<span class="hljs-string">"marrycode"</span>,  <span class="hljs-comment">//标题</span><span class="hljs-string">"xxgc_hui"</span>, <span class="hljs-comment">//描述信息</span><span class="hljs-string">"1.0"</span>,  <span class="hljs-comment">//版本号</span><span class="hljs-string">"http://www.baidu.com"</span>,  <span class="hljs-comment">//一个url</span>new Contact(<span class="hljs-string">"作者"</span>,<span class="hljs-string">"url"</span>,<span class="hljs-string">"邮箱"</span>),  <span class="hljs-comment">//作者信息，需要new一个Contact对象</span><span class="hljs-string">""</span>,  <span class="hljs-comment">//这个可以写空字符串</span><span class="hljs-string">""</span>,  <span class="hljs-comment">//这个可以写空字符串</span>new ArrayList());  <span class="hljs-comment">//这两个可以new一个List即可</span>&#125;        <span class="hljs-comment">//核心配置信息</span>    @<span class="hljs-selector-tag">Bean</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">Docket</span> <span class="hljs-selector-tag">getDocket</span>()&#123;        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">Docket</span>(DocumentationType.SWAGGER_2)            <span class="hljs-selector-class">.apiInfo</span>(apiInfo())  <span class="hljs-comment">//配置Swagger2的ui界面的一些信息</span>            <span class="hljs-selector-class">.select</span>()  <span class="hljs-comment">//配置接口扫描的前提方法</span>            <span class="hljs-selector-class">.apis</span>(RequestHandlerSelectors   <span class="hljs-comment">//配置要给哪些类生成接口文档</span>          .basePackage(<span class="hljs-string">"cn.dyf.controller"</span>))            <span class="hljs-selector-class">.paths</span>(PathSelectors.ant(<span class="hljs-string">"/xxx/xxx"</span>))  <span class="hljs-comment">//为指定访问路径下的类生成接口文档</span>            <span class="hljs-selector-class">.build</span>();  <span class="hljs-comment">//配置完成后，构建Docket对象</span>    &#125;&#125;说明：一、<span class="hljs-selector-tag">RequestHandlerSelectors</span>有以下几个参数：<span class="hljs-selector-tag">1</span><span class="hljs-selector-class">.basePackage</span>()：指定要扫描的包；<span class="hljs-selector-tag">2</span><span class="hljs-selector-class">.any</span>()：扫描全部；<span class="hljs-selector-tag">3</span><span class="hljs-selector-class">.none</span>()：不扫描；<span class="hljs-selector-tag">4</span><span class="hljs-selector-class">.withClassAnnotation</span>：扫描类上的注解，参数是一个注解的反射对象；<span class="hljs-selector-tag">5</span><span class="hljs-selector-class">.withMethodAnnotation</span>：扫描方法上的注解。二、<span class="hljs-selector-tag">PathSelectors</span>参数有以下几个参数：<span class="hljs-selector-tag">1</span><span class="hljs-selector-class">.ant</span>()：扫描指定访问路径；<span class="hljs-selector-tag">2</span><span class="hljs-selector-class">.any</span>()：扫描全部访问路径；<span class="hljs-selector-tag">3</span><span class="hljs-selector-class">.none</span>()：不扫描访问路径；<span class="hljs-selector-tag">4</span><span class="hljs-selector-class">.regex</span>()：扫描符合正则表达式的路径。</code></pre></li><li><p>配置Swagger2的生效环境：</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableSwagger</span>2  <span class="hljs-comment">//开启Swagger2</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConf</span> </span>&#123;        <span class="hljs-comment">//返回一个ApiInfo对象，该对象中就包含了Swagger2的ui界面的一些配置信息</span><span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfo(<span class="hljs-string">"marrycode"</span>,  <span class="hljs-comment">//标题</span><span class="hljs-string">"xxgc_hui"</span>, <span class="hljs-comment">//描述信息</span><span class="hljs-string">"1.0"</span>,  <span class="hljs-comment">//版本号</span><span class="hljs-string">"http://www.baidu.com"</span>,  <span class="hljs-comment">//一个url</span><span class="hljs-keyword">new</span> Contact(<span class="hljs-string">"作者"</span>,<span class="hljs-string">"url"</span>,<span class="hljs-string">"邮箱"</span>),  <span class="hljs-comment">//作者信息，需要new一个Contact对象</span><span class="hljs-string">""</span>,  <span class="hljs-comment">//这个可以写空字符串</span><span class="hljs-string">""</span>,  <span class="hljs-comment">//这个可以写空字符串</span><span class="hljs-keyword">new</span> ArrayList());  <span class="hljs-comment">//这两个可以new一个List即可</span>&#125;        <span class="hljs-comment">//核心配置信息</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">getDocket</span><span class="hljs-params">(Environment environment)</span></span>&#123;        <span class="hljs-comment">//设置Swagger2生效时的环境</span>    Profiles profiles = <span class="hljs-keyword">new</span> Profiles.of(<span class="hljs-string">""</span>dev,<span class="hljs-string">"test"</span>);         <span class="hljs-comment">//通过environment对象的方法判断当前SpringBoot的环境是哪个环境</span>    <span class="hljs-keyword">boolean</span> flag = environment.acceptsProfiles(profiles);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)            .apiInfo(apiInfo())  <span class="hljs-comment">//配置Swagger2的ui界面的一些信息</span>            .enable(flag)  <span class="hljs-comment">//配置是否开启Swagger2，默认是true</span>            .select()  <span class="hljs-comment">//配置接口扫描的前提方法</span>            .apis(RequestHandlerSelectors   <span class="hljs-comment">//配置要给哪些类生成接口文档</span>          .basePackage(<span class="hljs-string">"cn.dyf.controller"</span>))            .paths(PathSelectors.ant(<span class="hljs-string">"/xxx/xxx"</span>))  <span class="hljs-comment">//为指定访问路径下的类生成接口文档</span>            .build();  <span class="hljs-comment">//配置完成后，构建Docket对象</span>    &#125;&#125;说明：设置是否开启Swagger2，调用enable()方法，该方法默认是<span class="hljs-keyword">true</span>；另外，如果想要根据当前SpringBoot的运行环境来决定Swagger2是否生效，可以使用environment的acceptsProfiles()方法来设置Swagger2生效的环境。</code></pre></li><li><p>配置Swagger2的分组：</p><ul><li>只要创建不同的Docket对象，然后调用groupName()方法即可；</li></ul><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableSwagger</span>2  <span class="hljs-comment">//开启Swagger2</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConf</span> </span>&#123;        <span class="hljs-comment">//核心配置信息</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">getDocket</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)        .groupName(<span class="hljs-string">"a"</span>));  <span class="hljs-comment">//配置Swagger2的组名为a</span>    &#125;        <span class="hljs-comment">//核心配置信息</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">getDocket</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)        .groupName(<span class="hljs-string">"b"</span>));  <span class="hljs-comment">//配置Swagger2的组名为b</span>    &#125;<span class="hljs-comment">//核心配置信息</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">getDocket</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)        .groupName(<span class="hljs-string">"c"</span>));  <span class="hljs-comment">//配置Swagger2的组名为c</span>    &#125;&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-2-Swagger2注解"><a href="#NO2-2-Swagger2注解" class="headerlink" title="NO2.2 Swagger2注解"></a>NO2.2 Swagger2注解</h3><ul><li><p>常用的Swagger2注解：</p><p><img src="Swagger--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Image-swa2.png" srcset="/img/loading.gif" alt="image-20200712170425839"></p><pre><code class="hljs java"><span class="hljs-comment">//实体类</span><span class="hljs-meta">@ApiModel</span>(<span class="hljs-string">"用户实体类"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>&#123;<span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"用户姓名"</span>)<span class="hljs-keyword">private</span> String name;<span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"用户年龄"</span>)<span class="hljs-keyword">private</span> Integer age;&#125;说明：只要调用的Controller方法中有返回User类，那么Swagger生成的文档中相应的Controller方法的返回值就会有中文解释    <span class="hljs-comment">//---------------------------------------</span>    <span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> </span>&#123;    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"获取信息的方法"</span>)  <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"hello"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessage</span><span class="hljs-params">(@ApiParam(<span class="hljs-string">"这是xx参数"</span>)</span> String name)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"hello world"</span>;&#125;&#125;    说明：<span class="hljs-meta">@ApiOperation</span>注解用于方法上，解释说明该方法的用途；而<span class="hljs-meta">@ApiParam</span>注解则是说明参数。</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>5.다른 과정</category>
      
      <category>11.API接口框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swagger2</tag>
      
      <tag>接口文档</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01.ZooKeeper--学习笔记</title>
    <link href="/2020/07/12/ZooKeeper--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/12/ZooKeeper--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="ZooKeeper–学习笔记-包含ZooKeeper视频"><a href="#ZooKeeper–学习笔记-包含ZooKeeper视频" class="headerlink" title="ZooKeeper–学习笔记(包含ZooKeeper视频)"></a>ZooKeeper–学习笔记(包含ZooKeeper视频)</h1><h2 id="Lesson1-ZooKeeper概述"><a href="#Lesson1-ZooKeeper概述" class="headerlink" title="Lesson1 ZooKeeper概述"></a>Lesson1 ZooKeeper概述</h2><h3 id="NO1-1-ZooKeeper简介"><a href="#NO1-1-ZooKeeper简介" class="headerlink" title="NO1.1 ZooKeeper简介"></a>NO1.1 ZooKeeper简介</h3><p>如果你没有学习过Spring Cloud的话，那么就简单的理解为ZooKeeper是一个服务注册中心，类似于我们生活中的工商注册中心。</p><ul><li>ZooKeeper<ul><li>介绍：ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件；它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等；</li><li>目标：ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户；</li><li>优点：<ul><li>作为一个中间件，提供协调服务；</li><li>支持Java 和 C语言；</li><li>作用于分布式系统，发挥其优势，可为大数据服务等等；</li></ul></li><li>特点：<ul><li>一致性：数据一致性，数据按顺序分批入库；</li><li>原子性：事务要么都成功，要么都失败，不会局部化；</li><li>单一视图：客户端连接集群中的任一zk节点，数据都是一致的；</li><li>可靠性：每次对zk的操作状态都保存在服务器中；</li><li>实时性：客户端可以读取zk服务端的最新数据；</li></ul></li><li>基本数据模型：<ul><li>ZooKeeper的数据模型是一个树形结构；</li><li>每一个节点都称之为<code>Znode</code>；节点分为两种，即临时节点和永久节点；</li><li>每个Znode节点都有各自的版本号；每当节点数据发生变化，那么该节点的版本号会累加；</li><li>每个节点存储的数据不宜过大，默认存储1MB数据；</li><li>节点可以设置权限acl，可以通过权限来限制用户访问；</li></ul></li><li>应用：<ul><li>master节点选举：主节点挂了以后，从节点就会接手工作，并且保证这个节点是唯一的，这也是所谓的首脑模式，从而保证我们的集群是高可用的；</li><li>统一配置文件管理：即只需要部署一台服务器，则可以把相同的配置文件同步更新到其他所有服务器，该操作在云计算中应用广泛；</li><li>发布与订阅：类似消息队列MQ，Dubbo发布者把数据存在Znode上，订阅者会读取这个数据；</li><li>提供分布式锁：分布式环境中不同进程之间争夺资源，类似于多线程的锁；</li><li>集群管理：集群中保证数据的强一致性；</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>分布式系统理解：通俗易懂的讲，就是一个大系统拆分成多个小系统分散到不同的设备上。</p><p><img src="./Image-z1.png" srcset="/img/loading.gif" alt="image-20200712092603254"></p></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-2-ZooKeeper安装与配置"><a href="#NO1-2-ZooKeeper安装与配置" class="headerlink" title="NO1.2 ZooKeeper安装与配置"></a>NO1.2 ZooKeeper安装与配置</h3><p>zk的安装和配置都比较简单。</p><ul><li><p>安装与配置：</p><ul><li><p>Windows：</p><ul><li><p>到官网下载自己想要下载的zk版本即可；</p></li><li><p>下载完成后，然后解压zk安装包；</p></li><li><p>找到解压目录中的conf目录，并在conf目录中找到zoo_sample.cfg配置文件，重命名为zoo.cfg；</p></li><li><p>进入zoo.cfg文件，简单配置数据文件目录和日志文件目录：即自定义设置数据文件目录和日志文件目录；</p><p><img src="./Image-z2.png" srcset="/img/loading.gif" alt="image-20200712094129383"></p></li><li><p>到此zk的安装和简单的就配置完成，可以启动了，但是前提是必须安装了JDK，因为zk是建立在Java平台上的；</p></li><li><p>使用命令行，进入zk安装目录中的bin目录，找到zkServer.cmd并运行即可。</p></li></ul></li><li><p>Linux：</p><ul><li>到官网下载自己想要下载的zk版本即可，但要注意Linux版本的安装包最好为tar.gz后缀的安装包；</li><li>下载完成后，上传到Linux中，解压zk安装包；</li><li>找到解压目录中的conf目录，并在conf目录中找到zoo_sample.cfg配置文件，重命名为zoo.cfg；</li><li>进入zoo.cfg文件，简单配置数据文件目录和日志文件目录：即自定义设置数据文件目录和日志文件目录；</li><li>zk的安装和简单的配置就基本完成了，进入zk的安装目录，再进入bin目录，输入：<code>./zkServer start</code>命令启动zk即可。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>zoo.cfg配置内容：<ul><li><code>tickTime</code>：用于计算的时间单元；</li><li><code>initLimit</code>：用于集群，允许从节点连接并同步到master节点的初始化连接时间，以tickTime 的倍数来表示；</li><li><code>syncLimit</code>：用于集群，master主节点与 从节点 之间发送消息，请求和应答时间长度(心跳机制)；</li><li><code>dataDir</code>：存放数据文件目录，必须配置；</li><li><code>dataLogDir</code>：日志目录；</li><li><code>clientPort</code>：连接服务器的端口，默认2181；</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson2-ZooKeeper基础"><a href="#Lesson2-ZooKeeper基础" class="headerlink" title="Lesson2 ZooKeeper基础"></a>Lesson2 ZooKeeper基础</h2><h3 id="NO2-1-ZooKeeper命令"><a href="#NO2-1-ZooKeeper命令" class="headerlink" title="NO2.1 ZooKeeper命令"></a>NO2.1 ZooKeeper命令</h3><p>因为zk是建立在JDK之上的，所以我们常用Java中的命令来操作zk。</p><ul><li><p>ZooKeeper的常用命令行操作：</p><ul><li><p>Linux的zk客户端命令行；</p><pre><code class="hljs java"><span class="hljs-comment">//stat命令用于查看节点的状态信息</span>stat path [watch]      <span class="hljs-comment">//set命令用于设置节点的数据(修改节点)    </span>set path data [version]      <span class="hljs-comment">//ls命令用于获取路径下的节点信息，注意路径为绝对路径</span>ls path [watch]     <span class="hljs-comment">//delquota命令用于删除配额，-n为子节点个数，-b为节点数据长度</span>delquota [-n|-b] path<span class="hljs-comment">//ls2命令是ls命令的增强版，比ls命令多输出本节点信息</span>ls2 path [watch]    <span class="hljs-comment">//用于设置节点Acl，Acl由三部分构成：1为scheme，2为user，3为permission，一般情况下表示为scheme:id:permissions(设置权限)</span>setAcl path acl     <span class="hljs-comment">//setquota命令用于设置节点个数以及数据长度的配额</span>setquota -n|-b val path  <span class="hljs-comment">//history用于列出最近的命令历史，可以和redo配合使用</span>history      <span class="hljs-comment">//redo命令用于再次执行某个命令</span>redo cmdno          <span class="hljs-comment">//printWatchers命令用于设置和显示监视状态，值为on或则off</span>printwatches on|off    <span class="hljs-comment">//delete命令用于删除节点，如delete /nodeDelete ；(删除节点)</span>delete path [version]      <span class="hljs-comment">//sync命令用于强制同步，由于请求在半数以上的zk server上生效就表示此请求生效，那么就会有一些zk server上的数据是旧的。sync命令就是强制同步所有的更新操作</span>sync path       <span class="hljs-comment">//查看指定znode的配额</span>listquota path       <span class="hljs-comment">//递归删除</span>rmr path             <span class="hljs-comment">//查询节点：用于获取节点的信息，注意节点的路径必须是以/开头的绝对路径。如，get /</span>get path [watch]     <span class="hljs-comment">//创建节点：create命令用于创建节点，其中-s为顺序充点，-e临时节点</span>create [-s] [-e] path data acl   <span class="hljs-comment">//用于节点认证，使用方式：如，addauth digest username:password</span>addauth scheme auth  <span class="hljs-comment">//退出客户端</span>quit     <span class="hljs-comment">//查看某个节点的权限：用于获取节点的Acl，如，getAcl /node1</span>getAcl path        <span class="hljs-comment">//断开服务器连接：用于关闭与服务端的链接</span>close     <span class="hljs-comment">//连接服务器：用于连接zk服务端，与close命令配合使用可以连接或者断开zk服务端</span>connect host:port</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>返回信息的具体含义：</p><pre><code class="hljs java"><span class="hljs-comment">//节点创建时的zxid</span>cZxid = <span class="hljs-number">0x0</span><span class="hljs-comment">//节点创建时间</span>ctime = Thu Jan <span class="hljs-number">01</span> <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> CST <span class="hljs-number">1970</span>mZxid = <span class="hljs-number">0x0</span><span class="hljs-comment">//节点最近一次更新时的zxid</span><span class="hljs-comment">//节点最近一次更新的时间</span>mtime = Thu Jan <span class="hljs-number">01</span> <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> CST <span class="hljs-number">1970</span><span class="hljs-comment">//子节点的id</span>pZxid = <span class="hljs-number">0x2c</span><span class="hljs-comment">//子节点数据更新次数</span>cversion = <span class="hljs-number">10</span><span class="hljs-comment">//本节点数据更新次数</span>dataVersion = <span class="hljs-number">0</span><span class="hljs-comment">//节点ACL(授权信息)的更新次数</span>aclVersion = <span class="hljs-number">0</span><span class="hljs-comment">//如果该节点为临时节点,ephemeralOwner值表示与该节点绑定的session id；如果该节点不是临时节点,ephemeralOwner值为0</span>ephemeralOwner = <span class="hljs-number">0x0</span><span class="hljs-comment">//节点数据长度，本例中为hello world的长度</span>dataLength = <span class="hljs-number">0</span><span class="hljs-comment">//子节点个数</span>numChildren = <span class="hljs-number">10</span></code></pre></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-2-session的基本原理"><a href="#NO2-2-session的基本原理" class="headerlink" title="NO2.2 session的基本原理"></a>NO2.2 session的基本原理</h3><ul><li>基本原理：<ul><li>客户端与服务端之间的连接存在会话；</li><li>每个会话都可以设置一个超时时间；</li><li>心跳结束，session则过期；</li><li>session过期，则临时节点znode则会被抛弃；</li><li>心跳机制：客户端向服务端的ping包请求；</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-3-watcher机制"><a href="#NO2-3-watcher机制" class="headerlink" title="NO2.3 watcher机制"></a>NO2.3 watcher机制</h3><ul><li>watcher机制：<ul><li>针对每个节点的操作，都会有一个监督者-&gt;wathcer ；</li><li>当监控的某个对象(Znode)发生了变化。则触发wathcer事件；</li><li>zk中的wathcer是一次性的，触发后立即销毁；</li><li>父节点、子节点 增删改查都能够触发其wathcer ；</li><li>针对不同类型的操作，触发的wathcer事件是不同的；子节点的创建事件，子节点的删除事件，子节点数据变化事件；</li><li>ls 为父节点设置watcher，创建子节点后触发：NodeChildChanged</li><li>ls 为父节点设置watcher，删除子节点后触发：NodeChildChanged</li><li>ls 为父节点设置watcher，修改子节点后不触发事件</li><li>如果只对父节点添加watcher，子节点的增删只会触发NodeChildChanged这一个事件，且修改子节点，不会触发watcher；如果想让子节点跟父节点一样，根据不同的操作，触发的watcher事件也不相同，那么只需要对应的在具体的子节点设置watcher即可，即把子节点当成父节点；</li></ul></li></ul><p>&nbsp;</p><ul><li><p>watch的使用场景：统一资源配置；</p><p><img src="./Image-z3.png" srcset="/img/loading.gif" alt="Image"></p></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-4-ACL权限控制"><a href="#NO2-4-ACL权限控制" class="headerlink" title="NO2.4 ACL权限控制"></a>NO2.4 ACL权限控制</h3><ul><li>ACL(access control lists)权限控制：<ul><li>针对节点可以设置相关的读写等权限，目的为了保证数据安全性；</li><li>权限permissions可以指定不同的权限范围以及角色；</li><li>zk的acl通过[scheme:id:permissions]来构成权限列表；<ul><li><code>scheme</code>：代表采用的某种权限机制(4种常用，1种不常用)；<ul><li><code>world</code>：world下只有一个id，即只有一个用户，也就是anyone，那么组合的写法就是<code>world:anyone:[permissions]</code>；</li><li><code>auth</code>：代表认证登录，需要注册用户addauth后才能操作，形式为<code>auth:user:password:[permissions]</code>；</li><li><code>digest</code>：需要对密码加密才能访问，组合形式为<code>digest:username:BASE64(SHA1(password)):[permissions]</code>；<ul><li>auth/digest的区别：<ul><li>前者明文，后者密文；</li><li><code>setAcl /path auth:lee:lee:cdrwa</code>与<code>setAcl /path digest:lee:BASE64(SHA1(password)):cdrwa</code> 是等价的，在通过<code>addauth digest lee:lee</code>注册后都能操作指定节点的权限；</li></ul></li></ul></li><li><code>ip</code>：当设置为ip属性指定的ip地址，此时限制ip进行访问。如，ip:192.168.1.12:[permissions] ；</li><li>super：超级管理员，拥有所有的权限；首先只需要修改zkServer.sh增加super管理员；、重启 zkServer.sh；</li></ul></li><li><code>id</code> : 代表允许访问的用户(与scheme绑定一起使用的)；</li><li><code>permissions</code>：即权限组合字符串；权限字符串包括<code>crdwa</code>：<ul><li><code>CREATE</code>：创建子节点； </li><li><code>READ</code>：获取节点/子节点；</li><li><code>WRITE</code>：设置节点数据；</li><li><code>DELETE</code>：删除子节点；</li><li><code>ADMIN</code>：设置权限；</li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>ACL的常用使用场景；<ul><li>开发/测试环境分离，开发者无权操作测试库的节点，只能看；</li><li>生产环境上的控制指定ip的服务可以访问相关节点，防止混乱；</li></ul></li></ul><p>&nbsp;</p><h3 id="NO2-5-zk的四字命令与集群搭建"><a href="#NO2-5-zk的四字命令与集群搭建" class="headerlink" title="NO2.5 zk的四字命令与集群搭建"></a>NO2.5 zk的四字命令与集群搭建</h3><ul><li><p>ZooKeeper的四字命令；</p><ul><li><p>ZooKeeper可以通过它自身提供的简写命令来和服务器进行交互；</p></li><li><p>需要使用nc命令，安装： <code>yum install nc</code> ；</p></li><li><p>echo [command] | nc [ip] [port] ；</p></li><li><p>常用四字命令；</p><p><img src="./Image-z4.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><ul><li>ZooKeeper集群搭建；<ul><li>ZooKeeper伪集群搭建；</li><li>ZooKeeper真实环境集群搭建；<ul><li>需要注意：环境变量的配置，ip配置的不同，端口号可以相同；</li></ul></li></ul></li></ul><h3 id="NO2-6-zk的原生Java-API使用"><a href="#NO2-6-zk的原生Java-API使用" class="headerlink" title="NO2.6 zk的原生Java API使用"></a>NO2.6 zk的原生Java API使用</h3><ul><li><p>会话连接与恢复；</p><pre><code class="hljs java"><span class="hljs-comment">//使用Java创建ZooKeeper连接</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZKConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Watcher</span> </span>&#123;        <span class="hljs-comment">//想要连接的zk服务器ip地址和端口</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String zkServerPath = <span class="hljs-string">"127.0.0.1:2181"</span>;        <span class="hljs-comment">//如果要连接集群</span><span class="hljs-comment">//public static final String zkServerPath </span>    =<span class="hljs-string">"127.0.0.1:2181,127.0.0.2:2182"</span>;            <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer timeout = <span class="hljs-number">5000</span>;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 当客户端连接服务器成功后，会收到一个watch</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent event)</span> </span>&#123;                System.out.println(<span class="hljs-string">"收到来自zk的watch的通知啦"</span>);    &#125;&#125;<span class="hljs-comment">//------------------------------------------------</span><span class="hljs-comment">//打开ZK服务器，测试连接</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;        ZooKeeper zk =             <span class="hljs-keyword">new</span> ZooKeeper(ZKConnection.zkServerPath,                          ZKConnection.timeout,                           <span class="hljs-keyword">new</span> ZKConnection());        <span class="hljs-comment">//用于会话重新连接时使用，拿到本次会话的sessionId和sessionPasswd，下一次想要再连接到本次会话，只需在构造方法中添加这两个参数即可</span>        <span class="hljs-comment">//long sessionId = zk.getSessionId();</span>        <span class="hljs-comment">//byte[] sessionPasswd = zk.getSessionPasswd();</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;            Thread.sleep(<span class="hljs-number">10</span>);            System.out.println(i+<span class="hljs-string">"-------"</span>+zk.getState());        &#125;    &#125;&#125;说明：一、客户端和zk服务端的连接是一个异步的过程；二、当连接成功后，客户端会收到一个watch通知；三、构造方法的参数介绍：ZooKeeper(String connectString,<span class="hljs-keyword">int</span> sessionTimeout, Watcher watcher,<span class="hljs-keyword">long</span> sessionId, <span class="hljs-keyword">byte</span>[] sessionPasswd, <span class="hljs-keyword">boolean</span> canBeReadOnly)<span class="hljs-number">1</span>.connectString：连接服务器的ip字符串,可以是一个ip，也可以是多个ip，一个ip代表单机，多个ip代表集群，如：<span class="hljs-string">"192.168.1.1:2181,192.168.1.2:2181,192.168.1.3:2181"</span><span class="hljs-number">2</span>.sessionTimeout：超时时间，心跳收不到了，那就超时<span class="hljs-number">3</span>.watcher：通知事件，如果有对应的事件触发，则会收到一个通知：如果不需要，那就设为<span class="hljs-keyword">null</span><span class="hljs-number">4</span>.sessionId：会话的id<span class="hljs-number">5</span>.sessionPasswd：会话密码，当会话丢失后，可以依据sessionId和sessionPasswd重新获取会话<span class="hljs-number">6</span>.canBeReadOnly：可读，当这个物理机节点断开后，还是可以读到数据的，只是不能写,此时数据被读取到的可能是旧数据，一般设置为<span class="hljs-keyword">false</span>，不推荐使用</code></pre><ul><li><p>如果想要创建临时节点，则只需调用不同的构造方法即可； 如果创建永久节点，则需要额外创建一个回调函数类；</p><pre><code class="hljs java"><span class="hljs-comment">//回调函数类，用于创建永久节点用</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateNodeCallBack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">StringCallback</span></span>&#123;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rc, String path, </span></span><span class="hljs-function"><span class="hljs-params">                                Object ctx, String name)</span> </span>&#123;                System.out.println(<span class="hljs-string">"创建节点："</span> + path);        System.out.println((String)ctx);    &#125;&#125;<span class="hljs-comment">//---------------------------------------</span><span class="hljs-comment">//测试创建节点</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                ZooKeeper zk =             <span class="hljs-keyword">new</span> ZooKeeper(            ZKConnection.zkServerPath,                ZKConnection.timeout,             <span class="hljs-keyword">new</span> ZKConnection());                String ctx= <span class="hljs-string">"&#123;'create':'success'&#125;"</span>;                <span class="hljs-comment">//调用同步方法：viod create(String path,byte[] data,List&lt;Acl&gt; acl,CreateMode createMode);</span>                <span class="hljs-comment">//调用异步方法：viod create(String path,byte[] data,List&lt;ACL&gt; acl,CreateMode createMode,StringCallback cb,Object ctx);</span>                <span class="hljs-comment">//异步创建节点</span>        zk.create(<span class="hljs-string">"/dyf/baidu"</span>, <span class="hljs-string">"baidu"</span>.getBytes(),                    Ids.OPEN_ACL_UNSAFE,                   CreateMode.PERSISTENT,                   <span class="hljs-keyword">new</span> CreateNodeCallBack(),                   ctx);                System.out.println(<span class="hljs-string">"永久节点创建成功啦"</span>);                <span class="hljs-keyword">new</span> Thread().sleep(<span class="hljs-number">2000</span>);    &#125;&#125;说明：一、<span class="hljs-function">String <span class="hljs-title">create</span><span class="hljs-params">(String path, <span class="hljs-keyword">byte</span>[] data, List&lt;ACL&gt; acl,CreateMode createMode)</span>；注意：同步或异步创建节点，都不支持子节点的递归操作，异步有一个callBack方法。</span><span class="hljs-function"></span><span class="hljs-function">二、参数解析：</span><span class="hljs-function">1.path：创建的路径</span><span class="hljs-function">    2.data：存储的数据,<span class="hljs-keyword">byte</span>[]类型</span><span class="hljs-function">    3.acl：权限控制策略</span><span class="hljs-function">    Ids.OPEN_ACL_UNSAFE ---&gt; world:anyone:crdwa</span><span class="hljs-function">        CREATE_ALL_ACL ---&gt; auth:user:password:cdrwa</span><span class="hljs-function">4.createMode：节点类型，是一个枚举</span><span class="hljs-function">    CreateMode.PERSISTENT：           持久节点</span><span class="hljs-function">        CreateMode.PERSISTENT_SEQUENTIAL：持久顺序节点</span><span class="hljs-function">        CreateMode.EPHEMERAL：            临时节点</span><span class="hljs-function">        CreateMode.EPHEMERAL_SEQUENTIAL： 临时顺序节点</span></code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>节点的删改查；</p><pre><code class="hljs java"><span class="hljs-comment">//修改节点</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                ZooKeeper zk = <span class="hljs-keyword">new</span> ZooKeeper(            ZKConnection.zkServerPath,                ZKConnection.timeout,             <span class="hljs-keyword">new</span> ZKConnection());                <span class="hljs-comment">/**</span><span class="hljs-comment">        * path：节点路径</span><span class="hljs-comment">        * data：修改后的数据</span><span class="hljs-comment">        * version:版本号，这里的版本号必须是正要修改的节点数据的版本号！！</span><span class="hljs-comment">        */</span>                <span class="hljs-comment">//使用同步方法：Stat setData(String path, byte[] data, int version)</span>                <span class="hljs-comment">//使用异步方法：setData(String path, byte[] data, int version,</span>                                        StatCallback cb, String ctx);               <span class="hljs-comment">//同步修改节点</span>        Stat stat = zk.setData(<span class="hljs-string">"/dyf/baidu"</span>, <span class="hljs-string">"baidupan"</span>.getBytes(), <span class="hljs-number">0</span>);                System.out.println(<span class="hljs-string">"修改后的数据版本号为："</span>+stat.getVersion());    &#125;&#125;<span class="hljs-comment">//=================================================</span><span class="hljs-comment">//删除节点</span><span class="hljs-comment">//编写一个类，继承VoidCallback，因为删除节点后会异步回调该类下的方法processResult</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">deleteNodeCallBack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">VoidCallback</span></span>&#123;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rc, String path, Object ctx)</span> </span>&#123;        System.out.println(<span class="hljs-string">"删除节点："</span> + path);        System.out.println((String)ctx);    &#125;&#125;<span class="hljs-comment">//---------------------------------------</span><span class="hljs-comment">//测试删除节点</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                ZooKeeper zk = <span class="hljs-keyword">new</span> ZooKeeper(            ZKConnection.zkServerPath,            ZKConnection.timeout,             <span class="hljs-keyword">new</span> ZKConnection());                <span class="hljs-comment">/**</span><span class="hljs-comment">          * 删除节点</span><span class="hljs-comment">          * 注意：version版本号必须和要删除的节点数据的版本号一致</span><span class="hljs-comment">          */</span>                <span class="hljs-comment">//调用同步方法：void delete(String path, int version);</span>                <span class="hljs-comment">//调用异步方法：void delete(String path, int version,</span>        VoidCallback cb,Object obj)                <span class="hljs-comment">//异步删除节点</span>        String ctx = <span class="hljs-string">"&#123;'delete':'success'&#125;"</span>;        zk.delete(<span class="hljs-string">"/dyf/baidu"</span>, <span class="hljs-number">0</span>,<span class="hljs-keyword">new</span> deleteNodeCallBack(),ctx);                <span class="hljs-keyword">new</span> Thread().sleep(<span class="hljs-number">2000</span>);     &#125;&#125;<span class="hljs-comment">//=================================================</span><span class="hljs-comment">//查询节点数据、查询子节点、判断节点是否存在</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZkConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Watcher</span></span>&#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String zkServerPath = <span class="hljs-string">"127.0.0.1:2181"</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer timeout = <span class="hljs-number">5000</span>;        <span class="hljs-comment">//创建CountDownLatch，设置等待一个线程完成后，就闭锁</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> </span>&#123;        System.err.println(<span class="hljs-string">"收到zk的watch通知----"</span> );                <span class="hljs-comment">//闭锁需要等待的线程数-1</span>        latch.countDown();    &#125;    <span class="hljs-comment">//-------------------------------------------</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        ZooKeeper zk = <span class="hljs-keyword">new</span> ZooKeeper(            zkServerPath,timeout,            <span class="hljs-keyword">new</span> ZkConnection());        <span class="hljs-comment">//调用同步方法：byte[] getData(String path, boolean watch, Stat stat) 等参数依次分别为：节点路径、是否需要注册一个watch、节点的状态信息对象</span>        <span class="hljs-comment">//调用异步方法：void getData(String path, Watcher watcher,</span>DataCallback cb, Object ctx)等参数依次分别为：节点路径、是否需要注册一个watch、回调的函数、以及用于传递上下文信息的对象            <span class="hljs-comment">//查询节点数据</span>        Stat stat = <span class="hljs-keyword">new</span> Stat();        <span class="hljs-keyword">byte</span>[] data = zk.getData(<span class="hljs-string">"/dyf/tengxun"</span>, <span class="hljs-keyword">true</span>, stat);        latch.await();        System.out.println(<span class="hljs-keyword">new</span> String(data));<span class="hljs-comment">//---------------------------------------</span>                <span class="hljs-comment">//调用同步方法：List&lt;String&gt; getChildren(String path, boolean watcher)等</span>                <span class="hljs-comment">//调用异步方法：void getChildren(String path, Watcher watcher,ChildrenCallback cb, Object ctx)等</span>                <span class="hljs-comment">//查询子节点</span>        List&lt;String&gt; children = zk.getChildren(<span class="hljs-string">"/dyf"</span>, <span class="hljs-keyword">true</span>);        <span class="hljs-keyword">for</span> (String string : children) &#123;            System.out.println(string);        &#125;<span class="hljs-comment">//---------------------------------------------------</span>                <span class="hljs-comment">//调用同步方法：exists(String path,boolean watch)</span>        <span class="hljs-comment">//调用异步方法：exists(String path, boolean watch,StatCallback cb,Object ctx);</span>        <span class="hljs-comment">//查询节点是否为空</span>        Stat exists = zk.exists(<span class="hljs-string">"/dyf/tengxun"</span>, <span class="hljs-keyword">true</span>);        <span class="hljs-keyword">if</span>(exists != <span class="hljs-keyword">null</span>) &#123;            System.out.println(<span class="hljs-string">"节点版本号："</span>+exists.getVersion());        &#125;<span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">"节点为空"</span>);        &#125;    &#125;&#125;<span class="hljs-comment">//=================================================</span><span class="hljs-comment">//---------------------------------------</span></code></pre></li></ul><p>&nbsp;</p><ul><li><p>Watch与Acl的相关操作；</p><pre><code class="hljs java"><span class="hljs-comment">//设置权限(auth(不常用)、digest(常用)、ip)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//创建ZooKeeper连接</span>        ZooKeeper zk = <span class="hljs-keyword">new</span> ZooKeeper(            ZKConnection.zkServerPath,            ZKConnection.timeout,             <span class="hljs-keyword">new</span> ZKConnection());        <span class="hljs-comment">//用具体用户auth或digest登录方式设置权限</span>        String ctx= <span class="hljs-string">"&#123;'create':'success'&#125;"</span>;        <span class="hljs-comment">//设置权限acls</span>        List&lt;ACL&gt; acls = <span class="hljs-keyword">new</span> ArrayList&lt;ACL&gt;();        <span class="hljs-comment">//使用指定的用户以密文方式登陆ZooKeeper</span>        Id user = <span class="hljs-keyword">new</span> Id(<span class="hljs-string">"digest"</span>,              DigestAuthenticationProvider.generateDigest(<span class="hljs-string">"账号:密码"</span>));        <span class="hljs-comment">//创建指定的用户拥有的使用节点权限，前者是权限的种类，后者是指定的用户</span>        acls.add(<span class="hljs-keyword">new</span> ACL(Perms.ALL,user));        <span class="hljs-comment">//创建节点(已经设置：指定的用户，以及指定用户所拥有的权限)</span>        zk.create(<span class="hljs-string">"/dyf/baidu"</span>, <span class="hljs-string">"baidu"</span>.getBytes(), acls,                  CreateMode.PERSISTENT,<span class="hljs-keyword">new</span> CreateNodeCallBack(),ctx);                System.out.println(<span class="hljs-string">"节点创建成功啦"</span>);<span class="hljs-comment">//---------------------------------------------</span>        <span class="hljs-comment">//用IP方式设置权限</span>        String ctx= <span class="hljs-string">"&#123;'create':'success'&#125;"</span>;        <span class="hljs-comment">//设置权限acls</span>        List&lt;ACL&gt; acls = <span class="hljs-keyword">new</span> ArrayList&lt;ACL&gt;();        <span class="hljs-comment">//使用指定的用户以密文方式登陆ZooKeeper</span>        Id user = <span class="hljs-keyword">new</span> Id(<span class="hljs-string">"ip"</span>,<span class="hljs-string">"具体的ip地址"</span>);        <span class="hljs-comment">//创建指定的ip拥有的使用节点权限，前者是权限的种类，后者是指定的ip</span>        acls.add(<span class="hljs-keyword">new</span> ACL(Perms.ALL,user));        <span class="hljs-comment">//创建节点(已经设置：指定的用户，以及指定用户所拥有的权限)</span>        zk.create(<span class="hljs-string">"/dyf/baidu"</span>, <span class="hljs-string">"baidu"</span>.getBytes(), acls,                  CreateMode.PERSISTENT,<span class="hljs-keyword">new</span> CreateNodeCallBack(),ctx);        System.out.println(<span class="hljs-string">"节点创建成功啦"</span>);    &#125;&#125;</code></pre></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-7-CountDownLatch优化连接zk"><a href="#NO2-7-CountDownLatch优化连接zk" class="headerlink" title="NO2.7 CountDownLatch优化连接zk"></a>NO2.7 CountDownLatch优化连接zk</h3><ul><li><p>使用CountDownLatch优化连接ZooKeeper：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZkConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Watcher</span></span>&#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String zkServerPath = <span class="hljs-string">"127.0.0.1:2181"</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer timeout = <span class="hljs-number">5000</span>;        <span class="hljs-comment">//创建CountDownLatch，设置等待一个线程完成后，就闭锁</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> </span>&#123;        System.err.println(<span class="hljs-string">"收到zk的watch通知----"</span> );                <span class="hljs-comment">//闭锁需要等待的线程数-1</span>        latch.countDown();    &#125;    <span class="hljs-comment">//---------------------------------------</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;                ZooKeeper zk = <span class="hljs-keyword">new</span> ZooKeeper(            zkServerPath,timeout,            <span class="hljs-keyword">new</span> ZkConnect());                System.out.println(<span class="hljs-string">"连接状态---"</span> + zk.getState());        latch.await();        System.out.println(<span class="hljs-string">"连接状态---"</span> + zk.getState());    &#125;&#125;</code></pre></li></ul><p>&nbsp;</p><ul><li>CountDownLatch工作原理：<ul><li>构造器中的计数值(count)实际上就是闭锁需要等待的线程数量；这个值只能被设置一次，而且CountDownLatch没有提供任何机制去重新设置这个计数值；与CountDownLatch的第一次交互是主线程等待其他线程；主线程必须在启动其     他线程后立即调用CountDownLatch.await()方法；这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务；其他N个线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务。这种通知机制是通过CountDownLatch.countDown()方法来完成的；每调用一次这个方法，在构造函数中初始化的count值就减1。所以当N个线程都调用了这个方法，count的值等于0，然后主线程就能通过await()方法，恢复执行自己的任务。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>NO2.7 Curator客户端</p><ul><li>常用的ZooKeeper的Java客户端；除了原生的ZooKeeper的API，常用的就是Apache curator；   但是原生的API不足之处有以下几点：<ul><li>超时重连，不支持自动，需要手动操作；</li><li>Watch注册一次后失效；</li><li>不支持递归创建节点。</li></ul></li></ul><p>&nbsp;</p><ul><li><p>基本步骤：</p><pre><code class="hljs java"><span class="hljs-comment">//使用Curator创建ZooKeeper的连接</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CuratorOperator</span> </span>&#123;        <span class="hljs-keyword">public</span> CuratorFramework client = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String zkServerPath = <span class="hljs-string">"127.0.0.1:2181"</span>;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CuratorOperator</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">/**</span><span class="hljs-comment">         *  ExponentialBackoffRetry重试策略，该构造有三个参数，推荐使用：</span><span class="hljs-comment">         *  baseSleepTimeMs：初始sleep的时间</span><span class="hljs-comment">         *  maxRetries：最大重试次数</span><span class="hljs-comment">         *  maxSleepMs：最大重试时间</span><span class="hljs-comment">         */</span>        <span class="hljs-comment">//RetryPolicy rp = new ExponentialBackoffRetry(1000,5);</span>                        <span class="hljs-comment">/**</span><span class="hljs-comment">         * RetryNTimes重试策略，该方法有两个参数，推荐使用：</span><span class="hljs-comment">         * n：重试的次数</span><span class="hljs-comment">         * sleepMsBetweenRetries：每次重试间隔的时间</span><span class="hljs-comment">         */</span>        RetryPolicy rp = <span class="hljs-keyword">new</span> RetryNTimes(<span class="hljs-number">5</span>, <span class="hljs-number">3000</span>);                            <span class="hljs-comment">/**</span><span class="hljs-comment">         * RetryOneTime策略，只重试1次，不推荐：</span><span class="hljs-comment">         * sleepMsBetweenRetry：重试间隔的时间</span><span class="hljs-comment">         *</span><span class="hljs-comment">         */</span><span class="hljs-comment">//RetryPolicy rp = new RetryOneTime(3000);</span>                        <span class="hljs-comment">/**</span><span class="hljs-comment">         * RetryForever策略，永远重试，不推荐：</span><span class="hljs-comment">         * retryIntervalMs：重试间隔的时间</span><span class="hljs-comment">         *</span><span class="hljs-comment">         */</span><span class="hljs-comment">//RetryPolicy rp = new RetryForever(3000);</span>                        <span class="hljs-comment">/**</span><span class="hljs-comment">         * RetryUtilElapsed策略，不推荐：</span><span class="hljs-comment">         * maxElapsedTimeMs：最大重试时间</span><span class="hljs-comment">         * sleepMsBetweenRetries：每次重试间隔时间</span><span class="hljs-comment">         * 当重试时间超过最大重试时间，就不再重试</span><span class="hljs-comment">         */</span><span class="hljs-comment">//RetryPolicy rp = new RetryUtilElapsed(2000,3000);</span>                                <span class="hljs-comment">//创建连接</span>        client = CuratorFrameworkFactory.builder()                .connectString(zkServerPath)                .sessionTimeoutMs(<span class="hljs-number">10000</span>).retryPolicy(rp)                .build();                <span class="hljs-comment">//开启连接</span>        client.start();    &#125;        <span class="hljs-comment">//关闭客户端</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">choseClient</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(client != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">this</span>.client.close();        &#125;    &#125;&#125;<span class="hljs-comment">//----------------------------------------</span><span class="hljs-comment">//测试连接Zookeeper，打开ZK服务端，并测试</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;                <span class="hljs-comment">//实例化</span>        CuratorOperator co = <span class="hljs-keyword">new</span> CuratorOperator();                <span class="hljs-comment">//获取连接状态，并输出结果</span>        <span class="hljs-keyword">boolean</span> flag = co.client.isStarted();        System.out.println(<span class="hljs-string">"客户端状态："</span>+(flag?<span class="hljs-string">"连接中"</span>:<span class="hljs-string">"已关闭"</span>));                <span class="hljs-comment">//模拟我们认为的操作，让线程休息几秒</span>        Thread.sleep(<span class="hljs-number">3000</span>);                <span class="hljs-comment">//操作完成，关闭连接</span>        co.choseClient();                <span class="hljs-comment">//再次获取连接状态，并输出结果</span>        <span class="hljs-keyword">boolean</span> flag2 = co.client.isStarted();        System.out.println(<span class="hljs-string">"客户端状态："</span>+(flag2?<span class="hljs-string">"连接中"</span>:<span class="hljs-string">"已关闭"</span>));    &#125;&#125;</code></pre></li></ul><p>&nbsp;</p><ul><li><p>使用Curator创建节点、删除节点、查询节点、修改节点操作；</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CuratorOperator</span> </span>&#123;        <span class="hljs-keyword">public</span> CuratorFramework client = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String zkServerPath = <span class="hljs-string">"127.0.0.1:2181"</span>;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CuratorOperator</span><span class="hljs-params">()</span> </span>&#123;                      <span class="hljs-comment">/**</span><span class="hljs-comment">         * RetryNTimes重试策略，该方法有两个参数，推荐使用：</span><span class="hljs-comment">         * n：重试的次数</span><span class="hljs-comment">         * sleepMsBetweenRetries：每次重试间隔的时间</span><span class="hljs-comment">         */</span>        RetryPolicy rp = <span class="hljs-keyword">new</span> RetryNTimes(<span class="hljs-number">5</span>, <span class="hljs-number">3000</span>);                                    <span class="hljs-comment">//创建连接的时候，顺便创建一个工作空间，增删改查的操作都在这里面进行</span>        <span class="hljs-comment">//如果工作空间节点存在，则不创建，否则在根节点下创建工作空间节点</span>        client = CuratorFrameworkFactory.builder()                .connectString(zkServerPath)                .sessionTimeoutMs(<span class="hljs-number">10000</span>).retryPolicy(rp)                .namespace(<span class="hljs-string">"workspace"</span>).build();                <span class="hljs-comment">//开启连接</span>        client.start();    &#125;        <span class="hljs-comment">//关闭客户端</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">choseClient</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(client != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">this</span>.client.close();        &#125;    &#125;&#125;        测试创建、删除、修改、查询节点操作；<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;                <span class="hljs-comment">//实例化</span>        CuratorOperator co = <span class="hljs-keyword">new</span> CuratorOperator();                <span class="hljs-comment">//获取连接状态，并输出结果</span>        <span class="hljs-keyword">boolean</span> flag = co.client.isStarted();        System.out.println(<span class="hljs-string">"客户端状态："</span>+(flag?<span class="hljs-string">"连接中"</span>:<span class="hljs-string">"已关闭"</span>));                        <span class="hljs-comment">//-------------------------------------------------</span>                <span class="hljs-comment">//创建节点</span>        String nodePath = <span class="hljs-string">"/dyf/alibaba"</span>;        <span class="hljs-keyword">byte</span>[] data = <span class="hljs-string">"taobao"</span>.getBytes();                <span class="hljs-comment">//路径中如果没有父节点则创建</span>        co.client.create().creatingParentsIfNeeded()             .withMode(CreateMode.PERSISTENT)            .withACL(Ids.OPEN_ACL_UNSAFE)            .forPath(nodePath, data);                <span class="hljs-comment">//-------------------------------------------------</span>                <span class="hljs-comment">//修改节点</span>        <span class="hljs-keyword">byte</span>[] newData = <span class="hljs-string">"tianmao"</span>.getBytes();        co.client.setData()            .withVersion(<span class="hljs-number">0</span>)            .forPath(nodePath, newData);                <span class="hljs-comment">//-------------------------------------------------</span>                <span class="hljs-comment">//删除节点</span>        co.client.delete()            .guaranteed() <span class="hljs-comment">//如果删除失败，那么在后端还是会继续删除，直到成功    </span>            .deletingChildrenIfNeeded() <span class="hljs-comment">//如果有子节点，就删除</span>            .withVersion(<span class="hljs-number">1</span>)            .forPath(nodePath);                <span class="hljs-comment">//-------------------------------------------------</span>                <span class="hljs-comment">//查询节点数据</span>        Stat stat = <span class="hljs-keyword">new</span> Stat();        <span class="hljs-keyword">byte</span>[] res = co.client.getData()            .storingStatIn(stat) <span class="hljs-comment">//将查询到的节点数据都封装到stat对象里</span>            .forPath(nodePath);        System.out.println(<span class="hljs-keyword">new</span> String(res)); <span class="hljs-comment">//输出结果</span>                  <span class="hljs-comment">//-------------------------------------------------</span>                <span class="hljs-comment">//获取子节点</span>        List&lt;String&gt; res = co.client.getChildren()                .forPath(nodePath);                <span class="hljs-keyword">for</span> (String string : res) &#123;            System.out.println(string);        &#125;                <span class="hljs-comment">//-------------------------------------------------</span>                <span class="hljs-comment">//判断节点是否存在</span>        Stat res = co.client.checkExists().forPath(nodePath);        System.out.println(res==<span class="hljs-keyword">null</span>?<span class="hljs-string">"节点是空的"</span>:<span class="hljs-string">"节点是存在的"</span>);                <span class="hljs-comment">//-------------------------------------------------</span>        <span class="hljs-comment">//模拟我们认为的操作，让线程休息几秒</span>        Thread.sleep(<span class="hljs-number">3000</span>);                <span class="hljs-comment">//操作完成，关闭连接</span>        co.choseClient();                <span class="hljs-comment">//再次获取连接状态，并输出结果</span>        <span class="hljs-keyword">boolean</span> flag2 = co.client.isStarted();        System.out.println(<span class="hljs-string">"客户端状态："</span>+(flag2?<span class="hljs-string">"连接中"</span>:<span class="hljs-string">"已关闭"</span>));    &#125;&#125;</code></pre></li></ul><p>&nbsp;</p><ul><li><p>使用Curator设置Watcher监听事件；</p><pre><code class="hljs java"><span class="hljs-comment">//首先，创建监听类</span><span class="hljs-comment">//一次性的监听Watcher</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCuratorWatcher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CuratorWatcher</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent event)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">"该路径下的节点的数据已变更"</span>+event.getPath());    &#125;&#125;<span class="hljs-comment">//永久性的监听Watcher</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyNodeCacheListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">NodeCacheListener</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nodeChanged</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">"节点数据已发生变化"</span>);    &#125;&#125;<span class="hljs-comment">//测试</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;                <span class="hljs-comment">//实例化对象，创建连接</span>        CuratorOperator co = <span class="hljs-keyword">new</span> CuratorOperator();                <span class="hljs-comment">//获取连接状态，并输出结果</span>        <span class="hljs-keyword">boolean</span> flag = co.client.isStarted();        System.out.println(<span class="hljs-string">"客户端状态："</span>+(flag?<span class="hljs-string">"连接中"</span>:<span class="hljs-string">"已关闭"</span>));                <span class="hljs-comment">//-------------------------------------------------</span>                <span class="hljs-comment">//使用Watcher，但是只能监听一次</span>        co.client.getData()            .usingWatcher(<span class="hljs-keyword">new</span> MyCuratorWatcher())            .forPath(nodePath);       <span class="hljs-comment">//-------------------------------------------------</span>                <span class="hljs-comment">//使用一个能够永久性监听节点的watcher</span>        NodeCache nodeCache = <span class="hljs-keyword">new</span> NodeCache(co.client, nodePath);        nodeCache.start(<span class="hljs-keyword">true</span>);                <span class="hljs-keyword">if</span>(nodeCache.getCurrentData() != <span class="hljs-keyword">null</span>) &#123;            System.out.println(<span class="hljs-string">"获取的数据为："</span>+            <span class="hljs-keyword">new</span> String(nodeCache.getCurrentData().getData()));        &#125;<span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">"节点中没有数据哦"</span>);        &#125;                nodeCache.getListenable().addListener(<span class="hljs-keyword">new</span> MyNodeCacheListener());        <span class="hljs-comment">//-------------------------------------------------</span>                <span class="hljs-comment">//PathChildrenCache：监听数据节点的增删改，会触发事件</span>        <span class="hljs-comment">//第三个参数：如果设置true，是否需要缓存数据</span>        <span class="hljs-keyword">final</span> PathChildrenCache pcc = <span class="hljs-keyword">new</span> PathChildrenCache(co.client,                                       nodePath,<span class="hljs-keyword">true</span>);                <span class="hljs-comment">/**</span><span class="hljs-comment">         * StartMode.POST_INITIALIZED_EVENT：异步初始化，初始化后会触发事件                          PathChildrenCacheEvent.Type.INITIALIZED  </span><span class="hljs-comment">         * NORMAL：异步初始化，初始化后不会触发事件</span><span class="hljs-comment">         * BUILD_INITIAL_CACHE：同步初始化</span><span class="hljs-comment">         *</span><span class="hljs-comment">         */</span>        pcc.start(StartMode.BUILD_INITIAL_CACHE);                Thread.sleep(<span class="hljs-number">2000</span>);        System.out.println(<span class="hljs-string">"获取数据"</span>);        List&lt;ChildData&gt; cdl = pcc.getCurrentData();        <span class="hljs-keyword">for</span> (ChildData cd : cdl) &#123;            System.out.println(<span class="hljs-keyword">new</span> String(cd.getData()));        &#125;    <span class="hljs-comment">//-------------------------------------------------</span>        <span class="hljs-comment">//模拟我们认为的操作，让线程休息几秒</span>        Thread.sleep(<span class="hljs-number">100000</span>);                <span class="hljs-comment">//操作完成，关闭连接</span>        co.choseClient();                <span class="hljs-comment">//再次获取连接状态，并输出结果</span>        <span class="hljs-keyword">boolean</span> flag2 = co.client.isStarted();        System.out.println(<span class="hljs-string">"客户端状态："</span>+(flag2?<span class="hljs-string">"连接中"</span>:<span class="hljs-string">"已关闭"</span>));    &#125;&#125;注意：如果指定的监听节点不存在的话，会自动的创建该节点；如果在start之后立马调用getCurrentData()的话是会得到<span class="hljs-keyword">null</span>的，因为此时还没有缓存好内容，如果等待一会再调用getCurrentData()的话就能够得到数据；如果是POST_INITIALIZED_EVENT模式启动的话，在回调函数中使用PathChildrenCacheEvent.getData()的时候会得到<span class="hljs-keyword">null</span>对象，如果对<span class="hljs-keyword">null</span>调用其他方法比如getPath，但是此时并不会出现异常(抛出了异常，但是控制台不会显示)，而是下面的内容均不会输出；</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>5.다른 과정</category>
      
      <category>10.服务注册中心</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
      <tag>服务注册中心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01.Maven--学习笔记</title>
    <link href="/2020/07/11/Maven--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/11/Maven--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Maven–学习笔记-包含Maven视频"><a href="#Maven–学习笔记-包含Maven视频" class="headerlink" title="Maven–学习笔记(包含Maven视频)"></a>Maven–学习笔记(包含Maven视频)</h1><h2 id="Lesson1-Maven概述"><a href="#Lesson1-Maven概述" class="headerlink" title="Lesson1 Maven概述"></a>Lesson1 Maven概述</h2><h3 id="NO1-1-Maven简介"><a href="#NO1-1-Maven简介" class="headerlink" title="NO1.1 Maven简介"></a>NO1.1 Maven简介</h3><p>Java程序员常在IDEA中使用Maven来创建工程。</p><ul><li>Maven：<ul><li>定义：Maven是基于项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建、报告和文档的软件项目管理工具。Maven是一个跨平台的项目管理工具，是Apache组织中的一个开源项目；Maven主要服务于基于Java平台的项目构建、依赖管理和项目信息管理；</li><li>其他项目构建工具：<ul><li>Make(Make由一个名为Makefile的脚本文件驱动，该文件使用Make自己定义的语法格式)；</li><li>Ant(即Another Neat Tool，另一个整洁的工具，它最早用来构建Tomcat，可以看成是Java版本的Make)；</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-2-Maven的安装"><a href="#NO1-2-Maven的安装" class="headerlink" title="NO1.2 Maven的安装"></a>NO1.2 Maven的安装</h3><p>Maven的安装比较简单。</p><ul><li>基本步骤：<ul><li>安装JDK1.8以上，并在环境变量里配置好Java，即安装Java，配置好JAVA_HOME；</li><li>下载Maven，即下载apache-maven-3.x-bin.zip文件；</li><li>解压Maven到本地自定义目录中，在环境变量中，配置一个<code>M2_HOME</code>或<code>MAVEN_HOME</code>变量(变量名二选一即可)，和配置JAVA_HOME步骤差不多；</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson2-Maven基础"><a href="#Lesson2-Maven基础" class="headerlink" title="Lesson2 Maven基础"></a>Lesson2 Maven基础</h2><h3 id="NO2-1-Maven的中央仓库配置和本地仓库配置"><a href="#NO2-1-Maven的中央仓库配置和本地仓库配置" class="headerlink" title="NO2.1 Maven的中央仓库配置和本地仓库配置"></a>NO2.1 Maven的中央仓库配置和本地仓库配置</h3><p>要使用Maven，首先要配置好中央仓库和本地仓库。</p><ul><li><p>配置maven的中央仓库。</p><ul><li><p>介绍：中央仓库是一个集合了框架、插件的JAR包的仓库，以供开发者下载，简单的将，就是一个远程的JAR包仓库，就像超市一样，我们要什么样的JAR包，直接从这个中央仓库下载就行了。</p></li><li><p>基本步骤：</p><ul><li><p>当构建一个Maven项目时，首先检查pom.xml文件以确定依赖的JAR包的下载位置。也就是说，先检查pom.xml文件，确定要下载哪些JAR包，然后确定从哪里下载，执行顺序如下：</p><ul><li>从本地仓库中查找并获得JAR包，如果没有，就执行下面一步；</li><li>上面没有找到的JAR包，会从Maven默认的中央仓库(<code>http://repo1.maven.org/maven2/</code>)中查找并获得所需的JAR包，如果没有，就执行下面一步；</li><li>如果在pom.xml文件中定义了自定义的远程仓库，那么也会在自己制定的这个仓库中进行查找并获得所需的JAR包，如果都没有找到，那么Maven就会抛出异常。</li></ul></li><li><p>我们一般不会使用默认的Maven远程中央仓库，因为那个默认的中央仓库服务器是在国外，网速特别慢，不利于项目的构建，所以我们都很修改默认的中央仓库，即将中央仓库的镜像换成阿里云的。找到Maven的安装目录，找到安装目录中的conf文件夹，点击进入，找到settings.xml配置文件，这个就是Maven的配置文件了，用Notepad++打开该文件，找到<code>&lt;mirror&gt;</code>标签，并添加下面内容：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span></code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>配置maven的本地仓库。</p><ul><li><p>介绍：本地仓库，即从中央仓库下载的JAR包，会统一放到本地仓库中，所以需要我们配置本地仓库；</p></li><li><p>基本步骤：</p><ul><li><p>默认的本地仓库：如果不配置本地仓库，会使用默认的本地仓库，地址为：<code>C://Users//Administrator//.m2//repository</code>，不建议使用默认的；</p></li><li><p>自定义本地仓库(推荐)：打开Maven的安装目录，找到conf目录下的settings.xml文件，添加一个<code>&lt;localRepository&gt;</code>标签即可(如果已经有该标签，直接修改值即可)。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>自定义的本地仓库安装目录<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span>  如：<span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>E:xxx/myrepository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span>拓展：项目的依赖获取顺序：本地仓库 &gt; 远程仓库(其实就是公司自己搭建的私服所使用的本地仓库) &gt; 远程中央仓库；</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-2-Maven项目的创建"><a href="#NO2-2-Maven项目的创建" class="headerlink" title="NO2.2 Maven项目的创建"></a>NO2.2 Maven项目的创建</h3><p>Maven创建项目能够提高项目的创建效率。</p><ul><li><p>Maven项目的创建：</p><ul><li><p>使用命令行创建Maven项目：使用命令行创建目录、打包项目，该方式不常用于Windows，但是常用于LUNIX等系统；两种方式：</p><ul><li><p>方式一：在指定目录文件夹路径下，命令行输入指令：<code>mvn archetype:generate</code>，按回车键后，根据提示选择archetype类型进而创建项目，最后确认创建项目即可；如果是第一次使用，需要下载一些插件，稍等几分钟即可；</p></li><li><p>方式二(Linux中推荐)：在命令行输入的命令中直接指定参数：</p><pre><code class="hljs verilog">mvn archetype:<span class="hljs-keyword">generate</span> -DgroupId=cn<span class="hljs-variable">.dyf</span><span class="hljs-variable">.springMVC</span> -DartifactId=springMVC -DarchetypeArtifactId=maven-archetyp<span class="hljs-comment">//使用命令行打包项目：mvn package</span><span class="hljs-comment">//将Maven创建的项目，转换成能够在IDEA上打开的样式：mvn idea:idea</span><span class="hljs-comment">//将普通的项目转为Maven项目：在项目上点击右键，点击Add Frameworks Support(项目支持的意思)，勾选Maven即可</span></code></pre></li></ul></li><li><p>使用IDEA创建Maven项目：该方式常用于Windows中。基本步骤：</p><ul><li><p>点击Create New Project，也就是创建新的项目；</p><p><img src="./Image-m1.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>选择Maven项目，再选择Create from archetype(选择指定模板创建项目)，最后根据自身情况选择maven-archetype-webapp或者maven-archetype-quickstart即可(这两个比较常用)；</p><p><img src="./Image-m2.png" srcset="/img/loading.gif" alt="Image"></p><ul><li><p>maven-archetype-quickstart模型创建出来的文件结构如下；</p><p><img src="./Image-m3.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>maven-archetype-webapp模型创建出来的文件结构如下；</p><p><img src="./Image-m4.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>maven提供的41中骨架原型；</p><p><img src="./Image-m5.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-m6.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li><li><p>设置groupid(项目组名，也是包名)和artifactid(项目名)；</p><p><img src="./Image-m7.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>选择maven版本、settings.xml文件、以及本地仓库；</p><p><img src="./Image-m8.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>检查项目名称是否需要重新修改，确认项目路径，最后点击finsh，完成项目创建；</p><p><img src="./Image-m9.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul></li></ul><h3 id="NO2-3-IDEA中的Tomcat配置和Maven项目启动"><a href="#NO2-3-IDEA中的Tomcat配置和Maven项目启动" class="headerlink" title="NO2.3 IDEA中的Tomcat配置和Maven项目启动"></a>NO2.3 IDEA中的Tomcat配置和Maven项目启动</h3><p>当配置好Maven并编写完程序后，我们常常会想要启动Tomcat来跑一跑我们创建的Maven项目。</p><ul><li><p>IDEA中配置Tomcat，并使用Tomcat启动Maven创建的项目：</p><ul><li><p>IDEA的菜单栏点击Run，选择EDit Configurations；</p><p><img src="./Image-m10.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>选择EDit Configurations选项后，出现对话框，点击“+”号，选择Tomcat Server(Tomcat服务器)，选择Local；</p><p><img src="./Image-m11.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>最后点击Configure按钮，将本地安装的Tomcat路径设置进去即可；</p><p><img src="./Image-m12.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>将项目部署到Tomcat上；</p><ul><li><p>方式一：</p><p><img src="./Image-m13.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-m14.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-m15.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>方式二：</p><p><img src="./Image-m16.png" srcset="/img/loading.gif" alt="image-20200711222535200"></p></li></ul></li><li><p>检查项目启动环境的，即查看Artifacts中是否已经放入了要启动的项目和所需的JAR包；</p><p><img src="./Image-m17.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-4-Maven依赖"><a href="#NO2-4-Maven依赖" class="headerlink" title="NO2.4 Maven依赖"></a>NO2.4 Maven依赖</h3><p>我们来介绍一下Maven的一些常用概念。</p><ul><li><p>Maven依赖解析：</p><ul><li><p>三个向量：使用如下三个向量在Maven的仓库中确定一个唯一的Maven工程；</p><ul><li><code>groupid</code>：公司或组织的域名倒序 + 当前项目名称(因为一个公司不可能只有一个项目)。<code>如，cn.xxx.product</code>；</li><li><code>artifactld</code>：当前项目的唯一名称；</li><li><code>version</code>：当前项目的版本；</li></ul></li><li><p>依赖范围：Maven依赖的默认范围是compile；也就是除了groupid、artifactld、version三个必要的要素之外，还有个scope(范围)，一般都不写，默认范围就是compile；</p><p><img src="./Image-m18.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-m19.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-5-Maven常用命令"><a href="#NO2-5-Maven常用命令" class="headerlink" title="NO2.5 Maven常用命令"></a>NO2.5 Maven常用命令</h3><p>Maven中有一些命令的使用频率很高。</p><ul><li>常用命令：<ul><li><code>clean</code>：清理，即清除编译后的目录，也就是清除target目录下的所有文件(包括target文件夹本身)；</li><li><code>compile</code>：编译，即只编译<code>src/main/java</code>目录中的代码，不编译<code>src/test/java</code>中的代码；</li><li><code>test-compile</code>：编译<code>src/main/test</code>目录中的代码；</li><li><code>test</code>：运行<code>src/main/test</code>目录中的代码；<strong><code>注意：测试代码的类要求以XxxTest结尾，方便Maven的插件进行寻找并进行测试代码。</code></strong></li><li><code>package</code>：将项目打包，Java项目打包成JAR包，Web项目打包成WAR包；</li><li><code>install</code>：发布项目到本地仓库，用在JAR包上，打包好的JAR包就可以被其他项目所使用。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-6-Maven命令的生命周期"><a href="#NO2-6-Maven命令的生命周期" class="headerlink" title="NO2.6 Maven命令的生命周期"></a>NO2.6 Maven命令的生命周期</h3><p>  Maven命令的生命周期是什么呢？</p><ul><li>Maven命令的生命周期：<ul><li>定义：Maven命令的生命周期(life-cycle)是由阶段(Phase)组成的，我们敲入的命令无法直接触摸到某生命周期，因为这不是我们控制的，是由Maven自身控制的，我们只能摸到某个生命周期的某个阶段(Phase)；如，最常见的命令 mvn clean，它其实要Maven做的不是执行Clean生命周期(你摸不到Clean生命周期)，而是执行Clean生命周期的clean阶段，因为Clean 生命周期有3种阶段(pre-clean/clean/post-clean)，而Maven约定为，执行某个阶段时，一定会执行该阶段前面的所有阶段；简单的说就是，人工键入的命令总是指向某生命周期的某个阶段，Maven引擎根据你指向的阶段去跑完阶段所在的生命周期的(某Life-Cycle)该阶段之前的所有阶段；</li></ul></li></ul><p>&nbsp;</p><ul><li><p>Maven拥有三套独立的生命周期：</p><ul><li><p><code>Clean生命周期</code>：该生命周期的目的是清理项目；</p><ul><li><code>pre-clean</code>：执行清理前需要完成的工作；</li><li><code>clean</code>：清理上一次构建过程中生成的文件，比如编译后的class文件等；</li><li><code>post-clean</code>：执行清理后需要完成的工作。</li></ul></li><li><p><code>Default生命周期</code>：该生命周期定义了构建项目时所需要的执行步骤，它是所有生命周期中最核心部分；</p><p><img src="./Image-m20.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p><code>Site生命周期</code>：该生命周期的目的是建立和发布项目站点，Maven可以基于pom所描述的信息自动生成项目的站点，同时还可以根据需要生成相关的报告文档集成在站点中，方便团队交流和发布项目信息；</p><ul><li><code>pre-site</code>：执行生成站点前的准备工作；</li><li><code>site</code>：生成站点文档；</li><li><code>post-site</code>：执行生成站点后需要收尾的工作；</li><li><code>site-deploy</code>：将生成的站点发布到服务器上。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-7-Maven中父项目与子项目"><a href="#NO2-7-Maven中父项目与子项目" class="headerlink" title="NO2.7 Maven中父项目与子项目"></a>NO2.7 Maven中父项目与子项目</h3><p>有时候，我们需要在父项目中创建子项目，分布式项目中最常用这种方式。</p><ul><li><p>创建父项目与子项目，只需要在基于Maven创建了父项目(package那一栏选择pom)后，创建Module子项目即可；基本步骤：</p><p><img src="./Image-m21.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-m22.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-m23.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-m24.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-m25.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-m26.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-m27.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-m28.png" srcset="/img/loading.gif" alt="Image"></p></li></ul><h3 id="NO2-8-Maven依赖的传递性"><a href="#NO2-8-Maven依赖的传递性" class="headerlink" title="NO2.8 Maven依赖的传递性"></a>NO2.8 Maven依赖的传递性</h3><p>依赖传递，简单讲就是引入的JAR又依赖于别的JAR包。</p><ul><li><p>依赖传递性：</p><ul><li><p>定义：即在项目往往需要引入多个依赖， 而引入的依赖又会引入其他的依赖；如，项目中引入了spring-core依赖，而spring-core又依赖commons-logging；因为项目直接引入了spring-core依赖，则spring-core为项目的第一直接依赖，而因为spring-core引入了commons-logging依赖， 则commons-logging为项目的一个传递性依赖；假设A(项目)依赖B，B依赖C(1.1版本)，B是A的直接依赖，C就是A的传递依赖，最后导入依赖D，D依赖C(1.2版本)，这时会产生依赖冲突；</p></li><li><p>当传递性依赖产生版本冲突时，Maven有几种解决方式：</p><ul><li><p>Maven自身调解原则：</p><ul><li>第一声明者优先原则：即谁先定义的就使用谁的传递依赖，也就是说在pom.xml文件中，谁放在前面就用谁的；</li><li>路径近者优先原则：即直接依赖高于传递依赖，也就是说使用的是直接依赖中所依赖的传递性依赖的版本，即为假设中的C(1.1版本)；</li></ul></li><li><p>排除依赖：即手动去除冲突依赖中的一个即可：</p><ul><li><p>pom.xml文件中的配置；</p><p><img src="./Image-m29.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li><li><p>版本锁定(推荐使用)：即对依赖的版本进行统一；</p><pre><code class="hljs xml">//可以进行属性设置，所有jar包的依赖版本都直接引用相应的属性，便于以后升级（更改）版本    <span class="hljs-comment">&lt;!-- 属性 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">spring.version</span>&gt;</span>4.2.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">hibernate.version</span>&gt;</span>5.0.7.Final<span class="hljs-tag">&lt;/<span class="hljs-name">hibernate.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">struts.version</span>&gt;</span>2.3.24<span class="hljs-tag">&lt;/<span class="hljs-name">struts.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-comment">&lt;!-- dependencyManagement标签的作用是指定依赖的版本，并不会导入依赖，锁定版本，struts2-2.3.24、spring4.2.4、hibernate5.0.7 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;hibernate.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.struts<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>struts2-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;struts.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><span class="hljs-comment">&lt;!-- 这里才是导入依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.struts<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>struts2-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></li></ul></li></ul></li></ul><h3 id="NO2-9-Maven的私服"><a href="#NO2-9-Maven的私服" class="headerlink" title="NO2.9 Maven的私服"></a>NO2.9 Maven的私服</h3><p>有些比较大型的公司会用于自己的Maven私服。</p><ul><li><p>远程仓库(私服)Nexus里使用Maven；</p><ul><li><p>定义：Nexus是一种私服，类似的还有chiva、Artifactory，主要用于Maven远程仓库，大型公司里项目中使用会多一些；</p></li><li><p>基本步骤：</p><ul><li><p>下载Nexus并解压；</p><p><img src="./Image-m30.png" srcset="/img/loading.gif" alt="image-20200712003215013"></p></li><li><p>使用安装命令安装Nexus(安装目录不要有中文)，进入解压文件的bin目录下，基于管理员权限进入DOS命令行执行命令；</p><p><img src="./Image-m31.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>配置nexus；</p><p><img src="./Image-m32.png" srcset="/img/loading.gif" alt="image-20200712003350693"></p></li><li><p>在nexus的bin目录下使用命令行命令，启动服务；</p><p><img src="./Image-m33.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>访问nexus私服；</p><p><img src="./Image-m34.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>Nexus中常用的Maven仓库类型；</p><ul><li><p>按照仓库名区分：</p><ul><li><p><code>Central</code>：中央仓库；</p></li><li><p><code>3rd party</code>：第三方仓库，比如手工上传的jar包就保存在这里；</p></li><li><p><code>Apache Snapshots</code>：apache 快照仓库；</p></li><li><p><code>Releases</code>：发行版本仓库；</p></li><li><p><code>Public Respositories</code>：仓库组，是上述所有仓库的聚合，对外提供统一的地址服务。</p><p><img src="./Image-m35.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li><li><p>按照仓库类型区分：</p><ul><li><code>group</code>：仓库组，用来合并多个hosted/proxy仓库。<code>如，Public Respositories</code>；</li><li><code>hosted</code>：本地仓库，通常我们会部署自己的构件到这一类型的仓库。<code>如，公司的第二方库(即存放本公司开发的JAR包)，Releases，3rd party</code>；</li><li><code>proxy</code>：代理仓库，它们被用来代理远程的公共仓库。<code>如，Maven中央仓库，Central，Apache Snapshots</code>；</li></ul></li><li><p>各种类型仓库直接的关系；</p><p><img src="./Image-m36.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>将JAR包上传到私服nexus：注意通过Maven的方式，即depoly；基本步骤：</p><ul><li><p>添加nexus的管理账号</p><p><img src="./Image-m37.png" srcset="/img/loading.gif" alt="Image"></p><p><code>说明：需要注意的是，settings.xml中server元素下id的值必须与POM中repository或snapshotRepository下id的值完全一致；Maven在处理发布时会根据id查找用户名称和密码进行登录和文件的上传发布。</code></p></li><li><p>在需要上传的项目中的pom.xml文件中，配置要上传的私服的仓库(url地址在私服仓库的Repository Path中可以找到，引用就可以)；</p><p><img src="./Image-m38.png" srcset="/img/loading.gif" alt="image-20200712004326740"></p><p><code>说明：&lt;distributionManagement&gt; 中的 &lt;repository&gt; &amp;&amp; &lt;snapshotsrepository&gt;各自的含义，maven仓库分为两种release发布仓库(&lt;repository&gt;)和snapshot快照仓库(&lt;snapshotsrepository&gt;)；snapshot快照仓库用于保存开发过程中的不稳定版本，release正式仓库用来保存稳定的发行版本；定义一个组件/模块为快照版本：只需要在pom文件中的该模板的版本号后面加上 -SNAPSHOT就可以了，注意:必须是大写；maven会根据模块的版本号(pom文件中的&lt;version&gt;版本号&lt;/version&gt;)中是否带有-SNAPSHOT来判断这个是快照版本还是正式版本。</code></p></li><li><p>最后depoly到私服仓库即可；</p><p><img src="./Image-m39.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>从私服nexus下载JAR包：</p><ul><li><p>在settings.xml中配置如下；</p><p><img src="./Image-m40.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>激活模板，也就是告诉Maven从我所指定的仓库下载JAR包；</p><p><img src="./Image-m41.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>5.다른 과정</category>
      
      <category>08.项目管理框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
      <tag>项目管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01.Nginx--学习笔记</title>
    <link href="/2020/07/11/Nginx--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/11/Nginx--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx–学习笔记-包含Nginx视频"><a href="#Nginx–学习笔记-包含Nginx视频" class="headerlink" title="Nginx–学习笔记(包含Nginx视频)"></a>Nginx–学习笔记(包含Nginx视频)</h1><h2 id="Lesson1-Nginx概述"><a href="#Lesson1-Nginx概述" class="headerlink" title="Lesson1 Nginx概述"></a>Lesson1 Nginx概述</h2><h3 id="NO1-1-Nginx简介"><a href="#NO1-1-Nginx简介" class="headerlink" title="NO1.1 Nginx简介"></a>NO1.1 Nginx简介</h3><p>Web服务器是用来运行、发布Web应用的容器，就是说只有将开发的Web项目放到该容器中，才能使网络中的所有用户通过浏览器进行访问。</p><ul><li>常见的Web服务器主要有：Apache、Tomcat、IIS、Nginx等等；其中Nginx是一个高性能的HTTP和反向代理服务器，基于REST架构风格，以统一资源描述符URI或者统一资源定位符URL作为沟通依据，通过HTTP协议提供各种网络服务。如，淘宝、新浪、网易、迅雷等都在使用Nginx作为Web服务器。</li></ul><p>&nbsp;</p><ul><li>Nginx服务器的特点：<ul><li>热部署：Nginx在修改配置文件之后，不需要重启、重载操作；</li><li>高并发连接：即相同配置的服务器，Nginx比Apache能接受的连接要多很多；</li><li>低内存消耗：即相同配置的服务器，Nginx比Apache消耗更低的内存；</li><li>响应请求速度快：处理静态文件，响应速度很快；</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-2-Nginx的正向代理和反向代理"><a href="#NO1-2-Nginx的正向代理和反向代理" class="headerlink" title="NO1.2 Nginx的正向代理和反向代理"></a>NO1.2 Nginx的正向代理和反向代理</h3><p>代理其实就是一个中介，A和B本来可以直接连接，中间插入一个C，C就是中介。</p><ul><li><p>正向代理：正向代理类似一个跳板机，需要帮忙代理的主体是客户端，帮它去访问外部资源。如，我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，将请求发送到代理服务器上，然后代理服务器去访问谷歌；这样由代理去访问谷歌并取得数据后，再返回给我们，这样我们就能访问谷歌了。</p><p>  <img src="./Image-n1.png" srcset="/img/loading.gif" alt="Image"></p></li></ul><p>&nbsp;</p><ul><li><p>反向代理：反向代理与正向代理相反，需要帮忙代理的主体是服务器，也就是说帮忙接收internet上的请求，然后将请求转发给内部网络上的服务器，并把从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器和内部服务器，对外就表现为一个服务器。</p><p>  <img src="./Image-n2.png" srcset="/img/loading.gif" alt="Image"></p></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-3-Nginx的负载均衡"><a href="#NO1-3-Nginx的负载均衡" class="headerlink" title="NO1.3 Nginx的负载均衡"></a>NO1.3 Nginx的负载均衡</h3><p>Nginx的负载均衡，说白了就是把接收到的请求，按照某种规则平均分发到多台服务器上去。</p><ul><li>客户端发送的请求，也就是Nginx这个反向代理服务器需要接收的请求数量，我们称为负载量。Nginx反向代理服务器，根据一定的规则把接收到的请求分发到集群的服务器中去，而这种规则就是一种均衡规则。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-4-Nginx的动静分离"><a href="#NO1-4-Nginx的动静分离" class="headerlink" title="NO1.4 Nginx的动静分离"></a>NO1.4 Nginx的动静分离</h3><p>所谓的动静分离，就是把动态请求和静态请求区分访问。</p><ul><li><p>动静分离是指在Web服务器架构中，将静态请求(如，HTML、CSS、JS)与动态请求(如，JSP、Servlet)分开，不同的请求去访问不同的服务器即可，进而提升整个服务的访问性能和可维护性。</p><p>  <img src="./Image-n3.png" srcset="/img/loading.gif" alt="Image"></p></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-5-Nginx的安装"><a href="#NO1-5-Nginx的安装" class="headerlink" title="NO1.5 Nginx的安装"></a>NO1.5 Nginx的安装</h3><p>我们一般把Nginx安装到装有Linux的虚拟机上，这样才能发挥Nginx服务器的最大性能。</p><ul><li><p>想要安装Nginx，必须要先安装Nginx的依赖：</p><ul><li><p>gcc、g++：主要用来编译源码包。直接使用yum安装方式安装即可(前提是Linux要联网)：</p><ul><li>安装gcc：<code>yum install gcc</code>；</li><li>安装g++：<code>yum -y install gcc-c++</code>。</li></ul></li><li><p>pcre库：这个依赖的作用主要是让Nginx支持Rewrite功能。两种安装方式的步骤如下：</p><ul><li>第一种安装方式(了解即可，zlib、openssl的第一种安装方式同pcre的第一种安装方式，只是安装包不一样)：<ul><li>第一步：下载pcre安装包(要下载Linux使用的pcre-8.35.tar.gz)，并将该安装包上传到Linux中，我使用的是XFTP，专门用于Linux中文件传输的；</li><li>第二步：将安装包复制到Linux中自定义专门用于安装软件的目录，并解压pcre-8.35.tar.gz安装包，Linux中使用命令：<code>tar zxvf pcre-8.35.tar.gz</code>；</li><li>第三步：安装包解压完成后，进入pcre-8.37目录，先检查一下安装包，使用命令：<code>./configure</code>，等待检查完成后，使用编译和安装命令：<code>make &amp;&amp; make install</code>，然后等待安装完成即可，到此pcre安装完成；使用命令：<code>pcre-config --version</code>，查看pcre版本，并检查是否成功安装。</li></ul></li><li>第二种安装方式(推荐)：直接输入安装命令下载并自动安装：<code>yum install pcre pcre-devel</code>。</li></ul></li><li><p>zlib库：这个依赖的作用主要是让Nginx支持gzip功能。直接输入安装命令下载并自动安装：<code>yum install zlib zlib-devel</code>；</p></li><li><p>openssl库：这个依赖的作用主要是让Nginx支持ssl功能。直接输入安装命令下载并自动安装：<code>yum install openssl openssl-devel</code>。</p>  <pre><code class="hljs nsis">拓展：一次性安装Nginx依赖命令一、还可以使用这个命令一次性安装Nginx所需要的所有依赖(推荐这种方式安装哦)：yum -y install gcc gcc-c++ <span class="hljs-literal">zlib</span> <span class="hljs-literal">zlib</span>-devel pcre pcre-devel openssl openssl-devel。</code></pre></li><li><p>Nginx所需要的依赖安装完成后，接下来就是Nginx的安装：</p><ul><li><p>第一步：去Nginx官网上下载自己想要下载的Nginx版本，并将安装包上传到Linux(这里一般都放到一个自定义的目录下即可)，然后进行解压，使用命令：<code>tar -xvf nginx-1.12.2.tar.gz</code>；</p></li><li><p>第二步：Nginx安装包解压完成后，进入解压得到的Nginx目录，先检查一下安装包，使用命令：<code>./configure --prefix=/usr/local/nginx(如果是安装到当前目录下，“--prefix”可以不写)</code>，等待检查完成后，使用编译和安装命令：<code>make &amp;&amp; make install</code>，然后等待安装完成即可，到此Nginx安装完成。</p></li><li><p>第三步：Nginx安装完成后，会在usr/local下生成一个nginx目录，这个目录位置为：/usr/local/nginx，进入到nginx目录中，可以看到有四个子目录：conf存放配置文件、html存放了两个Nginx的页面、logs存放了日志文件、sbin则是存放了Nginx的启动程序。</p><p>  <img src="./Image-n4.png" srcset="/img/loading.gif" alt="Image"></p>  <pre><code class="hljs jboss-cli">拓展：Linux的软件安装目录Linux的软件安装目录是也是有讲究的，正确的选择安装目录对系统管理是有益的，这里讲解一下程序安装目录<span class="hljs-string">/opt</span>目录和<span class="hljs-string">/usr/local</span>目录的区别。一、opt目录：<span class="hljs-string">/opt</span>目录用来安装附加软件包，是用户级的程序目录，可以理解为D:<span class="hljs-string">/Software</span>。安装到<span class="hljs-string">/opt</span>目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。opt有可选的意思，这里可以用于放置第三方大型软件<span class="hljs-params">(或游戏)</span>，当你不需要时，直接rm -rf掉即可。在硬盘容量不够时，也可将<span class="hljs-string">/opt</span>单独挂载到其他磁盘上使用；二、<span class="hljs-string">/usr</span>目录：<span class="hljs-string">/usr</span>：系统级的目录，可以理解为C:<span class="hljs-string">/Windows/</span>；<span class="hljs-string">/usr/lib</span>：理解为C:<span class="hljs-string">/Windows/System32</span>；<span class="hljs-string">/usr/local</span>：用户级的程序目录，可以理解为C:<span class="hljs-string">/Progrem</span> Files/。用户自己编译的软件默认会安装到这个目录下。这里主要存放那些手动安装的软件，即不是通过“yum”或apt-get安装的软件。它和<span class="hljs-string">/usr</span>目录具有相类似的目录结构。让软件包管理器来管理<span class="hljs-string">/usr</span>目录，而把自定义的脚本<span class="hljs-params">(scripts)</span>放到<span class="hljs-string">/usr/local</span>目录下面；三、源码放哪里：<span class="hljs-string">/usr/src</span>：系统级的源码目录；<span class="hljs-string">/usr/local/src</span>：用户级的源码目录。四、总结其实安装软件程序并不是非要在指定的目录下完成，安装java、tomcat等也可以安装在opt目录下，但是按照程序的扩展性和管理性来说，方便使用才是最好的。总结的话，opt目录和usr/local目录就是<span class="hljs-string">/usr/local</span>下一般是你安装软件的目录，这个目录就相当于在windows下的programefiles这个目录。<span class="hljs-string">/opt</span>这个目录是一些大型软件的安装目录，或者是一些服务程序的安装目录。</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson2-Nginx基础"><a href="#Lesson2-Nginx基础" class="headerlink" title="Lesson2 Nginx基础"></a>Lesson2 Nginx基础</h2><h3 id="NO2-1-Nginx的常用命令"><a href="#NO2-1-Nginx的常用命令" class="headerlink" title="NO2.1 Nginx的常用命令"></a>NO2.1 Nginx的常用命令</h3><p>使用Nginx的命令的前提条件：必须要在/usr/local/nginx/sbin目录下进行操作。</p><ul><li><p>启动Nginx：</p><ul><li><p>使用命令：进入到/usr/local/nginx/sbin后，直接输入：<code>./nginx</code>，即可启动Nginx；</p></li><li><p>还可以使用命令：<code>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf(该方式要求Nginx必须安装在/usr/local目录下，且目录名为nginx，这是程序员们约定俗成的)</code>。</p><p>  <img src="./Image-n5.png" srcset="/img/loading.gif" alt="image-20200711173410201"></p>  <pre><code class="hljs java">拓展：Nginx启动后，我们可以根据IP和端口号进行访问Nginx，查看Nginx是否成功启动。但是要注意CentOS6.x和<span class="hljs-number">7</span>.x的命令是不相同的：一、CentOS <span class="hljs-number">6</span>.x    <span class="hljs-number">1</span>.防火墙操作：        开启防火墙：service iptables start；        重启防火墙：service iptables restart；        关闭防火墙：service iptables stop。    <span class="hljs-number">1</span>.开放指定端口：        写入修改：iptables -I INPUT -p tcp --dport 端口号 -j ACCEPT；        保存修改：iptables save；        重启防火墙，修改生效：service iptables restart。    <span class="hljs-number">2</span>.关闭指定端口：        写入修改：iptables -I INPUT -p tcp --dport 端口号 -j DROP；        保存修改：iptables save；        重启防火墙，修改生效：service iptables restart。    <span class="hljs-number">3</span>.查看端口状态：        service iptables status。二、CentOS <span class="hljs-number">7</span>(推荐使用这个版本)    <span class="hljs-number">1</span>.防火墙操作：        启动： systemctl start firewalld        查看状态： systemctl status firewalld        停止： systemctl disable firewalld        禁用： systemctl stop firewalld    <span class="hljs-number">2</span>.开放指定端口：        开放端口：firewall-cmd --zone=<span class="hljs-keyword">public</span> --add-port=端口号/tcp --permanent；        重新载入，使其生效：firewall-cmd --reload。    <span class="hljs-number">3</span>.关闭指定端口：        关闭端口：firewall-cmd --zone=<span class="hljs-keyword">public</span> --remove-port=端口号/tcp --permanent；        重新载入，使其生效：firewall-cmd --reload。    <span class="hljs-number">4</span>.查看端口状态：        查看端口状态：firewall-cmd --zone=<span class="hljs-keyword">public</span> --query-port=端口号/tcp。</code></pre><p>  <img src="./Image-n6.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>关闭Nginx：</p><ul><li><p>优雅关闭(使用该命令后，不会立刻关闭，而是会将请求处理完成后再关闭)，有两种方式：</p><ul><li>方式一：<ul><li>首先，查询Nginx的主进程号，使用命令：<code>ps -ef | grep nginx</code>；</li><li>然后使用命令：<code>kill -QUIT 主进程号</code>。</li></ul></li><li>方式二：<ul><li>使用命令：进入到/usr/local/nginx/sbin后，直接输入：<code>./nginx -s quit</code>；</li></ul></li></ul></li><li><p>强制关闭(这种方法比较强硬，无论进程是否在工作，都直接停止进程)，也是两种方式：</p><ul><li><p>方式一：</p><ul><li>首先，查询Nginx的主进程号，使用命令：<code>ps -ef | grep nginx</code>；</li><li>然后使用命令：<code>kill -TERM 主进程号</code>。</li></ul></li><li><p>方式二：</p><ul><li><p>使用命令：进入到/usr/local/nginx/sbin后，直接输入：<code>./nginx -s stop</code>。</p><p>  <img src="./Image-n7.png" srcset="/img/loading.gif" alt="image-20200711173655578"></p></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>查看当前Nginx的版本：<ul><li>使用命令：进入到/usr/local/nginx/sbin后，直接输入：<code>./nginx -v</code>。</li></ul></li></ul><p>&nbsp;</p><ul><li>重新加载Nginx(即重新加载服务配置文件，类似于重启，但服务不会中止)：<ul><li>使用命令：进入到/usr/local/nginx/sbin后，直接输入：<code>./nginx -s reload</code>。</li></ul></li></ul><p>&nbsp;</p><ul><li><p>检查Nginx配置文件的正确性：</p><ul><li><p>使用命令：<code>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf -t</code>。</p><p>  <img src="./Image-n8.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-2-Nginx的配置文件"><a href="#NO2-2-Nginx的配置文件" class="headerlink" title="NO2.2 Nginx的配置文件"></a>NO2.2 Nginx的配置文件</h3><p>Nginx配置文件的位置：/usr/local/nginx/conf/nginx.conf。</p><ul><li><p>Nginx配置文件nginx.conf中的内容由三部分构成：</p><ul><li><p>main模块：即从配置文件开始到events之前的内容就是main的内容，这里面的设置会作用到整个Nginx，起到一个全局设置的作用。常见内容有：</p><ul><li><code>user</code>：用来指定Nginx中worker process进程运行的用户以及用户组，默认是使用nobody账号运行；</li><li><code>worker_processe</code>：指定了Nginx要开启的进程数。每个Nginx进程平均耗费10M~12M内存，建议指定和CPU的数量一致即可。简单讲就是这个数值越大，能够支持的并发处理量越多；</li><li><code>error_log</code>：定义错误日志文件的存放路径及输出级别。日志输出级别有debug、info、notice、warn、error、crit可供选择，debug输出日志最为最详细，而crit输出日志最少；</li><li><code>pid</code>：用来指定进程id的存储文件的位置；</li><li><code>worker_rlimit_nofile</code>：用于指定一个进程可以打开最多文件数量的描述；</li><li>….等等。</li></ul></li><li><p>events模块：用于配置Nginx的工作模式及连接数上限。常见内容有：</p><ul><li><code>worker_connections</code>：用于定义Nginx每个worker process进程的最大连接数，默认是1024。Nginx支持的最大连接数由worker_processes * worker_connections决定，即这两个的乘积就是最大支持的连接上；</li><li><code>multi_accept</code>：配置指定nginx在收到一个新连接通知后尽可能多的接受更多的连接；</li><li><code>use</code>：用来指定Nginx的工作模式。Nginx支持的工作模式有select、poll、kqueue、epoll、rtsig和/dev/poll。其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，不同的是epoll用在Linux平台上，而kqueue用在BSD系统中。对于Linux系统，epoll工作模式是首选；</li><li>…等等。</li></ul></li><li><p>http模块：作为web服务器，http模块是Nginx最核心的一个模块，配置项也是比较多的，项目中会设置到很多的实际业务场景，需要根据硬件信息进行适当的配置。该部分又可以分为：</p><ul><li><p>基本配置：</p><ul><li>基础配置：<ul><li><code>sendfile on</code>：配置on让sendfile发挥作用，将文件的回写过程交给数据缓冲去去完成，而不是放在应用中完成，这样的话在性能提升有有好处；</li><li><code>tcp_nopush on</code>：让nginx在一个数据包中发送所有的头文件，而不是一个一个单独发；</li><li><code>tcp_nodelay on</code>：让nginx不要缓存数据，而是一段一段发送，如果数据的传输有实时性的要求的话可以配置它，发送完一小段数据就立刻能得到返回值，但是不要滥用哦；</li><li><code>keepalive_timeout 10</code>：给客户端分配连接超时时间，服务器会在这个时间过后关闭连接。一般设置时间较短，可以让nginx工作持续性更好；</li><li><code>client_header_timeout 10</code>：设置请求头的超时时间；</li><li><code>client_body_timeout 10</code>：设置请求体的超时时间；</li><li><code>send_timeout 10</code>：指定客户端响应超时时间，如果客户端两次操作间隔超过这个时间，服务器就会关闭这个链接；</li><li><code>limit_conn_zone $binary_remote_addr zone=addr:5m</code>：设置用于保存各种key的共享内存的参数；</li><li><code>limit_conn addr 100</code>：给定的key设置最大连接数；</li><li><code>server_tokens</code>：虽然不会让nginx执行速度更快，但是可以在错误页面关闭nginx版本提示，对于网站安全性的提升有好处哦；</li><li><code>include</code>：指定Nginx能够解析的文件类型，一般在nginx/conf/mime.types中可以查看Nginx所支持的类型。如，mp3、html、png等等很多类型；</li><li><code>default_type application/octet-stream</code>：指定默认处理的文件类型可以是二进制；</li><li><code>type_hash_max_size 2048</code>：混淆数据，影响三列冲突率，值越大消耗内存越多，散列key冲突率会降低，检索速度更快；值越小key，占用内存较少，冲突率越高，检索速度变慢。</li></ul></li><li>日志配置：<ul><li><code>access_log logs/access.log</code>：设置存储访问记录的日志；</li><li><code>error_log logs/error.log</code>：设置存储记录错误发生的日志。</li></ul></li><li>SSL证书配置：<ul><li><code>ssl_protocols</code>：指令用于启动特定的加密协议，nginx在1.1.13和1.0.12版本后默认是ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2，TLSv1.1与TLSv1.2要确保OpenSSL &gt;= 1.0.1 ，SSLv3 现在还有很多地方在用但有不少被攻击的漏洞；</li><li><code>ssl prefer server ciphers</code>：设置协商加密算法时，优先使用我们服务端的加密套件，而不是客户端浏览器的加密套件。</li></ul></li><li>压缩配置：<ul><li><code>gzip</code>：是告诉nginx采用gzip压缩的形式发送数据。这将会减少我们发送的数据量；</li><li><code>gzip_disable</code>：为指定的客户端禁用gzip功能。我们设置成IE6或者更低版本以使我们的方案能够广泛兼容；</li><li><code>gzip_static</code>：告诉nginx在压缩资源之前，先查找是否有预先gzip处理过的资源。这要求你预先压缩你的文件(在这个例子中被注释掉了)，从而允许你使用最高压缩比，这样nginx就不用再压缩这些文件了(想要更详尽的gzip_static的信息，请点击这里)；</li><li><code>gzip_proxied</code>：允许或者禁止压缩基于请求和响应的响应流。我们设置为any，意味着将会压缩所有的请求；</li><li><code>gzip_min_length</code>：设置对数据启用压缩的最少字节数。如果一个请求小于1000字节，我们最好不要压缩它，因为压缩这些小的数据会降低处理此请求的所有进程的速度；</li><li><code>gzip_comp_level</code>：设置数据的压缩等级。这个等级可以是1-9之间的任意数值，9是最慢但是压缩比最大的。我们设置为4，这是一个比较折中的设置；</li><li><code>gzip_type</code>：设置需要压缩的数据格式。上面例子中已经有一些了，你也可以再添加更多的格式。</li></ul></li><li>文件缓存配置：<ul><li><code>open_file_cache</code>：打开缓存的同时也指定了缓存最大数目，以及缓存的时间。我们可以设置一个相对高的最大时间，这样我们可以在它们不活动超过20秒后清除掉；</li><li><code>open_file_cache_valid</code>：在open_file_cache中指定检测正确信息的间隔时间；</li><li><code>open_file_cache_min_uses</code>：定义了open_file_cache中指令参数不活动时间期间里最小的文件数；</li><li><code>open_file_cache_errors</code>：指定了当搜索一个文件时是否缓存错误信息，也包括再次给配置中添加文件。我们也包括了服务器模块，这些是在不同文件中定义的。如果你的服务器模块不在这些位置，你就得修改这一行来指定正确的位置。</li></ul></li></ul></li><li><p>upstream模块：主要负责负载均衡的配置，通过默认的轮询调度方式来分发请求到后端服务器；负载均衡模块附带一个健康检查功能，即自动检测服务器状态是否正常运行。常见内容如下：</p><ul><li><p><code>ip_hash</code>：指定请求调度算法，默认是weight权重轮询调度，可以指定；</p></li><li><p><code>weight</code>：表示权重，即权重越大，访问的几率一般就越高，否则就越低；</p></li><li><p><code>server host:port</code>：分发服务器的列表配置；</p></li><li><p><code>server host:port down</code>：表示该主机暂停服务；</p></li><li><p><code>server host:port max_fails</code>：表示失败最大次数，超过失败最大次数暂停服务；</p></li><li><p><code>server host:port fail_timeout</code>：表示如果请求受理失败，暂停指定的时间之后重新发起请求；</p></li><li><p><code>server host:port backup</code>：表示这个服务器是备用的，除非其他所有机器都宕机，否则不会启用该服务器；一般用于更新项目，即将部分服务器设置为backup后，在backup服务器上进行修改项目操作，然后backup的服务器再重新上线，一般那些游戏服务器就是这么类似的操作。</p>  <pre><code class="hljs angelscript">upstream name &#123;    ip_hash;  <span class="hljs-comment">//ip_hash策略</span>    least_conn;  <span class="hljs-comment">//最少连接策略</span>    server <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.100</span>:<span class="hljs-number">8000</span>;  <span class="hljs-comment">//默认的轮训策略</span>    server <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.100</span>:<span class="hljs-number">8000</span> weight=<span class="hljs-number">3</span>;  <span class="hljs-comment">//weight权重策略</span>    server <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.100</span>:<span class="hljs-number">8001</span> down;    server <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.100</span>:<span class="hljs-number">8002</span> max_fails=<span class="hljs-number">3</span>;    server <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.100</span>:<span class="hljs-number">8003</span> fail_timeout=<span class="hljs-number">20</span>s;    server <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.100</span>:<span class="hljs-number">8004</span> max_fails=<span class="hljs-number">3</span> fail_timeout=<span class="hljs-number">20</span>s;&#125;拓展：Nginx常用的负载均衡策略一、轮序调度(默认)：即如果有两台服务器，第一次访问第一台服务器，第二次访问第二台服务器，第三次又访问第一台服务器，第四次又访问第二台服务器，轮着访问；如，server <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.100</span>:<span class="hljs-number">8000</span>；二、权重：即weight，weight的值越大，访问的比例就会越大，一般用于后台服务器性能不均的情况；如，server <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.100</span>:<span class="hljs-number">8000</span> weight=数值；三、ip_hash：也就IP绑定，意思就是根据每个请求的IP的hash值来确定该请求去访问哪个服务器，因为IP是固定的，所以访问的服务器也是固定的，可以解决Session丢失问题；在server <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.100</span>:<span class="hljs-number">8000</span>上面添加ip_hash即可；四、最少连接：即会将请求转发到连接数最少的服务器上。如，在server <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.100</span>:<span class="hljs-number">8000</span>;上面添加least_conn即可。</code></pre></li></ul></li><li><p>server模块：主要用于指定主机和端口。简单讲一个server就相当于一个服务器，你可以配置多个server模块来虚拟多个服务器。该部分可分为两部分：</p><ul><li><p>基本配置：</p><ul><li><p><code>server</code>：一个虚拟服务器的配置，一个http中可以配置多个server；</p></li><li><p><code>listen</code>：表示该服务器监听哪个端口，默认是80端口；</p></li><li><p><code>server_name</code>：表示匹配的主机名。如，server_name是<a href="http://www.aaa.com，那么，当客户端通过域名www.aaa.com(前提是该域名已经正确解析到该服务器的IP地址)来访问的时候，就是匹配到这个服务器；如果通过IP直接访问，会默认访问第一个服务器，这也是为什么我们直接通过IP访问虚拟机时，会出现Nginx的欢迎页面的原因；如果想要访问其他端口，那么只要写清楚IP和端口号就可以访问指定的虚拟服务器了；如果有多个匹配项，则用空格隔开；" target="_blank" rel="noopener">www.aaa.com，那么，当客户端通过域名www.aaa.com(前提是该域名已经正确解析到该服务器的IP地址)来访问的时候，就是匹配到这个服务器；如果通过IP直接访问，会默认访问第一个服务器，这也是为什么我们直接通过IP访问虚拟机时，会出现Nginx的欢迎页面的原因；如果想要访问其他端口，那么只要写清楚IP和端口号就可以访问指定的虚拟服务器了；如果有多个匹配项，则用空格隔开；</a></p></li><li><p><code>charset</code>：用于设置www/路径中配置的网页的默认编码格式；</p></li><li><p><code>access_log</code>：用于指定该虚拟主机服务器中的访问记录日志存放路径；</p></li><li><p><code>error_log</code>：用于指定该虚拟主机服务器中访问错误日志的存放路径。</p>  <pre><code class="hljs properties"><span class="hljs-attr">server</span> <span class="hljs-string">&#123;</span>    <span class="hljs-attr">listen</span>         <span class="hljs-string">80;</span>    <span class="hljs-attr">server_name</span>    <span class="hljs-string">localhost  192.168.1.100;</span>    <span class="hljs-attr">charset</span>        <span class="hljs-string">utf-8;</span>    <span class="hljs-attr">access_log</span>     <span class="hljs-string">logs/access.log;</span>    <span class="hljs-attr">error_log</span>      <span class="hljs-string">logs/error.log;</span>    <span class="hljs-attr">......</span>    <span class="hljs-attr">location</span> <span class="hljs-string">....&#123;</span>        <span class="hljs-attr">....</span>    <span class="hljs-attr">&#125;</span><span class="hljs-attr">&#125;</span></code></pre></li></ul></li><li><p>location模块：Nginx配置中出现最多的一个配置，主要用于配置路由访问信息。在路由访问信息配置中关联到反向代理、负载均衡等等各项功能，所以location模块也是一个非常重要的配置模块。常见内容如下：</p><ul><li><p><code>location /</code>：这是传统匹配，表示匹配的访问请求中只要带有“/”，就能匹配上。如，192.168.5.66:80/aaa，这样也能匹配到“/”了；location的匹配标识符如下：</p><ul><li><code>=</code>：精确匹配；用于标准uri前，要求请求字符串和uri严格匹配。如果匹配成功，就停止匹配，立即执行该location里面的请求；</li><li><code>~</code>：正则匹配；用于正则uri前，表示uri里面包含正则，并且区分大小写；</li><li><code>~*</code>：正则匹配；用于正则uri前，表示uri里面包含正则，不区分大小写；</li><li><code>^~</code>：非正则匹配；用于标准uri前，nginx服务器匹配到前缀最多的uri后就结束，该模式匹配成功后，不会使用正则匹配；</li><li><code>无</code>：普通匹配(最长字符匹配)；与location顺序无关，是按照匹配的长短来取匹配结果。若完全匹配，就停止匹配。</li></ul></li><li><p><code>root</code>：用于指定从服务器上的哪一个目录开始访问，默认规定从/nginx/html开始访问。如，我规定来访问的请求从/picture/aaa目录下开始访问，那么aaa目录就是这类请求的起点；</p></li><li><p><code>index</code>：就是在root配置后，会在指定的起点目录下寻找首页文件的名称，按顺序查找，若首页文件不存在就找下一个。</p>  <pre><code class="hljs crmsh">//基本配置<span class="hljs-keyword">location</span> <span class="hljs-title">/ &#123;</span><span class="hljs-title">    root</span>    /nginx/www;    index    index.php index.html index.htm;    proxy_pass    要转发的IP:端口号;&#125;//反向代理配置：通过反向代理的代理服务器访问模式，通过proxy_set配置让客户端访问透明化。<span class="hljs-keyword">location</span> <span class="hljs-title">/ &#123;</span><span class="hljs-title">    proxy_pass</span> http://localhost:<span class="hljs-number">8888</span>;    proxy_set_header X-real-ip $remote_addr;    proxy_set_header Host $http_host;&#125;//uwsgi配置<span class="hljs-keyword">location</span> <span class="hljs-title">/ &#123;</span><span class="hljs-title">    include</span> uwsgi_params;    uwsgi_pass localhost:<span class="hljs-number">8888</span>;&#125;//----------------------------------------------//各个标识符的匹配：//“=”精准匹配案例<span class="hljs-keyword">location</span>  <span class="hljs-title">= /login</span> &#123;  <span class="hljs-comment"># 精确匹配 /login ，匹配成功后，立即结束</span>&#125;//“~”区分大小写正则匹配案例<span class="hljs-keyword">location</span> <span class="hljs-title">~ /images</span>/ &#123;  <span class="hljs-comment">#正则匹配，区分大小写，匹配成功后，立即结束</span>&#125;//“~*”不区分大小写正则匹配案例<span class="hljs-keyword">location</span> <span class="hljs-title">~* /images</span>/ &#123;  <span class="hljs-comment">#正则匹配，不区分大小写，匹配成功后，立即结束</span>&#125;//“^~” 不进行正则匹配的标准匹配<span class="hljs-keyword">location</span> <span class="hljs-title">^~ /images</span>/ &#123;  <span class="hljs-comment"># 匹配任何以/images/开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。</span>&#125;//普通匹配(最长字符匹配)<span class="hljs-keyword">location</span>  <span class="hljs-title">/blog</span>/ &#123;  <span class="hljs-comment"># 与location顺序无关</span>  <span class="hljs-comment"># 若完全匹配成功，就不再继续匹配，否则还会进行正则匹配</span>&#125;注意：匹配顺序：(<span class="hljs-keyword">location</span> <span class="hljs-title">=) &gt; (location</span> 完整路径) &gt; (<span class="hljs-keyword">location</span> <span class="hljs-title">^~ 路径) &gt; (location</span> ~,~* 正则顺序) &gt; (<span class="hljs-keyword">location</span> <span class="hljs-title">部分起始路径) &gt; (location</span> /)。</code></pre></li></ul></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-3-Nginx反向代理配置"><a href="#NO2-3-Nginx反向代理配置" class="headerlink" title="NO2.3 Nginx反向代理配置"></a>NO2.3 Nginx反向代理配置</h3><p>反向代理在日常生活的项目中用的还是比较多的。</p><ul><li><p>Nginx配置静态网站的步骤：</p><ul><li><p>使用命令：vim /usr/local/nginx/conf/nginx.conf，进入到Nginx的配置文件中进行配置，配置如下：</p>  <pre><code class="hljs angelscript">....省略其他upstream www.dyf.com &#123;  <span class="hljs-comment">//upstream后面跟的内容必须和location中proxy_pass所映射的内容要相同，否则就无法映射过来</span>    server <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.100</span>:<span class="hljs-number">8000</span> weight=<span class="hljs-number">3</span>;      server <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.100</span>:<span class="hljs-number">8001</span> weight=<span class="hljs-number">1</span>;  &#125;server &#123;    listen         <span class="hljs-number">80</span>;    server_name    www.dyf.com <span class="hljs-number">192.168</span><span class="hljs-number">.2</span><span class="hljs-number">.66</span>;        location /dyf &#123;        proxy_pass http:<span class="hljs-comment">//www.dyf.com;  //首先，当url匹配上以后就会走这里，然后使用proxy_pass转发到上面的负载均衡的配置里面去</span>    &#125;&#125;....省略其他server</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-4-Nginx的静态网站部署配置"><a href="#NO2-4-Nginx的静态网站部署配置" class="headerlink" title="NO2.4 Nginx的静态网站部署配置"></a>NO2.4 Nginx的静态网站部署配置</h3><p>我们可以把只有html、css、js等静态资源的网站放到Nginx上，以便我们去访问。</p><ul><li><p>Nginx配置静态网站的步骤：</p><ul><li><p>将静态资源网站上传到Linux中指定的目录下(这里举例，放到了/opt/static/test目录下)，只要方便自己寻找即可；</p></li><li><p>使用命令：<code>vim /usr/local/nginx/conf/nginx.conf</code>，进入到Nginx的配置文件中进行配置，配置如下：</p>  <pre><code class="hljs axapta"><span class="hljs-comment">//通过访问url：192.168.83.129，跳转到指定目录下</span>....省略其他<span class="hljs-keyword">server</span> &#123;    listen         <span class="hljs-number">80</span>;    server_name    localhost;    location / &#123;        root    /opt/<span class="hljs-keyword">static</span>/test;        <span class="hljs-keyword">index</span>    <span class="hljs-keyword">index</span>.html <span class="hljs-keyword">index</span>.htm;    这个选项不配置也是可以的，因为会默认按顺序寻找<span class="hljs-keyword">index</span>.html、<span class="hljs-keyword">index</span>.htm、<span class="hljs-keyword">index</span>.php....但是要注意，Nginx并不支持JSP    &#125;&#125;....省略其他<span class="hljs-comment">//-------------------------------------------</span><span class="hljs-comment">//通过访问url：192.168.83.129/test，跳转到指定目录下</span>....省略其他<span class="hljs-keyword">server</span> &#123;    listen         <span class="hljs-number">80</span>;    server_name    localhost;        location /test &#123;        root    /opt/<span class="hljs-keyword">static</span>;        <span class="hljs-keyword">index</span>    <span class="hljs-keyword">index</span>.html <span class="hljs-keyword">index</span>.htm;    这个选项不配置也是可以的，因为会默认按顺序寻找<span class="hljs-keyword">index</span>.html、<span class="hljs-keyword">index</span>.htm、<span class="hljs-keyword">index</span>.php....但是要注意，Nginx并不支持JSP    &#125;&#125;....省略其他注意：简单讲，root所代表的路径就等于location中第一个“/”前面的内容，这么理解就可以了。如，上面的/test，而root的路径为/opt/<span class="hljs-keyword">static</span>，那么Nginx会将用户的请求匹配到/opt/<span class="hljs-keyword">static</span>/test下去寻找文件，因为“/”前面的内容等于/opt/<span class="hljs-keyword">static</span>，那么“/test”就是/opt/<span class="hljs-keyword">static</span>/test了，而我们的目录下有test这么个目录，那么久匹配成功。</code></pre></li><li><p>访问测试，开启Nginx，在浏览器中输入Linux的IP地址进行访问测试。</p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-5-Nginx的负载均衡配置"><a href="#NO2-5-Nginx的负载均衡配置" class="headerlink" title="NO2.5 Nginx的负载均衡配置"></a>NO2.5 Nginx的负载均衡配置</h3><p>我们可以把请求分发到不同的服务器上，以便减轻单个服务器的访问压力。</p><ul><li><p>Nginx配置负载均衡的步骤：</p><ul><li><p>使用命令：<code>vim /usr/local/nginx/conf/nginx.conf</code>，进入到Nginx的配置文件中进行配置，配置如下：</p>  <pre><code class="hljs angelscript">....省略其他upstream www.dyf.com &#123;  <span class="hljs-comment">//upstream后面跟的内容必须和location中proxy_pass所映射的内容要相同，否则就无法映射过来</span>    server <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.100</span>:<span class="hljs-number">8000</span> weight=<span class="hljs-number">3</span>;  <span class="hljs-comment">//优先访问这个，大概4次中，有3次会访问该服务器</span>    server <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.100</span>:<span class="hljs-number">8001</span> weight=<span class="hljs-number">1</span>;  <span class="hljs-comment">//每4次中，只有1次会访问该服务器</span>&#125;server &#123;    listen         <span class="hljs-number">80</span>;    server_name    localhost;        location /dyf &#123;        proxy_pass http:<span class="hljs-comment">//www.dyf.com;  //首先，当url匹配上以后就会走这里，然后使用proxy_pass转发到上面的负载均衡的配置里面去</span>    &#125;&#125;....省略其他</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-6-Nginx的动静分离配置"><a href="#NO2-6-Nginx的动静分离配置" class="headerlink" title="NO2.6 Nginx的动静分离配置"></a>NO2.6 Nginx的动静分离配置</h3><p>简单讲，静态代理就是将所有的静态资源放入到Nginx中，而不放到项目中；动态资源放入项目中。</p><ul><li><p>Nginx配置静态代理的步骤：</p><ul><li><p>使用命令：<code>vim /usr/local/nginx/conf/nginx.conf</code>，进入到Nginx的配置文件中进行配置，配置如下：</p>  <pre><code class="hljs gherkin">....省略其他//负载均衡配置upstream www.aaa.com &#123;     server 192.168.1.100:8000 weight=3;      server 192.168.1.100:8001 weight=1;  &#125;server &#123;    listen         80;    server_name    localhost;        //动态请求走这里：    location  /aaa &#123;        proxy_pass  http://www.aaa.com  //跳转到www.aaa.com，并进行负载均衡      &#125;    //静态请求走这里：    //方式一：    location  ~ .<span class="hljs-symbol">*</span>\.(js|<span class="hljs-string">css</span>|<span class="hljs-string">html</span>|<span class="hljs-string">gif</span>|<span class="hljs-string">jpg</span>|<span class="hljs-string">jpeg</span>|<span class="hljs-string">png</span>|<span class="hljs-string">bmp</span>|<span class="hljs-string">ioc</span>|<span class="hljs-string">rar</span>|<span class="hljs-string">zip</span>|<span class="hljs-string">txt</span>|<span class="hljs-string">flv</span>|<span class="hljs-string">mid</span>|<span class="hljs-string">doc</span>|<span class="hljs-string">ppt</span>|<span class="hljs-string">pdf</span>|<span class="hljs-string">xls</span>|<span class="hljs-string">mp3</span>|<span class="hljs-string">wma)$  &#123;</span><span class="hljs-string">        root /opt/static;</span><span class="hljs-string">    &#125;</span><span class="hljs-string">    //方式二：</span><span class="hljs-string">    location  ~ .*\(js</span>|<span class="hljs-string">css</span>|<span class="hljs-string">img</span>|<span class="hljs-string">images)  &#123;</span><span class="hljs-string">        root /opt/static;</span><span class="hljs-string">    &#125;</span><span class="hljs-string">&#125;</span><span class="hljs-string">....省略其他</span><span class="hljs-string">说明：</span><span class="hljs-string">~：表示正则匹配，也就是说后面可以是正则表达式；</span><span class="hljs-string">.：第一个点就表示任意字符；</span><span class="hljs-string">*：表示一个或多个字符；</span><span class="hljs-string">\.：“\”是转义字符，表示将后面的字符按其本身的含义进行输出，上面“\.”表示输出一个点；</span>|<span class="hljs-string">：表示或者的意思；</span><span class="hljs-string">$：表示结尾。</span></code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-7-Nginx的虚拟主机配置"><a href="#NO2-7-Nginx的虚拟主机配置" class="headerlink" title="NO2.7 Nginx的虚拟主机配置"></a>NO2.7 Nginx的虚拟主机配置</h3><p>所谓虚拟主机，其实就是server块，也就是说通过配置多个不同的server就能够达到配置不同服务器效果。常用于根据不同的城市站点进入不同服务器进行操作。如，租房定位，然后进入不同的城市服务站点，就可以通过这种方式来实现。</p><ul><li><p>Nginx的虚拟主机可分为：</p><ul><li><p>基于端口的虚拟主机：即主要是通过端口号来区分不同的虚拟主机服务器；</p></li><li><p>基于域名的虚拟主机：即通过域名，也就是server_name来区分不同的虚拟主机服务器。</p>  <pre><code class="hljs roboconf">//在主Nginx中配置基于域名进行不同的转发....省略其他//beijing负载均衡配置upstream www.beijing.myweb.com &#123;    <span class="hljs-attribute">server 192.168.1.100</span>:8000;  &#125;//nanjing负载均衡配置upstream www.nanjing.myweb.com &#123;    <span class="hljs-attribute">server 192.168.1.100</span>:8000;  &#125;//tianjing负载均衡配置upstream www.tianjing.myweb.com &#123;    <span class="hljs-attribute">server 192.168.1.100</span>:8000;  &#125;//第一个虚拟主机server &#123;    <span class="hljs-attribute">listen         80;</span><span class="hljs-attribute">    server_name    beijing.myweb.com;</span><span class="hljs-attribute">    </span><span class="hljs-attribute">    //动态请求走这里：</span><span class="hljs-attribute">    location  /aaa &#123;</span><span class="hljs-attribute">        proxy_pass  http</span>://www<span class="hljs-variable">.beijing</span><span class="hljs-variable">.myweb</span><span class="hljs-variable">.com</span>  //跳转到www<span class="hljs-variable">.beijing</span><span class="hljs-variable">.myweb</span><span class="hljs-variable">.com</span>，并进行负载均衡      &#125;&#125;//第二个虚拟主机server &#123;    listen         80;    <span class="hljs-attribute">server_name    nanjing.myweb.com;</span><span class="hljs-attribute">    </span><span class="hljs-attribute">    //动态请求走这里：</span><span class="hljs-attribute">    location  /aaa &#123;</span><span class="hljs-attribute">        proxy_pass  http</span>://www<span class="hljs-variable">.nanjing</span><span class="hljs-variable">.myweb</span><span class="hljs-variable">.com</span>  //跳转到www<span class="hljs-variable">.nanjing</span><span class="hljs-variable">.myweb</span><span class="hljs-variable">.com</span>，并进行负载均衡      &#125;&#125;//第三个虚拟主机server &#123;    listen         80;    <span class="hljs-attribute">server_name    tianjing.myweb.com;</span><span class="hljs-attribute">    </span><span class="hljs-attribute">    //动态请求走这里：</span><span class="hljs-attribute">    location  /aaa &#123;</span><span class="hljs-attribute">        proxy_pass  http</span>://www<span class="hljs-variable">.tianjing</span><span class="hljs-variable">.myweb</span><span class="hljs-variable">.com</span>  //跳转到www<span class="hljs-variable">.tianjing</span><span class="hljs-variable">.myweb</span><span class="hljs-variable">.com</span>，并进行负载均衡      &#125;&#125;....省略其他注意：通过域名访问时，必须在本机上的C:\Windows\System32\drivers\etc\hosts文件中指定域名的解析，也就是我输入域名，要跳转到哪个IP去，只不过用域名代替了IP，便捷易记而已：实际要跳转到的IP 自定义的域名拓展：还可以使用include方式实现上述配置(推荐该方式，这样主配置文件就不会有那么多的复杂配置)一、仍然要配置三个server；二、将三个配置好的server放入到一个文件中，取名为vhost<span class="hljs-variable">.conf</span>，并将vhost<span class="hljs-variable">.conf</span>放入到nginx目录中的conf目录下；三、在Nginx的nginx<span class="hljs-variable">.conf</span>中加入：include /usr/local/nginx/conf/vhost;即可。</code></pre><p>  <img src="./Image-n9.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>5.다른 과정</category>
      
      <category>07.服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01.Linux--学习笔记</title>
    <link href="/2020/07/11/Linux--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/11/Linux--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux–学习笔记-包含Linux视频"><a href="#Linux–学习笔记-包含Linux视频" class="headerlink" title="Linux–学习笔记(包含Linux视频)"></a>Linux–学习笔记(包含Linux视频)</h1><h2 id="Lesson1-Linux概述"><a href="#Lesson1-Linux概述" class="headerlink" title="Lesson1 Linux概述"></a>Lesson1 Linux概述</h2><h3 id="NO1-1-Linux简介"><a href="#NO1-1-Linux简介" class="headerlink" title="NO1.1 Linux简介"></a>NO1.1 Linux简介</h3><p>Linux是一个多用户、多任务的操作系统。与Windows不同之处在于，Linux是一套开放源代码程序的、可以自由传播的类Unix操作系统软件。</p><ul><li>Linux系统主要被应用于服务器端、嵌入式开发和PC桌面三大领域，其中服务器端领域是重中之重。如，我们熟知的百度、腾讯、Sina、阿里等，都在使用Linux系统作为其服务器端的程序运行平台，全球及国内排名前1000的90%以上的网站使用的主流系统都是Linux系统。</li></ul><p>&nbsp;</p><ul><li>Linux是一个类似Unix的操作系统，也就是说，Linux源于Unix。Unix要早于Linux，Linux的初衷就是要替代 UNIX，并在功能和用户体验上进行优化，所以Linux模仿了UNIX(但并没有抄袭UNIX的源码)，使得Linux在外观和交互上与UNIX非常类似。相比于UNIX，Linux最大的创新是开源免费，这是它能够蓬勃发展的最重要原因；而目前的UNIX大部分都是收费的，小公司和个人都难以承受。</li></ul><p>&nbsp;</p><ul><li>Linux的特点：<ul><li>有大量的可用软件及免费软件。如，声名赫赫的Apache、Samba、PHP、MySQL等，构建成本低廉，是Linux被众多企业青睐的原因之一；</li><li>具备良好的可移植性及灵活性。Linux系统有良好的可移植性，它几乎支持所有的CPU平台；</li><li>优良的稳定性和安全性。Linux开放源代码，将所有代码放在网上，全世界的程序员都看得到，有什么缺陷和漏洞，很快就会被发现，从而成就了它的稳定性和安全注；</li><li>支持几乎所有的网络协议及开发语言。</li></ul></li></ul><p>&nbsp;</p><ul><li>Linux的发行版本大体可以分为两类：<ul><li>商业公司维护的发行版本，以著名的Red Hat为代表；</li><li>社区组织维护的发行版本，以Debian为代表。</li></ul></li></ul><p>&nbsp;</p><ul><li>常用的Linux发行版本：<ul><li>Red Hat Linux：Red Hat(红帽公司)创建于1993年，是目前世界上资深的Linux厂商，也是最获认可的Linux品牌。Red Hat公司的产品主要包括RHEL(Red Hat Enterprise Linux，收费版本)和CentOS(RHEL的社区克隆版本，免费版本)、Fedora Core(由Red Hat桌面版发展而来，免费版本)；</li><li>Ubuntu Linux：Ubuntu基于知名的Debian Linux发展而来，界面友好，容易上手，对硬件的支持非常全面，是目前最适合做桌面系统的 Linux 发行版本，而且Ubuntu的所有发行版本都免费提供；</li><li>SuSE Linux：SuSE Linux以Slackware Linux为基础，原来是德国的SuSE Linux AG公司发布的Linux版本，早期只有商业版本，2004年被 Novell公司收购后，成立了OpenSUSE 社区，推出了自己的社区版本OpenSUSE；SuSE Linux在欧洲较为流行。SuSE Linux可以非常方便地实现与Windows的交互，硬件检测非常优秀，拥有界面友好的安装过程、图形管理工具，对于终端用户和管理员来说使用非常方便；</li><li>其他Linux发行版。</li></ul></li></ul><p>&nbsp;</p><ul><li>发行版本的选择使用：<ul><li>如果你需要的是一个服务器系统，而且已经厌烦了各种Linux的配置，只是想要一个比较稳定的服务器系统，那么建议你选择CentOS或RHEL；</li><li>如果你只是需要一个桌面系统，而且既不想使用盗版，又不想花大价钱购买商业软件，不想自己定制，也不想在系统上浪费太多时间，则可以选择Ubuntu。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-2-安装VM和Linux，以及配置Linux"><a href="#NO1-2-安装VM和Linux，以及配置Linux" class="headerlink" title="NO1.2 安装VM和Linux，以及配置Linux"></a>NO1.2 安装VM和Linux，以及配置Linux</h3><p>这里使用VM12虚拟机来安装Linux(CentOS 6.8/7.x均可)系统。</p><ul><li><p>安装完成VM12之后，将CentOS 6.8/7.x安装到VM12上，这两步安装的步骤只要按照具体的安装视频或者安装文档来安装即可，这里不做过多的描述。</p><ul><li><p>终端的使用：在进入Linux6.8/7.x之后，右键鼠标，选择“在终端中打开”即可；</p><p>  <img src="./Image-ln1.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>网络的连接：在Linux界面的右上角点击网络图标，选择“System eth0”，就会自动连接网络了。</p><p>  <img src="./Image-ln2.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>VMTools的安装和使用，该工具用于共享主机和虚拟机之间的文件，说白了就是本机和虚拟机之间能够进行复制和粘贴。</p><ul><li><p>点击VM12的菜单栏，选择安装VMTools选项即可；</p></li><li><p>点击Linux中的计算机，双击第一个，这时就会出现VMTools的安装包，是一个xxx.tar.gz格式的文件；</p></li><li><p>将这个安装包复制到opt文件夹下，这个文件夹一般是我们用户自己安装软件的常用文件夹；</p></li><li><p>打开终端，输入命令：./vmware-install.pl，一路回车即可。</p><p>  <img src="./Image-ln3.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><ul><li>本机和虚拟机之间的共享文件夹设置。<ul><li>虚拟机菜单栏里是选择设置，选择选项一栏，启用共享文件，并添加本机上要共享的文件夹；</li><li>该文件夹在虚拟机的地址为：计算机/文件系统/mnt/hgfs/。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-3-Linux文件目录结构"><a href="#NO1-3-Linux文件目录结构" class="headerlink" title="NO1.3  Linux文件目录结构"></a>NO1.3  Linux文件目录结构</h3><p>Linux的根目录是“/”，有且只有这一个根目录。</p><ul><li>Linux的文件目录结构(即以下文件夹都是在“/”根目录下)。<ul><li><code>bin</code>：存放系统命令，普通用户和 root 都可以执行。放在 /bin 下的命令在单用户模式下也可以执行；</li><li><code>boot</code>：系统启动目录，保存与系统启动相关的文件，<code>如，内核文件和启动引导程序(grub)文件等</code>；</li><li><code>dev</code>：设备文件保存位置；</li><li><code>etc</code>：配置文件保存位置。系统内所有采用默认安装方式(rpm 安装)的服务配置文件全部保存在此目录中。如，用户信息、服务的启动脚本、常用服务的配置文件等；</li><li><code>home</code>：普通用户的主目录(也称为家目录)。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在/home/下建立一个和用户名相同的目录。<code>如，用户liming的主目录就是/home/liming</code>；</li><li><code>lib</code>：系统调用的函数库保存位置；</li><li><code>media</code>：挂载目录。系统建议用来挂载媒体设备。<code>如，软盘和光盘</code>；</li><li><code>mnt</code>：挂载目录。早期Linux中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备。<code>如，U盘、移动硬盘和其他操作系统的分区</code>；</li><li><code>misc</code>：挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录 /media/、/mnt/、/misc/，但是到底在哪个目录中挂载什么设备可以由管理员自己决定。如，我在接触 Linux 的时候，默认挂载目录只有 /mnt/，所以养成了在 /mnt/ 下建立不同目录挂载不同设备的习惯，如 /mnt/cdrom/ 挂载光盘、/mnt/usb/ 挂载 U 盘，都是可以的；</li><li><code>opt</code>：第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过我还是习惯把软件放到 /usr/local/ 目录中，也就是说，/usr/local/ 目录也可以用来安装软件；</li><li><code>root</code>：系统管理员的的主目录。普通用户主目录在/home/下，系统管理员的主目录直接在“/”下；</li><li><code>sbin</code>：保存与系统环境设置相关的命令，只有root可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看；</li><li><code>srv</code>：服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据；</li><li><code>tmp</code>：临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空；</li><li><code>usr</code>：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录；<ul><li><code>usr/local</code>：手工安装的软件保存位置。这也是常用于安装软件的位置。</li></ul></li><li><code>var</code>：目录用于存储动态数据，例如缓存、日志文件、软件运行过程中产生的文件等。</li></ul></li></ul><p>&nbsp;</p><ul><li>Linux是以文件的形式管理我们的设备的，换句话说，就是Linux系统中，一切皆文件，无论是CPU，还是别的什么设备，都是以文件的形式进行存储。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-4-Linux远程登录与文件传输"><a href="#NO1-4-Linux远程登录与文件传输" class="headerlink" title="NO1.4 Linux远程登录与文件传输"></a>NO1.4 Linux远程登录与文件传输</h3><p>我们常常需要使用Linux，但是有时候Linux系统并不在本机，而是在其他专门的用于服务器的电脑上，那么这个时候我们就需要远程登录Linux，然后进行文件的上传和下载了。</p><ul><li><p>Linux远程登录：XShell。Xshell是Windows下一款功能非常强大的安全终端模拟软件，支持Telnet、Rlogin、SSH、SFTP、Serial 等协议，可以非常方便的对linux主机进行远程管理。安装步骤如下：</p><ul><li><p>直接下载并安装XShell5即可；</p></li><li><p>打开XShell5，并进行连接配置，如下图所示：</p><p>  <img src="./Image-ln4.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>连接配置完成后，就可以开始连接了；连接时会提示你输入Linux系统的用户名和密码，说白了就是我用什么身份去登录这个Linux，之前安装Linux系统的时候设置过了的，而账户默认大家都是root，密码则是自己设置的密码，输入完成后就可以登录。</p><p>  <img src="./Image-ln5.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>Linux文件传输：XFTP。这是一个基于MS windows平台的功能强大的SFTP、FTP文件传输软件。使用了Xftp以后，MS windows用户能安全地在UNIX/Linux和Windows PC之间传输文件。注意：该软件需要Linux主机开启了sshd服务，该服务的作用就是能够让别的电脑和Linux主机建立连接并进行文件传输；在Linux主机是使用命令查看sshd服务是否已开启：service sshd status，如果是正在运行，那么就表示已开启，否则就是没有开启。该服务监听的端口号为22。</p><ul><li><p>安装步骤比较简单，就不详述了；</p></li><li><p>配置XFTP，即配置连接Linux：安装完成后，打开XFTP，在左上角的菜单栏中找到“打开”，就会出现名为“会话”的对话框，点击新建，如下图所示；</p><p>  <img src="./Image-ln6.png" srcset="/img/loading.gif" alt=""></p><p>  <img src="./Image-ln7.png" srcset="/img/loading.gif" alt=""></p></li><li><p>上面描述的步骤都操作完成了，那么XFTP就配置完成，可以使用了。</p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson2-Linux基础"><a href="#Lesson2-Linux基础" class="headerlink" title="Lesson2 Linux基础"></a>Lesson2 Linux基础</h2><h3 id="NO2-1-vi和vim的使用"><a href="#NO2-1-vi和vim的使用" class="headerlink" title="NO2.1 vi和vim的使用"></a>NO2.1 vi和vim的使用</h3><p>所有的类Unix系统都会内建vi文本编辑器，也就是说vi是一个文书编辑器。而vim是从vi发展出来的一个文本编辑器。代码补充、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><ul><li><p>简单的来说，vi是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。vim则可以说是程序开发者的一项很好用的工具。vi/vim 有三种模式，分别是正常模式(Command mode)、编辑模式(Insert mode)和命令行模式(Last line mode)。这三种模式的作用分别是：</p><ul><li><p>正常模式：用户刚刚启动vi/vim，即使用“vim 文件名称”，便进入了正常模式。此状态下敲击键盘动作会被vim识别为命令，而非输入字符。如，我们此时按下i，并不会输入一个字符，i被当作了一个命令；以下是常用的几个命令：</p><ul><li><code>i命令</code>：切换到编辑模式，以输入字符；</li><li><code>x命令</code>：删除当前光标所在处的字符；</li><li><code>:命令</code>：切换到命令行模式，以在最底一行输入命令。</li></ul></li><li><p>编辑模式：在正常模式下按下i就进入了编辑模式。在输入模式中，可以使用以下按键：</p><ul><li><code>HOME/END</code>：移动光标到行首/行尾；</li><li><code>Page Up/Page Down</code>：上/下翻页；</li><li><code>Insert</code>：切换光标为输入/替换模式；</li><li><code>ESC</code>：退出编辑模式，切换到正常模式。</li></ul></li><li><p>命令行模式：在编辑模式下按下:(即英文冒号)就进入了命令行模式。命令行模式可以输入单个或多个字符的命令，可用的命令非常多。在命令行模式中，基本的命令有：注意：按ESC键可随时退出命令行模式。</p><ul><li><p><code>:q命令</code>：(查看文件后，没有修改)退出程序；</p><ul><li>:<code>q!命令</code>：表示不保存修改部分，并退出；</li><li><code>:wq命令</code>：表示保存修改部分，并退出。</li></ul></li><li><p><code>:w命令</code>：仅做保存文件的操作，不做退出文件的操作。</p><p>  <img src="./Image-ln8.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>vi/vim的快捷键：<ul><li><code>yy</code>：需要在正常模式中使用，作用是拷贝光标所在的当前行，随后按p粘贴；</li><li><code>dd</code>：需要在正常模式中使用，作用是删除光标所在的当前行；</li><li><code>gg/G</code>：需要在正常模式中使用，作用是快速跳转到首行/最后一行；</li><li><code>u</code>：需要在正常模式中使用，作用是撤销上一次保存的所有操作，但是在使用“:wq”之后，使用该命令无法撤销；</li><li><code>行号 shift+g</code>：需要在正常模式中使用，作用是跳转到指定行；</li><li><code>行数+ente</code>r：需要在正常模式中使用，作用是跳转到从当前行开始+指定行数。如，光标在第2行，转换到正常模式中，输入3，再按enter键，就会跳到第5行；</li><li><code>:/</code>：需要在命令行模式中使用，作用是查找，格式为：“:/要查找的单词”，按n跳转到下一个查找到的关键字；</li><li><code>:set nu/:set nonu</code>：需要在命令行模式中使用，作用是显示行号/不显示行号。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-2-重启、关机和用户登录注销"><a href="#NO2-2-重启、关机和用户登录注销" class="headerlink" title="NO2.2 重启、关机和用户登录注销"></a>NO2.2 重启、关机和用户登录注销</h3><p>关机、重启和用户的登录与注销，这些都是我们Linux用户常用的命令。</p><ul><li>关机和重启命令：<ul><li>关机命令：<ul><li><code>shutdown -h now</code>：表示立即关机；</li><li><code>shutdown -h 1</code>：表示1分钟后关机；</li><li><code>halt</code>：立即关机。</li></ul></li><li>重启命令：<ul><li><code>reboot</code>：立即重启系统；</li><li><code>shutdown -r now</code>：表示立即重启。</li></ul></li><li>保存命令：<ul><li><code>sync</code>：把内存的数据保存到磁盘，简单讲，就是保存数据的意思，建议关机或重启之前都使用以下该命令。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>用户的登录与注销：我们常常不使用root用户进行登录并操作Linux，因为root是最大权限的管理者，可能因为不小心的错误导致系统异常，所以我们一般会使用权限较低的用户登录和操作。<ul><li>用户注销(退出)：使用命令logout即可，表示退出当前登录的用户。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-3-用户管理"><a href="#NO2-3-用户管理" class="headerlink" title="NO2.3 用户管理"></a>NO2.3 用户管理</h3><p>Linux系统是一个多用户、多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。换句话说，Linux系统支持多个用户在同一时间内登陆，不同用户可以执行不同的任务，并且互不影响。</p><ul><li>用户和用户组：<ul><li>用户：每个用户都拥有唯一的用户名和各自的口令；</li><li>用户组：是具有相同特征用户的集合。简单的理解，就是有时我们需要让多个用户具有相同的权限。如，查看、修改某一个文件的权限等等，如果有10个用户的话，就需要授权10次，那如果有100、1000甚至更多的用户呢？显然，这种方法不太合理。最好的方式是建立一个组，让这个组具有查看、修改此文件的权限，然后将所有需要访问此文件的用户放入这个组中，那么，所有用户就具有了和组一样的权限，这就是用户组。</li></ul></li></ul><p>&nbsp;</p><ul><li><p>linux系统用户角色的划分：Linux系统中，每个用户的ID细分为两种，分别是用户ID(User ID，简称UID)和组ID(Group ID，简称GID)，也就是说其实Linux并不认识你的用户名称，它只认识用户名对应的ID号(也就是一串数字)；Linux系统将所有用户的用户名与ID的对应关系都存储在 /etc/passwd文件中。每个文件都有自己的UID和GID。用户的划分：</p><ul><li><p>超级用户：默认是root用户，其UID和GID均为0。在每台unix/linux操作系统中都是唯一且真实存在的，通过它可以登录系统，可以操作系统中任何文件和命令，拥有最高的管理权限。在生产环境，一般禁止root账号远程登录SSH连接服务器，以加强系统安全；</p></li><li><p>程序用户：UID范围为1~499。与真实的普通用户区分开来，这类用户最大特点是安装系统后默认就会存在，且默认情况大多数不能登陆系统，其在/etc/passwd文件中，最后字段为/sbin/nologin的都是程序用户。但是，他们是系统正常运行不可缺少的，他们的主要是方便系统管理，满足相应的系统进程对文件属主的要求。如，默认的bin，adm，nobody，mail用户等等。服务的运行需要用户角色，可以不用登陆。如，当我们需要运行MySQL数据库时，可以创建一个虚拟用户，作为运行MySQL服务的角色；</p><p>  <img src="./Image-ln9.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>普通用户：UID范围为500~65535。这类用户一般是由超级用户(即root用户)进行添加。</p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>用户的添加、删除、修改与查询。<strong><code>注意：用户的信息都放在了/etc/passwd文件中；每行的含义是：用户名:口令:用户ID号:组ID号:注视性描述:主目录:登录Shell。</code></strong></p><ul><li><p>添加：<code>useradd [选项] 用户名</code>。其中[选项]如下；通常情况下，根本不需要手工指定任何内容，因为使用默认值就可以满足我们的要求；</p><ul><li><p><code>-u UID</code>：手工指定用户的UID，但是UID的范围不要小于500；</p></li><li><p><code>-d 主目录</code>：手工指定用户的主目录。主目录必须写绝对路径，而且如果需要手工指定主目录，则一定要注意权限；</p></li><li><p><code>-c 用户说明</code>：手工指定/etc/passwd文件中各用户信息中第5个字段的描述性内容，可随意配置；</p></li><li><p><code>-g 组名</code>：手工指定用户的初始组。一般以和用户名相同的组作为用户的初始组，在创建用户时会默认建立初始组。一旦手动指定，则系统将不会再创建和用户名相同的那个初始组目录；</p></li><li><p><code>-G 组名</code>：指定用户的附加组。我们把用户加入其他组，一般都使用附加组；</p></li><li><p><code>-s shell</code>：手工指定用户的登录Shell，默认是/bin/bash；</p></li><li><p><code>-e 日期</code>：指定用户的失效日期，格式为”YYYY-MM-DD”。也就是/etc/shadow文件的第八个字段；</p></li><li><p><code>-o</code>：允许创建的用户的UID可以与其他用户的UID相同。如，执行 “useradd -u 0 -o usertest” 命令建立用户 usertest，它的UID和root用户的UID相同，都是0；</p></li><li><p><code>-m</code>：建立用户时强制建立用户的家目录。在建立系统用户时，该选项是默认的；</p></li><li><p><code>-r</code>：创建系统用户，也就是UID在1~499之间，供系统程序使用的用户。由于系统用户主要用于运行系统所需服务的权限配置，因此系统用户的创建默认不会创建主目录。</p><p>  <img src="./Image-ln10.png" srcset="/img/loading.gif" alt=""></p>  <pre><code class="hljs angelscript">useradd -d /home/master dyf  <span class="hljs-comment">//这就表示创建了一个dyf用户，并指定了主目录为master，如果没有就会自动创建该主目录</span>拓展：为添加的用户设置密码一、格式：passwd [选项] 用户名；二、[选项]中的内容：    <span class="hljs-number">1.</span>-l：锁定已经命名的账户名称；    <span class="hljs-number">2.</span>-u：解开账户锁定状态；    <span class="hljs-number">3.</span>-x, --maximum=DAYS：密码使用最大时间（天）；    <span class="hljs-number">4.</span>-n, --minimum=DAYS：密码使用最小时间（天）；    <span class="hljs-number">5.</span>-d：删除使用者的密码；    <span class="hljs-number">6.</span>-S：检查指定使用者的密码认证种类；    <span class="hljs-number">7.</span>--stdin：非交互式修改/设置密码，弊端是操作日志能查密码，用history -c 干掉。</code></pre></li></ul></li><li><p>删除：<code>userdel 用户名</code>。分为两种删除：</p><ul><li><p>删除用户时，并不删除其关联的主目录：<code>userdel 用户名</code>。工作中，删除Linux用户后，一般不会将用户所在的主目录删除掉，所以常用的一般是这个。</p></li><li><p>删除用户时，也同时删除其关联的主目录：<code>userdel -r 用户名</code>。如下图所示。</p><p>  <img src="./Image-ln11.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li><li><p>修改：</p><ul><li><p>修改用户信息：<code>usermod [选项] 用户名</code>。选项如下：</p><ul><li><p><code>-c 用户说明</code>：修改用户的说明信息，即修改/etc/passwd文件目标用户信息的第5个字段；</p></li><li><p><code>-d 主目录</code>：修改用户的主目录，即修改/etc/passwd文件中目标用户信息的第6个字段，需要注意的是，主目录必须写绝对路径；</p></li><li><p><code>-e 日期</code>：修改用户的失效曰期，格式为”YYYY-MM-DD”，即修改 /etc/shadow 文件目标用户密码信息的第8个字段；</p></li><li><p><code>-g 组名</code>：修改用户的初始组，即修改/etc/passwd文件目标用户信息的第4个字段(GID)；</p></li><li><p><code>-u UID</code>：修改用户的UID，即修改/etc/passwd文件目标用户信息的第3个字段(UID)；</p></li><li><p><code>-G 组名</code>：修改用户的附加组，其实就是把用户加入其他用户组，即修改/etc/group文件；</p></li><li><p><code>-l 用户名</code>：修改用户名称；</p></li><li><p><code>-L</code>：临时锁定用户(Lock)；</p></li><li><p><code>-U</code>：解锁用户(Unlock)，和-L对应；</p></li><li><p><code>-s shell</code>：修改用户的登录 Shell，默认是/bin/bash。</p><p>  <img src="./Image-ln12.png" srcset="/img/loading.gif" alt=""></p></li><li><p>临时切换用户的身份：<code>su [选项] 用户名</code>。<strong><code>选项如下；注意：用户切换之后，想要切换回原先的用户，使用exit即可，退回到原先的用户。</code></strong></p><ul><li><p><code>-</code>：当前用户不仅切换为指定用户的身份，同时所用的工作环境也切换为此用户的环境(包括PATH变量、MAIL变量等)。使用“-”选项可省略用户名，默认会切换为root用户；</p></li><li><p><code>-l</code>：同 - 的使用类似，也就是在切换用户身份的同时，完整切换工作环境，但后面需要添加欲切换的使用者账号；</p></li><li><p><code>-p</code>：表示切换为指定用户的身份，但不改变当前的工作环境(不使用切换用户的配置文件)；</p></li><li><p><code>-m</code>：和-p命令一样；</p></li><li><p><code>-c</code>：仅切换用户执行一次命令，执行后自动切换回来，该选项后通常会带有要执行的命令。</p><p>  <img src="./Image-ln13.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul></li></ul></li><li><p>查询：</p><ul><li><p>查询指定用户的信息：<code>id 用户名</code>；</p><p>  <img src="./Image-ln14.png" srcset="/img/loading.gif" alt=""></p></li><li><p>查询当前用户：</p><ul><li><p>打印当前执行操作的用户名：<code>whoami</code>；</p></li><li><p>打印登陆当前Linux系统的用户名：<code>who am i</code>。</p><p>  <img src="./Image-ln15.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>用户组的管理。<strong><code>注意：用户组的信息都放在了/etc/group文件里；每行的含义是：组名:口令:组ID号:组内的用户。</code></strong></p><p>  <img src="./Image-ln16.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>用户组的添加：<code>groupadd [选项] 组名</code>。</p><ul><li><code>-g GID</code>：指定组的ID；</li><li><code>-r</code>：创建系统群组。</li></ul></li><li><p>用户组的删除：<code>groupdel 组名</code>。</p></li><li><p>用户组的修改：<code>groupmod [选项] 组名</code>。选项如下：</p><ul><li><p><code>-g GID</code>：修改组ID；</p></li><li><p><code>-n 新组名</code>：修改组名。</p><p>  <img src="./Image-ln17.png" srcset="/img/loading.gif" alt="image-20200711140120014"></p></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-4-运行级别和Root密码找回"><a href="#NO2-4-运行级别和Root密码找回" class="headerlink" title="NO2.4 运行级别和Root密码找回"></a>NO2.4 运行级别和Root密码找回</h3><p>Linux的运行级别有7个。</p><ul><li><p>Linux的7个运行级别；<strong><code>注意：Linux运行级别的配置文件为/etc/inittab</code>。</strong></p><ul><li><p><code>0</code>：关机；</p></li><li><p><code>1</code>：单用户模式，可以想象为Windows的安全模式，主要用于系统修复；单用户模式不需要密码就可以登录，所以一般会用来找回root密码；</p></li><li><p><code>2</code>：无网络支持的多用户模式；</p></li><li><p><code>3</code>：有网络支持的多用户模式(文本模式，工作中最常用的模式)；</p></li><li><p><code>4</code>：保留，未使用；</p></li><li><p><code>5</code>：图形界面；</p></li><li><p><code>6</code>: 重启。</p><p>  <img src="./Image-ln18.png" srcset="/img/loading.gif" alt="image-20200711140236576"></p></li></ul></li></ul><p>&nbsp;</p><ul><li>改变当前的运行级别：<code>init 运行级别</code>。<code>如，从图像界面5转换到命令行界面3，使用命令：init 3</code>。</li></ul><p>&nbsp;</p><ul><li><p>如果我们不小心忘记了root密码，无法登陆Linux，怎么把呢？方法：可以让linux通过进入单用户模式来重置root密码命令。</p><ul><li><p>在Linux开机读秒时按任意键进入grub菜单；</p><p>  <img src="./Image-ln19.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>根据提示，按e进入编辑界面；</p><p>  <img src="./Image-ln20.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>选择第二项：内核，继续按e编辑；</p><p>  <img src="./Image-ln21.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>结尾输入：<code>[空格] 1[回车]</code>；</p><p>  <img src="./Image-ln22.png" srcset="/img/loading.gif" alt="image-20200711140555621"></p></li><li><p>回到菜单界面，按b启动；</p><p>  <img src="./Image-ln23.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>启动后就会进入到单用户模式，可以使用passwd命令直接重置root用户密码；</p><p>  <img src="./Image-ln24.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>密码修改完成后使用reboot命令重启，系统将会重新进入之前默认的运行级别。</p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-5-帮助类命令"><a href="#NO2-5-帮助类命令" class="headerlink" title="NO2.5 帮助类命令"></a>NO2.5 帮助类命令</h3><p>如果我们不熟悉指令的用法，Linux也提供了指令的说明。</p><ul><li><p>使用man获得某个指令的用法：<code>man 命令名称</code>；该命令的功能是获得想要了解的指令的用法。<code>如，man ls，表示想要知道ls这个命令的用法</code>。</p></li><li><p>使用help获得某个指令的说明：<code>help 命令名称</code>；该命令用于查看指定的命令的说明。<code>如，help cd，表示查看cd命令的说明文档</code>。</p></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-6-文件目录类常用命令"><a href="#NO2-6-文件目录类常用命令" class="headerlink" title="NO2.6 文件目录类常用命令"></a>NO2.6 文件目录类常用命令</h3><p>接下来要学习的是Linux中常用的文本目录命令，这些都比较重要，因为使用的频率很高。</p><ul><li><code>pwd命令</code>：查看当前工作目录的完整路径(也就是绝对路径)；格式：<code>pwd</code>。</li></ul><p>&nbsp;</p><ul><li><p><code>ls命令</code>：用来打印当前目录的清单，可以指定其他目录；格式：<code>ls [选项]</code>。选项如下；<code>如，ls -l t*：列出所有文件名以&quot;t&quot;开头的文件信息</code>。</p><ul><li><p><code>-a</code>：列出目录下所有的文件，包括以”.”开头的隐藏文件；</p></li><li><p><code>-l</code>：以列表的方式列出：文件名、文件权限、所有者、大小等详细信息；</p></li><li><p><code>-r</code>：反向次序排列；</p></li><li><p><code>-t</code>：以文件修改时间排序；</p></li><li><p><code>-g</code>：类似-l，但是不列出所有者；</p></li><li><p><code>-h</code>：以容易理解的文件格式列出。</p><p>  <img src="./Image-ln25.png" srcset="/img/loading.gif" alt="image-20200711140853717"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><code>cd命令</code>：切换到指定的文件目录中去；格式：<code>cd /文件目录</code>。以下是常用的cd命令形式：<ul><li><code>cd /</code>：进入系统根目录；</li><li><code>cd /aa/bb/cc</code>：跳转到指定目录；</li><li><code>cd ~/cd</code>：进入当前用户所属的home目录中；</li><li><code>cd ..</code>：跳转到上一级。</li></ul></li></ul><p>&nbsp;</p><ul><li><code>mkdir命令</code>：用于创建目录，简单讲就是创建文件夹，但只能创建一级的目录，要是父目录不存在就会报错；格式：<code>mkdir [选项] 要创建的目录名称</code>。选项如下：<ul><li><code>-p</code>：自动按需创建父目录。<code>如，mkdir -p /home/aaa/bbb，其中aaa和bbb文件夹都不存在，要创建多级目录，就要加入-p选项</code>；</li><li><code>-m</code>：创建目录时给定权限。</li></ul></li></ul><p>&nbsp;</p><ul><li><p><code>rmdir命令</code>：用于删除目录，就是删除指定的文件夹，但无法删除非空文件夹，即里面有文件或文件夹则无法删除；格式：<code>rmdir [选项] 要删除的目录名称</code>。选项如下；<strong><code>注意：如果要删除的目录里有东西，使用“rm -rf 指定要删除的目录名称”，那么指定目录以及里面的东西都会一并删除。</code></strong></p><ul><li><p><code>-p</code>：删除指定目录后如果其父目录为空，则一并删除；</p><p>  <img src="./Image-ln26.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p><code>touch命令</code>：用于创建一个或多个空的文件；格式：<code>touch 文件1 文件2....</code>。</p><p>  <img src="./Image-ln27.png" srcset="/img/loading.gif" alt="Image"></p></li></ul><p>&nbsp;</p><ul><li><p><code>cp命令</code>：用于复制文件。有两种：</p><ul><li><p>文件到文件或目录到目录的复制，格式：<code>cp [选项] SOURCE DEST(如果DEST文件不存在则创建，存在则覆盖；如果DEST是目录，目录不存在则无法复制)</code>；</p></li><li><p>文件到目录的复制，格式：<code>cp [选项] SOURCE... DIRECTORY(DEST必须为directory，也就是目录)</code>。两种复制的选项如下；<strong><code>注意：如果想要强制覆盖某个目录或某个文件，只需要在cp前面加个\即可，就不会询问用户是否覆盖了。</code></strong></p><ul><li><p><code>-i</code>：交互式复制，即覆盖前提醒用户确认；</p></li><li><p><code>-f</code>：强制覆盖目标文件；</p></li><li><p><code>-r/-R</code>：递归复制目录。</p><p>  <img src="./Image-ln28.png" srcset="/img/loading.gif" alt="image-20200711141212063"></p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p><code>rm指令</code>：删除文件或目录；格式：<code>rm [选项] 要删除的文件或目录</code>。选项如下：</p><ul><li><p><code>-f</code>：强制删除目标文件，不提示；</p></li><li><p><code>-r/-R</code>：递归处理，将制定目录下的所有文件包括目录一并删除。</p><p>  <img src="./Image-ln29.png" srcset="/img/loading.gif" alt="image-20200711141357270"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p><code>mv指令</code>：有两个功能。</p><ul><li><p>剪切文件或目录：格式：<code>mv file dest</code>；</p></li><li><p>重命名文件或目录：格式：<code>mv oldName newName</code>。</p><p>  <img src="./Image-ln30.png" srcset="/img/loading.gif" alt="image-20200711141447623"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p><code>cat指令</code>：以只读的方式查看文件内容，即只能查看，无法修改；格式：<code>cat [选项] 要查看的文件</code>。选项如下：</p><ul><li><p><code>-n</code>：显示行号；</p></li><li><p><code>-E</code>：在每一行的结束的地方显示“$”符号。</p>  <pre><code class="hljs stata">拓展：如果要显示的文件内容过多，你希望一页一页的显示一、使用“<span class="hljs-keyword">cat</span> [选项] 要查看的文件 | <span class="hljs-keyword">more</span>”，这样就能够一页一页的显示文件的内容，按空格键翻页。</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><code>more指令</code>：以全屏的方式按页来显示文本内容；格式：<code>more 要查看的文件</code>。进入more命令后，可以使用以下快捷键：<ul><li><code>Space键</code>：显示文本下一屏内容；</li><li><code>Enter键</code>：只显示文本下一行内容；</li><li><code>b键</code>：显示文本上一屏内容；</li><li><code>q键</code>：退出。</li></ul></li></ul><p>&nbsp;</p><ul><li><code>less指令</code>：分页显示文件的内容，一般用于大型文件的内容查看(如，10M、100M等)，优点在于不会加载文件的全部内容，而是一边查看一边加载，所以速度较快；格式：<code>less 要查看的文件</code>。进入less命令后，可以使用以下快捷键：<ul><li><code>Space键</code>：显示文本下一屏内容；</li><li><code>Enter键</code>：只显示文本下一行内容；</li><li><code>b键</code>：显示文本上一屏内容；</li><li><code>q键</code>：退出。</li></ul></li></ul><p>&nbsp;</p><ul><li><code>&gt;和&gt;&gt;命令</code>：<ul><li><code>&gt;</code>：表示输出到文件中，文件不存则会创建；文件已存在，内容会被覆盖，修改时间会更新；</li><li><code>&gt;&gt;</code>：表示输出到文件中，文件不存则会创建。文件已存在，内容会继续追加在后面，修改时间会更新。</li></ul></li></ul><p>&nbsp;</p><ul><li><p><code>echo命令</code>：输出内容到控制台；格式：<code>echo [选项] 要输出的内容</code>。选项如下：</p><ul><li><p><code>-n</code>：表示输出之后不换行；</p></li><li><p><code>-e</code>：表示对于转义字符按对应的方式进行处理。</p><p>  <img src="./Image-ln31.png" srcset="/img/loading.gif" alt="image-20200711141748970"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p><code>head指令</code>：显示文本内容，默认显示头10行；格式：<code>head [选项] 要显示的文件</code>。选项如下：</p><ul><li><p><code>-n #</code>：显示文本头#行内容。</p><p>  <img src="./Image-ln32.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><code>tail命令</code>：显示文本内容，默认显示后10行；格式：<code>tail [选项] 要查看的文件</code>。选项如下：<ul><li><code>-n #</code>：显示文本后#行内容；</li><li><code>-f</code>：查看文件尾部内容，结束后不退出，能够实时跟踪文件新增的行内容。注意：使用ctrl+c退出文件。</li></ul></li></ul><p>&nbsp;</p><ul><li><p><code>ln命令</code>：在当前目录下生成一个类似于快捷方式的文件(也叫软链接文件)，用于跳转到某个指定文件或目录；</p><ul><li><p>常用格式：<code>ln -s 原文件或目录 快捷方式名称</code>；如果要删除这个快捷方式的话，使用删除文件的文明即可：<code>rm -rf 快捷方式名称</code>；</p></li><li><p>还可以使用ln命令创建硬链接，效果和软链接差不多，只不过生成的是一个硬链接文件；格式：<code>ln 原文件或目录 硬链接名称</code>；</p><p>  <img src="./Image-ln33.png" srcset="/img/loading.gif" alt="image-20200711141928852"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p><code>history命令</code>：用于显示历史记录和执行过的指令命令；格式：<code>history [选项]</code>。选项如下；<strong><code>注意：如果在使用history后，想要使用历史指令中的某个指令的话，使用：!历史指令序号，即可执行指定序号的命令。</code></strong></p><ul><li><p><code>n</code>: 显示历史记录中最近的N个记录，这个比较常用；</p></li><li><p><code>-c</code>：清空当前历史命令；</p></li><li><p><code>-a</code>：将历史命令缓冲区中命令写入历史命令文件中；</p></li><li><p><code>-r</code>：将历史命令文件中的命令读入当前历史命令缓冲区；</p></li><li><p><code>-w</code>：将当前历史命令缓冲区命令写入历史命令文件中;</p></li><li><p><code>-d&lt;offset&gt;</code>：删除历史记录中第offset个命令</p></li><li><p><code>-n&lt;filename&gt;</code>：读取指定文件。</p><p>  <img src="./Image-ln34.png" srcset="/img/loading.gif" alt="image-20200711142024180"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-7-时间日期类命令"><a href="#NO2-7-时间日期类命令" class="headerlink" title="NO2.7 时间日期类命令"></a>NO2.7 时间日期类命令</h3><p>时间日期类指令比较少。</p><ul><li><p><code>date命令</code>：显示当前时间；格式：<code>date [选项]</code>。</p><ul><li><p><code>不加参数</code>：表示显示当前时间；</p></li><li><p><code>+%Y</code>：显示当前年份；</p></li><li><p><code>+%m</code>：显示当前月份；</p></li><li><p><code>+%d</code>：显示当前是哪一天；</p></li><li><p><code>&quot;+%Y-%m-%d %H:%M:%S&quot;</code>：显示年月日时分秒，该命令前后要加双引号。</p></li><li><p><code>-s</code>：设置时间，即将自己指定的时间设置为当前的时间；格式为：<code>date -s 字符串时间</code>。</p><p>  <img src="./Image-ln35.png" srcset="/img/loading.gif" alt="image-20200711142124275"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p><code>cal命令</code>：用于查看当前日历；格式：<code>cal [选项]</code>。选项如下：</p><ul><li><p><code>不加参数</code>：显示本月日历，这个常用；</p></li><li><p><code>指定年份</code>：显示指定年份的所有月份的日历；</p></li><li><p><code>指定月份 指定年份</code>：显示指定年份下的指定月份的日历；</p><p>  <img src="./Image-ln36.png" srcset="/img/loading.gif" alt="image-20200711142309240"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-8-搜索查找类命令"><a href="#NO2-8-搜索查找类命令" class="headerlink" title="NO2.8 搜索查找类命令"></a>NO2.8 搜索查找类命令</h3><p>这类命令用的也比较多。</p><ul><li><p><code>find命令</code>：将从指定目录下递归遍历多个子目录，将满足条件的文件或者目录进行显示；格式：<code>find 搜索范围 [选项]</code>。选项如下：</p><ul><li><p><code>-name</code>：按照文件名查找文件，该选项后面跟的是完整的文件名称；</p></li><li><p><code>-perm</code>：按照文件权限查找文件，该选项后面跟的是文件的具体权限；</p></li><li><p><code>-user</code>：按照文件属主来查找文件，该选项后面跟的是要查找的用户；</p></li><li><p><code>-size</code>：按照指定的文件大小查找文件，+n：大于，-n：小于，n：等于；数字后面的常用单位有：k、M、G等等；</p></li><li><p><code>-group</code>：按照文件所属的组来查找文件，该选项后面跟的是组名称；</p></li><li><p><code>-mtime&lt;-n&gt;&lt;+n&gt;</code>：按照文件更改时间来查找文件，-n表示n天之内，+n表示n天以前；</p></li><li><p><code>-newer file1 file2</code>：查找更改时间在file1和file2之间的文件。</p><p>  <img src="./Image-ln37.png" srcset="/img/loading.gif" alt="image-20200711142357223"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p><code>locate命令</code>：查找与指定文件相关的文件，该命令是在数据库中进行查询，所以速度快、但需要维护数据库；格式：<code>lcate 要搜索的文件</code>。由于locate是基于数据库查询，需要先使用命令：<code>updatedb</code>，作用是在第一次运行前，创建locate数据库。</p><p>  <img src="./Image-ln38.png" srcset="/img/loading.gif" alt="Image"></p></li></ul><p>&nbsp;</p><ul><li><p><code>grep命令</code>：用于过滤或搜索指定字符串；可以使用正则表达式，能配合多种命令使用。格式：<code>grep [选项] 查找内容 源文件</code>。选项如下；该命令经常和管道符一起使用：<code>管道符“|”</code>，表示将前一个命令的处理结果输出传递给后面的命令处理。</p><ul><li><p><code>-A</code>：显示符合的行及之后的内容；</p></li><li><p><code>-B</code>：显示符合的行及之前的内容；</p></li><li><p><code>-C</code>：显示符合的行及前后的内容；</p></li><li><p><code>-c</code>：计算符合的行数目；</p></li><li><p><code>-n</code>：显示查找到的内容所在文件的行号；</p></li><li><p><code>-i</code>：忽略大小写。</p><p>  <img src="./Image-ln39.png" srcset="/img/loading.gif" alt="image-20200711142516718"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-9-压缩和解压缩命令"><a href="#NO2-9-压缩和解压缩命令" class="headerlink" title="NO2.9 压缩和解压缩命令"></a>NO2.9 压缩和解压缩命令</h3><p>这一类的命令，我常用来对压缩文件进行操作。</p><ul><li><p><code>“.tar”命令</code>：</p><ul><li><p>解包：格式：<code>tar [选项] 压缩包名</code>。选项如下：</p><ul><li><code>-x</code>：对tar包做解打包操作；</li><li><code>-z</code>：解压缩“.tar.gz”格式的文件；</li><li><code>-f</code>：指定要解压的tar包的包名，这个是必选的；</li><li><code>-t</code>：只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作；</li><li><code>-C 目录</code>：指定解打包位置；</li><li><code>-j</code>：解压缩“.tar.bz2”格式的文件；</li><li><code>-v</code>：显示解打包的具体过程。</li></ul></li><li><p>打包：格式：<code>tar [选项] 源文件或源目录</code>。选项如下；<strong><code>注意：tar是打包，不是压缩。</code></strong></p><ul><li><p><code>-c</code>：将多个文件或目录进行打包；</p></li><li><p><code>-z</code>：压缩成“.tar.gz”格式文件；</p></li><li><p><code>-A</code>：追加tar文件到归档文件；</p></li><li><p><code>-f 包名</code>：指定包的文件名。这个是必选的。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名；</p></li><li><p><code>-v</code>：显示打包文件过程。</p></li><li><p><code>-j</code>：压缩成“.tar.bz2”格式文件；</p><p>  <img src="./Image-ln40.png" srcset="/img/loading.gif" alt="image-20200711142622881"></p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p><code>“.zip”命令</code>：</p><ul><li><p>解压：格式：<code>unzip [选项] 压缩包名</code>。选项如下：</p><ul><li><code>-d 目录名</code>：将压缩文件解压到指定目录下；</li><li><code>-n</code>：解压时并不覆盖已经存在的文件；</li><li><code>-o</code>：解压时覆盖已经存在的文件，并且无需用户确认；</li><li><code>-v</code>：查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作；</li><li><code>-t</code>：测试压缩文件有无损坏，但并不解压；</li><li><code>-x</code>：文件列表：解压文件，但不包含文件列表中指定的文件。</li></ul></li><li><p>压缩：格式：<code>zip [选项] 压缩包名 源文件或源目录</code>。选项如下：</p><ul><li><p><code>-r</code>：递归压缩目录，及将制定目录下的所有文件以及子目录全部压缩。</p></li><li><p><code>-m</code>：将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中。</p></li><li><p><code>-v</code>：显示详细的压缩过程信息。</p></li><li><p><code>-q</code>：在压缩的时候不显示命令的执行过程。</p></li><li><p><code>-压缩级别</code>：压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好。</p></li><li><p><code>-u</code>：更新压缩文件，即往压缩文件中添加新文件。</p><p>  <img src="./Image-ln41.png" srcset="/img/loading.gif" alt="image-20200711142733664"></p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p><code>“.gz”命令</code>：</p><ul><li><p>解压：格式：<code>gunzip [选项] 文件</code>。选项如下：</p><ul><li><code>-r</code>：递归处理，解压缩指定目录下以及子目录下的所有文件；</li><li><code>-c</code>：把解压缩后的文件输出到标准输出设备；</li><li><code>-f</code>：强制解压缩文件，不理会文件是否已存在等情况；</li><li><code>-l</code>：列出压缩文件内容；</li><li><code>-v</code>：显示命令执行过程；</li><li><code>-t</code>：测试压缩文件是否正常，但不对其做解压缩操作。</li></ul></li><li><p>压缩：格式：<code>gzip [选项] 文件</code>。选项如下；<strong><code>注意：使用该命令进行压缩之后，源文件不会被保留；还可以同时对不同的文件进行压缩。</code></strong></p><ul><li><p><code>-c</code>：将压缩数据输出到标准输出中，并保留源文件；</p></li><li><p><code>-d</code>：对压缩文件进行解压缩。即gzip -d 压缩文件.gz；</p></li><li><p><code>-r</code>：递归压缩指定目录下以及子目录下的所有文件；</p></li><li><p><code>-v</code>：对于每个压缩和解压缩的文件，显示相应的文件名和压缩比；</p></li><li><p><code>-l</code>：对每一个压缩文件，显示以下字段：</p><ul><li>压缩文件的大小；</li><li>未压缩文件的大小；</li><li>压缩比；</li><li>未压缩文件的名称。</li></ul></li><li><p><code>-数字</code>：用于指定压缩等级，-1压缩等级最低，压缩比最差；-9压缩比最高。默认压缩比是-6。</p><p>  <img src="./Image-ln42.png" srcset="/img/loading.gif" alt="image-20200711142856637"></p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><code>&quot;.bz2&quot;命令</code>：<ul><li>解压2：格式：<code>bunzip2 [选项] 源文件</code>；选项如下：<ul><li><code>-k</code>：解压缩后，默认会删除原来的压缩文件。若要保留压缩文件，需使用此参数；</li><li><code>-f</code>：解压缩时，若输出的文件与现有文件同名时，默认不会覆盖现有的文件。若要覆盖，可使用此选项；</li><li><code>-v</code>：显示命令执行过程；</li><li><code>-L</code>：列出压缩文件内容。</li></ul></li><li>压缩：格式：<code>bzip2 [选项] 源文件</code>；选项如下：<ul><li><code>-d</code>：执行解压缩，此时该选项后的源文件应为标记有“.bz2”后缀的压缩包文件；</li><li><code>-k</code>：bzip2在压缩或解压缩任务完成后，会删除原始文件，若要保留原始文件，可使用此选项；</li><li><code>-f</code>：bzip2在压缩或解压缩时，若输出文件与现有文件同名，默认不会覆盖现有文件，若使用此选项，则会强制覆盖现有文件；</li><li><code>-t</code>：测试压缩包文件的完整性；</li><li><code>-v</code>：压缩或解压缩文件时，显示详细信息；</li><li><code>-数字</code>：这个参数和 gzip 命令的作用一样，用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-10-文件权限"><a href="#NO2-10-文件权限" class="headerlink" title="NO2.10 文件权限"></a>NO2.10 文件权限</h3><p>Linux中文件或目录的创建者一般就是该文件的所有者。</p><ul><li><p>查看文件或目录的所有者、所属组：</p><ul><li><p>命令：<code>ls -ahl或ls -l(这个比较常用)</code>。该命令查看文件或目录的所有者和所属组。</p><p>  <img src="./Image-ln43.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>修改文件或目录的所有者：</p><ul><li><p>命令：<code>chown [选项]  所有者 文件名或目录</code>；选项如下：</p><ul><li><p><code>-R</code>：如果修改的是目录，则递归更改该目录下的所有子文件或目录的所有者，也就是与父目录的所有者一致。</p><p>  <img src="./Image-ln44.png" srcset="/img/loading.gif" alt="image-20200711143054305"></p></li><li><p>命令：<code>chown [选项] 所有者:所属组 文件或目录</code>。该命令同时修改所有者和所属组。选项如下：</p><ul><li><p><code>-R</code>：如果修改的是目录，则递归更改该目录下的所有子文件或目录的所有者和所属组，也就是与父目录的所有者、所属组一致。</p><p>  <img src="./Image-ln45.png" srcset="/img/loading.gif" alt="image-20200711143603282"></p></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>修改文件的所属组：</p><ul><li><p>命令：<code>chgrp 所属组 文件名或目录</code>。</p><p>  <img src="./Image-ln46.png" srcset="/img/loading.gif" alt="image-20200711143704698"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-11-权限位的详细介绍"><a href="#NO2-11-权限位的详细介绍" class="headerlink" title="NO2.11 权限位的详细介绍"></a>NO2.11 权限位的详细介绍</h3><p>所谓权限管理，其实就是指对不同的用户，设置不同的文件访问权限，包括对文件的读、写、删除等。在Linux系统中，每个用户都具有不同的权限，拿非 root用户来说，它们只能在自己的主目录下才具有写权限，而在主目录之外，只具有访问和读权限。</p><ul><li><p>Linux的权限位第1列：</p><ul><li><p>首位：表示这是一个什么东西。如，是一个文件、目录、软链接、字符设备或块文件；</p><ul><li><code>-</code>：表示为这是一个普通的文件；</li><li><code>d</code>：表示这是一个目录，也就是文件夹；</li><li><code>l</code>：表示这是一个软链接，就相当于快捷方式的意思；</li><li><code>c</code>：表示这是一个字符设备。如，键盘、鼠标等等；</li><li><code>b</code>：表示这是一个块文件。如，硬盘等等；</li><li><code>p</code>：表示该文件为命令管道文件。与shell编程有关的文件；</li><li><code>s</code>：表示该文件为sock文件。与shell编程有关的文件。</li></ul></li><li><p>第二、三、四位：这三位表示文件所有者所具有的权限；</p><ul><li>用于文件：<ul><li><code>r</code>：表示read，即文件的可读取，查看；另外，“r”权限还可以用十进制的“4”表示；</li><li><code>w</code>：表示write，即文件的可写入，修改；另外，“w”权限还可以用十进制的“2”表示；<strong><code>注意：可写入不代表可以删除，要想删除一个文件，必须对该文件的父目录有写的权限才可删除。</code></strong></li><li><code>x</code>：表示execute，即文件可执行；另外，“x”权限还可以用十进制的“1”表示。</li></ul></li><li>用于目录：<ul><li><code>r</code>：表示read，即目录的可读取，查看；另外，“r”权限还可以用十进制的“4”表示；</li><li><code>w</code>：表示write，即目录的修改，目录内的创建、修改、删除权限；另外，“w”权限还可以用十进制的“2”表示；</li><li><code>x</code>：表示execute，即可进入该目录；另外，“x”权限还可以用十进制的“1”表示。</li></ul></li></ul></li><li><p>第五、六、七位：这三位表示文件所属组所具有的权限；</p><p>  <img src="./Image-ln47.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>第八、九、十位：这三位表示其他人对该文件所具有的权限；</p><p>  <img src="./Image-ln48.png" srcset="/img/loading.gif" alt="image-20200711143916225"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>Linux的权限位第2列：分为两种情况</p><ul><li><p>如果这是一个文件：表示指向这个文件的硬链接数。简单的说，就是能够打开这个文件的硬链接方式，一般创建文件后，只会有一个硬链接数，也就是输入这个文件的文件名，就可以打开该文件；另外还能够创建硬链接来打开这个文件，使用命令：<code>ln 源文件名 硬链接名</code>，就可以为某个文件创建一个硬链接，通过这个硬链接也能够打开这个文件，此时该文件的第2字段值就会变为2；<strong><code>注意：硬链接生成的是一个文件。</code></strong></p><p>  <img src="./Image-ln49.png" srcset="/img/loading.gif" alt="image-20200711144035005"></p></li><li><p>如果这是一个目录(也就是文件夹)：表示该目录下所拥有的子目录数；新创建的目录中，就会有两个隐藏的子目录，分别为<code>“.”</code>和<code>“..”</code>：</p><ul><li><p><code>“.”</code>：代表你的当前目录，即”pwd”命令所返回的目录；</p></li><li><p><code>“..”</code>：代表你的当前目录的上一级目录，即当前目录的父目录(或叫父路径)。</p><p>  <img src="./Image-ln50.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>Linux的权限位第3列：表示文件或目录的所有者；</p><p>  <img src="./Image-ln51.png" srcset="/img/loading.gif" alt="Image"></p></li></ul><p>&nbsp;</p><ul><li><p>Linux的权限位第4列：表示文件或目录的所属组；</p><p>  <img src="./Image-ln52.png" srcset="/img/loading.gif" alt="Image"></p></li></ul><p>&nbsp;</p><ul><li><p>Linux的权限位第5列：表示文件或目录的大小，单位是字节；<strong><code>注意：目录统一是4096个字节；</code></strong></p><p>  <img src="./Image-ln53.png" srcset="/img/loading.gif" alt="image-20200711144412693"></p></li></ul><p>&nbsp;</p><ul><li><p>Linux的权限位第6、7、8列：表示文件或目录的最后修改时间；</p><p>  <img src="./Image-ln54.png" srcset="/img/loading.gif" alt="Image"></p></li></ul><p>&nbsp;</p><ul><li><p>Linux的权限位第9列：表示文件或目录的名称；</p><p>  <img src="./Image-ln55.png" srcset="/img/loading.gif" alt="Image"></p></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-12-权限管理"><a href="#NO2-12-权限管理" class="headerlink" title="NO2.12 权限管理"></a>NO2.12 权限管理</h3><p>我们可以手动修改文件的访问权限。</p><ul><li><p>使用chmod命令修改文件或目录权限，主要有两种修改方式：</p><ul><li><p>第一种：使用+、-、=符号进行修改权限操作，格式：<code>[ugoa] [[+-=] [perms]] 文件名</code>，简单说就是<code>[用户身份][[赋予方式][权限]] 文件名</code>，其中：</p><ul><li><p>用户身份：</p><ul><li><code>-u</code>：代表文件所有者(user)；</li><li><code>-g</code>：代表文件所属组(group)；</li><li><code>-o</code>：代表其他用户(other)；</li><li><code>-a</code>：代表全部身份，包括所有者、所属组和其他用户(all)。</li></ul></li><li><p>赋予方式：</p><ul><li><code>+</code>：加入权限；</li><li><code>–</code>：减去权限；</li><li><code>=</code>：设置权限。</li></ul></li><li><p>权限：</p><ul><li><p><code>-r</code>：读取权限(read)；</p></li><li><p><code>-w</code>：写权限(write)；</p></li><li><p><code>-x</code>：执行权限(execute)。</p><p>  <img src="./Image-ln56.png" srcset="/img/loading.gif" alt="image-20200711144550285"></p></li></ul></li></ul></li><li><p>第二种：使用4(r)、2(w)、1(x)、5(即4+1)、6(即4+2)、7(即4+2+1)修改权限操作，格式和第一种方式一样，只不过将字母可以替换成数字4、2、1。</p><p>  <img src="./Image-ln57.png" srcset="/img/loading.gif" alt="image-20200711144636015"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-13-定时任务调度"><a href="#NO2-13-定时任务调度" class="headerlink" title="NO2.13 定时任务调度"></a>NO2.13 定时任务调度</h3><p>Linux的crontab任务调度是在规定的时间频率内去执行相应的任务，说白了就是定时任务的意思。</p><ul><li>crontab命令：定时任务的守护进程，精确到分；涉及秒的我们一般写脚本，因为这相当于闹钟。格式：<code>crontab [-u username] [选项]</code>；选项如下：<ul><li><code>-u</code>：省略用户的话，表示当前是哪个用户就操作当前用户的crontab；</li><li><code>-e</code>：编辑crontab的工作内容，也就是要制定一个定时任务；</li><li><code>-l</code>：查阅crontab的工作内容，查看一下制定的任务；</li><li><code>-r</code>：删除所有的crontab的工作内容，若仅要删除一项，请用-e去编辑。</li></ul></li></ul><p>&nbsp;</p><ul><li><p>定时任务的步骤：</p><ul><li><p>首先，在某个文件中写入要执行的定时任务，并在定时任务写入完成后给予文件能够被执行的权限；</p><p>  <img src="./Image-ln58.png" srcset="/img/loading.gif" alt="image-20200711144906565"></p></li><li><p>然后，使用crontab -e命令，进入当前用户的定时任务的编辑界面(是常见的vim界面)，设置定时执行的命令即可，每行是一条命令。crontab的命令构成：时间+动作，其时间有分、时、日、月、周共五种，操作符有：</p><ul><li><p><code>*</code>：取值范围内的所有数字，即每周、每月、每天、每时、每分的意思；</p></li><li><p><code>/</code>：每过多少个数字，即隔多少的意思。如，/20 * * * *，表示每天，每隔20分钟执行；</p></li><li><p><code>-</code>：表示一个范围，即从多少到多少的意思。如，* * 1-3 * *，表示每月的第一到第三天都执行；</p></li><li><p><code>,</code>：表示“第几”执行，根据具体的位置来区分。如，3,25 * * * *，表示每小时的第3和第25分钟都执行。</p><p>  <img src="./Image-ln59.png" srcset="/img/loading.gif" alt="Image"></p>  <pre><code class="hljs angelscript">每<span class="hljs-number">1</span>分钟执行一次myCommand* * * * * myCommand每小时的第<span class="hljs-number">3</span>和第<span class="hljs-number">15</span>分钟执行<span class="hljs-number">3</span>,<span class="hljs-number">15</span> * * * * myCommand在上午<span class="hljs-number">8</span>点到<span class="hljs-number">11</span>点的第<span class="hljs-number">3</span>和第<span class="hljs-number">15</span>分钟执行<span class="hljs-number">3</span>,<span class="hljs-number">15</span> <span class="hljs-number">8</span><span class="hljs-number">-11</span> * * * myCommand每隔两天的上午<span class="hljs-number">8</span>点到<span class="hljs-number">11</span>点的第<span class="hljs-number">3</span>和第<span class="hljs-number">15</span>分钟执行<span class="hljs-number">3</span>,<span class="hljs-number">15</span> <span class="hljs-number">8</span><span class="hljs-number">-11</span> */<span class="hljs-number">2</span>  *  * myCommand每周一上午<span class="hljs-number">8</span>点到<span class="hljs-number">11</span>点的第<span class="hljs-number">3</span>和第<span class="hljs-number">15</span>分钟执行<span class="hljs-number">3</span>,<span class="hljs-number">15</span> <span class="hljs-number">8</span><span class="hljs-number">-11</span> * * <span class="hljs-number">1</span> myCommand每晚的<span class="hljs-number">21</span>:<span class="hljs-number">30</span>重启smb<span class="hljs-number">30</span> <span class="hljs-number">21</span> * * * /etc/init.d/smb restart每月<span class="hljs-number">1</span>、<span class="hljs-number">10</span>、<span class="hljs-number">22</span>日的<span class="hljs-number">4</span> : <span class="hljs-number">45</span>重启smb<span class="hljs-number">45</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">22</span> * * /etc/init.d/smb restart每周六、周日的<span class="hljs-number">1</span>:<span class="hljs-number">10</span>重启smb<span class="hljs-number">10</span> <span class="hljs-number">1</span> * * <span class="hljs-number">6</span>,<span class="hljs-number">0</span> /etc/init.d/smb restart每天<span class="hljs-number">18</span>:<span class="hljs-number">00</span>至<span class="hljs-number">23</span>:<span class="hljs-number">00</span>之间每隔<span class="hljs-number">30</span>分钟重启smb<span class="hljs-number">0</span>,<span class="hljs-number">30</span> <span class="hljs-number">18</span><span class="hljs-number">-23</span> * * * /etc/init.d/smb restart每星期六的晚上<span class="hljs-number">11</span>:<span class="hljs-number">00</span>重启smb<span class="hljs-number">0</span> <span class="hljs-number">23</span> * * <span class="hljs-number">6</span> /etc/init.d/smb restart每一小时重启smb* */<span class="hljs-number">1</span> * * * /etc/init.d/smb restart晚上<span class="hljs-number">11</span>点到早上<span class="hljs-number">7</span>点之间，每隔一小时重启smb* <span class="hljs-number">23</span><span class="hljs-number">-7</span>/<span class="hljs-number">1</span> * * * /etc/init.d/smb restart</code></pre><p>  <img src="./Image-ln60.png" srcset="/img/loading.gif" alt="image-20200711145118442"></p></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-14-磁盘分区、挂载"><a href="#NO2-14-磁盘分区、挂载" class="headerlink" title="NO2.14 磁盘分区、挂载"></a>NO2.14 磁盘分区、挂载</h3><p>分区是把每个硬盘连续的区块都当做一个独立的磁盘使用，说白了就是我们电脑上可能只有一块硬盘，但是我们电脑上却有什么C盘、E盘、F盘、G盘等等，而这就是分区，也就是把一个硬盘，我们逻辑上划分成了不同的区域来存放不同的数据而已。分区表是一个硬盘分区的索引，分区的信息都会写进分区表。</p><ul><li>分区的两种方式：MBR与GPT。<ul><li>MBR分区：<ul><li>最多支持4个主分区；</li><li>系统只能安装在主分区；</li><li>扩展分区要占一个主分区；</li><li>MBR最大支持2TB，但兼容性好。</li></ul></li><li>GPT分区：<ul><li>支持无限多个主分区(但由于操作系统，可能会限制。<code>如，Windows下最大128个分区)</code>；</li><li>最大支持18EB的大容量(1EB=1024PB，1PB = 1024TB)；</li><li>Windows7 64位以后支持GPT。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>Linux的分区硬盘：</p><ul><li><p>IDE硬盘：</p><ul><li>驱动器标识符为：<code>“hdx~”</code>。其中，“hd”表示硬盘类型为IDE；“x”表示盘号(a为基本盘或第一块硬盘、b为基本从属盘或第二块硬盘、c为辅助主盘或第三块硬盘、d为辅助从属盘或第四块硬盘)；“~”表示第几分区，前四个分区用1到4表示，它们是主分区或扩展分区，从5开始就是逻辑分区。<code>如，hda3表示IDE硬盘上第1块硬盘的第3个分区</code>。</li></ul></li><li><p>SCSI硬盘；<strong><code>注意：现在基本是都是SCSI类型的硬盘。</code></strong></p><ul><li><p>驱动器标识符为：<code>“sdx~”</code>。其中，“sd”表示硬盘类型为SCSI，其他的和IDE硬盘表示是一样的。</p><p>  <img src="./Image-ln61.png" srcset="/img/loading.gif" alt="image-20200711145249093"></p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>Linux分区步骤：</p><ul><li><p>单击进入设置，并添加一块硬盘，全程默认硬盘的安装即可；</p><p>  <img src="./Image-ln62.png" srcset="/img/loading.gif" alt="image-20200711145349537"></p></li><li><p>使用命令lsblk -f查看自己Linux的分区，看看新添加的硬盘名称是什么，记住该硬盘的名称，然后就可以开始给硬盘分区了；</p><p>  <img src="./Image-ln63.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>使用分区命令进行分区：fdisk /dev/新安装的硬盘的名称，然后输入m；</p><p>  <img src="./Image-ln64.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>输入m后，再输入n即可，n选项表示新建一个分区；</p><p>  <img src="./Image-ln65.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>输入n后，再输入p建立分区，输入分区编号1，之后在First cylinder选项栏里按回车键表示默认即可；</p><p>  <img src="./Image-ln66.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>最后在询问是否还需要帮助时，输入w，w选项表示将刚刚的分区信息写入到硬盘并保持退出；</p><p>  <img src="./Image-ln67.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>其实这个时候，建立好的分区还不能用，还要经过格式化、挂载后，才可以用。格式化命令：mkfs -t ext4 /dev/新安装的硬盘的名称，是格式化成ext4格式；</p><p>  <img src="./Image-ln68.png" srcset="/img/loading.gif" alt="image-20200711145919411"></p></li><li><p>挂载，简单讲就是将分区和指定的文件做一个关联，以后在这个文件中操作时，实际就是在这个关联的分区中进行操作。使用命令：mount /dev/新安装的硬盘的名称 要关联的文件的目录。</p><p>  <img src="./Image-ln69.png" srcset="/img/loading.gif" alt="image-20200711145956418"></p><ul><li>Linux自动挂载：使用命令：vim /etc/fstab，编辑fstab文件；模板配置如下；两个模板使用哪个都可以，建议使用模板2，方便快捷；<pre><code>- 配置模板1：UUID=*  /要关联的目录  ext4  defaults  1  1；</code></pre><ul><li>配置模板2：/dev/新安装的硬盘的名称 /要关联的目录  ext4  defaults  1  1。</li></ul></li><li>重启Linux，该配置即可生效。</li></ul></li><li><p>取消挂载：umount 文件系统或者挂载点；<strong><code>注意：如果取消的挂载目录，那么此时我们就不能在挂载目录下进行取消操作，否则会报错。</code></strong></p><p>  <img src="./Image-ln70.png" srcset="/img/loading.gif" alt="image-20200711150043076"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-15-磁盘命令"><a href="#NO2-15-磁盘命令" class="headerlink" title="NO2.15 磁盘命令"></a>NO2.15 磁盘命令</h3><p>Linux中也有用于查看磁盘使用量的命令。</p><ul><li><p>Linux磁盘管理常用三个命令：</p><ul><li><p>df：列出整个文件系统的整体磁盘使用量；格式：<code>df [选项] 目录或文件名</code>；选项如下；<strong><code>注意：如果df没有加任何选项，那么默认会将系统内所有的(不含特殊内存内的文件系统与swap)都以1Kbytes的容量来列出来。</code></strong></p><ul><li><p><code>-a</code>：列出所有的文件系统，包括系统特有的 /proc 等文件系统；</p></li><li><p><code>-k</code>：以KBytes的容量显示各文件系统；</p></li><li><p><code>-m</code>：以MBytes的容量显示各文件系统；</p></li><li><p><code>-h</code>：以人们较易阅读的GBytes、MBytes、KBytes等格式显示；</p></li><li><p><code>-H</code>：以M=1000K取代M=1024K的进位方式；</p></li><li><p><code>-T</code>：显示文件系统类型，连同该partition的filesystem名称(如，ext3)也列出；</p></li><li><p><code>-i</code>：不用硬盘容量，而以inode的数量来显示。</p><p>  <img src="./Image-ln71.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li><li><p>du：对文件或目录的磁盘空间使用量的查看；格式：<code>du [选项] 目录或文件名</code>；选项如下；<strong><code>注意：直接输入du没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间。</code></strong></p><ul><li><p><code>-a</code>：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已；</p></li><li><p><code>-h</code>：以人们较易读的容量格式(G/M)显示；</p></li><li><p><code>-s</code>：列出总量而已，而不列出每个各别的目录占用容量；</p></li><li><p><code>-S</code>：不包括子目录下的总计，与-s有点差别；</p></li><li><p><code>-k</code>：以KBytes列出容量显示；</p></li><li><p><code>-c</code>：列出明细的同时，增加汇总值；</p></li><li><p><code>--max-depth=数字</code>：表示子目录的深度，1为1层，2为2层，以此类推；</p></li><li><p><code>-m</code>：以MBytes列出容量显示。</p><p>  <img src="./Image-ln72.png" srcset="/img/loading.gif" alt="image-20200711150322534"></p><p>  <img src="./Image-ln73.png" srcset="/img/loading.gif" alt="image-20200711150417916"></p></li></ul></li></ul></li></ul><pre><code>- fdisk：用于磁盘分区；该命令之前已经详细介绍，这里不过多叙述，参照NO2.14小节即可。</code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-16-进程管理"><a href="#NO2-16-进程管理" class="headerlink" title="NO2.16 进程管理"></a>NO2.16 进程管理</h3><p>进程是Unix和Linux系统中对正在运行中的应用程序的抽象，通过它可以管理和监视程序对内存、处理器时间和I/O资源的使用。</p><ul><li>进程和父进程：Linux中每个进程都有父进程，而所有的进程以init进程为根，形成一个树状结构。</li></ul><p>&nbsp;</p><ul><li><p>查看进程的命令(静态查看进程)：<code>ps [选项]</code>；选项如下：</p><ul><li><p><code>-a</code>：显示现在运行在终端机下的所有程序；</p></li><li><p><code>-u</code>：以用户为主的格式来显示程序状况；</p></li><li><p><code>-x</code>：不以终端机来区分。</p><p>  <img src="./Image-ln74.png" srcset="/img/loading.gif" alt="image-20200711150647051"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>查看进程的父进程命令：<code>ps -ef</code>。</p><p>  <img src="./Image-ln75.png" srcset="/img/loading.gif" alt="Image"></p></li></ul><p>&nbsp;</p><ul><li>进程终止命令有两种格式：<ul><li>格式：<code>kill 进程的PID号</code>；只终止指定PID号的进程；如果要强制关闭某个进程，则使用：<code>kill -9 进程的PID号</code>；</li><li>格式：<code>killall 程序名称</code>；用于杀死指定名称进程的所有实例。</li></ul></li></ul><p>&nbsp;</p><ul><li><p>使用进程树查看进程的命令：<code>pstree [选项]</code>；选项如下：</p><ul><li><p><code>-p</code>：显示进程的PID；</p></li><li><p><code>-u</code>：显示进程的所属用户。</p><p>  <img src="./Image-ln76.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-17-服务管理"><a href="#NO2-17-服务管理" class="headerlink" title="NO2.17 服务管理"></a>NO2.17 服务管理</h3><p>我们知道，系统服务是在后台运行的应用程序，并且可以提供一些本地系统或网络的功能。我们把这些应用程序称作服务，也就是Service。</p><ul><li><p>Linux使用Service命令用于对系统服务进行管理。如，启动(start)、停止(stop)、重启(restart)、查看状态(status)等。</p><ul><li><p><code>CentOS 6.8版本</code>：使用命令：<code>service 服务名 [选项]</code>；选项如下：</p><ul><li>start：打开服务；</li><li>stop：关闭服务；</li><li>restart：重启服务；</li><li>status：查看服务状态；</li></ul></li><li><p><code>CentOS 7.0以后</code>：使用命令：<code>systemctl 服务名 [start|stop|restart|status]</code>。</p>  <pre><code class="hljs armasm">拓展：查看指定<span class="hljs-built_in">IP</span>下指定端口是否可以访问一、命令格式：telnet <span class="hljs-built_in">ip</span>地址 端口号。</code></pre><p>  <img src="./Image-ln77.png" srcset="/img/loading.gif" alt="image-20200711150903279"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>查看系统服务：</p><ul><li><p>使用命令：<code>setup</code>；</p><p>  <img src="./Image-ln78.png" srcset="/img/loading.gif" alt="image-20200711151119646"></p></li><li><p>使用命令：<code>ls -l /etc/init.d/</code>。</p><p>  <img src="./Image-ln79.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li><li><p>chkconfig命令：主要用来更新(启动或停止)和查询系统服务的运行级别信息。</p><ul><li><p><code>chkconfig --list命令</code>：查看所有的服务运行级别；</p><p>  <img src="./Image-ln80.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p><code>chkconfig 指定服务名称 --list命令</code>：查看指定的服务运行级别；</p><p>  <img src="./Image-ln81.png" srcset="/img/loading.gif" alt="image-20200711151248580"></p></li><li><p><code>chkconfig --level 运行级别 服务名称 on/off</code>：开启/关闭指定的服务的运行级别的自启；</p><p>  <img src="./Image-ln82.png" srcset="/img/loading.gif" alt="image-20200711151319789"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-18-动态监控进程"><a href="#NO2-18-动态监控进程" class="headerlink" title="NO2.18 动态监控进程"></a>NO2.18 动态监控进程</h3><p>顾名思义，动态监控进程就是实时监控进程的动态。</p><ul><li><p>top [选项]：显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等；选项如下：</p><ul><li><p><code>-s</code>：改变画面更新频率；</p></li><li><p><code>-l</code>：关闭或开启第一部分第一行 top 信息的表示；</p></li><li><p><code>-t</code>：关闭或开启第一部分第二行 Tasks 和第三行 Cpus 信息的表示；</p></li><li><p><code>-m</code>：关闭或开启第一部分第四行 Mem 和 第五行 Swap 信息的表示；</p></li><li><p><code>-N</code>：以 PID 的大小的顺序排列表示进程列表；</p></li><li><p><code>-P</code>：以 CPU 占用率大小的顺序排列进程列表；</p></li><li><p><code>-M</code>：以内存占用率大小的顺序排列进程列表；</p></li><li><p><code>-h</code>：显示帮助；</p></li><li><p><code>-n</code>：设置在进程列表所显示进程的数量；</p></li><li><p><code>-q</code>：退出top；</p></li><li><p><code>-s/d</code>：改变画面更新周期；</p></li><li><p><code>-u</code>：查看指定用户名的进程。</p><p>  <img src="./Image-ln83.png" srcset="/img/loading.gif" alt="image-20200711151407872"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-19-监控网络状态"><a href="#NO2-19-监控网络状态" class="headerlink" title="NO2.19 监控网络状态"></a>NO2.19 监控网络状态</h3><p>利用netstat命令可让你得知整个Linux系统的网络情况。</p><ul><li><p>Linux netstat命令用于显示网络状态。格式：<code>netstat [选项]</code>。选项如下：</p><ul><li><p><code>-a或--all</code>：显示所有连线中的Socket；</p></li><li><p><code>-A&lt;网络类型&gt;或--&lt;网络类型&gt;</code>：列出该网络类型连线中的相关地址；</p></li><li><p><code>-c或--continuous</code>：持续列出网络状态；</p></li><li><p><code>-C或--cache</code>：显示路由器配置的快取信息；</p></li><li><p><code>-e或--extend</code>：显示网络其他相关信息；</p></li><li><p><code>-F或--fib</code>：显示FIB；</p></li><li><p><code>-g或--groups</code>：显示多重广播功能群组组员名单；</p></li><li><p><code>-h或--help</code>：在线帮助；</p></li><li><p><code>-i或--interfaces</code>：显示网络界面信息表单；</p></li><li><p><code>-l或--listening</code>：显示监控中的服务器的Socket；</p></li><li><p><code>-M或--masquerade</code>：显示伪装的网络连线；</p></li><li><p><code>-n或--numeric</code>：直接使用IP地址，而不通过域名服务器；</p></li><li><p><code>-N或--netlink或--symbolic</code>：显示网络硬件外围设备的符号连接名称；</p></li><li><p><code>-o或--timers</code>：显示计时器；</p></li><li><p><code>-p或--programs</code>：显示正在使用Socket的程序识别码和程序名称；</p></li><li><p><code>-r或--route</code>：显示Routing Table；</p></li><li><p><code>-s或--statistics</code>：显示网络工作信息统计表；</p></li><li><p><code>-t或--tcp</code>：显示TCP传输协议的连线状况；</p></li><li><p><code>-u或--udp</code>：显示UDP传输协议的连线状况；</p></li><li><p><code>-v或--verbose</code>：显示指令执行过程；</p></li><li><p><code>-V或--version</code>：显示版本信息；</p></li><li><p><code>-w或--raw</code>：显示RAW传输协议的连线状况；</p></li><li><p><code>-x或--unix</code>：此参数的效果和指定”-A unix”参数相同；</p></li><li><p><code>--ip或--inet</code>：此参数的效果和指定”-A inet”参数相同。</p><p>  <img src="./Image-ln84.png" srcset="/img/loading.gif" alt="image-20200711151540778"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-20-RPM"><a href="#NO2-20-RPM" class="headerlink" title="NO2.20 RPM"></a>NO2.20 RPM</h3><p>rpm原本是Red Hat Linux发行版专门用来管理Linux各项套件的程序，由于它遵循GPL规则且功能强大方便，因而广受欢迎，逐渐受到其他发行版的采用。RPM套件管理方式的出现，让Linux易于安装，升级，间接提升了Linux的适用度。</p><ul><li><p>RPM的命令：格式：<code>rpm [选项...] 软件包名称</code>；选项如下；<strong><code>注意：选项中的套件，就是安装包的意思。</code></strong></p><ul><li><p><code>-a</code>：查询所有套件；</p></li><li><p><code>-b&lt;完成阶段&gt;&lt;套件档&gt;+或-t &lt;完成阶段&gt;&lt;套件档&gt;+</code>：设置包装套件的完成阶段，并指定套件档的文件名称；</p></li><li><p><code>-c</code>：只列出组态配置文件，本参数需配合”-l”参数使用；</p></li><li><p><code>-d</code>：只列出文本文件，本参数需配合”-l”参数使用；</p></li><li><p><code>-e&lt;套件档&gt;或--erase&lt;套件档&gt;</code>：删除指定的套件；</p></li><li><p><code>-f&lt;文件&gt;+</code>：查询拥有指定文件的套件；</p></li><li><p><code>-h或--hash</code>：套件安装时列出标记；</p></li><li><p><code>-i</code>：显示套件的相关信息；</p></li><li><p><code>-i&lt;套件档&gt;或--install&lt;套件档&gt;</code>：安装指定的套件档；</p></li><li><p><code>-l</code>：显示套件的文件列表；</p></li><li><p><code>-p&lt;套件档&gt;+</code>：查询指定的RPM套件档；</p></li><li><p><code>-q</code>：使用询问模式，当遇到任何问题时，rpm指令会先询问用户；</p></li><li><p><code>-R</code>：显示套件的关联性信息；</p></li><li><p><code>-s</code>：显示文件状态，本参数需配合“-l”参数使用；</p></li><li><p><code>-U&lt;套件档&gt;或--upgrade&lt;套件档&gt;</code>：升级指定的套件档；</p></li><li><p><code>-v</code>：显示指令执行过程；</p></li><li><p><code>-vv</code>：详细显示指令执行过程，便于排错。</p><p>  <img src="./Image-ln85.png" srcset="/img/loading.gif" alt="image-20200711151651434"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-21-YUM"><a href="#NO2-21-YUM" class="headerlink" title="NO2.21 YUM"></a>NO2.21 YUM</h3><p>YUM是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。简单讲，YUM就相当于一个软件管家。</p><ul><li>yum常用命令：<ul><li>列出所有可更新的软件清单命令：<code>yum check-update</code>；</li><li>更新所有软件命令：<code>yum update</code>；</li><li>仅安装指定的软件命令：<code>yum install &lt;package_name&gt;</code>；</li><li>仅更新指定的软件命令：<code>yum update &lt;package_name&gt;</code>；</li><li>列出所有可安裝的软件清单命令：<code>yum list</code>；</li><li>删除软件包命令：<code>yum remove &lt;package_name&gt;</code>；</li><li>查找软件包 命令：<code>yum search &lt;keyword&gt;</code>；</li><li>清除缓存命令:<ul><li><code>yum clean packages</code>：清除缓存目录下的软件包</li><li><code>yum clean headers</code>：清除缓存目录下的 headers</li><li><code>yum clean oldheaders</code>：清除缓存目录下旧的 headers</li><li><code>yum clean, yum clean all (= yum clean packages; yum clean oldheaders)</code>：清除缓存目录下的软件包及旧的headers。</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>5.다른 과정</category>
      
      <category>06.操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01.Shiro--学习笔记</title>
    <link href="/2020/07/10/Shiro--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/10/Shiro--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Shiro–学习笔记-包含Shiro视频"><a href="#Shiro–学习笔记-包含Shiro视频" class="headerlink" title="Shiro–学习笔记(包含Shiro视频)"></a>Shiro–学习笔记(包含Shiro视频)</h1><h2 id="Lesson1-Shiro概述"><a href="#Lesson1-Shiro概述" class="headerlink" title="Lesson1 Shiro概述"></a>Lesson1 Shiro概述</h2><h3 id="NO1-1-Shiro简介"><a href="#NO1-1-Shiro简介" class="headerlink" title="NO1.1 Shiro简介"></a>NO1.1 Shiro简介</h3><p>Shiro是一个安全框架，也就是最基本功能是登录校验的一个框架。</p><ul><li>Shiro：<ul><li>介绍：Apache Shiro是一个强大且易用的Java安全框架，具有验证、授权、加密、会话管理、与Web集成、缓存等功能。目前，使用Apache Shiro的人越来越多，因为它相当简单，对比Spring Security，可能没有Spring Security做的功能强大，但是在实际工作时可能并不需要那么复杂的东西，所以使用小而简单的 Shiro 就足够了。对于它俩到底哪个好，这个不必纠结，能更简单的解决项目问题就好了。</li><li>优点：<ul><li>易于理解的Java Security API；</li><li>简单的身份认证(登录)，支持多种数据源(LDAP，JDBC，Kerberos，ActiveDirectory 等)；</li><li>对角色的简单的签权(访问控制)，支持细粒度的签权；</li><li>支持一级缓存，以提升应用程序的性能；</li><li>内置的基于POJO企业会话管理，适用于Web以及非Web的环境；</li><li>异构客户端会话访问；</li><li>非常简单的加密API；</li><li>不跟任何的框架或者容器捆绑，可以独立运行；</li></ul></li><li>Shiro框架中的关键对象：<ul><li><code>Subject</code>：主体(也就是当前登录的用户)。访问系统的用户，主体可以是用户、程序等，进行认证的都称为主体；</li><li><code>Principal</code>：身份信息(也就是username)。是主体进行身份认证的标识，标识必须具有唯一性。如，用户名、手机号、邮箱地址等，一个主体可以有多个身份，但是必须有一个主身份(Primary Principal)；</li><li><code>Credential</code>：凭证信息(也就是password)。即只有主体自己知道的安全信息，如，密码、证书；</li></ul></li><li>基本功能：<ul><li><code>Authentication</code>：身份认证或登录。验证用户是不是拥有相应的身份；</li><li><code>Authorization</code>：授权。即权限验证，验证某个已认证的用户是否拥有某个权限，即判断用户是否能执行某个操作；</li><li><code>Session Manager</code>：会话管理。即用户登录后就是一次会话，在没有退出之前，它的所有信息都会在会话中；该功能下还包括：<ul><li><code>Cryptography(加密)</code>：加密。保护数据的安全性，<code>如，密码加密存储到数据库，而不是明文存储</code>；</li><li><code>Web Support(Web支持)</code>：Web支持。可以非常容易的集成到Web环境；</li><li><code>Caching(缓存)</code>：缓存。<code>如，用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率</code>；</li><li><code>Concurrency(并发验证)</code>：Shiro支持多线程应用的并发验证。即如在一个线程中开启另一个线程，能把权限自动传播过去；</li><li><code>Testing(测试)</code>：提供测试支持；</li><li><code>Remeber Me(记住我)</code>：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了；</li><li><code>Run As</code>：允许一个用户假装为另一个用户(如果他们允许)的身份进行访问。</li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>Shiro入门案例；</p><ul><li><p>首先使用IDEA创建MAVEN项目后，在pom.xml文件中添加Shiro的依赖；</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Shiro安全框架使用的依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>在resources文件夹下创建shiro.ini配置文件；如果没有resources文件夹，就直接在main文件夹下创建一个Directory，然后在项目配置里(File菜单下Project Structure选项)，选择Modules，点击Sources，选择main文件夹下的resources文件夹，然后点击Mark as Resources 即可；</p><p><img src="./Image-s1.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>ini配置；</p><ul><li><p><code>[main]</code>：提供了对securityManager及其依赖的配置；</p><pre><code class="hljs ini"><span class="hljs-attr">securityManager</span>=org.apache.shiro.mgt.DafaultSecurityManager<span class="hljs-attr">securityManager.realms</span>=<span class="hljs-variable">$jdbcRealm</span></code></pre></li><li><p><code>[users]</code>：提供了对用户/密码及其角色的配置，例如，用户名=密码，角色1，角色2；</p></li><li><p><code>[roles]</code>：提供了角色及权限之间关系的配置，例如，角色=权限1，权限2；</p></li><li><p><code>[urls]</code>：用于web，提供对web的url拦截的相关配置，url=拦截器[参数]；</p><pre><code class="hljs ini"><span class="hljs-comment">#anon是指匿名，即匿名，也就是没登录也可以访问首页</span>/index.html=anon <span class="hljs-comment">#authc是指登录以后才可以访问admin路由下的资源，且角色必须是admin，权限必须是permission1</span>/admin/=authc,roles[admin],perms["permission1"]</code></pre></li></ul></li><li><p>编写测试类；</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.dengyanfei;<span class="hljs-keyword">import</span> org.apache.shiro.SecurityUtils;<span class="hljs-keyword">import</span> org.apache.shiro.authc.UsernamePasswordToken;<span class="hljs-keyword">import</span> org.apache.shiro.config.IniSecurityManagerFactory;<span class="hljs-keyword">import</span> org.apache.shiro.mgt.SecurityManager;<span class="hljs-keyword">import</span> org.apache.shiro.subject.Subject;<span class="hljs-keyword">import</span> org.apache.shiro.util.Factory;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">( String[] args )</span> </span>&#123;        <span class="hljs-comment">//1.读取配置文件，初始化工厂对象(能够获得SecurityManager的工厂)</span>        Factory&lt;SecurityManager&gt; factory = <span class="hljs-keyword">new</span> IniSecurityManagerFactory(<span class="hljs-string">"classpath:shiro.ini"</span>);                <span class="hljs-comment">//2.获取SecurityManeger对象</span>        SecurityManager serurityManager = factory.getInstance();                <span class="hljs-comment">//3.将SecurityManager绑定到工具类SecurityUtils上</span>        SecurityUtils.setSecurityManager(serurityManager);                <span class="hljs-comment">//4.通过SecurityUtils获取当前登陆的用户</span>        Subject subject = SecurityUtils.getSubject();                <span class="hljs-comment">//5.创建Token令牌，即通俗的讲就是传入用户名和密码，而Token用于用户进行登录验证</span>        UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(<span class="hljs-string">"admin"</span>,<span class="hljs-string">"456"</span>);                <span class="hljs-comment">//6.传入Token令牌，用户进行登录验证</span>        <span class="hljs-keyword">try</span> &#123;            subject.login(token);            <span class="hljs-comment">//输出</span>            System.out.println(<span class="hljs-string">"登录成功啦！！"</span>);        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            e.printStackTrace();            <span class="hljs-comment">//输出</span>            System.out.println(<span class="hljs-string">"登录失败了！！"</span>);        &#125;                <span class="hljs-comment">//7.退出</span>        subject.logout();    &#125;&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson2-Shiro基础"><a href="#Lesson2-Shiro基础" class="headerlink" title="Lesson2 Shiro基础"></a>Lesson2 Shiro基础</h2><h3 id="NO2-1-Realm"><a href="#NO2-1-Realm" class="headerlink" title="NO2.1 Realm"></a>NO2.1 Realm</h3><p>Realm是Shiro比较重要的对象。</p><ul><li><p>Realm：</p><ul><li><p>定义：即域，Shiro从Realm中获取安全数据(如用户、角色、权限)，就是说SecurityManager要验证用户身份，那么它需要从Realm中获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限验证用户是否能进行操作；</p></li><li><p>种类：</p><ul><li><p><code>IniRealm：Shiro</code>默认使用自带的IniRealm，IniRealm从ini配置文件中读取用户的信息，而大部分情况下需要从系统的数据库中读取用户信息，所以需要自定义Realm；</p></li><li><p><code>JDBCRealm</code>：即使用JDBC进行操作数据库，但是这要求数据库中创建的用户表名称必须为users，且表中字段名也必须为username和password。使用JDBC连接数据库有两种数据源选择：</p><ul><li><p><code>C3P0数据源</code>：导入相应的C3P0依赖，然后在Shiro配置文件中，必须使用如下的配置：</p><pre><code class="hljs ini"><span class="hljs-section">[main]</span><span class="hljs-comment">#使用JDBCRealm</span><span class="hljs-attr">jdbcRealm</span>=org.apache.shiro.realm.jdbc.JdbcRealm<span class="hljs-comment">#C3P0数据源</span><span class="hljs-attr">dataSource</span>=com.mchange.v2.c3p0.ComboPooledDataSource<span class="hljs-comment">#数据库驱动</span><span class="hljs-attr">dataSource.driverClass</span>=com.mysql.cj.jdbc.Driver<span class="hljs-comment">#连接字符串</span><span class="hljs-attr">dataSource.jdbcUrl</span>=jdbc:mysql://localhost:<span class="hljs-number">3306</span>/数据库名称?userUnicode=<span class="hljs-literal">true</span>&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC<span class="hljs-comment">#数据库用户名</span><span class="hljs-attr">dataSource.user</span>=root    <span class="hljs-comment">#数据库密码</span><span class="hljs-attr">dataSource.password</span>=密码    <span class="hljs-comment">#引用、注入数据源</span><span class="hljs-attr">jdbcRealm.dataSource</span>=<span class="hljs-variable">$dataSource</span>    <span class="hljs-comment">#引用Realm</span><span class="hljs-attr">securityManager.realms</span>=<span class="hljs-variable">$jdbcRealm</span></code></pre></li><li><p><code>Druid数据源</code>：导入相应的Druid依赖，然后在Shiro配置文件中，必须使用如下的配置：</p><pre><code class="hljs ini"><span class="hljs-section">[main]</span><span class="hljs-comment">#使用JDBCRealm</span><span class="hljs-attr">realm</span>=org.apache.shiro.realm.jdbc.JdbcRealm<span class="hljs-comment">#Druid数据源</span><span class="hljs-attr">dataSource</span>=com.alibaba.druid.pool.DruidDataSource<span class="hljs-comment">#数据库驱动</span><span class="hljs-attr">dataSource.driverClassName</span>=com.mysql.cj.jdbc.Driver<span class="hljs-comment">#连接字符串</span><span class="hljs-attr">dataSource.jdbcUrl</span>=jdbc:mysql://localhost:<span class="hljs-number">3306</span>/数据库名称?useUnicode=<span class="hljs-literal">true</span>&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC<span class="hljs-comment">#数据库用户名</span><span class="hljs-attr">dataSource.user</span>=root    <span class="hljs-comment">#数据库密码</span><span class="hljs-attr">dataSource.password</span>=密码    <span class="hljs-comment">#引用、注入数据源</span><span class="hljs-attr">jdbcRealm.dataSource</span>=<span class="hljs-variable">$dataSource</span>    <span class="hljs-comment">#引用Realm</span><span class="hljs-attr">securityManager.realms</span>=<span class="hljs-variable">$realm</span></code></pre></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-2-URL匹配方式"><a href="#NO2-2-URL匹配方式" class="headerlink" title="NO2.2 URL匹配方式"></a>NO2.2 URL匹配方式</h3><ul><li>URL中可以使用占位符：<ul><li><code>?占位符</code>：该匹配符只能匹配一个字符。<code>如，/admin?，只能匹配/admin1，/admin2，不能匹配/admin12，也不能匹配/admin</code>；</li><li><code>*占位符</code>：该匹配符匹配0到n个字符。<code>如，/admin*，可以匹配/admin1、/admin、/admin12</code>；</li><li><code>**占位符</code>：改匹配符匹配路径。<code>如，/admin/**，可配/admin/1、/admin/12、/admin</code>；</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-3-Shiro标签库"><a href="#NO2-3-Shiro标签库" class="headerlink" title="NO2.3 Shiro标签库"></a>NO2.3 Shiro标签库</h3><ul><li><p>Shiro标签库使用基本步骤：：</p><ul><li><p>在使用Shiro标签时，必须首先导入标签库：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">%@</span> <span class="hljs-attr">taglib</span> <span class="hljs-attr">uri</span>=<span class="hljs-string">"http://shiro.apache.org/tags"</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"shiro"</span> %&gt;</span></code></pre></li><li><p>Shiro标签库常用标签：</p><ul><li><code>&lt;shiro:guest&gt;&lt;/shiro:guest&gt;</code>：该标签用于游客访问，即不需要登录也允许访问；登录之后反而看不到该标签里的信息；</li><li><code>&lt;shiro:user&gt;&lt;/shiro:user&gt;</code>：该标签用于用户登录后，才能展示标签里的信息，否则不展示；</li><li><code>&lt;shiro:principal&gt;&lt;/shiro:principal&gt;</code>：该标签用于获取当前登录的用户的用户名；默认调用的是Subject.getPrincipal()方法获取；</li><li><code>&lt;shiro:hasRole name=&quot;需要判断的角色名&quot;&gt;&lt;/shiro:hasRole</code>&gt;：该标签用于判断当前登录用户是否拥有某个角色；</li><li><code>&lt;shiro:hasPermission name=&quot;需要判断的权限名&quot;&gt;&lt;/shiro:hasPermission&gt;</code>：用于判断当前登录用户是否具有某个权限；</li><li><code>&lt;shiro:authenticated&gt;&lt;/shiro:&gt;</code>：用于当用户通过身份验证时，展示标签里的信息，否则不展示；</li><li><code>&lt;shiro:notAuthenticated&gt;&lt;/shiro:&gt;</code>：用于当用户没通过身份验证时，展示标签里的信息，否则不展示；</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-4-Shiro加密"><a href="#NO2-4-Shiro加密" class="headerlink" title="NO2.4 Shiro加密"></a>NO2.4 Shiro加密</h3><ul><li><p>Shiro加密：</p><ul><li><p>Base64加密：不常用，容易被解密；</p></li><li><p>MD5加密：常用，散列算法，即哈希算法，加入盐值(建议该值是唯一的，一般是密码+用户名+ID)后，破解更难；</p><ul><li><p>编写密码加密工具类；</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">md5Hash</span><span class="hljs-params">(String password,String salt)</span></span>&#123;    <span class="hljs-function">reutrn new <span class="hljs-title">Md5Hash</span><span class="hljs-params">(password,salt)</span>.<span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;&#125;</code></pre></li><li><p>测试即可；</p></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-5-Spring集成Shiro"><a href="#NO2-5-Spring集成Shiro" class="headerlink" title="NO2.5 Spring集成Shiro"></a>NO2.5 Spring集成Shiro</h3><ul><li><p>Spring集成Shiro的基本步骤：</p><ul><li><p>创建Maven项目，在pom.xml中导入依赖，创建基本的Controller、Service、Dao目录结构；</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Servlet依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--JSP依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--JSTL依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--Spring依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context-support<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--日志依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--MyBatis依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--JDBC驱动依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.15<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--Shiro依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--SlF4日志依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>在resources包下创建applicationContext.xml文件、mybatis-config文件、springmvc文件，并配置web.xml文件；</p><ul><li><p>Spring配置文件applicationContext.xml；</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">"http://www.springframework.org/schema/aop"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">"http://www.springframework.org/schema/tx"</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-tag"><span class="hljs-string">    http://www.springframework.org/schema/context</span></span><span class="hljs-tag"><span class="hljs-string">    http://www.springframework.org/schema/context/spring-context.xsd</span></span><span class="hljs-tag"><span class="hljs-string">    http://www.springframework.org/schema/aop</span></span><span class="hljs-tag"><span class="hljs-string">    http://www.springframework.org/schema/aop/spring-aop.xsd</span></span><span class="hljs-tag"><span class="hljs-string">    http://www.springframework.org/schema/tx</span></span><span class="hljs-tag"><span class="hljs-string">    http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 配置自动扫描注解 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"cn.dyf.service"</span> /&gt;</span>        <span class="hljs-comment">&lt;!-- 配置数据源 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClassName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span></span><span class="hljs-tag">                  <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql://localhost:3306/db_shiro?</span></span><span class="hljs-tag"><span class="hljs-string">                   useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf-8<span class="hljs-symbol">&amp;amp;</span>serverTimezone=UTC"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Deng521314"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 配置MyBatis的sqlSessionFactory --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sqlSessionFactory"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span> /&gt;</span>        <span class="hljs-comment">&lt;!-- 加载MyBatis配置文件 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"configLocation"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"classpath:mybatis-config.xml"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 配置自动扫描dao接口所在的包 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"basePackage"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"cn.dyf.dao"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sqlSessionFactoryBeanName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"sqlSessionFactory"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 配置transaction manager(事务管理) --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"transactionManager"</span></span><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 配置事务通知属性 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txAdvice"</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 定义事务传播属性 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"insert*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"update*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"edit*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"save*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"add*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"new*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"set*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"remove*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"delete*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"change*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"check*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"get*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"true"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"find*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"true"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"load*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"true"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"true"</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 配置事务切面 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"serviceOperation"</span></span><span class="hljs-tag">                      <span class="hljs-attr">expression</span>=<span class="hljs-string">"execution(* cn.dyf.service.*.*(..))"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">"txAdvice"</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">"serviceOperation"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></li><li><p>MyBatis配置文件mybatis-config；</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--因为这里面的内容都集成到Spring的全局配置文件中去管理了，所以几乎没什么东西需要配置--&gt;</span><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></code></pre></li><li><p>SpringMVC配置文件springmvc.xml；</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">"http://www.springframework.org/schema/mvc"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/mvc</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>    <span class="hljs-comment">&lt;!--配置自动扫描注解--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"cn.dyf.controller"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span>    <span class="hljs-comment">&lt;!--配置注解开发--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>    <span class="hljs-comment">&lt;!--配置实拍图解析器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"viewResolver"</span></span><span class="hljs-tag"></span><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".jsp"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></li><li><p>配置web.xml；</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://xmlns.jcp.org/xml/ns/javaee  http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span> <span class="hljs-attr">version</span>=<span class="hljs-string">"4.0"</span>&gt;</span>             <span class="hljs-comment">&lt;!-- Spring配置文件 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 编码过滤器 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">async-supported</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">async-supported</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span>        <span class="hljs-comment">&lt;!-- Spring监听器 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 添加对SpringMVC的支持 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">async-supported</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">async-supported</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.action<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></li></ul></li><li><p>编写entity、Service、Dao；</p><ul><li><p>entity类；</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.dyf.entity;<span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@description</span>: 用户类</span><span class="hljs-comment">* <span class="hljs-doctag">@auther</span>: 带头大哥杰尼龟</span><span class="hljs-comment">* <span class="hljs-doctag">@date</span>: 2019-12-11 22:56</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> username;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;        <span class="hljs-keyword">this</span>.username = username;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> password;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span><span class="hljs-params">(String password)</span> </span>&#123;        <span class="hljs-keyword">this</span>.password = password;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"User&#123;"</span> +                <span class="hljs-string">"id="</span> + id +                <span class="hljs-string">", username='"</span> + username + <span class="hljs-string">'\''</span> +                <span class="hljs-string">", password='"</span> + password + <span class="hljs-string">'\''</span> +                <span class="hljs-string">'&#125;'</span>;    &#125;&#125;</code></pre></li><li><p>Service、ServiceImpl；</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.dyf.service;<span class="hljs-keyword">import</span> cn.dyf.entity.User;<span class="hljs-comment">/**</span><span class="hljs-comment">  * <span class="hljs-doctag">@description</span>: 用户类Service接口</span><span class="hljs-comment">  * <span class="hljs-doctag">@auther</span>: 带头大哥杰尼龟</span><span class="hljs-comment">  * <span class="hljs-doctag">@date</span>: 2019-12-11 23:08</span><span class="hljs-comment">  */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-function">User <span class="hljs-title">findUserByName</span><span class="hljs-params">(String username)</span></span>;&#125;<span class="hljs-comment">//---------------------------------------------------</span>    <span class="hljs-keyword">package</span> cn.dyf.service.impl;<span class="hljs-keyword">import</span> cn.dyf.dao.UserMapper;<span class="hljs-keyword">import</span> cn.dyf.entity.User;<span class="hljs-keyword">import</span> cn.dyf.service.UserService;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<span class="hljs-comment">/**</span><span class="hljs-comment">  * <span class="hljs-doctag">@description</span>: 用户类Service实现类</span><span class="hljs-comment">  * <span class="hljs-doctag">@auther</span>: 带头大哥杰尼龟</span><span class="hljs-comment">  * <span class="hljs-doctag">@date</span>: 2019-12-11 23:09</span><span class="hljs-comment">  */</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserMapper userMapper;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">findUserByName</span><span class="hljs-params">(String username)</span> </span>&#123;        <span class="hljs-keyword">return</span> userMapper.queryUserByName(username);    &#125;&#125;</code></pre></li><li><p>Dao和Mapper；</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.dyf.dao;<span class="hljs-keyword">import</span> cn.dyf.entity.User;<span class="hljs-comment">/**</span><span class="hljs-comment">  * <span class="hljs-doctag">@description</span>: 用户类dao接口</span><span class="hljs-comment">  * <span class="hljs-doctag">@auther</span>: 带头大哥杰尼龟</span><span class="hljs-comment">  * <span class="hljs-doctag">@date</span>: 2019-12-11 22:58</span><span class="hljs-comment">  */</span>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;    <span class="hljs-function">User <span class="hljs-title">queryUserByName</span><span class="hljs-params">(String username)</span></span>;&#125;<span class="hljs-comment">//--------------------------------------------------</span>&lt;!DOCTYPE mapper        PUBLIC <span class="hljs-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span>        <span class="hljs-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;&lt;mapper namespace=<span class="hljs-string">"cn.dyf.dao.UserMapper"</span>&gt;    &lt;select id=<span class="hljs-string">"queryUserByName"</span> resultType=<span class="hljs-string">"User"</span> parameterType=<span class="hljs-string">"java.lang.String"</span>&gt;        SELECT username，password        FROM tb_user        WHERE username = #&#123;username&#125;    &lt;/select&gt;&lt;/mapper&gt;</code></pre></li></ul></li><li><p>编写Controller以及自定义Realm；</p><ul><li><p>Controller；</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.dyf.controller;<span class="hljs-keyword">import</span> cn.dyf.entity.User;<span class="hljs-keyword">import</span> cn.dyf.service.UserService;<span class="hljs-keyword">import</span> org.apache.shiro.SecurityUtils;<span class="hljs-keyword">import</span> org.apache.shiro.authc.AuthenticationException;<span class="hljs-keyword">import</span> org.apache.shiro.authc.UsernamePasswordToken;<span class="hljs-keyword">import</span> org.apache.shiro.session.Session;<span class="hljs-keyword">import</span> org.apache.shiro.subject.Subject;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<span class="hljs-keyword">import</span> org.springframework.ui.Model;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;<span class="hljs-keyword">import</span> javax.annotation.Resource;<span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-comment">/**</span><span class="hljs-comment">  * <span class="hljs-doctag">@description</span>: 用户类的Controller</span><span class="hljs-comment">  * <span class="hljs-doctag">@auther</span>: 带头大哥杰尼龟</span><span class="hljs-comment">  * <span class="hljs-doctag">@date</span>: 2019-12-12 21:25</span><span class="hljs-comment">  */</span><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> UserService userService;        <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/login"</span>, method = RequestMethod.POST)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(User user, Model model)</span></span>&#123;            <span class="hljs-comment">//1.获取当前登录的用户</span>        Subject subject = SecurityUtils.getSubject();        <span class="hljs-comment">//2.创建Token令牌</span>        UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(              user.getUsername(),user.getPassword());        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//3.验证登录</span>            subject.login(token);            <span class="hljs-comment">//4.登录成功</span>            <span class="hljs-comment">//输出</span>            System.out.println(<span class="hljs-string">"恭喜你，成功登录"</span>);            <span class="hljs-comment">//5.获取Session，并存入当前登录的用户</span>            Session session = subject.getSession();            session.setAttribute(<span class="hljs-string">"currentUser"</span>,user);            <span class="hljs-comment">//6.跳转页面</span>            <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-comment">//输出</span>            System.out.println(<span class="hljs-string">"登录失败了~~"</span>);            model.addAttribute(<span class="hljs-string">"errorMessage"</span>,<span class="hljs-string">"用户名或密码错误，请重新输入！"</span>);            <span class="hljs-keyword">return</span> <span class="hljs-string">"login"</span>;        &#125;    &#125;&#125;</code></pre></li><li><p>自定义Realm；</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.dyf.realm;<span class="hljs-keyword">import</span> cn.dyf.entity.User;<span class="hljs-keyword">import</span> cn.dyf.service.UserService;<span class="hljs-keyword">import</span> org.apache.shiro.authc.AuthenticationException;<span class="hljs-keyword">import</span> org.apache.shiro.authc.AuthenticationInfo;<span class="hljs-keyword">import</span> org.apache.shiro.authc.AuthenticationToken;<span class="hljs-keyword">import</span> org.apache.shiro.authc.SimpleAuthenticationInfo;<span class="hljs-keyword">import</span> org.apache.shiro.authz.AuthorizationInfo;<span class="hljs-keyword">import</span> org.apache.shiro.realm.AuthorizingRealm;<span class="hljs-keyword">import</span> org.apache.shiro.subject.PrincipalCollection;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> javax.annotation.Resource;<span class="hljs-comment">/**</span><span class="hljs-comment">  * <span class="hljs-doctag">@description</span>: 自定义的Realm</span><span class="hljs-comment">  * <span class="hljs-doctag">@auther</span>: 带头大哥杰尼龟</span><span class="hljs-comment">  * <span class="hljs-doctag">@date</span>: 2019-12-12 21:54</span><span class="hljs-comment">  */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;        <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> UserService userService;        <span class="hljs-comment">/**</span><span class="hljs-comment">      * 方法描述</span><span class="hljs-comment">      * <span class="hljs-doctag">@description</span>: 这个方法的作用是授权，即为当前登录的用户授予权限以及角色</span><span class="hljs-comment">      * <span class="hljs-doctag">@auther</span>: 带头大哥杰尼龟</span><span class="hljs-comment">      * <span class="hljs-doctag">@param</span>:</span><span class="hljs-comment">      * <span class="hljs-doctag">@return</span>:</span><span class="hljs-comment">      * <span class="hljs-doctag">@date</span>: 2019-12-12 22:03</span><span class="hljs-comment">      */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">               PrincipalCollection principalCollection)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">      * 方法描述</span><span class="hljs-comment">      * <span class="hljs-doctag">@description</span>: 这个方法的作用是验证，即验证当前登录的用户</span><span class="hljs-comment">      * <span class="hljs-doctag">@auther</span>: 带头大哥杰尼龟</span><span class="hljs-comment">      * <span class="hljs-doctag">@param</span>:</span><span class="hljs-comment">      * <span class="hljs-doctag">@return</span>:</span><span class="hljs-comment">      * <span class="hljs-doctag">@date</span>: 2019-12-12 22::13</span><span class="hljs-comment">      */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">          AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        User user = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//在这里调用Service层的方法</span>            user = userService.findUserByName((String) token.getPrincipal());            <span class="hljs-comment">//如果user不为空，则说明数据库有该用户的信息</span>            <span class="hljs-keyword">if</span>(user != <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-comment">//验证用户名及密码</span>                SimpleAuthenticationInfo sai = <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(                    user.getUsername(),user.getPassword(),<span class="hljs-string">""</span>);                <span class="hljs-keyword">return</span> sai;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-comment">//验证失败</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></li></ul></li><li><p>自定义完成Realm之后，还需要在applicationContext.xml中配置这个自定义的Realm，以及进行一些其他配置；</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置Shiro与Spring的集成环境--&gt;</span><span class="hljs-comment">&lt;!--1.配置自定义的Realm--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"myRealm"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.dyf.realm.UserRealm"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!--2.配置将myRealm注入到SecurityManager--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"securityManager"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"realm"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"myRealm"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!--3.配置保证实现了Shiro内部lifecycle函数的bean执行--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"lifecycleBeanPostProcessor"</span></span><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.spring.LifecycleBeanPostProcessor"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!--4.开启Shiro注解支持--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"</span></span><span class="hljs-tag">      <span class="hljs-attr">depends-on</span>=<span class="hljs-string">"lifecycleBeanPostProcessor"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"securityManager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"securityManager"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!--5.配置URL访问路径--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"shiroFilter"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</span>    <span class="hljs-comment">&lt;!--Shiro的核心安全接口，这个属性是必须的--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"securityManager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"securityManager"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-comment">&lt;!--配置身份验证失败，则跳转到登录页面--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"loginUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/login.jsp"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-comment">&lt;!--配置权限验证失败，则跳转到指定页面--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"unauthorizedUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"unauthorized.jsp"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-comment">&lt;!--Shiro连接约束配置，即过滤链的定义--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"filterChainDefinitions"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>            /user/login.action=anon            /admin/**=authc,roles[admin]            /student=roles[teacher]            /teacher=perms["user:create"]            <span class="hljs-comment">&lt;!--以下所有请求必须进行身份验证--&gt;</span>            /**=authc        <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-6-Shiro验证流程的底层原理"><a href="#NO2-6-Shiro验证流程的底层原理" class="headerlink" title="NO2.6 Shiro验证流程的底层原理"></a>NO2.6 Shiro验证流程的底层原理</h3><ul><li><p>Shiro的验证流程；</p><p><img src="Shiro--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Image-s2.png" srcset="/img/loading.gif" alt="Image"></p><ul><li><p>第一步：用户登录，根据用户登录名密码生产Token；</p><pre><code class="hljs java">UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(username, password);Subject subject = SecurityUtils.getSubject();subject.login(token);<span class="hljs-comment">//这里调用了代理subject的login方法，代码如下：</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        clearRunAsIdentitiesInternal();        Subject subject = securityManager.login(<span class="hljs-keyword">this</span>, token);  <span class="hljs-comment">//可以看到这里，实际是调用securityManager的login方法</span>        PrincipalCollection principals;        String host = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (subject <span class="hljs-keyword">instanceof</span> DelegatingSubject) &#123;            DelegatingSubject delegating = (DelegatingSubject) subject;            <span class="hljs-comment">//we have to do this in case there are assumed identities - we don't want to lose the 'real' principals:</span>            principals = delegating.principals;            host = delegating.host;        &#125; <span class="hljs-keyword">else</span> &#123;            principals = subject.getPrincipals();        &#125;        <span class="hljs-keyword">if</span> (principals == <span class="hljs-keyword">null</span> || principals.isEmpty()) &#123;            String msg = <span class="hljs-string">"Principals returned from securityManager.login( token ) returned a null or "</span> +                    <span class="hljs-string">"empty value.  This value must be non null and populated with one or more elements."</span>;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(msg);        &#125;        <span class="hljs-keyword">this</span>.principals = principals;        <span class="hljs-keyword">this</span>.authenticated = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span> (token <span class="hljs-keyword">instanceof</span> HostAuthenticationToken) &#123;            host = ((HostAuthenticationToken) token).getHost();        &#125;        <span class="hljs-keyword">if</span> (host != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">this</span>.host = host;        &#125;        Session session = subject.getSession(<span class="hljs-keyword">false</span>);        <span class="hljs-keyword">if</span> (session != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">this</span>.session = decorate(session);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">this</span>.session = <span class="hljs-keyword">null</span>;        &#125;    &#125;</code></pre></li><li><p>第二步：调用securityManager的login方法；</p><pre><code class="hljs java"><span class="hljs-comment">//这就是securityManager中的login方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> Subject <span class="hljs-title">login</span><span class="hljs-params">(Subject subject, AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;    AuthenticationInfo info;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//主要调用了这个方法</span>        info = authenticate(token);    &#125; <span class="hljs-keyword">catch</span> (AuthenticationException ae) &#123;        <span class="hljs-keyword">try</span> &#123;            onFailedLogin(token, ae, subject);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-keyword">if</span> (log.isInfoEnabled()) &#123;                log.info(<span class="hljs-string">"onFailedLogin method threw an "</span> +                  <span class="hljs-string">"exception.  Logging and propagating original AuthenticationException."</span>, e);            &#125;        &#125;        <span class="hljs-keyword">throw</span> ae; <span class="hljs-comment">//propagate</span>    &#125;    Subject loggedIn = createSubject(token, info, subject);    onSuccessfulLogin(token, info, loggedIn);    <span class="hljs-keyword">return</span> loggedIn;&#125;</code></pre></li><li><p>第三步：调用securityManager的authenticate方法，该方法(authenticate方法)在其上级类 AuthenticatingSecurityManager中，代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationInfo <span class="hljs-title">authenticate</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.authenticator.authenticate(token);    &#125; <span class="hljs-comment">//---------------------------------</span><span class="hljs-comment">//实际调用了authenticator的authenticate方法，而AuthenticatingSecurityManager的无参构造函数中的ModularRealmAuthenticator类继承了AbstractAuthenticator类</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AuthenticatingSecurityManager</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>();        <span class="hljs-keyword">this</span>.authenticator = <span class="hljs-keyword">new</span> ModularRealmAuthenticator();    &#125;</code></pre></li><li><p>第四步：调用AbstractAuthenticator的authenticate方法；</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> AuthenticationInfo <span class="hljs-title">authenticate</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;    <span class="hljs-keyword">if</span> (token == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Method argumet (authentication token) cannot be null."</span>);    &#125;    log.trace(<span class="hljs-string">"Authentication attempt received for token [&#123;&#125;]"</span>, token);    AuthenticationInfo info;    <span class="hljs-keyword">try</span> &#123;        info = doAuthenticate(token);        <span class="hljs-keyword">if</span> (info == <span class="hljs-keyword">null</span>) &#123;            String msg = <span class="hljs-string">"No account information found for authentication token ["</span> + token + <span class="hljs-string">"] by this "</span> +                <span class="hljs-string">"Authenticator instance.  Please check that it is configured correctly."</span>;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationException(msg);        &#125;    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        AuthenticationException ae = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> AuthenticationException) &#123;            ae = (AuthenticationException) t;        &#125;        <span class="hljs-keyword">if</span> (ae == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//Exception thrown was not an expected AuthenticationException.  Therefore it is probably a little more</span>            <span class="hljs-comment">//severe or unexpected.  So, wrap in an AuthenticationException, log to warn, and propagate:</span>            String msg = <span class="hljs-string">"Authentication failed for token submission ["</span> + token + <span class="hljs-string">"].  Possible unexpected "</span> +                <span class="hljs-string">"error? (Typical or expected login exceptions should extend from AuthenticationException)."</span>;            ae = <span class="hljs-keyword">new</span> AuthenticationException(msg, t);        &#125;        <span class="hljs-keyword">try</span> &#123;            notifyFailure(token, ae);        &#125; <span class="hljs-keyword">catch</span> (Throwable t2) &#123;            <span class="hljs-keyword">if</span> (log.isWarnEnabled()) &#123;                String msg = <span class="hljs-string">"Unable to send notification for failed authentication attempt - listener error?.  "</span> +                    <span class="hljs-string">"Please check your AuthenticationListener implementation(s).  Logging sending exception "</span> +                    <span class="hljs-string">"and propagating original AuthenticationException instead..."</span>;                log.warn(msg, t2);            &#125;        &#125;        <span class="hljs-keyword">throw</span> ae;    &#125;    log.debug(<span class="hljs-string">"Authentication successful for token [&#123;&#125;].  Returned account [&#123;&#125;]"</span>, token, info);    notifySuccess(token, info);    <span class="hljs-keyword">return</span> info;&#125;看<span class="hljs-keyword">try</span>语句中的 doAuthenticate（）方法 则是在其子类ModularRealmAuthenticator中实现，所以</code></pre></li><li><p>第五步：调用ModularRealmAuthenticator的doAuthenticate方法；</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doAuthenticate</span><span class="hljs-params">(AuthenticationToken authenticationToken)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;    assertRealmsConfigured();    Collection&lt;Realm&gt; realms = getRealms();    <span class="hljs-keyword">if</span> (realms.size() == <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> doSingleRealmAuthentication(realms.iterator().next(), authenticationToken);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> doMultiRealmAuthentication(realms, authenticationToken);    &#125;&#125;第二行获取realms，但我们记得只配置过realm,realms是什么时候赋值的呢，其实很简单  spring对bean属性的赋值是通过反射 实际调用的是set方法，即我们配置了    一个property 为realm的属性  对属性注入的时候调用的setRealm方法    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRealm</span><span class="hljs-params">(Realm realm)</span> </span>&#123;    <span class="hljs-keyword">if</span> (realm == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Realm argument cannot be null"</span>);    &#125;    Collection&lt;Realm&gt; realms = <span class="hljs-keyword">new</span> ArrayList&lt;Realm&gt;(<span class="hljs-number">1</span>);    realms.add(realm);    setRealms(realms);&#125;所以这里我们的realms实际就是配置的realm，当然前提是我们只配置了单个</code></pre></li><li><p>第六步：调用ModularRealmAuthenticator的doSingleRealmAuthentication方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doSingleRealmAuthentication</span><span class="hljs-params">(Realm realm, AuthenticationToken token)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!realm.supports(token)) &#123;        String msg = <span class="hljs-string">"Realm ["</span> + realm + <span class="hljs-string">"] does not support authentication token ["</span> +            token + <span class="hljs-string">"].  Please ensure that the appropriate Realm implementation is "</span> +            <span class="hljs-string">"configured correctly or that the realm accepts AuthenticationTokens of this type."</span>;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedTokenException(msg);    &#125;    AuthenticationInfo info = realm.getAuthenticationInfo(token);    <span class="hljs-keyword">if</span> (info == <span class="hljs-keyword">null</span>) &#123;        String msg = <span class="hljs-string">"Realm ["</span> + realm + <span class="hljs-string">"] was unable to find account data for the "</span> +            <span class="hljs-string">"submitted AuthenticationToken ["</span> + token + <span class="hljs-string">"]."</span>;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownAccountException(msg);    &#125;    <span class="hljs-keyword">return</span> info;&#125;其中调用了realm自身的getAuthenticationInfo方法</code></pre></li><li><p>第七步：调用AuthenticatingRealm的getAuthenticationInfo方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> AuthenticationInfo <span class="hljs-title">getAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;    AuthenticationInfo info = getCachedAuthenticationInfo(token);    <span class="hljs-keyword">if</span> (info == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">//otherwise not cached, perform the lookup:</span>        info = doGetAuthenticationInfo(token);        log.debug(<span class="hljs-string">"Looked up AuthenticationInfo [&#123;&#125;] from doGetAuthenticationInfo"</span>, info);        <span class="hljs-keyword">if</span> (token != <span class="hljs-keyword">null</span> &amp;&amp; info != <span class="hljs-keyword">null</span>) &#123;            cacheAuthenticationInfoIfPossible(token, info);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        log.debug(<span class="hljs-string">"Using cached authentication info [&#123;&#125;] to perform credentials matching."</span>, info);    &#125;        <span class="hljs-keyword">if</span> (info != <span class="hljs-keyword">null</span>) &#123;        assertCredentialsMatch(token, info);    &#125; <span class="hljs-keyword">else</span> &#123;        log.debug(<span class="hljs-string">"No AuthenticationInfo found for submitted AuthenticationToken [&#123;&#125;].  Returning null."</span>, token);    &#125;    <span class="hljs-keyword">return</span> info;&#125;第一行代码，通过缓存获取AuthenticationInfo，说到这里正好看看缓存是怎么实现的，同样代码全在这，跟着走就行而我们的cacheManager哪来的呢，我们发现在setRealm方法中调用了setRealms    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRealms</span><span class="hljs-params">(Collection&lt;Realm&gt; realms)</span> </span>&#123;    <span class="hljs-keyword">if</span> (realms == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Realms collection argument cannot be null."</span>);    &#125;    <span class="hljs-keyword">if</span> (realms.isEmpty()) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Realms collection argument cannot be empty."</span>);    &#125;    <span class="hljs-keyword">this</span>.realms = realms;    afterRealmsSet();&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterRealmsSet</span><span class="hljs-params">()</span> </span>&#123;    applyCacheManagerToRealms();    applyEventBusToRealms();&#125;可以看到在设置完realms以后调用了一个后续处理方法，在afterRealmsSet中 有个调用 applyCacheManagerToRealms方法 ，字面意思也是很好理解 应用缓存管理器到realms中，而这种方法代码为：    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyCacheManagerToRealms</span><span class="hljs-params">()</span> </span>&#123;    CacheManager cacheManager = getCacheManager();    Collection&lt;Realm&gt; realms = getRealms();    <span class="hljs-keyword">if</span> (cacheManager != <span class="hljs-keyword">null</span> &amp;&amp; realms != <span class="hljs-keyword">null</span> &amp;&amp; !realms.isEmpty()) &#123;        <span class="hljs-keyword">for</span> (Realm realm : realms) &#123;            <span class="hljs-keyword">if</span> (realm <span class="hljs-keyword">instanceof</span> CacheManagerAware) &#123;                ((CacheManagerAware) realm).setCacheManager(cacheManager);            &#125;        &#125;    &#125;&#125;实际就是判断如果cacheManager不为空 就循环realms设置cacheManager（有点啰嗦，哈哈，自己当时就是这么想的）在上面getAuthenticationInfo方法中，我们刚才说过第一行是从缓存中取AuthenticationInfo，如果为空</code></pre></li><li><p>第八步：调用realm的doGetAuthenticationInfo方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;    <span class="hljs-comment">// TODO Auto-generated method stub</span>    String userName = (String) token.getPrincipal();        <span class="hljs-comment">//通过token获取用户信息,这里我们一般从数据库中查询</span>    SimpleAuthenticationInfo authenticationInfo = <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(user, password, getName());    <span class="hljs-keyword">return</span> authenticationInfo;&#125;返回AuthenticationInfo，接着下面代码    <span class="hljs-keyword">if</span> (token != <span class="hljs-keyword">null</span> &amp;&amp; info != <span class="hljs-keyword">null</span>) &#123;        cacheAuthenticationInfoIfPossible(token, info);    &#125;判断 如果token与获取到的AuthenticationInfo都不为空，缓存AuthenticationInfo信息    关于从缓存中查询AuthenticationInfo以及缓存AuthenticationInfo信息的方法 这里就不作分析了，可以看做对一个map的操作吧    当然到这里还没完，同样在上面方法中，    <span class="hljs-keyword">if</span> (info != <span class="hljs-keyword">null</span>) &#123;        assertCredentialsMatch(token, info);    &#125; <span class="hljs-keyword">else</span> &#123;        log.debug(<span class="hljs-string">"No AuthenticationInfo found for submitted AuthenticationToken [&#123;&#125;].  Returning null."</span>, token);    &#125;如果AuthenticationInfo不为空 即通过登录用户查询到了对应的信息</code></pre></li><li><p>第九步：调用assertCredentialsMatch方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">assertCredentialsMatch</span><span class="hljs-params">(AuthenticationToken token, AuthenticationInfo info)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;    CredentialsMatcher cm = getCredentialsMatcher();    <span class="hljs-keyword">if</span> (cm != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (!cm.doCredentialsMatch(token, info)) &#123;            <span class="hljs-comment">//not successful - throw an exception to indicate this:</span>            String msg = <span class="hljs-string">"Submitted credentials for token ["</span> + token + <span class="hljs-string">"] did not match the expected credentials."</span>;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IncorrectCredentialsException(msg);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationException(<span class="hljs-string">"A CredentialsMatcher must be configured in order to verify "</span> +                                          <span class="hljs-string">"credentials during authentication.  If you do not wish for credentials to be examined, you "</span> +                                          "can configure an " + AllowAllCredentialsMatcher.class.getName() + " instance.");    &#125;&#125;第一行获取CredentialsMatcher，如果不为空</code></pre></li><li><p>第十步：调用CredentialsMatcher的doCredentialsMatch方法，当然CredentialsMatcher我们可以自定义了；</p></li><li><p>第十一步：上面步骤都通过以后回到DefualtSecurityManager的login方法中；</p><pre><code class="hljs java"><span class="hljs-comment">//创建Subject</span>Subject loggedIn = createSubject(token, info, subject);<span class="hljs-function"><span class="hljs-keyword">protected</span> Subject <span class="hljs-title">createSubject</span><span class="hljs-params">(AuthenticationToken token, AuthenticationInfo info, Subject existing)</span> </span>&#123;    SubjectContext context = createSubjectContext();    context.setAuthenticated(<span class="hljs-keyword">true</span>);    context.setAuthenticationToken(token);    context.setAuthenticationInfo(info);    <span class="hljs-keyword">if</span> (existing != <span class="hljs-keyword">null</span>) &#123;        context.setSubject(existing);    &#125;    <span class="hljs-keyword">return</span> createSubject(context);&#125;接着就是通过SubjectFactory生成subject，这里就不说了，就是从我们查询把我们查询到的用户身份信息关联到对应的subject中整个过程大致就是这样了，可能有遗漏，后续再慢慢补充咯</code></pre></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>5.다른 과정</category>
      
      <category>04.安全框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shiro</tag>
      
      <tag>安全框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03.Oracle--学习笔记</title>
    <link href="/2020/07/10/Oracle--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/10/Oracle--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Oracle–学习笔记-包含Oracle视频"><a href="#Oracle–学习笔记-包含Oracle视频" class="headerlink" title="Oracle–学习笔记(包含Oracle视频)"></a>Oracle–学习笔记(包含Oracle视频)</h1><h2 id="Lesson1-Oracle概述"><a href="#Lesson1-Oracle概述" class="headerlink" title="Lesson1 Oracle概述"></a>Lesson1 Oracle概述</h2><h3 id="NO1-1-Oracle简介"><a href="#NO1-1-Oracle简介" class="headerlink" title="NO1.1 Oracle简介"></a>NO1.1 Oracle简介</h3><p>Oracle数据库是相对于其他数据库来说比较难的一个。</p><ul><li>Oracle Database：<ul><li>介绍：又名Oracle RDBMS，简称Oracle，是甲骨文公司推出的一款关系数据库管理系统。Oracle数据库系统是目前世界上流行的关系数据库管理系统。Oracle是一种高效率、可靠性好的、适应高吞吐量的数据库解决方案。</li><li>Oracle的特点：<ul><li>支持多用户、大事务量的事务处理；</li><li>数据安全性和完整性控制；</li><li>支持分布式数据处理；</li><li>可移植性。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-2-Oracle服务端、客户端和PL-SQL-Developer的安装"><a href="#NO1-2-Oracle服务端、客户端和PL-SQL-Developer的安装" class="headerlink" title="NO1.2 Oracle服务端、客户端和PL/SQL Developer的安装"></a>NO1.2 Oracle服务端、客户端和PL/SQL Developer的安装</h3><p>Oracle的服务端和客户端、PL/SQL Developer的都要统一，我这里是三个软件都是64位的。</p><ul><li><p>安装包版本：</p><ul><li>64位Oracle 11g；</li><li>64位Oracle 11g Client；</li><li>64位PL/SQL Development 14。</li></ul></li><li><p>Oracle服务端安装步骤中，需要注意几个地方：</p><ul><li><p>下载下来的64位Oracle 11g，有两个文件压缩包，必须同时进行解压，不要单独解压某一个压缩包(我就是单独解压1，没解压2，就直接安装了…粗心)；解压完成后，点击database文件夹，双击setup.exe安装程序即可；</p><p>  <img src="./Image-o1.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>安装步骤如下列所示；</p><p>  <img src="./Image-o3.png" srcset="/img/loading.gif" alt=""></p><p>  <img src="./Image-o4.png" srcset="/img/loading.gif" alt=""></p><p>  <img src="./Image-o5.png" srcset="/img/loading.gif" alt=""></p><p>  <img src="./Image-o6.png" srcset="/img/loading.gif" alt=""></p><p>  <img src="./Image-o7.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>Oracle客户端安装步骤中，需要注意几个地方：</p><ul><li><p>两个需要注意的地方：</p><p>  <img src="./Image-o8.png" srcset="/img/loading.gif" alt=""></p></li><li><p>Oracle客户端安装完成后，需要进行两个配置：</p><ul><li><p>首先，配置监听服务文件。监听服务文件在Oracle客户端安装目录下的network/admin/tnsnames.ora。以记事本的方式打开admin目录下的tnsnames.ora，删除全部内容，并按照下面的格式想里面写入网络服务名、传输协议、IP地址、端口和数据库名；<strong><code>注意：新安装的客户端如果没有配置过监听，admin目录下可能没有tnsnames.ora这个文件，可以手动创建文本文档，文件名改为tnsnames，后缀改为ora。</code></strong></p>  <pre><code class="hljs nix"><span class="hljs-attr">ORCL</span> =    (<span class="hljs-attr">DESCRIPTION</span> =        (<span class="hljs-attr">ADDRESS_LIST</span> =            (<span class="hljs-attr">ADDRESS</span> = (<span class="hljs-attr">PROTOCOL</span> = TCP)(<span class="hljs-attr">HOST</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>)(<span class="hljs-attr">PORT</span> = <span class="hljs-number">1521</span>))        )        (<span class="hljs-attr">CONNECT_DATA</span> =            (<span class="hljs-attr">SERVICE_NAME</span> = orcl)        )    )说明：配置简介一、ORCL是一个别名，你叫啥都行，你自己认识就行；二、HOST就是你要连接的Oracle服务端IP地址，如果是本机，就写<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>就行；三、PORT则是你要连接的Oracle服务端的端口号，一般都为<span class="hljs-number">1521</span>；四、SERVICE_NAME是填你在安装Oracle服务端时，给Oracle服务端取得实例名，简单讲就是告诉Oracle客户端要监听的是哪个Oracle数据库，虽然电脑上只有一个Oracle数据库，但是还是要这么做；五、其他的一般默认就可以了。</code></pre></li><li><p>然后，配置监听器。监听器文件在Oracle客户端安装目录下的network/admin/listener.ora。以记事本的方式打开admin目录下的listener.ora，删除全部内容，并按照下面的格式想里面写入网络服务名、传输协议、IP地址、端口和数据库名；<strong><code>注意：新安装的客户端如果没有配置过监听，admin目录下可能没有listener.ora这个文件，可以手动创建文本文档，文件名改为listener，后缀改为ora。</code></strong></p>  <pre><code class="hljs nix"><span class="hljs-attr">LISTENER</span> =  (<span class="hljs-attr">DESCRIPTION_LIST</span> =    (<span class="hljs-attr">DESCRIPTION</span> =      (<span class="hljs-attr">ADDRESS</span> = (<span class="hljs-attr">PROTOCOL</span> = TCP)(<span class="hljs-attr">HOST</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>)(<span class="hljs-attr">PORT</span> = <span class="hljs-number">1521</span>))      (<span class="hljs-attr">ADDRESS</span> = (<span class="hljs-attr">PROTOCOL</span> = IPC)(<span class="hljs-attr">KEY</span> = EXTPROC1521))    )  )<span class="hljs-attr">ADR_BASE_LISTENER</span> = E:\orcl_cli64说明：配置简介一、HOST，这个不用说了吧，和上面配置监听服务的配置差不多；二、PORT一般都为<span class="hljs-number">1521</span>；三、ADR_BASE_LISTENER，这个改成你客户端的最外层的安装目录就行。</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>PL/SQL Developer的安装，这个安装程序没有太多需要注意的，按照正常安装软件的步骤来即可，但是在安装完成后需要配置一下。</p><ul><li><p>打开PL/SQL，然后取消登录，随后会进入主界面，在上方的菜单栏中找到Preferences选项，出现如下对话框后，只要把图中圈出来的地方配置好即可。</p><p>  <img src="./Image-o9.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><ul><li>Oracle的访问：<ul><li>可以使用Bin目录下的sqlplus.exe访问Oracle，只不过是命令行形式的；</li><li>使用sql_developer来访问Oracle，这个也是Oracle里自带的；</li><li>使用PL/SQL Developer来访问Oracle。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson2-Oracle基础"><a href="#Lesson2-Oracle基础" class="headerlink" title="Lesson2 Oracle基础"></a>Lesson2 Oracle基础</h2><h3 id="NO2-1-Oracle基础概念"><a href="#NO2-1-Oracle基础概念" class="headerlink" title="NO2.1 Oracle基础概念"></a>NO2.1 Oracle基础概念</h3><p>Oracle和其他数据库不太一样，Oracle只有一个数据库(MySQL中就可以创建数据库，然后在指定数据库中创建表进行操作)，即全局只有一个数据库。</p><ul><li>基本概念：<ul><li>数据库实例：官方概念为实例是由一些内存和进程组成，这看的我一脸懵逼。我自己的理解为：我们安装的Oracle数据库，是一个超大型的数据库，里面有许多小型数据库；所谓的数据库实例，其实就是一把钥匙，一把能够打开某一个小型数据库的钥匙，所以才有了“一个实例只能打开一个数据库”的限制。一个数据库可以有多个实例，这不就相当于，这个超大型的Oracle数据库能够造许多小型的个人类型的oracle数据库，只有安装并配置了Oracle数据库，才能得到一个实例，也就是一把钥匙，用钥匙才能打开数据库；</li><li>表空间：用来存储物理表的这么一片空间，我又懵了….用名词解释名词….我的理解为：表空间是一个小型的数据库，然后在表空间里面可以放许多的表；数据库实例相当于一个MySQL，多个实例就等于是多个MySQL，而表空间就是在MySQL中建立了一个数据库的意思；</li><li>数据文件：即dbf，数据文件是数据库的物理存储单位。表面上Oracle数据库的数据是存储在表空间中，而实际上是存储在一个或多个数据文件中。一个表空间可以由一个或者多个数据文件组成，而一个数据文件只能属于一个表空间。一旦数据文件被放入一个表空间过后，就不能删除这个数据文件，如果要删除某个数据文件，则必须删除其所属的表空间。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-2-创建表空间"><a href="#NO2-2-创建表空间" class="headerlink" title="NO2.2 创建表空间"></a>NO2.2 创建表空间</h3><p>创建表空间，其实就相当于我们在自己的MySQL中，创建一个数据库。</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">tablespace</span> 表空间名<span class="hljs-keyword">datafile</span> <span class="hljs-string">'数据文件名'</span><span class="hljs-keyword">size</span> 表空间大小;说明：表空间的创建一、tablespace，后面跟的是要创建的表空间的名称；二、datafile，后面跟的是这个表空间的表数据要放到哪个数据文件中，文件路径要带盘符；三、size，表示这个数据文件要多大空间。如：<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLESPACE</span> myfirstts<span class="hljs-keyword">DATAFILE</span> <span class="hljs-string">'d:\myfirstts.dbf'</span><span class="hljs-keyword">SIZE</span> <span class="hljs-number">100</span>m<span class="hljs-keyword">AUTOEXTEND</span> <span class="hljs-keyword">ON</span>   //这个表示，如果数据文件满了，也就是满<span class="hljs-number">100</span>m了，那么该文件就会自动扩容<span class="hljs-keyword">NEXT</span> <span class="hljs-number">10</span>m;  //表示每次自动扩容10m</code></pre><p>  <img src="./Image-o10.png" srcset="/img/loading.gif" alt=""></p></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-3-创建用户与授予权限"><a href="#NO2-3-创建用户与授予权限" class="headerlink" title="NO2.3 创建用户与授予权限"></a>NO2.3 创建用户与授予权限</h3><p>用户是建立在表空间的基础上，而表则是建立在用户的基础上。也就是说用户是属于一个表空间的，而以用户的身份进入之后，在表空间下创建的表，都属于这个用户。</p><ul><li><p>创建用户：</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> 用户名<span class="hljs-keyword">identified</span> <span class="hljs-keyword">by</span> 密码<span class="hljs-keyword">default</span> <span class="hljs-keyword">tablespace</span> 表空间表;说明：用户的创建一、user，后面跟的是要创建的用户名称；二、identified by，后面跟的是为该用户的设置的密码；三、default tablespace，表示该用户属于哪个表空间。如：<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> dyf  //用户名<span class="hljs-keyword">IDENTIFIED</span> <span class="hljs-keyword">BY</span> dyf  //用户密码<span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">TABLESPACE</span> myfirstts;  //所属表空间</code></pre><p>  <img src="./Image-o11.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>为新创建的用户赋予权限：</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> DBA <span class="hljs-keyword">TO</span> 用户名;说明：表示给指定的用户授予DBA的权限，也就是数据库管理员的权限。如：<span class="hljs-keyword">GRANT</span> DBA <span class="hljs-keyword">TO</span> dyf;  //这里的DBA是数据管理员的意思，也就是赋予数据管理员用于的权限</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-4-表的创建、修改、删除"><a href="#NO2-4-表的创建、修改、删除" class="headerlink" title="NO2.4 表的创建、修改、删除"></a>NO2.4 表的创建、修改、删除</h3><p>首先，我们先学习一下Oracle中的数据类型。</p><ul><li>Oracle的数据类型：<ul><li>字符型：<ul><li><code>char</code>：固定长度的字符型数据，最长2000字节；不够长度的用空格补齐；</li><li><code>varchar2</code>：可变长度的字符串，最长4000字节；这个是最常用的数据类型；</li><li><code>nchar/nvarchar2</code>：用来存储unicode字符集的定长/变长字符型数据，最长1000字节；</li><li><code>long</code>：大文本类型，用来存储变长的字符串，最长2G；</li><li><code>raw</code>：用来存储二进制，最大2G。</li></ul></li><li>数值型：<ul><li><code>number(p,s)</code>：p表示数字最多38位，s表示小数点占几位；不指定长度时，默认是18；</li><li><code>float</code>：最多存储126位的二进制或38位的十进制的浮点数；</li></ul></li><li>日期类型：<ul><li><code>date</code>：用来存储日期和时间，精确到秒；常用；</li><li><code>timestamp</code>：显示的日期比date更精确，精确到小数秒，还能够显示上午还是下午。</li></ul></li><li>其他数据类型：<ul><li><code>blob</code>：存储二进制数据，最多可以存放4G；</li><li><code>clob</code>：存储字符串数据，最多可以存放4GB。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>表的创建：</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名&#123;    字段名 数据类型(长度),    字段名 数据类型(长度),    ....&#125;;如：<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_owners(  <span class="hljs-keyword">ID</span> <span class="hljs-built_in">NUMBER</span> PRIMARY <span class="hljs-keyword">KEY</span>,  <span class="hljs-keyword">NAME</span> <span class="hljs-built_in">VARCHAR2</span>(<span class="hljs-number">30</span>),  addressid <span class="hljs-built_in">NUMBER</span>,  housenumber <span class="hljs-built_in">VARCHAR2</span>(<span class="hljs-number">30</span>),  watermeter <span class="hljs-built_in">VARCHAR2</span>(<span class="hljs-number">30</span>),  adddate <span class="hljs-built_in">DATE</span>,  ownertypeid <span class="hljs-built_in">NUMBER</span>);</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>表的修改：</p><ul><li><p>给表添加新的字段。基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span>(字段名 数据类型(长度) [默认值]....);如：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> student <span class="hljs-keyword">ADD</span>(courseid <span class="hljs-built_in">number</span>(<span class="hljs-number">3</span>));</code></pre></li><li><p>修改表的字段。基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">MODIFY</span>(字段名 数据类型(长度) [默认值]....);如：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> student <span class="hljs-keyword">MODIFY</span>(courseid <span class="hljs-built_in">varchar2</span>(<span class="hljs-number">15</span>));</code></pre></li><li><p>删除表的字段。基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> 字段名<span class="hljs-number">1</span>，字段名<span class="hljs-number">2.</span>...;如：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> student <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> courseid;</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>表的删除：</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> 表名;如：<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> student;</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-5-表数据的添加、修改、删除"><a href="#NO2-5-表数据的添加、修改、删除" class="headerlink" title="NO2.5 表数据的添加、修改、删除"></a>NO2.5 表数据的添加、修改、删除</h3><p>对表数据的增删改查，是我们经常要接触的，尤其是查询，使用频率更高。</p><ul><li><p>插入数据：</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名(字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2.</span>...) <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>,值<span class="hljs-number">2.</span>...);<span class="hljs-keyword">COMMIT</span>;如：<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_ownertype(<span class="hljs-keyword">ID</span>,<span class="hljs-keyword">NAME</span>) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">'邓先森'</span>);<span class="hljs-keyword">COMMIT</span>;注意：在Oracle中插入数据之后，需要额外的执行事务提交，才能将数据插入到指定表中。</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>删除数据：</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件;<span class="hljs-keyword">COMMIT</span>;如：<span class="hljs-keyword">delete</span> <span class="hljs-keyword">FROM</span> t_ownertype <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">ID</span> =<span class="hljs-number">1</span>;<span class="hljs-keyword">COMMIT</span>;注意：在Oracle中删除数据时，需要额外的执行事务提交，才能将数删除。//<span class="hljs-comment">--------------------------------------------------</span>拓展：另一种删除表数据的方法一、格式：<span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> 表名;二、这种删除表数据的方式，是将表中所有数据都删除，并重建了表结构。</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>修改数据：</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> 表名 <span class="hljs-keyword">SET</span> 字段<span class="hljs-number">1</span>=值<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span>=值<span class="hljs-number">2.</span>...where 条件;<span class="hljs-keyword">commit</span>;如：<span class="hljs-keyword">UPDATE</span> t_ownertype <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NAME</span> = <span class="hljs-string">'dyf'</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">ID</span>=<span class="hljs-number">1</span>;<span class="hljs-keyword">COMMIT</span>;注意：在Oracle中修改数据之后，需要额外的执行事务提交，才能将数修改；且如果需要修改列的属性，那么需要先将列中的值都设置为NULL后，才允许修改列属性。</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-6-使用JDBC连接Oracle数据库"><a href="#NO2-6-使用JDBC连接Oracle数据库" class="headerlink" title="NO2.6 使用JDBC连接Oracle数据库"></a>NO2.6 使用JDBC连接Oracle数据库</h3><p>使用JDBC连接Oracle，除了URL稍微需要修改一下，其他和使用JDBC连接MySQL步骤是一样的。</p><ul><li><p>使用JDBC连接Oracle。</p>  <pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<span class="hljs-keyword">import</span> java.sql.DriverManager;<span class="hljs-keyword">import</span> java.sql.PreparedStatement;<span class="hljs-keyword">import</span> java.sql.ResultSet;<span class="hljs-keyword">import</span> java.sql.SQLException;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DBUtils</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span></span>&#123;        Connection conn=<span class="hljs-keyword">null</span>;              <span class="hljs-keyword">try</span> &#123;            String url=<span class="hljs-string">"jdbc:oracle:thin:@127.0.0.1:1521:orcl"</span>;             String user=<span class="hljs-string">"dyf"</span>;            String password=<span class="hljs-string">"dyf"</span>;                      Class.forName(<span class="hljs-string">"oracle.jdbc.driver.OracleDriver"</span>);  <span class="hljs-comment">//加载数据驱动</span>            conn = DriverManager.getConnection(url, user, password);  <span class="hljs-comment">// 连接数据库</span>                  &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();            System.out.println(<span class="hljs-string">"加载数据库驱动失败"</span>);        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;            e.printStackTrace();            System.out.println(<span class="hljs-string">"连接数据库失败"</span>);        &#125;        <span class="hljs-keyword">return</span> conn;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Connection conn, PreparedStatement ps, ResultSet rs)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span>(rs!=<span class="hljs-keyword">null</span>)&#123;              rs.close();            &#125;        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();        &#125;              <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span>(ps!=<span class="hljs-keyword">null</span>)&#123;                ps.close();            &#125;        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();        &#125;              <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span>(conn!=<span class="hljs-keyword">null</span>)&#123;                  conn.close();            &#125;        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();        &#125;  &#125;&#125;注意：oci连接必须在本机上安装oracle客户端才能连接；而thin就不需要，因此从使用上来讲thin还是更加方便，这也道是thin比较常见的原因。</code></pre></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-7-Oracle数据的导入与导出"><a href="#NO2-7-Oracle数据的导入与导出" class="headerlink" title="NO2.7 Oracle数据的导入与导出"></a>NO2.7 Oracle数据的导入与导出</h3><p>在Oracle中，导入导出数据的方法有两种，一种是使用cmd命令行的形式导入导出数据，另一种是使用PL/SQL工具导入导出数据。</p><ul><li><p>使用cmd命令行的形式导入导出数据：</p><ul><li>第一种：使用cmd命令行整库导入导出数据；<ul><li>整库导出：exp 管理员账号/密码 full=y，其中参数full表示整库导出。导出后会在当前目录下生成一个EXPDAT.DMP的文件，此文件为备份文件。如果想导出数据到指定位置，并且取个名字，需要添加file参数。如，exp system/123456 file=C:\person.dmp full=y；</li><li>整库导入：imp 管理员账号/密码 full=y。如，imp system/123456 file=C:\person.dmp full=y。</li></ul></li><li>第二种：使用cmd命令按用户导出导入；<ul><li>用户导出：exp 指定用户账号/密码 owner=用户名 file=文件路径；</li><li>按用户导入：imp 指定用户账号/密码 file=文件路径 fromuser=用户名 。</li></ul></li><li>第三种：使用cmd命令按表导出导入。<ul><li>按表导出：exp 指定用户账号/密码 file=文件路径 tables=表1,表2….；</li><li>按表导入：imp 指定用户账号/密码 file =文件路径 tables=表1,表2….。</li></ul></li></ul></li><li><p>使用PL/SQL开发工具导入导出数据：pl/sql工具包含三种方式导出oracle表结构和表数据，分别为：oracle export、SQL inserts、pl/sql developer。它们的含义如下：</p><ul><li>第一种：oracle export：导出的是.dmp格式的文件，“.dmp”文件是二进制文件，可以跨平台，包含权限等优点；</li><li>第二种：SQL inserts：导出的是.sql格式的文件，可以用文本编辑器查看，通用性比较好，效率不如第一种，适合小数据量的导入导出。需要注意的是表中不能有大字段(blob,clob,long)，如果有则不能导出；</li><li>第三种：pl/sql：导出的是.pde格式的文件，“.pde”为pl/sql自有的文件格式，只能用pl/sql工具导入导出，文本编辑器不能查看。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson3-Oracle查询"><a href="#Lesson3-Oracle查询" class="headerlink" title="Lesson3 Oracle查询"></a>Lesson3 Oracle查询</h2><h3 id="NO3-1-单表查询"><a href="#NO3-1-单表查询" class="headerlink" title="NO3.1 单表查询"></a>NO3.1 单表查询</h3><p>单表查询，即只对一张表进行查询操作。</p><ul><li><p>简单查询：没有条件的查询；没有关键字。基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表名;如：<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> student;注意：简单条件查询还可以使用“SELECT * FROM 表名;”，默认查询指定记录的所有字段；但是不推荐该方式，因为*号会减慢查询效率。</code></pre></li></ul><p>&nbsp;</p><ul><li><p>简单条件查询：即必须满足单个指定条件的查询；使用关键字where。基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件;如：<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span> =<span class="hljs-string">'小明'</span>;</code></pre></li></ul><p>&nbsp;</p><ul><li><p>模糊查询：即对于要查询的内容不清楚的情况下而使用的查询；使用关键字%或_。基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 字段名 <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%条件'</span>;  //%号匹配零个或多个字符；%可以写在最前面、中间、最后面或两头都加<span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 字段名 <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'_条件'</span>;  //_号只能匹配一个字符；_可以写在最前面、中间、最后面或两头都加如：<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">'%明'</span>; 或 <span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">'小_'</span>;</code></pre></li></ul><p>&nbsp;</p><ul><li><p>and查询：即同时满足多个条件的查询；使用关键字and连接多个条件。基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件<span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> 条件<span class="hljs-number">2</span> <span class="hljs-keyword">and</span> ....;如：<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> score &gt; <span class="hljs-number">60</span> <span class="hljs-keyword">and</span> sex = <span class="hljs-string">'男'</span>;</code></pre></li></ul><p>&nbsp;</p><ul><li><p>or查询：即只需满足多个条件中的一个条件的查询；使用关键字or连接多个条件。基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件<span class="hljs-number">1</span> <span class="hljs-keyword">OR</span> 条件<span class="hljs-number">2</span> <span class="hljs-keyword">or</span> ....;如：<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> score &gt; <span class="hljs-number">60</span> <span class="hljs-keyword">or</span> sex = <span class="hljs-string">'男'</span>;</code></pre></li></ul><p>&nbsp;</p><ul><li><p>范围查询：即满足某种范围条件的查询；使用关键字betweem….and…连接范围连接。基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 字段名 <span class="hljs-keyword">BETWEEN</span> 条件<span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> 条件<span class="hljs-number">2</span>;如：<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> score <span class="hljs-keyword">between</span> <span class="hljs-number">50</span> <span class="hljs-keyword">and</span> <span class="hljs-number">80</span>;</code></pre></li></ul><p>&nbsp;</p><ul><li><p>空值查询：即字段的值为null或不为null的查询；使用关键字is null/is not null。基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 字段 <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;如：<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> score <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>;</code></pre></li></ul><p>&nbsp;</p><ul><li><p>去重复查询：即去掉重复值的查询；使用关键字distinct。基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span>(字段名) <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件;如：<span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> Brand <span class="hljs-keyword">from</span> Car;注意：如果格式为：<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> 字段名<span class="hljs-number">1</span>,字段名<span class="hljs-number">2.</span>.. <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件，则表示两条记录中指定的所有字段都相同，才会去重，否则不去重。</code></pre></li></ul><p>&nbsp;</p><ul><li><p>排序查询：即将查询的结果按照指定字段名的值来进行排序；使用关键字order by。基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 字段名;如：<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> score &gt; <span class="hljs-number">60</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> score;注意：默认排序使用的是升序排序，即ASC，也就是从低到高；如果想要使用从高到低的降序排序的话，要使用DESC，格式：<span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 字段名 <span class="hljs-keyword">DESC</span>;</code></pre></li></ul><p>&nbsp;</p><ul><li><p>伪列查询：Oracle的伪列是Oracle表在存储的过程中或查询的过程中，表会有一些附加列(系统给我们的表附加的)，称为伪列。伪列就像表中的字段一样，但是表中并不存储。伪列只能查询，不能增删改。Oracle的伪列有：ROWID、ROWNUM。所谓伪列查询，就是针对这两个列的查询。</p><ul><li><p><code>ROWID</code>：Oracle表中的每一行在数据文件中都有一个物理地址，而ROWID表示的就是一行记录在数据文件中的物理地址；插入记录时生成，是字符串，可以唯一的标识表中的一行(和主键一样)。基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ROWID</span>,.... <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件;  //查询出来的ROWID表示的是这一条记录在数据文件中的物理地址</code></pre><p>  <img src="./Image-o12.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p><code>ROWNUM</code>：表示的是查询结果的行的顺序，也就是说ROWNUM为每个查询出来的行标识一个行号，第一行返回1，第二行返回2，依次顺序递增；查询数据时生成，是数字；ROWNUM经常用来限制查询的结果返回的行数，求前几行或前几名的数据。基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ROWNUM</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件;  //查询出来的ROWNUM表示的是这一条记录在结果集的顺序注意：ROWNUM是将查询结果进行顺序编号产生的列，但要注意的是，这种顺序编号是每查询到一条记录，就给这条记录编号，也就是说，一边查询，一边给记录编号。</code></pre><p>  <img src="./Image-o13.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><ul><li>聚合统计查询；<strong><code>注意：使用聚合或者分组查询时，select后面一定跟的是分组或聚合的字段名、又或者直接是聚合函数。</code></strong><ul><li>sum()：求和函数；<ul><li>基本语法格式：<code>SUM(数值型的字段名)</code>。<code>如，select sum(age) from student</code>；</li></ul></li><li>avg()：求平均值函数；<ul><li>基本语法格式：<code>AVG(数值型的字段名)</code>。<code>如，select avg(age) from student</code>；</li></ul></li><li>max()：求最大值函数；<ul><li>基本语法格式：<code>MAX(字段名)</code>。<code>如，select max(age) from student</code>；</li></ul></li><li>min()：求最小值函数；<ul><li>基本语法格式：<code>MIN(字段名)</code>。<code>如，select min(age) from student</code>；</li></ul></li><li>count()：求统计记录的函数。<ul><li>基本语法格式：<code>COUNT(字段名)</code>。<code>如，select count(id) from student</code>；</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>分组查询：即将查询的结果按照指定的字段进行分组的查询；使用关键字group by；基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 字段名;如：<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> score &gt; <span class="hljs-number">60</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sex;</code></pre><ul><li><p>如果分组之后还需要按照条件来查询的话，在“group by 字段名”的后面加上关键字having即可。基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 字段名 <span class="hljs-keyword">HAVING</span> 条件;如：<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> score &gt; <span class="hljs-number">60</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">having</span> sex = <span class="hljs-string">'男'</span>;</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>分页查询；由于Oracle没有像MySQL那样的Limit分页关键字，所以只能使用子查询嵌套的方式来进行分页查询，使用如下的基本语法格式就可以完成分页查询：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span>(    <span class="hljs-keyword">SELECT</span> A.字段名....,<span class="hljs-keyword">ROWNUM</span> RN <span class="hljs-keyword">FROM</span>    (        <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> TABLE_NAME    )    A <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">ROWNUM</span> &lt;= <span class="hljs-number">40</span>)<span class="hljs-keyword">WHERE</span> RN &gt; <span class="hljs-number">20</span></code></pre></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-2-多表查询"><a href="#NO3-2-多表查询" class="headerlink" title="NO3.2 多表查询"></a>NO3.2 多表查询</h3><p>多表查询，即对多张表进行联合查询的操作。</p><ul><li><p>连接查询；即连接多张表进行查询。分为两种：</p><ul><li><p>内连接查询：组合两个表中的记录，返回关联的字段相等的那些记录，也就是返回两个表的交集(阴影部分)；使用关键字inner join….on。基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 表<span class="hljs-number">1.</span>字段名 = 表<span class="hljs-number">2.</span>字段名;如：<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>,teacher_id <span class="hljs-keyword">from</span> student <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> teacher <span class="hljs-keyword">on</span> student.teacher_id = teacher.id;</code></pre><p>  <img src="./Image-o14.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>外链接查询：至少返回一个表中的所有记录，根据匹配的条件选择性地返回另外一张表的记录；可以分为左外连接和右外连接查询。注意：关键字左边的为左表，关键字右边的则为右表。</p><ul><li><p>左外连接查询：即返回左表所有记录，右表只返回符合条件的记录，右表有不足的地方用null补足；使用关键字left join….on/left outer join….on。基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 表<span class="hljs-number">1.</span>字段名 = 表<span class="hljs-number">2.</span>字段名;如：<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>,teacher_id <span class="hljs-keyword">from</span> student <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> teacher <span class="hljs-keyword">on</span> student.teacher_id = teacher.id;</code></pre><p>  <img src="./Image-o15.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>右外连接查询：即返回右表所有记录，左表只返回符合条件的记录，左表有不足的地方用null补足。基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 表<span class="hljs-number">1.</span>字段名 = 表<span class="hljs-number">2.</span>字段名;如：<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>,teacher_id <span class="hljs-keyword">from</span> student <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> teacher <span class="hljs-keyword">on</span> student.teacher_id = teacher.id;拓展：Oracle式的外链接一、除了使用outer join关键字来使用外链接查询之外，Oracle9i之前还支持使用“(+)”操作符，之后Oracle还是比较推荐使用关键字outer join；二、左外连接：在右表条件上添加(+)，格式为：<span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span>,表<span class="hljs-number">2</span> <span class="hljs-keyword">WHERE</span> 表<span class="hljs-number">1.</span>字段=表<span class="hljs-number">2.</span>字段(+)；三、右外连接：在左表条件上添加(+)，格式为：<span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span>,表<span class="hljs-number">2</span> <span class="hljs-keyword">WHERE</span> 表<span class="hljs-number">1.</span>字段(+)=表<span class="hljs-number">2.</span>字段；</code></pre><p>  <img src="./Image-o16.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>子查询：即查询当中还有嵌套了一个查询。分为三种：</p><ul><li><p>where字句中的子查询：即子查询的位置位于where条件中；基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span>(<span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">WHERE</span> 条件)如：<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> teacher_id =(<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">where</span> 科目=<span class="hljs-string">'语文'</span>)</code></pre></li><li><p>from子句中的子查询：即子查询的位置位于from后面；基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span>(<span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">WHERE</span> 条件)<span class="hljs-keyword">WHERE</span> 条件如：<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span> <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>,age <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">where</span> 科目=<span class="hljs-string">'语文'</span>)<span class="hljs-keyword">where</span> age &gt; <span class="hljs-number">22</span>;</code></pre></li><li><p>select子句中的子查询：即子查询的位置位于select之后；基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段名,(<span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">WHERE</span> 条件)<span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span> 条件如：<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">name</span>,age <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> =teacher_id)<span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> score &gt; <span class="hljs-number">60</span>;</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-3-单行函数"><a href="#NO3-3-单行函数" class="headerlink" title="NO3.3 单行函数"></a>NO3.3 单行函数</h3><p>Oracle的单行函数是指：对于每一行数据进行计算后得到一行输出结果。Oracle的单行函数根据数据类型分为字符函数、数字函数、日期函数、转换函数，另外还有一些通用函数。<strong><code>注意：所有的单行函数可以在SQL语句的任意位置上出现。</code></strong></p><ul><li><p>字符函数：主要指参数类型是字符型，不同函数返回值可能是字符型或数值型。字符函数可以分为：</p><ul><li><p>大小写控制函数；<strong><code>注意：dual表：SQL标准中要求，必须编写的是完整的SQL语句，为了可以方便的使用函数验证，我们就会使用dual这张虚拟表。</code></strong></p><p>  <img src="./Image-o17.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：这就是dual表的内容，其实没啥内容，就是为了让我们方便调试函数使用的。</code></p><ul><li><p><code>LOWER(列名/表达式)</code>：将大写或大小写混合的字符串转换成小写。<code>如，SELECT LOWER(&#39;SQL Course&#39;) FROM dual，结果为sql course</code>；</p></li><li><p><code>UPPER(列名/表达式)</code>：将小写或大小写混合的字符串转换成大写。<code>如，SELECT UPPER(&#39;SQL  Course)  FROM dual，结果为SQL COURSE</code>；</p></li><li><p><code>INITCAP(列名/表达式)</code>：将每一个单词的第一个字母转换成大写，其余的字母都转换成小写。<code>如，SELECT INITCAP(&#39;SQL Course&#39;)  FROM dual，结果为Sql Course</code>。<strong><code>注意：该函数中的参数，如果每个单词都各自有空格，则视为多个单词，否则就只视为一个单词。</code></strong></p><p><img src="./Image-o18.png" srcset="/img/loading.gif" alt=""></p></li></ul></li><li><p>字符控制函数：</p><ul><li><code>concat(参数1，参数2)</code>：连接两个值，等同于<code>||</code>。<code>如，SELECT CONCAT(&#39;Good&#39;,&#39;String&#39;) FROM dual，结果为GoodString</code>；<ul><li>如果要进行多个参数进行拼接：使用<code>||</code>，格式为：<code>SELECT  参数1||参数2||参数3 FROM dual</code>，推荐使用这种，方便又快捷。还可以使用格式为：<code>SELECT CONCAT(CONCAT(&#39;参数1&#39;,&#39;参数2&#39;),&#39;参数3&#39;) FROM dual</code>，但是该方式比较麻烦。</li></ul></li><li><code>substr(参数1,start,len)</code>：返回参数1中，从第start位开始，长度为len的子串。<code>如，SELECT SUBSTR(&#39;String&#39;,1,3) FROM dual，结果为Str</code>；<strong><code>注意：这里面的字符串索引是从1开始，即&#39;abc&#39;的索引，分别是1、2、3，而不是0、1、2。</code></strong><ul><li>如果len省略，则取从第start位开始的所有字符；</li><li>如果start是负值，表示从参数1的后面第abs(start)位开始，也就是取start的绝对值，然后向右取长度为len的子串。</li></ul></li><li><code>length(参数)</code>：取字符串的长度。<code>如，SELECT LENGTH(&#39;String&#39;) FROM dual，结果为6</code>；</li><li><code>instr(参数1,参数2,start,where)</code>：从start位置开始，返回参数2在参数1中第where次出现的位置。一般start和where都不写，因为默认值都为1。<code>如，SELECT INSTR(&#39;String&#39;,r,) FROM dual，结果为3</code>；</li><li><code>lpad/rpad(参数1,len,参数2)</code>：表示填充len个参数2到参数1的左边或右边。<code>如，SELECT LPAD(sal,6,*) FROM dual，结果为******5000、SELECT RPAD(sal,6,*) FROM dual，结果为5000******</code>；</li><li><code>trim(参数1 From 参数2)</code>：从参数2中去掉所有的参数1。<code>如，SELECT TRIM(&#39;S&#39; From &#39;SSSHHHLLL&#39;) FROM dual，结果为HHHLLL</code>；</li><li><code>replace(参数1,参数2,参数3)</code>：将参数1中的参数2用参数3替换。<code>如，SELECT RPPLACE(&#39;Sring&#39;,&#39;rin&#39;,&#39;&#39;) FROM dual，结果为Sg</code>。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>数字函数：<ul><li><code>ROUND(参数，n)</code>：将参数所表示的数值四舍五入，但保留小数点后的第n位；不指定n的话，一般对整数部分四舍五入，即舍弃所有的小数部分。<code>如，SELECT ROUND(45.926,2) FROM dual，结果为45.93、ROUND(45.926)，结果为46</code>；</li><li><code>TRUNC(参数，n)</code>：将参数所表示的数值截取到小数点后的第n位；不指定n的话，一般对整数部分进行截取，即舍弃所有的小数部分。<code>如，SELECT TRUNC(45.926,2) FROM dual，结果为45.92、TRUNC(45.926)，结果为45</code>；</li><li><code>MOD(m，n)</code>：取m除以n后得到的余数。<code>如，SELECT MOD(1600,300) FROM dual，结果为100</code>。</li></ul></li></ul><p>&nbsp;</p><ul><li><p>日期函数；<strong><code>注意：日期格式：世纪CC，年YY，月MM，日DD，小时(24)HH，分MI，秒SS。</code></strong></p><ul><li><p><code>SYSDATE</code>：返回系统日期。如，SELECT SYSDATE FROM dual，结果为2020/6/1 星期一 21:40:27；</p></li><li><p><code>MONTHS_BETWEEN(日期1，日期2)</code>：返回两个日期类型之间相隔的自然月数。一般要计算的两个天数尽量都相同；</p><p>  <img src="./Image-o19.png" srcset="/img/loading.gif" alt=""></p></li><li><p><code>ADD_MONTHS(日期,+/-的月数)</code>：返回指定日期加上指定月数后的日期。如，SELECT add_months(SYSDATE,2)  FROM dual，结果为2020/8/1 星期六 21:37:03；</p></li><li><p><code>NEXT_DAY(日期,星期数/数字1~7)</code>：从指定日期开始，返回下一个指定的星期数的日期。星期数可以使用字符串或者数字，1代表星期日，7代表星期六。</p><p>  <img src="./Image-o20.png" srcset="/img/loading.gif" alt=""></p></li><li><p>LAST_DAY(日期)：返回指定日期当月最后一天的日期；</p><p>  <img src="./Image-o21.png" srcset="/img/loading.gif" alt=""></p></li><li><p><code>ROUND(date [&#39;fmt&#39;])</code>：将date按照fmt指定的格式进行四舍五入，fmt为可选项，如果没有指定fmt。默认为保留年月日，将date四舍五入最近的一天；</p><ul><li><p>对年份进行四舍五入，则看月份是否超过6月，即1<del>6月份的话年份就保持不变，7</del>12月份的话年份就加1；</p><p>  <img src="./Image-o22.png" srcset="/img/loading.gif" alt=""></p></li><li><p>对月份进行四舍五入，则看天数份是否超过15，即1<del>15日的话月份就保持不变，16</del>31日的话月份就加1；</p><p>  <img src="./Image-o23.png" srcset="/img/loading.gif" alt=""></p></li><li><p>对天数进行四舍五入，则看当天星期数是否了超过星期三，即星期一到星期三的话就定位到最近的星期日，即上个星期日，因为距离最近；星期四到星期日的话也定位到最近的星期日，即下个星期日；如果当天是星期日的话，那么最近的星期日就是当天了。</p><p>  <img src="./Image-o24.png" srcset="/img/loading.gif" alt=""></p></li></ul></li><li><p><code>TRUNC(date [&#39;fmt&#39;])</code>：将date按照fmt中指定的格式进行截断，fmt为可选项，如果没有指定fmt，默认保留年月日，并将date截断为最近的一天；</p><p>  <img src="./Image-o25.png" srcset="/img/loading.gif" alt=""></p></li><li><p><code>EXTRACT(年/月/日, DATE 日期)</code>：返回日期数据类型中的年份，月份或者日。</p><p>  <img src="./Image-o26.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>转换函数：通常是在字符类型、日期类型、数值类型之间进行显示转换。主要有3个显示转换函数：</p><ul><li><p><code>TO_CHAR()</code>：即将参数转成字符串。该函数又分为两种：</p><ul><li><p>将数字转成字符串：格式：<code>TO_CHAR(number,&#39;fmt&#39;)</code>。其中fmt中可以写入的内容有：</p><ul><li><p><code>9</code>：即一个9表示一位数字；</p></li><li><p><code>0</code>：即前导0，其实就是在字符串指定位置里面添加0；</p></li><li><p><code>$</code>：即美元符号；</p></li><li><p><code>L</code>：即本地货币符号，和$不能同时使用；</p></li><li><p><code>.</code>：即小数点；</p></li><li><p><code>,</code>：即千位符，其实就是每三位一个“,”的意思。</p><p>  <img src="./Image-o27.png" srcset="/img/loading.gif" alt=""></p></li></ul></li><li><p>将日期转成字符串：格式：<code>TO_CHAR(date,&#39;fmt&#39;)</code>。其中fmt中可以写入的内容有：</p><ul><li><p><code>YYYY/yyyy</code>：完整的年份数字表示；</p></li><li><p><code>MM/mm</code>：用两位数字来表示月份；</p></li><li><p><code>DD/dd</code>：天数；</p></li><li><p><code>DAY/day</code>：星期几。</p><p>  <img src="./Image-o28.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul></li><li><p><code>TO_NUMBER</code>：将一个字符串转成数值型数据；格式：<code>TO_NUMBER(数值型字符串,&#39;fmt&#39;)</code>；其中fmt中可以写入的内容有：</p><ul><li><p><code>9</code>：即一个9表示一位数字；</p></li><li><p><code>0</code>：即前导0，其实就是在字符串指定位置里面添加0；</p></li><li><p><code>$</code>：即美元符号；</p></li><li><p><code>L</code>：即本地货币符号，和$不能同时使用；</p></li><li><p><code>.</code>：即小数点；</p></li><li><p><code>,</code>：即千位符，其实就是每三位一个“,”的意思。</p><p>  <img src="./Image-o29.png" srcset="/img/loading.gif" alt=""></p></li></ul></li><li><p><code>TO_DATE</code>：将字符串转成日期；格式：<code>TO_DATE(日期字符串,&#39;fmt&#39;)</code>。</p><p>  <img src="./Image-o30.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>其他通用函数：</p><ul><li><p>NVL函数：空值处理函数；格式：<code>NVL(参数1,参数2)，表示如果参数1不是null，返回参数1，是null就返回参数2</code>；</p><p>  <img src="./Image-o31.png" srcset="/img/loading.gif" alt=""></p></li><li><p>NVL2函数：空值处理函数2；格式：<code>NVL(参数1,参数2,参数3)，表示如果参数1不是null，返回参数2，是null就返回参数3</code>；</p><p>  <img src="./Image-o32.png" srcset="/img/loading.gif" alt=""></p></li><li><p>DECODE函数：按条件取值函数；格式：<code>DECODE (字段或表达式,条件1,结果1,条件2,结果2....[默认值])，表示如果表达式满足条件1，则取结果1；满足条件2，则取结果2....，意思就是按符合的条件进行取值，当所以条件都不符合时，有默认值就取默认值，没有默认值则返回空</code>。</p><p>  <img src="./Image-o33.png" srcset="/img/loading.gif" alt=""></p></li><li><p>CASE..WHEN..THEN函数：也是按条件取值的函数；与DECODE函数效果相同，只是写法换成了CASE..WHEN..THEN；格式：<code>CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2....ELSE 结果，当都不符合的时候，则返回else中的结果或者Null(当没有设置ELSE，且都不匹配时才会返回Null)</code>。</p><p>  <img src="./Image-o34.png" srcset="/img/loading.gif" alt=""></p></li><li><p>NULLIF(参数1,参数2)函数：比较两个参数，相等返回Null，不相等就返回参数1。</p><p>  <img src="./Image-o35.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul><ul><li><p>分析函数：根据一组行来计算聚合值，用于计算完成聚集的累计排名、移动平均数等，分析函数为每组记录返回多个行。分析函数带有一个开窗函数over()，包含三个分析子句：分组(partition by)，排序(order by)，窗口(rows)，它们的使用形式如下：over(partition by xxx或order by yyy rows或between zzz)。常用的分析函数有：</p><ul><li><p><code>RANK()</code>：具有相等值的行，其排位相同，排位的序号随记录条数跳跃。</p><p>  <img src="./Image-o36.png" srcset="/img/loading.gif" alt=""></p></li><li><p><code>DENSE_RANK()</code>：具有相等值的行，其排位相同，排位的序号按顺序跳跃。</p><p>  <img src="./Image-o37.png" srcset="/img/loading.gif" alt=""></p></li><li><p><code>ROW_NUMBER()</code>：不论值是否相等，其排位按顺序排序。这个不常用。</p><p>  <img src="./Image-o38.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>集合运算：集合运算是用来把两个或多个查询的结果集做并、交、查的集合运算。包括：</p><ul><li><p><code>union/union all</code>：即并集运算，union会自动将查询出的结果进行去重，union all则不会对查询结果进行去重；格式：<code>SQL语句1 union/union all SQL语句2....</code>；</p><p>  <img src="./Image-o39.png" srcset="/img/loading.gif" alt=""></p></li><li><p>intersect：即交集运算，将多个查询中都拥有的记录取出。格式：SQL语句1  intersect SQL语句2….；</p></li><li><p>minus：即差集运算，将那些属于第一个查询中的而不在第二个查询中的行记录取出，简单说，AB两个查询，A-B就是查找那些属于A但不属于B的记录；而B-A则查找那些属于B但不属于A的记录。格式：SQL语句1 minusSQL语句2….。</p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson4-Oracle对象"><a href="#Lesson4-Oracle对象" class="headerlink" title="Lesson4 Oracle对象"></a>Lesson4 Oracle对象</h2><h3 id="NO4-1-视图"><a href="#NO4-1-视图" class="headerlink" title="NO4.1 视图"></a>NO4.1 视图</h3><p>视图(view)，简单讲视图就是SELECT语句生成的一张虚表，也就是说，使用SELECT语句得到查询结果后，将结果做成了一个不存在的表，我们就称这个东西为视图。视图是基于一个表或多个表或视图的逻辑表，本身不包含数据，通过它可以对表里面的数据进行查询和修改。视图基于的表称为基表。视图是存储在数据字典里的一条select语句。 通过创建视图可以提取数据的逻辑上的集合或组合。</p><ul><li><p>视图：</p><ul><li><p>定义：其实就是通过SQL语句生成的一张虚表；</p></li><li><p>优点：</p><ul><li>简化对数据库的访问，因为视图可以有选择性的选取数据库里的一部分；</li><li>用户通过简单的查询可以从复杂查询中得到结果；</li><li>维护数据的独立性，视图可从多个表检索数据；</li><li>对于相同的数据可产生不同的视图。</li></ul></li><li><p>创建视图：</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">or</span> <span class="hljs-keyword">replace</span>] [<span class="hljs-keyword">force</span>或noforce] <span class="hljs-keyword">VIEW</span> 视图名[column1, column2,...]<span class="hljs-keyword">AS</span><span class="hljs-keyword">SQL</span>查询语句[<span class="hljs-keyword">with</span> <span class="hljs-keyword">check</span> <span class="hljs-keyword">option</span>] [<span class="hljs-keyword">constraint</span> constraint_name][<span class="hljs-keyword">with</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">only</span>];说明：一、OR <span class="hljs-keyword">REPLACE</span>：如果视图已经存在，则替换旧视图；二、<span class="hljs-keyword">FORCE</span>：即使基表不存在，也可以创建该视图，但是该视图不能正常使用，当基表创建成功后，视图才能正常使用；三、NOFORCE：如果基表不存在，无法创建视图，该项是默认选项；四、column1：为视图产生的列定义的别名；五、<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">READ</span> <span class="hljs-keyword">ONLY</span>：默认可以通过视图对基表执行增删改操作，但是有很多在基表上的限制(比如：基表中某列不能为空，但是该列没有出现在视图中，则不能通过视图执行<span class="hljs-keyword">insert</span>操作)，<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">READ</span> <span class="hljs-keyword">ONLY</span>说明视图是只读视图，不能通过该视图进行增删改操作。现实开发中，基本上不通过视图对表中的数据进行增删改操作；*六、<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">CHECK</span> <span class="hljs-keyword">OPTION</span> ：插入或修改的数据行必须满足视图定义的约束，也就是生成视图的条件。如，条件是取大于<span class="hljs-keyword">id</span>大于<span class="hljs-number">5</span>的记录，你将<span class="hljs-keyword">id</span>改成<span class="hljs-number">3</span>，那么这个修改是会报异常的，因为不符合视图的定义条件，必须要大于<span class="hljs-number">5</span>才行。        例如：//创建一个简单的视图，简单视图是指视图中的语句只是单表查询，没有聚合函数，我们就称为简单视图<span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> view_student<span class="hljs-keyword">as</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student//<span class="hljs-comment">-----------------------------------</span>//创建一个带<span class="hljs-keyword">with</span> <span class="hljs-keyword">check</span> <span class="hljs-keyword">option</span>约束的视图<span class="hljs-keyword">create</span>  <span class="hljs-keyword">or</span> <span class="hljs-keyword">replace</span>  <span class="hljs-keyword">view</span> view_student   //<span class="hljs-keyword">or</span> <span class="hljs-keyword">replace</span>表示如果视图已存在，则会覆盖这个视图<span class="hljs-keyword">as</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> &gt; <span class="hljs-number">10</span>  //视图的定义条件为取<span class="hljs-keyword">id</span>&gt;<span class="hljs-number">10</span>的记录<span class="hljs-keyword">with</span> <span class="hljs-keyword">check</span> <span class="hljs-keyword">option</span><span class="hljs-keyword">update</span> <span class="hljs-keyword">from</span> view_student <span class="hljs-keyword">set</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">5</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">'dyf'</span>   //名称为<span class="hljs-string">"dyf"</span>的记录符合<span class="hljs-keyword">id</span>&gt;<span class="hljs-number">10</span>，但是现在我要修改这条记录的<span class="hljs-keyword">id</span>，让它等于<span class="hljs-number">5</span>，那么这就不符合视图的约束了，因为视图生成的条件是<span class="hljs-keyword">id</span>&gt;<span class="hljs-number">10</span>，所以只需该语句会报异常//<span class="hljs-comment">----------------------------------------</span>//创建一个带<span class="hljs-keyword">with</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">only</span>约束的视图<span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">replace</span> <span class="hljs-keyword">view</span> view_student<span class="hljs-keyword">as</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> &lt; <span class="hljs-number">25</span><span class="hljs-keyword">with</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">only</span>  //添加了这个约束的视图，只能查看，不能修改//<span class="hljs-comment">----------------------------------------</span>//创建一个带<span class="hljs-keyword">force</span>的视图<span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">replace</span>  <span class="hljs-keyword">force</span>  <span class="hljs-keyword">view</span> view_student   //添加了<span class="hljs-keyword">force</span>后，没有teacher这张表也可以创建视图；默认是noforce，即没有基表就无法创建视图<span class="hljs-keyword">as</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> teacher//=========================================//创建一个复杂视图，即创建视图的<span class="hljs-keyword">SELECT</span>语句中有聚合函数或多表查询<span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">replace</span> <span class="hljs-keyword">view</span> view_teacher<span class="hljs-keyword">as</span><span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>,age <span class="hljs-keyword">from</span> student s <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> teacher t <span class="hljs-keyword">on</span> s.teacher_id = t.id注意：复杂视图中，如果要修改值，要求这个被修改的值必须是键保留表中的字段(所谓键保留表就是视图中是主键的那一列所在的表)，也就是说，视图*中的主键属于哪个表，那么你想要修改的字段也必须在这个表中，否则就不允许修改值。但是视图语句中含有聚合函数列、<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>子句、含有<span class="hljs-keyword">distinct</span>关键字、含有伪列、含有由计算表达式定义的列，都不允许修改视图。</code></pre></li></ul></li><li><p>删除视图：</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> 视图名;s如：<span class="hljs-keyword">drop</span> <span class="hljs-keyword">view</span> student;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO4-2-物化视图"><a href="#NO4-2-物化视图" class="headerlink" title="NO4.2 物化视图"></a>NO4.2 物化视图</h3><p>简单讲，物化视图就是将视图真正的变成一张物理存在的表。</p><ul><li><p>物化视图：</p><ul><li><p>定义：物化视图是存储了查询结果的本地副本，可以查询表、视图和其他物化视图；</p></li><li><p>基本语法格式：</p><ul><li><p>创建：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">MATERIALIZED</span> <span class="hljs-keyword">VIEW</span> 视图名[<span class="hljs-keyword">BUILD</span> <span class="hljs-keyword">IMMEDIATE</span> | <span class="hljs-keyword">BUILD</span> <span class="hljs-keyword">DEFERRED</span> ]<span class="hljs-keyword">REFRESH</span> [<span class="hljs-keyword">FAST</span>|<span class="hljs-keyword">COMPLETE</span>|<span class="hljs-keyword">FORCE</span>] [<span class="hljs-keyword">on</span> [<span class="hljs-keyword">commit</span>|<span class="hljs-keyword">demand</span>] | <span class="hljs-keyword">start</span> <span class="hljs-keyword">with</span> (start_time) <span class="hljs-keyword">next</span> (next_time)]<span class="hljs-keyword">AS</span> <span class="hljs-keyword">SQL</span>语句;说明：一、视图创建时，是否立马生成数据：     1.BUILD IMMEDIATE：是指在创建物化视图的时候就生成数据；默认为BUILD IMMEDIATE。    2.BUILD DEFERRED：则是指在创建物化视图时不生成数据，以后根据需要在生成数据。二、REFRESH表示物化视图的刷新机制：    1.快速刷新(FAST)： 采用增量刷新的机制，只将自上次刷新以后对基表进行的所有操作刷新到物化视图中去。FAST必须创建基于主表的视图日志。对于增量刷新选项，如果在子查询中存在分析函数，则物化视图不起作用；    2.完全刷新(COMPLETE)： 会删除表中所有的记录(如果是单表刷新，可能会采用<span class="hljs-keyword">TRUNCATE</span>的方式)，然后根据物化视图中查询语句的定义重新生成物化视图；    <span class="hljs-number">3.</span><span class="hljs-keyword">FORCE</span>方式： 这是默认的数据刷新方式。<span class="hljs-keyword">Oracle</span>会自动判断是否满足快速刷新的条件，如果满足则进行快速刷新，否则进行完全刷新。三、物化视图有两种刷新模式：    <span class="hljs-number">1.</span><span class="hljs-keyword">on</span> <span class="hljs-keyword">commit</span>：提交触发，一旦基表有了<span class="hljs-keyword">commit</span>，即事务提交，则立刻刷新，立刻更新物化视图，使得数据和基表一致。一般用这种方法在操作基表时速度会比较慢；    <span class="hljs-number">2.</span><span class="hljs-keyword">on</span> <span class="hljs-keyword">demand</span>：仅在该物化视图“需要”被刷新了，才进行刷新(<span class="hljs-keyword">REFRESH</span>)，即“需要”更新物化视图操作时才更新，以保证和基表数据的一致性。这种方式也叫手动刷新。如果没有设置刷新模式，则这个选项是默认。//<span class="hljs-comment">---------------------------------------------</span>//创建默认选项的物化视图，即物化视图生成时立即生成数据、<span class="hljs-keyword">force</span>方式刷新数据、<span class="hljs-keyword">on</span> <span class="hljs-keyword">demand</span>刷新如：<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">MATERIALIZED</span> <span class="hljs-keyword">VIEW</span> mv_st<span class="hljs-keyword">AS</span><span class="hljs-keyword">SELECT</span> s.ID,s.NAME s_name,s.sex s_sex,s.t_id,t.name  t_name,t.sex t_sex<span class="hljs-keyword">FROM</span> student s<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> teacher t<span class="hljs-keyword">ON</span> s.t_id = t.id;//创建自动刷新数据的物化视图，即物化视图生成时立即生成数据、force方式刷新数据、on <span class="hljs-keyword">commit</span>刷新如：<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">MATERIALIZED</span> <span class="hljs-keyword">VIEW</span> mv_st<span class="hljs-keyword">REFRESH</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">COMMIT</span><span class="hljs-keyword">AS</span><span class="hljs-keyword">SELECT</span> s.ID,s.NAME s_name,s.sex s_sex,s.t_id,t.name  t_name,t.sex t_sex<span class="hljs-keyword">FROM</span> student s<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> teacher t<span class="hljs-keyword">ON</span> s.t_id = t.id;注意：但是我的Oracle 11g 无论如何使用该方式创建自动刷新的物化视图，都不行，不知道是不是没有创建物化视图日志的原因，所以一直创建不成功//创建不生成数据的的物化视图，即物化视图生成时不会立即生成数据、force方式刷新数据、on <span class="hljs-keyword">commit</span>刷新如：<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">MATERIALIZED</span> <span class="hljs-keyword">VIEW</span> mv_st<span class="hljs-keyword">BUILD</span> <span class="hljs-keyword">DEFERRED</span> <span class="hljs-keyword">REFRESH</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">COMMIT</span><span class="hljs-keyword">AS</span><span class="hljs-keyword">SELECT</span> s.ID,s.NAME s_name,s.sex s_sex,s.t_id,t.name  t_name,t.sex t_sex<span class="hljs-keyword">FROM</span> student s<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> teacher t<span class="hljs-keyword">ON</span> s.t_id = t.id;注意：使用该方式创建物化视图时，必须使用begin....end方式，手动刷新物化视图。</code></pre></li><li><p>删除：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> METERIALIZED <span class="hljs-keyword">VIEW</span> view_name;</code></pre></li><li><p>手动刷新物化视图：</p><ul><li><p>方式一：使用SQL窗口写入；</p>  <pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>  dbms_mview.refresh(<span class="hljs-string">'物化视图名称'</span>);<span class="hljs-keyword">END</span>;注意：还可以*使用dbms_mview.refresh('物化视图名称','c')，来刷新物化视图，其中第一个参数表示要刷新的视图名称，第二个参数则表示使用完全刷新。</code></pre></li><li><p>方式二：使用plsql的命令窗口输入。</p><pre><code class="hljs sql">exec dbms_mview.refresh('物化视图名称');</code></pre></li></ul></li><li><p>建立基表的物化视图日志：作用是当基表发生增删改操作数，会记录到该日志中，然后物化视图根据该日志进行更新；</p>  <pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">materialized</span> <span class="hljs-keyword">view</span> <span class="hljs-keyword">log</span> <span class="hljs-keyword">on</span> 表名 <span class="hljs-keyword">with</span> [primary <span class="hljs-keyword">key</span>|<span class="hljs-keyword">rowid</span>] [<span class="hljs-keyword">sequence</span> (AREA_NM_R, AREA_NM_N) <span class="hljs-keyword">including</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">values</span>];如：<span class="hljs-keyword">create</span> <span class="hljs-keyword">materialized</span> <span class="hljs-keyword">view</span> <span class="hljs-keyword">log</span> <span class="hljs-keyword">on</span> student <span class="hljs-keyword">with</span> <span class="hljs-keyword">rowid</span>说明：tablename为基表，<span class="hljs-keyword">with</span>后面可以接主键、<span class="hljs-keyword">rowid</span>，但是如果要使用这两个中的主键或<span class="hljs-keyword">rowid</span>列，那么生成物化视图中的列必须包含有主键或<span class="hljs-keyword">rowid</span>即可。注意：如果使用的是多表联查生成的物化视图，那么多表联查中涉及到的表都需要建立物化视图日志。</code></pre><p>  <img src="./Image-o40.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO4-3-序列"><a href="#NO4-3-序列" class="headerlink" title="NO4.3 序列"></a>NO4.3 序列</h3><p>Oracle中没有自动增长这个属性设置，但是有序列。</p><ul><li><p>序列(SEQUENCE)：</p><ul><li><p>定义：是序列号生成器，可以为表中的行自动生成序列号，产生一组等间隔的数值(类型为数字)。不占用磁盘空间，占用内存。</p></li><li><p>作用：生成表的主键值，可以在插入语句中引用，也可以通过查询来检查当前值，或使序列增至下一个值。</p></li><li><p>基本语法格式：</p><ul><li><p>创建序列：<strong><code>注意：创建序列需要CREATE SEQUENCE的系统权限。</code></strong></p>  <pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">SEQUENCE</span> 序列名[<span class="hljs-keyword">INCREMENT</span> <span class="hljs-keyword">BY</span> n][<span class="hljs-keyword">START</span> <span class="hljs-keyword">WITH</span> n][&#123;MAXVALUE/ <span class="hljs-keyword">MINVALUE</span> n| <span class="hljs-keyword">NOMAXVALUE</span>&#125;][&#123;<span class="hljs-keyword">CYCLE</span>|<span class="hljs-keyword">NOCYCLE</span>&#125;][&#123;<span class="hljs-keyword">CACHE</span> n| NOCACHE&#125;];说明：一、INCREMENT BY：用于定义序列的步长，如果省略，则默认为1；如果出现负值，则代表Oracle序列的值是按照此步长递减的；二、<span class="hljs-keyword">START</span> <span class="hljs-keyword">WITH</span>：定义序列的初始值(即产生的第一个值)，默认为<span class="hljs-number">1</span>；即自定义开始值从多少开始；三、MAXVALUE：定义序列生成器能产生的最大值。选项<span class="hljs-keyword">NOMAXVALUE</span>是默认选项，代表没有最大值定义，这时对于递增序列，系统能够产生的最大值是<span class="hljs-number">10</span>的<span class="hljs-number">27</span>次方；对于递减序列，最大值是<span class="hljs-number">-1</span>；四、<span class="hljs-keyword">MINVALUE</span>：定义序列生成器能产生的最小值。选项<span class="hljs-keyword">NOMINVALUE</span>是默认选项，代表没有最小值定义，这时对于递减序列，系统能够产生的最小值是<span class="hljs-number">10</span>的<span class="hljs-number">26</span>次方；对于递增序列，最小值是<span class="hljs-number">1</span>；五、<span class="hljs-keyword">CYCLE</span>和<span class="hljs-keyword">NOCYCLE</span>：表示当序列生成器的值达到限制值后是否循环。<span class="hljs-keyword">CYCLE</span>代表循环，<span class="hljs-keyword">NOCYCLE</span>代表不循环。如果循环，则当递增序列达到最大值时，循环到最小值；对于递减序列达到最小值时，循环到最大值。如果不循环，达到限制值后，继续产生新值就会发生错误；六、<span class="hljs-keyword">CACHE</span>(缓存)：定义存放序列的内存块的大小，默认为<span class="hljs-number">20</span>。NOCACHE表示不对序列进行内存缓冲。对序列进行内存缓冲，可以改善序列的性能；注意：大量语句发送请求去申请序列时，为了避免序列在运用层实现序列而引起的性能瓶颈。<span class="hljs-keyword">Oracle</span>序列允许将序列提前生成<span class="hljs-keyword">cache</span> x个先存入内存，在发生大量申请序列语句时，可直接到运行最快的内存中去得到序列。但<span class="hljs-keyword">cache</span>个数也不能设置太大，因为在数据库重启时，会清空内存信息，预存在内存中的序列会丢失，当数据库再次启动后，序列从上次内存中最大的序列号+<span class="hljs-number">1</span> 开始存入<span class="hljs-keyword">cache</span> x个。这种情况也会在数据库关闭时也会导致序号不连续。七、<span class="hljs-keyword">NEXTVAL</span>：返回序列中下一个有效的值，任何用户都可以引用；八、CURRVAL：即序列的当前值，<span class="hljs-keyword">NEXTVAL</span>应在CURRVAL之前指定 ，二者应同时有效。如：<span class="hljs-keyword">create</span> <span class="hljs-keyword">sequence</span> aa<span class="hljs-keyword">increment</span> <span class="hljs-keyword">by</span> <span class="hljs-number">2</span><span class="hljs-keyword">start</span> <span class="hljs-keyword">with</span> <span class="hljs-number">5</span></code></pre></li><li><p>修改序列：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> SEQUENC 序列名 ....注意：不允许修改序列的初始值。改变序列的初始值只能通过删除序列之后重建序列的方法实现。如：<span class="hljs-keyword">alter</span> <span class="hljs-keyword">sequence</span> seq_test maxvalue <span class="hljs-keyword">cycle</span>;</code></pre></li><li><p>删除序列：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">sequence</span> 序列名如：<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">SEQUENCE</span> seq_test;<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">sequence</span> seq_test;</code></pre></li><li><p>如果要查看当前序列的值，使用：</p>  <pre><code class="hljs sql">序列名.currval如：<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">SEQUENCE</span> seq_test;<span class="hljs-keyword">SELECT</span> seq_test.nextval <span class="hljs-keyword">FROM</span> dual;  //刚创建完序列后，必须先使用nextval才能使用currval，因为刚创建完的序列，里面是没有值的<span class="hljs-keyword">SELECT</span> seq_test.currval <span class="hljs-keyword">FROM</span> dual;  //会报错注意：默认创建序列时使用currval将报错，需要先使用nextval才可以使用currval。</code></pre><ul><li><p>如果要查看下一个序列的值，使用：</p>  <pre><code class="hljs sql">序列名.nextval如：<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">SEQUENCE</span> seq_test;<span class="hljs-keyword">SELECT</span> seq_test.nextval <span class="hljs-keyword">FROM</span> dual;</code></pre></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO4-4-同义词"><a href="#NO4-4-同义词" class="headerlink" title="NO4.4 同义词"></a>NO4.4 同义词</h3><p>所谓的同义词，就是为Oracle的对象取别名，Oracle的对象有：表、索引、视图(包括物化视图)、存储过程、函数、触发器等等。</p><ul><li><p>同义词：</p><ul><li><p>定义：就是为Oracle的对象取别名。</p></li><li><p>基本语法格式：</p><ul><li><p>创建：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">public</span>] <span class="hljs-keyword">SYNONYM</span> 同义词别名 <span class="hljs-keyword">for</span> 数据库对象;说明：一、public：表示创建的这个别名，是否是私有的，即是否只能为当前用户所使用；如果为public，那么所有用户都可以使用，否则就只能为创建的用户所使用。拓展：varchar就是varchar2的同义词，即别名。如：<span class="hljs-keyword">create</span> <span class="hljs-keyword">synonym</span> st <span class="hljs-keyword">for</span> student;<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span> <span class="hljs-keyword">from</span> st;  //其实就等同于<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span> <span class="hljs-keyword">from</span> student，且st这个同义词只能被当前用户所使用，如果别的用户想要使用的话，首先要有调用用户的权限，然后使用“用户.同义词”可以访问到指定的同义词</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO4-5-索引"><a href="#NO4-5-索引" class="headerlink" title="NO4.5 索引"></a>NO4.5 索引</h3><p>索引就相当于书的目录，根据目录查找到自己想要查询的数据。如果要在表中查询指定的记录，在没有索引的情况下，必须遍历整个表，而有了索引之后，只需要在索引中找到符合查询条件的索引字段值，就可以通过保存在索引中的ROWID快速找到表中对应的记录。</p><ul><li><p>索引：</p><ul><li><p>定义：简单讲，就是为了能够快速定位要查询的数据而创建并使用的一个Oracle对象。</p></li><li><p>Oralce中的索引类型：<strong><code>注意：对于查询密集的系统中，创建足够多的索引会起到帮助；而对于事务处理系统中，通常尽量减少索引数量;主键和具有唯一性约束的列都会自动创建索引。</code></strong></p><ul><li>B*索引：是一个树结构，树的根节点指向第二级别的多个节点，第二级别的节点又指向第三级别的多个节点，以此类推；常用于列值多、行多、有where子句或join子句的表中；</li><li>位图索引：用于应对列值较少，但表的行数很大的这种场景。</li></ul></li><li><p>基本语法格式：</p><ul><li><p>创建索引：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span> | <span class="hljs-keyword">BITMAP</span>] <span class="hljs-keyword">INDEX</span>  索引名 <span class="hljs-keyword">ON</span>  表名(列名);另外还可以建立复合索引，即为多个列建立一个索引，也就是多个列放在一个索引上：<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span>  索引名 <span class="hljs-keyword">ON</span>  表名(列名<span class="hljs-number">1</span>，列名<span class="hljs-number">2</span>,....);说明：一、UNIQUE：表示建立了索引的列必须是唯一，即建立唯一索引时，会同时给该列加上一个唯一约束；二、BITMAP：表示建立一个位图索引。如：<span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> aa <span class="hljs-keyword">on</span> student(<span class="hljs-keyword">name</span>);</code></pre></li><li><p>删除索引：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> 索引名;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson5-PL-SQL编程"><a href="#Lesson5-PL-SQL编程" class="headerlink" title="Lesson5 PL/SQL编程"></a>Lesson5 PL/SQL编程</h2><h3 id="NO5-1-PL-SQL简介及基本语法"><a href="#NO5-1-PL-SQL简介及基本语法" class="headerlink" title="NO5.1 PL/SQL简介及基本语法"></a>NO5.1 PL/SQL简介及基本语法</h3><p>PL/SQL是由甲骨文公司在90年代初开发，以提高SQL的功能。</p><ul><li><p>PL/SQL：</p><ul><li><p>定义：简单讲就是一种程序语言，叫做过程化SQL语言。PL/SQL是Oracle数据库使用的三种语言的其中之一(另外两个是SQL和Java)，是对SQL语句的扩展：即在普通SQL语句的使用上增加了编程语言的特点(即把数据操作和查询语句组织在PL/SQL代码的过程性单元中)，通过逻辑判断、循环等操作实现复杂的功能或者计算的程序语言；</p></li><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">declare</span>     声明变量<span class="hljs-keyword">begin</span>    <span class="hljs-comment">-- 这里的“--”表示这是注释</span>    <span class="hljs-comment">/*</span><span class="hljs-comment">     * 这是多行注释</span><span class="hljs-comment">     */</span>    dbms_output.put_line(<span class="hljs-string">'信息是：'</span> || msg);  <span class="hljs-comment">--这是输出，和Java的System.out.println()一样，另外“||”是字符串连接符</span>    代码逻辑exception  <span class="hljs-comment">--这部分是异常处理模块，可有可无</span><span class="hljs-keyword">end</span>;注意：当不需要定义变量时，<span class="hljs-keyword">declare</span>可省略不写，只写<span class="hljs-keyword">begin</span>和<span class="hljs-keyword">end</span>。如：<span class="hljs-keyword">declare</span>    v_name <span class="hljs-built_in">varchar2</span>(<span class="hljs-number">40</span>);    v_age number(20);<span class="hljs-keyword">begin</span>    v_name:= <span class="hljs-string">'dyf'</span>;    v_age:=18;    dbms_output.put_line('name:'|| v_name || '<span class="hljs-comment">---' ||  'age:' || v_age);</span><span class="hljs-keyword">end</span>;</code></pre><ul><li><p>变量声明：</p><ul><li><p>方式一：</p>  <pre><code class="hljs sql">变量名 类型(长度);</code></pre></li><li><p>方式二：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 列名 <span class="hljs-keyword">INTO</span> 变量名 <span class="hljs-keyword">SQL</span>语句;如：v_max_id number ;<span class="hljs-keyword">select</span> <span class="hljs-keyword">max</span>(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">into</span> v_max_id <span class="hljs-keyword">from</span> student;</code></pre></li></ul></li><li><p>变量赋值：</p>  <pre><code class="hljs sql">变量名:=变量值;注意：Oracle中的“=”号是一个比较运算符，并不是用于赋值符号，赋值符号是“:=”。Oracle中的“=”相当于Java中的“==”，不要搞混淆了。</code></pre></li><li><p>属性类型变量：当为某个变量指定类型，且需要用到与数据库中的某一行或某一列的数据类型时，就使用属性类型。分为：</p><ul><li><p>引用型变量：</p>  <pre><code class="hljs sql">变量名 表名.列名%type  //这个就指定了该变量名的数据类型与表中的某个列的数据类型一致如：a student.age%type;  //变量a的数据类型岁student中age列的数据类型变化而变化</code></pre></li><li><p>记录型变量：</p>  <pre><code class="hljs sql">变量名 表名%rowtype  //这个就指定了该变量名的数据类型为表中的某一行(一行记录包括多个数据类型)如：a student%rowtype  //就把student表中的一行记录的所有列，都放入了变量a中，当需要哪个列就是要“.”获取即可。如，a.id、a.name等等</code></pre></li></ul></li><li><p>异常(或称为例外)：</p><ul><li><p>预定义(Predefined)错误：ORACLE预定义的异常情况大约有24个。对这种异常情况的处理，无需在程序中定义，由ORACLE自动将其引发；</p></li><li><p>用户定义(User_define)错误：程序执行过程中，出现编程人员认为的非正常情况。对这种异常情况的处理，需要用户在程序中定义，然后显式地在程序中将其引发。</p>  <pre><code class="hljs sql">//预定义异常exceptionwhen 异常名称 then异常处理逻辑如：<span class="hljs-keyword">declare</span>    ...<span class="hljs-keyword">begin</span>    ....<span class="hljs-keyword">exception</span>    <span class="hljs-keyword">when</span> no_data_found <span class="hljs-keyword">then</span>        dbms_output.putline(<span class="hljs-string">'没有找到您想要的数据'</span>);<span class="hljs-keyword">end</span>;//<span class="hljs-comment">---------------------------------------------------</span>//自定义异常<span class="hljs-keyword">declare</span>    自定义异常名称 <span class="hljs-keyword">exception</span>;exceptionwhen 自定义异常名称 then异常处理逻辑如：<span class="hljs-keyword">declare</span>    no_student_found <span class="hljs-keyword">exception</span>;<span class="hljs-keyword">begin</span>    ....<span class="hljs-keyword">exception</span>    <span class="hljs-keyword">when</span> no_student_found <span class="hljs-keyword">then</span>        dbms_output.putline(<span class="hljs-string">'没有在学生表中找到您想要的数据'</span>);<span class="hljs-keyword">end</span>;</code></pre></li></ul></li><li><p>条件判断：</p>  <pre><code class="hljs sql">IF 条件判断表达式 THEN    PL/SQL、SQL语句<span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;<span class="hljs-comment">--------------------------------</span>IF 条件判断表达式 THEN    PL/SQL、SQL语句ELSE    其它语句<span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;<span class="hljs-comment">-----------------------------------</span>IF 条件判断表达式 THEN    PL/SQL、SQL语句ELSIF 其它条件判断表达式 THEN    其它语句ELSE    其它语句<span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;</code></pre></li><li><p>循环：</p>  <pre><code class="hljs sql">//与<span class="hljs-keyword">do</span>-<span class="hljs-keyword">while</span>类似的循环<span class="hljs-keyword">LOOP</span>      要执行的语句;      EXIT WHEN 条件判断表达式  //条件满足，退出循环语句<span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;//<span class="hljs-comment">------------------------------</span>//while循环WHILE 条件判断表达式 LOOP    要执行的语句;<span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;//<span class="hljs-comment">---------------------------------</span>//for循环FOR 变量 IN [REVERSE] 下限 .. 上限 LOOP  要执行的语句;<span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;注意：每循环一次，循环变量自动加1；使用关键字REVERSE，循环变量自动减1；跟在IN REVERSE 后面的数字必须是从小到大的顺序，而且必须是整数，不能是变量或表达式；可以使用EXIT退出循环；“..”是范围运算符。如：<span class="hljs-keyword">BEGIN</span>    <span class="hljs-keyword">FOR</span> i <span class="hljs-keyword">IN</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span> <span class="hljs-keyword">LOOP</span>        dbms_output.put_line(i);    <span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;<span class="hljs-keyword">END</span>;</code></pre></li><li><p>游标：是存在于服务器端的一个存储区，这个区域提供给用户使用。在这个区域里存储的是用户通过一个查询语句得到的结果集，用户通过控制这个游标区域当中的指针 来提取游标中的数据，然后来进行操。基本语法格式：</p>  <pre><code class="hljs awk"><span class="hljs-regexp">//</span>不带参数的游标声明cursor 游标变量名 is 查询语句;注意：无论是带参数还是不带参数的游标，声明都写在declare中。<span class="hljs-regexp">//</span>使用不带参数的游标open 游标变量名;    loop        fetch 游标变量名 into 变量名;        <span class="hljs-keyword">exit</span> when 条件(常使用：游标变量名%notfound，这句表示如果游标中存储的结果集记录都获取完了，那么就会返回true，没有则返回false)        循环体(使用变量执行其他语句)    end loop;close 游标变量名;注意：游标属性：%NOTFOUND：如果FETCH语句失败，则该属性为<span class="hljs-string">"TRUE"</span>，否则为<span class="hljs-string">"FALSE"</span>;%FOUND：如果FETCH语句成果，则该属性为<span class="hljs-string">"TRUE"</span>，否则为<span class="hljs-string">"FALSE"</span>;%ROWCOUNT：返回游标当前行的行数;%ISOPEN：如果游标是开的则返回<span class="hljs-string">"TRUE"</span>，否则为<span class="hljs-string">"FALSE"</span>。如：declare    cursor c1 is select * from student;    e student%rowtype;  <span class="hljs-regexp">//</span>声明了一个记录型的变量begin    open c1;        loop            fetch c1 into e;            <span class="hljs-keyword">exit</span> when c1%notfound;            dbms_output.put_line(e.ename);        end loop;    close c1;end;<span class="hljs-regexp">//</span>--------------------------------------------<span class="hljs-regexp">//</span>带参数的游标声明cursor 游标变量名(参数名 数据类型...) is 查询语句(查询语句中语句的右值可以使用游标参数)；注意：这里的参数是给后面的SQL语句使用的，SQL语句通过这个动态的参数获取结果集后放入游标区域中。<span class="hljs-regexp">//</span>使用带参数的游标open 游标变量名（实参列表）;    loop        fetch 游标变量名 into 变量;        <span class="hljs-keyword">exit</span> loop 条件（常使用:游标变量名%notfound;）        循环体（使用变量执行其他语句）    end loop;close 游标变量名;如：declare    cursor stu(dno emp.deptno%type) is select name from student where id= id;    v_stu student%rowtype;begin    open stu(<span class="hljs-number">1</span>);        loop            fetch stu into v_stu;            <span class="hljs-keyword">exit</span> when stu%notfound;            update emp set sal = sal + <span class="hljs-number">10</span> where empno = eno;            commit;        end loop;    close stu;end;拓展：还可以使用<span class="hljs-keyword">for</span>循环，代码更加简洁<span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> stu(<span class="hljs-number">1</span>)loopdbms_output.put_line(var.);end loop;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO5-2-存储函数、存储过程、触发器的使用"><a href="#NO5-2-存储函数、存储过程、触发器的使用" class="headerlink" title="NO5.2 存储函数、存储过程、触发器的使用"></a>NO5.2 存储函数、存储过程、触发器的使用</h3><p>存储函数其实就是用户自定义的函数，与之类似的还有存储过程。</p><ul><li><p>存储函数：</p><ul><li><p>定义：即自定义函数，可以接收一个或多个参数；</p></li><li><p>基本语法结构：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">create</span> [<span class="hljs-keyword">or</span> <span class="hljs-keyword">replace</span>] <span class="hljs-keyword">function</span> 函数名(形参 参数类型...) <span class="hljs-keyword">return</span> 返回值类型<span class="hljs-keyword">is</span>    变量声明<span class="hljs-keyword">begin</span>    函数体    返回变量<span class="hljs-keyword">end</span>;说明：<span class="hljs-keyword">replace</span>：表示如果该函数存在则替换。注意：参数类型，只写类型，不写长度。如：<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">REPLACE</span> <span class="hljs-keyword">FUNCTION</span> getName(v_ID <span class="hljs-built_in">NUMBER</span>) <span class="hljs-keyword">RETURN</span>  <span class="hljs-built_in">VARCHAR2</span><span class="hljs-keyword">IS</span>       res <span class="hljs-built_in">VARCHAR2</span>(<span class="hljs-number">40</span>);<span class="hljs-keyword">BEGIN</span>       <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">NAME</span> <span class="hljs-keyword">INTO</span> res <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">ID</span> = v_id;       RETURN res;<span class="hljs-keyword">END</span>;<span class="hljs-keyword">SELECT</span> getname(<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> dual;  //调用存储函数</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>存储过程：</p><ul><li><p>定义：和存储函数差不多，就是提前编译好一段PL/SQL语言放置在数据库中，但是存储过程可以返回多个值；</p></li><li><p>基本语法结构：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">create</span> [<span class="hljs-keyword">or</span> <span class="hljs-keyword">replace</span>] <span class="hljs-keyword">procedure</span> 存储过程名(参数 参数类型....)<span class="hljs-keyword">is</span>/<span class="hljs-keyword">as</span><span class="hljs-keyword">begin</span>    业务逻辑<span class="hljs-keyword">end</span>;说明：参数有三种形式：即IN：表示该参数是传入的参数，不写的话，默认是这个；OUT：表示参数是用来接收返回的结果的；IN OUT：表示该参数既可以用来传入，也可以用来接收；如果要使用带传出参数的存储过程，那么只需要在参数列表中指定参数的类型前面加上out，并且在<span class="hljs-keyword">select</span>语句中将结果存入指定的参数名中，即<span class="hljs-keyword">select</span> .... <span class="hljs-keyword">into</span> 参数名 <span class="hljs-keyword">from</span> ....即可。调用无参存储过程：使用<span class="hljs-keyword">call</span> 存储过程名();调用无参存储过程：<span class="hljs-keyword">declare</span>    传出参数变量的定义 数据类型;<span class="hljs-keyword">begin</span>  存储过程名(....,传出参数变量名)<span class="hljs-keyword">end</span>;</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>触发器：</p><ul><li><p>定义：定义一个规则(其实就是一个存储过程)，在增删改操作时，只有满足规则，自动触发，无需调用；</p></li><li><p>分类：</p><ul><li>语句级触发器：不包含for each row，即只有一条执行语句，那么只执行一次；</li><li>行级触发器：包含for each row，即哪怕只有一条执行语句，但影响的行数很多，影响了多少行就触发多少次。</li></ul></li><li><p>基本语法结构：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">create</span> [<span class="hljs-keyword">or</span> <span class="hljs-keyword">replace</span>] <span class="hljs-keyword">trigger</span> 触发器名称<span class="hljs-keyword">before</span>|<span class="hljs-keyword">after</span><span class="hljs-keyword">insert</span>|<span class="hljs-keyword">update</span>|<span class="hljs-keyword">delete</span><span class="hljs-keyword">on</span> 表名[<span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">row</span>]<span class="hljs-keyword">declare</span>    ....<span class="hljs-keyword">begin</span>    ....<span class="hljs-keyword">end</span>；说明：一、<span class="hljs-keyword">before</span>或<span class="hljs-keyword">after</span>：表示在语句执行之前或之后触发触发器；二、<span class="hljs-keyword">insert</span>、<span class="hljs-keyword">update</span>、<span class="hljs-keyword">delete</span>：表示执行对应类型的语句时触发触发器；如果对多种语句设置触发器，使用<span class="hljs-keyword">or</span>连接。如<span class="hljs-keyword">insert</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">update</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">delete</span>；注意：<span class="hljs-keyword">update</span>中还可以指定更新某些列时，才触发触发器，只需要在<span class="hljs-keyword">update</span>后面加个<span class="hljs-keyword">of</span>，即<span class="hljs-keyword">update</span> <span class="hljs-keyword">of</span> 列名<span class="hljs-number">1</span>,列名<span class="hljs-number">2.</span>...。三、<span class="hljs-keyword">on</span>：表示对某个表建立触发器，即如果表被删除了，那么连同依附该表的触发器也会被删除；四、伪记录变量：就是在执行增删改的操作时，用来获取执行语句之前的记录或之后的记录，具体如下：                :<span class="hljs-keyword">old</span>                :<span class="hljs-keyword">new</span><span class="hljs-keyword">insert</span>    所有列的值都是<span class="hljs-literal">null</span>        将要插入的那些数据 <span class="hljs-keyword">update</span>    更新之前的值              更新之后的值<span class="hljs-keyword">delete</span>    删除之前的值              所有字段都是<span class="hljs-literal">null</span>注意：语句级触发器无法使用伪记录变量。</code></pre></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>3.대학교 삼 학년</category>
      
      <category>05.数据库系统原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大三课程</tag>
      
      <tag>Oracle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02.MySql--学习笔记</title>
    <link href="/2020/07/09/MySql--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/09/MySql--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="MySql–学习笔记-包含MySQL视频、MySQL必知必会书籍"><a href="#MySql–学习笔记-包含MySQL视频、MySQL必知必会书籍" class="headerlink" title="MySql–学习笔记(包含MySQL视频、MySQL必知必会书籍)"></a>MySql–学习笔记(包含MySQL视频、MySQL必知必会书籍)</h1><h2 id="Lesson1-MySQL概述"><a href="#Lesson1-MySQL概述" class="headerlink" title="Lesson1 MySQL概述"></a>Lesson1 MySQL概述</h2><h3 id="NO1-1-数据库和SQL"><a href="#NO1-1-数据库和SQL" class="headerlink" title="NO1.1 数据库和SQL"></a>NO1.1 数据库和SQL</h3><p>简单讲，数据库就是存储数据的；SQL则是用于操作关系型数据库的一门编程语言。</p><ul><li>数据库：即database(简称DB)，是一种存储数据的仓库。<ul><li>特点：<ul><li>数据库是根据数据结构组织、存储和管理数据；</li><li>数据库能够长期、高效的管理和存储数据；</li><li>数据库的目的就是能够存储(写)和提供(读)数据。</li></ul></li><li>早期按存储模型分类为：<ul><li>层次数据库：基于层次的数据结构(数据分层)；</li><li>网状数据库：基于网状的数据结构(数据网络)；</li><li>(目前最流行)关系数据库：基于关系模型的数据结构(二维表)。</li></ul></li><li>现在按存储介质分类：<ul><li>关系型数据库：基于关系模型的数据结构(二维表)通常存储在磁盘。关系型数据库系统(DBS)模型有四层结构：<ul><li>数据库管理系统(DBMS)：管理系统运行(DataBase Management System)；DBMS又分为两类：<ul><li>基于共享文件系统的DBMS(如，ACCESS)；</li><li>基于客户机-服务器的DBMS(如，MySQL、Oracle、SqlServer)。</li></ul></li><li>数据库(DB)：数据存储的管理者(小管理，受DBMS管理)；</li><li>数据表(Table)：数据关系管理者；</li><li>数据字段(Field)：依赖于数据表，实际数据存储者。</li></ul></li><li>非关系型数据库：没有具体模型的数据结构(键值对)通常存储在内存。因此非关系型数据库也称为NoSQL(Not only SQL)，意为不仅仅是关系型数据库。有以下特点：<ul><li>所有不是关系型数据库的统称，都叫NoSQL；</li><li>数据存储模型不是二维表，而是键值对(key-&gt;value)；</li><li>存储的位置通常是内存(效率高)；</li><li>不能永久性存储(需要定时存到关系型数据库中)；</li><li>常见的非关系型数据库产品：MongoDB、Redis、Memcached等等。</li></ul></li></ul></li><li>常用的关系型数据库产品：<ul><li>大型：Oracle、DB2等等；</li><li>中型：MySQL、SqlServer等等；</li><li>小型：Sybase、Access等等。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>SQL：Structured Query Language，即结构化查询语言，是一种针对关系型数据库特殊标准化的编程语言；另外几乎所有的DBMS都支持SQL。简单讲，SQL就是一种编程语言，用来实现用户数据库查询和程序设计的。SQL根据操作不同，分为几类：<ul><li>DQL：Data Query Language，数据查询语言，用于查询和检索数据；</li><li>DML：Data Manipulation Language，数据操作语言，用于数据的写操作(增删改)；</li><li>DDL：Data Definition Language，数据定义语言，用于创建数据结构；</li><li>DCL：Data Control Language，数据控制语言，用于用户权限管理；</li><li>TPL：Transaction Process Language，事务处理语言，辅助DML进行事务操作(因此也归属于DML)。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-2-MySQL简介"><a href="#NO1-2-MySQL简介" class="headerlink" title="NO1.2 MySQL简介"></a>NO1.2 MySQL简介</h3><p>MySQL是一个开源的关系型数据库管理系统，即，是用来管理关系型数据库的工具。</p><ul><li><p>MySQL：</p><ul><li><p>介绍：MySQL是瑞典原AB(现在是Oracle)公司下的一款关系型数据库。关系型数据库是一种建立在关系模型上的数据库，而关系模型就是一张二维表；二维表由行和列组成，表名称唯一，用来标识不同的表。一行就是一条记录，一列就相当于一条记录的一个属性。</p></li><li><p>优点：</p><ul><li>MySQL数据库体积小、速度快、总体拥有成本低、开放源代码，其有着广泛的应用，一般中小型网站的开发都选择MySQL作为网站数据库；</li><li>使用C和C++编写，并使用多种编译器进行测试，保证源代码的可移植性；</li><li>支持 AIX、FreeBSD、HP-UX、Linux、Mac OS、NovellNetware、OpenBSD、OS/2 Wrap、Solaris、Windows 等多种操作系统；</li><li>支持多线程，充分利用CPU资源；</li><li>支持大型的数据库。可以处理拥有上千万条记录的大型数据库；</li><li>支持多种存储引擎；</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>MySQL的安装：<ul><li>下载MySQL的版本，然后按照一般的安装步骤安装即可，这里不做叙述；</li><li>其次需要安装MySQL的图形化使用工具。<code>如，SQL yog或Navicat等等</code>，我这里之前已经安装过SQL yog了，所以现在安装的是Navicat Premium15，具体安装和配置步骤，这里不做过多叙述。</li><li>连接MySQL，输入账号和密码即可连接；</li></ul></li></ul><p>&nbsp;</p><ul><li><p>MySQl服务的启动和停止：</p><ul><li><p>通过命令行操作：注意：如果在命令行中输入这些命令后报拒绝访问的错误，那么关掉命令行，并重新使用管理员身份打开命令行，然后再输入即可；如果报无效的命令，那么需要将你安装的MySQL路径，添加到环境变量中去，添加完成后，再使用命令行输入命令即可。</p><ul><li><code>net stop mysql</code>：停止服务；</li><li><code>net start mysql</code>：开启服务。</li></ul></li><li><p>通过右键点击我的电脑，选择管理，再选择服务和应用程序中的服务选项，在服务中找到MySQl服务，右键启动或关闭即可。</p><p>  <img src="./Image-ms1.png" srcset="/img/loading.gif" alt=""></p></li></ul></li><li><p>MySQL服务端的登录、退出、查看版本命令：</p><ul><li><code>mysql [-h localhost -P 3306](本机可省略这两个) -u root -p(可以直接写密码，不能有空格)</code>：登录。其中可选项如下：<ul><li><code>-h</code>：主机名或IP地址；</li><li><code>-P</code>：MySQL的端口号；</li><li><code>-u</code>：用户名；</li><li><code>-p</code>：密码。</li></ul></li><li><code>exit</code>：退出，前提是已经登陆了MySQL；</li><li>查看MySQL数据库的版本：<ul><li><code>select version()</code>：这是连接数据库后，在DBMS中使用的命令，实际是一条查询语句；</li><li><code>mysql –version</code>：命令行命令，可以不连接数据库而使用。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>MySQL中几个基本的命令：<ul><li><code>SHOW DATABASES</code>：查看当前所有的数据库；</li><li><code>USE 数据库名</code>：打开指定的库；</li><li><code>SHOW TABLES</code>：查看当前数据库的所有表；</li><li><code>SHOW TABLES FROM 数据库名</code>：查看其他库的所有表。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson2-MySQL基础"><a href="#Lesson2-MySQL基础" class="headerlink" title="Lesson2 MySQL基础"></a>Lesson2 MySQL基础</h2><h3 id="NO2-1-MySQL的数据类型"><a href="#NO2-1-MySQL的数据类型" class="headerlink" title="NO2.1 MySQL的数据类型"></a>NO2.1 MySQL的数据类型</h3><p>首先认识一下数MySQL数据库的基本数据类型，主要有三大类。</p><ul><li>数值类型：<strong><code>注意：在无符号类型的字段需要在数据类型后面使用unsigned进行标识。如，age tingint unsigned。</code></strong> <ul><li><code>TINYINT</code>：即迷你整型，占用1字节，有符号范围为<code>-128~127</code>，无符号范围为<code>0~255</code>；</li><li><code>SMALLINT</code>：即小整型，占用2个字节，有符号范围为<code>-32768~32767</code>，无符号范围为<code>0~65535</code>；</li><li><code>MEDIUMINT</code>：即中等整型，占用3个字节，有符号范围为<code>-8388608~8388607</code>，无符号范围为<code>0~16777215</code>；</li><li><code>INT</code>：即标准整型，占用4个字节，有符号范围为<code>-2147483648~2147483647</code>，无符号范围为<code>0~4294967295</code>；<strong><code>注意：INT是INTEGER的同义词，也就是别名的意思。</code></strong></li><li><code>BIGINT</code>：即大整型，占用8个字节，有符号范围为<code>-9223372036854775808~9223372036854775807</code>，无符号范围为<code>0~18446744073709551615</code>；</li><li><code>FLOAT(M,D)</code>：即单精度浮点型，m为总位数，d为小数的位数；占用4个字节，最大值比BIGINT还要大；</li><li><code>DOUBLE(M,D)</code>：即双精度浮点型，m为总位数，d为小数的位数；占用8个字节，最大值比float还要大很多；</li><li><code>DECIMAL(M,D)</code>：即定点型， m为总位数，d为小数的位数；如果M&gt;D，那么占用M+2个字节，否则占用D+2个字节，m最多65位，d最多30位，所以最大值为无符号的65个9；默认的是decimal(10,0)，且凡是涉及到钱的都会在数据库端使用decimal来进行数据的存储和运算。注意：DEC是DECIMAL的同义词。</li></ul></li></ul><p>&nbsp;</p><ul><li>字符类型：<ul><li><code>CHAR</code>：定长字符串，最多为255个字符；如果数据不够长度，空间依然被占用，容易造成空间的浪费；如果数据超出长度，系统会报错；注意：数据库中的字符串要用’’标识。</li><li><code>VARCHAR</code>：变长字符串，最多65535个字符，如果数据不够长度，会自动根据数据大小来分配存储空间，以此节省存储空间；</li><li><code>TEXT</code>：标准长文本数据，单位是字节，最多65535个字符，约为64KB；此外还有tinytext(255个字符)、mediumtext(16777215个字符)、longtext(4294967295个字符)；</li><li><code>BLOB</code>：二进制形式的长文本数据，最多65535个字符，用来存储图片、音乐等。此外还有tinyblob(255个字符)、mediumblob(16777215个字符)、longblob(4294967295个字符)。</li></ul></li></ul><p>&nbsp;</p><ul><li>日期类型：<ul><li><code>DATE</code>：占用3个字节，精确到年月日。如，2015-05-01；</li><li><code>TIME</code>：占用3个字节，精确到时分秒。如，11:12:00；</li><li><code>DATETIME</code>：占用8个字节，精确到年月日时分秒。如，2015-05-01 11::12:00；</li><li><code>TIMESTAMP</code>：精确到年月日时分秒。如，2015-05-01 11:12:00。timestamp会根据系统时区进行转换，而datetime不会。如果存时间戳(即时间自1970年1月1日(00:00:00 GMT)至当前时间的总秒数)使用数字类型BIGINT。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-2-表的创建、修改、删除"><a href="#NO2-2-表的创建、修改、删除" class="headerlink" title="NO2.2 表的创建、修改、删除"></a>NO2.2 表的创建、修改、删除</h3><p>想要操作数据库中的表，那么首先要明白表的创建、修改和删除。</p><ul><li><p>表的创建：</p><ul><li><p>定义：通过SQL语句建立一张可供用户操作的表；但是在建立表之前，首先要先建立一个数据库，然后在数据库中再建立表，那么该表就属于这个数据库；注意：AS关键字用于给字段、表创建一个别名，以便简化各种操作。</p></li><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> 数据库名;  //创建一个数据库<span class="hljs-keyword">USE</span> 数据库名;  //使用指定的数据库<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(  //创建一张表    字段名<span class="hljs-number">1</span> 数据类型[<span class="hljs-keyword">size</span>],    字段名<span class="hljs-number">2</span> 数据类型[<span class="hljs-keyword">size</span>],    ....);</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>表的修改，分为多种：</p><ul><li><p>添加列：</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> 字段名 数据类型(<span class="hljs-keyword">size</span>);</code></pre></li></ul></li><li><p>删除列：</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> 字段名;</code></pre></li></ul></li><li><p>修改列：</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">MODIFY</span> <span class="hljs-keyword">COLUMN</span> 字段名 数据类型(<span class="hljs-keyword">size</span>);  //修改指定字段的数据类型<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">CHANGE</span> 原字段名 新字段名 数据类型(<span class="hljs-keyword">size</span>);  //可以同时字段名和字段的数据类型</code></pre></li></ul></li><li><p>添加主键：</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> PRIMARY <span class="hljs-keyword">KEY</span> (字段名);</code></pre></li></ul></li><li><p>删除主键：</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名  <span class="hljs-keyword">MODIFY</span> 字段名 <span class="hljs-built_in">INT</span>, <span class="hljs-keyword">DROP</span> PRIMARY <span class="hljs-keyword">KEY</span>;  //一般主键都有自增属性时，使用这个，即先修改主键的字段类型，这样会自动去掉自增，然后再删除主键<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> PRIMARY <span class="hljs-keyword">KEY</span>;  //主键没有自增时，直接删除主键约束即可</code></pre></li></ul></li><li><p>添加外键：</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 从表 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> [外键约束名称] <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> 从表(外键字段名) <span class="hljs-keyword">REFERENCES</span> 主表(主键字段名);说明：外键约束名称，属于可写可不写。如，外键约束名称：FK_从表_主表。</code></pre></li></ul></li><li><p>删除外键：</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> 外键名称;</code></pre></li></ul></li><li><p>修改默认值：</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ALTER</span> 字段名 <span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span> 要设置的默认值;</code></pre></li></ul></li><li><p>删除默认值：</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ALTER</span> 字段名 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">DEFAULT</span>;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>表的删除，分为两种：</p><ul><li><p>TRUNCATE：只删除表中的数据，保留表结构；</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> 表名;</code></pre></li></ul></li><li><p>DROP：删除表结构(包括索引、触发器等等)以及表中的数据。</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> 表名;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-3-MySQL中的约束"><a href="#NO2-3-MySQL中的约束" class="headerlink" title="NO2.3 MySQL中的约束"></a>NO2.3 MySQL中的约束</h3><p>所谓约束，就是给字段加上一个限制条件，这样在对记录中的字段进行操作时，就会起到一个安全检查的作用。一般约束常用在创建表的时候。</p><ul><li><p>MySQl中的约束有：</p><ul><li><p><code>PRIMARY KEY</code>：设置主键约束。字段被设置该约束时，系统会先检查字段的值是否重复，有重复的值则会在设置主键时报错，所以设置了主键约束的字段会隐性自动加上UNIQUE(即唯一约束)和NOT NULL约束(不为空约束)；主键约束的添加方式：</p><ul><li><p>方式一：在创建表的时候，直接在字段的后面，跟PRIMARY KEY关键字(主键本身不允许为空)；</p></li><li><p>方式二：在创建表的时候，在所有的字段最后，使用PRIMARY KEY(主键字段列表)来创建主键，如果有多个字段作为主键，可以是复合主键(<code>如，PRIMARY KEY(id,name)</code>)；一般情况下，主键的字段长度和字段数目要越少越好；</p></li><li><p>方式三：当表已经创建好之后，额外追加主键，可以通过修改表字段属性，也可以直接追加ALTER TABLE 表名 ADD PRIMARY KEY(字段列表)。</p>  <pre><code class="hljs sql">拓展：主键的自增长一、一般主键还会添加一个属性：自增长，即AUTO_INCREMENT，当设置了自增长后，当对应的字段不给值，或给默认值、或给NULL值，会自动的被系统触发，系统会从当前字段中已有的最大值基础上，再进行+1操作，得到一个新的不同的数据；另外任何一个字段要做自增长，前提必须本身就是一个索引；自增长字段必须是数字，而且是整型；一张表最多只能有一个自增长。二、自增长的基本语法格式：    1.添加自增长：直接在对应的字段后面添加auto_increment即可；    2.修改自增长：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 AUTO_INCREMENT=值；    <span class="hljs-number">3.</span>查看自增长对应的变量：<span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">VARIABLES</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'auto_increment%'</span>；    <span class="hljs-number">4.</span>删除自增长：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">MODIFY</span> 字段 类型。</code></pre></li></ul></li><li><p><code>UNIQUE</code>：设置唯一性约束。字段被设置了该约束后，字段不能有重复值；没有添加新的记录时，默认待添加行的字段允许自动为空，而且可以多个字段为空；唯一约束的添加方式：</p><ul><li>方式一：在创建表的时候，在字段的后面直接跟UNIQUE或者UNIQUE KEY即可；</li><li>方式二：在创建表的时候，在所有的字段最后增加UNIQUE KEY(字段列表)；</li><li>方式三：在创建表之后增加唯一键。</li></ul></li><li><p><code>DEFAULT</code>：默认值约束。字段被设置了该约束后，待添加记录中的字段会有个默认值，而不再是NULL；在创建表的时候，一般在字段的后面直接跟“DEFAULT 指定的默认值”；如，tall DOUBLE(4,1) DEFAULT 170.0，拥有height字段的待添加行的默认值为170.0。</p></li><li><p><code>NOT NULL</code>：设置非空约束。字段被设置了该约束后，添加记录时该字段不能为空，也就是不能为NULL；在创建表的时候，一般在字段的后面直接跟“NOT NULL”；</p></li><li><p><code>FOREIGN KEY</code>：设置外键约束。字段被设置了该约束后，表明该字段与某个表的主键值是相关联的，即能够通过当前表的该字段找该字段在另一个表中所对应的主键值；一般直接在所有字段的最后增加FOREIGN KEY(字段名) REFERENCES 表2(表2的字段名)。如，学生表中有个外键约束的字段teacher_id，teacher_id表示教授该学生的教师的id，那么根据这个teacher_id就能在教师表中找到对应的id，以及其他信息了。</p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-4-表数据的添加、修改、删除"><a href="#NO2-4-表数据的添加、修改、删除" class="headerlink" title="NO2.4 表数据的添加、修改、删除"></a>NO2.4 表数据的添加、修改、删除</h3><p>可以对表数据进行添加，删除和修改等操作。</p><ul><li><p>表数据的添加：</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名(字段名<span class="hljs-number">1</span>,字段名<span class="hljs-number">2.</span>...) <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>);</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>表数据的修改：</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> 表名 <span class="hljs-keyword">SET</span> 字段名<span class="hljs-number">1</span>=值<span class="hljs-number">1</span>,字段名<span class="hljs-number">2</span>=值<span class="hljs-number">2.</span>... <span class="hljs-keyword">WHERE</span> 条件;注意：这里要修被修改的字段必须是符合条件的同一条记录，即一次只能修改一条记录；如果想要修改某个字段的所有记录中的值，则将后面的where条件去掉即可。</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>表数据的删除：</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件;</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-5-数据库的三范式"><a href="#NO2-5-数据库的三范式" class="headerlink" title="NO2.5 数据库的三范式"></a>NO2.5 数据库的三范式</h3><p>目前关系数据库有六种范式：第一范式(1NF)、第二范式(2NF)、第三范式(3NF)、巴斯-科德范式(BCNF)、第四范式(4NF)和第五范式(5NF，又称完美范式)。一般说来，数据库只需满足前三范式(3NF)就行了。</p><ul><li>第一范式(1NF)：每一列都是不可分割的原子数据项，即字段不可再分；</li><li>第二范式(2NF)：在1NF的基础上，非主键的其他字段必须依赖于主键(即在1NF基础上消除非主键的字段对主键的部分函数依赖)，即有主键，非主键字段依赖主键；</li><li>第三范式(3NF)：在2NF基础上，任何非主键的其他字段不依赖于其它非主键的其他字段(在2NF基础上消除传递依赖)，即每列都与主键有直接关系，不存在传递依赖(也就是间接依赖的意思)。如，订单表中有order_id、order_address、customer_id、customer_name，其中主键为order_id，其他字段都依赖于这个主键，符合第二范式，但是customer_name也依赖于customer_id，而customer_id又依赖于order_id，所以customer_name和order_id直接存在了一个间接依赖，所以不符合第三范式。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-6-单表查询"><a href="#NO2-6-单表查询" class="headerlink" title="NO2.6 单表查询"></a>NO2.6 单表查询</h3><p>在数据库中，除了增删改操作之外，使用最多的就是查询语句；而查询可分为单表查询和多表查询。</p><ul><li><p>基础查询：</p><ul><li><p>定义：不带任何限制条件的简单查询。</p></li><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> 表名;  //查询包含了所有字段的记录<span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2.</span>... <span class="hljs-keyword">FROM</span> 表名;  //查询包含了指定字段的记录说明：避免使用<span class="hljs-keyword">SELECT</span> *(“*”表示通配符)，因为使用通配符是查询表中的每一个列，会降低检索效率，以及应用程序的性能。</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>基础条件查询：</p><ul><li><p>定义：带限制条件的简单查询。</p></li><li><p>常用限制条件有：</p><ul><li>简单条件运算符：<code>&gt;、&gt;=、&lt;、&lt;=、=、!=</code>；</li><li>逻辑运算符：<code>AND、OR、NOT(也可以写成&amp;&amp;、||、!)</code>；</li><li>模糊查询：<code>LIKE、BETWEEN....AND、IN、IS NULL/IS NOT NULL</code>。<strong><code>注意：like模糊查询，要使用“%”或“_”，即百分号或下划线；前者表示任意个任意字符，后者表示一个任意字符。如，name LIKE &#39;a%&#39;，查找名字以a开头的记录。IN操作符一般比OR操作符执行更快；LIKE很慢，一般来说，最好使用FULLTEXT(全文本搜索)而不是LIKE。</code></strong></li></ul></li><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2.</span>... <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件;</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>排序查询：</p><ul><li><p>定义：即对查询结果进行排序。</p></li><li><p>关键字：<code>ORDER BY</code>，降序为<code>DES</code>C，而升序为<code>ASC(默认)</code>；当排序和分页一起使用时，ORDER BY必须在LIMIT前面；</p></li><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2.</span>... <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 字段名 降序或升序;  //按照指定字段的升序或降序进行排序<span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2.</span>...  <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 字段名<span class="hljs-number">1</span>  降序或升序,字段名<span class="hljs-number">2</span> 降序或升序....;  //按照指定的多个字段进行升序或降序，即当字段1相同时，按字段2进行升序或降序排序，依次类推</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>分组查询：</p><ul><li><p>定义：即对查询结果进行分组。</p></li><li><p>关键字：GROUP BY，如果还想在分组结果里面进行筛选，那么需要在GROUP BY之后添加关键字HAVING；注意：GROUP BY后面跟的字段，必须出现在SELECT后面。</p></li><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2.</span>... <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 字段名;  //按照指定字段进行分组<span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2.</span>... <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 字段名<span class="hljs-number">1</span>,字段名<span class="hljs-number">2.</span>...;  //按照指定的多个字段进行分组，即按字段1分组后，如果某些字段1的值相同，会再按照字段2进行分组，依次类推<span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2.</span>...  <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 字段名 <span class="hljs-keyword">HAVING</span> 条件;  //对查询结果进行分组后，又仅需筛选</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>分页查询：</p><ul><li><p>定义：即对查询结果进行分页显示。</p></li><li><p>关键字：LIMIT；注意：多种功能查询的使用格式：WHERE….GROUP BY….HAVING….ORDER BY….LIMIT….。</p></li><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2.</span>... <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">LIMIT</span> X;  //取查询结果的前X条SELECT 字段1,字段2.... FROM 表名 WHERE 条件 LIMIT X,Y;  //对查询结果进行分页显示，跳过前X条记录，从X+1开始显示，每页显示Y条；一般有个公式：X =(页码-1)*Y，意思就是说，假设Y为5，当我点第一页，那么X=(1-1)*5，即X=0，就是LIMIT 0,5，跳过前面0条记录，那不就是从第1条记录开始显示，且每页显示5条</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>去重查询：</p><ul><li><p>定义：即对查询结果的指定字段进行去重处理。</p></li><li><p>关键字：DISTINCT；注意：DISTINCT只能出现在SELECT后面的第一个，第二个甚至其他都不行。</p></li><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span>(字段名),字段<span class="hljs-number">1.</span>... <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件;<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> 字段名<span class="hljs-number">1</span>,字段<span class="hljs-number">2.</span>... <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件;  //表示当多个字段都重复时才会将这条记录当作重复记录过滤掉如：//表中有字段id、nameid name1 a2 b3 c4 c5 b//使用去重关键字DISTINCT<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> tb_user;//得到结果nameabc//<span class="hljs-comment">-----------------------------------------------</span>//使用去重，但作用多个字段<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">name</span>,<span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> tb_user;//得到结果id name1 a2 b3 c4 c5 b//总结：只有当两条记录的多个字段的值都相同时，才会去重</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>聚合函数查询：</p><ul><li><p>定义：即带有聚合函数的查询，查询结果只返回一个值。</p></li><li><p>常用聚合函数包括：</p><ul><li><code>COUNT(字段名)</code>：统计查询结果的行数；注意：COUNT(*)表示统计表中所有的记录总条数；COUNT(字段名)表示统计制度字段不为NULL的记录条数。其他聚合函数都会忽略NULL值记录；</li><li><code>MIN(字段名)</code>：查询指定字段的最小值；</li><li><code>MAX(字段名)</code>：查询指定字段的最大值；</li><li><code>SUM(字段名)</code>：求和，返回指定字段的总和；</li><li><code>AVG(字段名)</code>：求平均值，返回指定字段数据的平均值。</li></ul></li><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 聚合函数名(字段名) <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">where</span> 条件;</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-7-多表查询"><a href="#NO2-7-多表查询" class="headerlink" title="NO2.7 多表查询"></a>NO2.7 多表查询</h3><p>在实际业务中，都是多个表联合进行查询的。注意：使用多表联查时，无论是内连接还是外链接，一定要使用唯一的字段条件进行ON连接，否则查询结果会出现局部笛卡尔积(表1的记录数乘以表2的记录数)，甚至全部都是笛卡尔积的现象；</p><ul><li><p>内连接查询：</p><ul><li><p>定义：取两个表之间的交集记录，也就是两个表相等的记录；</p></li><li><p>关键字：<code>INNER JOIN....ON....</code>；</p></li><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2.</span>... <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 表<span class="hljs-number">1.</span>字段名 = 表<span class="hljs-number">2.</span>字段名 <span class="hljs-keyword">WHERE</span> 条件;</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>外连接(分为左外连接和右外连接，又称左链接和右连接)查询：</p><ul><li><p>定义：取左表(或右表)中的所有的记录，以及右表(或左表)中符合条件的记录；</p></li><li><p>关键字：<code>LEFT JOIN/RIGHT JOIN....ON....</code>；</p></li><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2.</span>... <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span>/<span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 表<span class="hljs-number">1.</span>字段名 = 表<span class="hljs-number">2.</span>字段名 <span class="hljs-keyword">WHERE</span> 条件;</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>子查询：</p><ul><li><p>定义：即查询当中还有嵌套了一个查询。分为三种：</p><ul><li><p>select子句中的子查询：即子查询的位置位于select之后；基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段名,(<span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">WHERE</span> 条件)<span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span> 条件</code></pre></li><li><p>where字句中的子查询：即子查询的位置位于where条件中；基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span>(<span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">WHERE</span> 条件)</code></pre></li><li><p>from子句中的子查询：即子查询的位置位于from后面。基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span>(<span class="hljs-keyword">SELECT</span> 字段名.... <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">WHERE</span> 条件)<span class="hljs-keyword">WHERE</span> 条件</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>UNION组合查询：</p><ul><li><p>定义： 即将两个表中的数据按照各自的查询条件查询出来后(但是列数必须一致)，将结果合并到一起；意思就是将两条或以上的SELECT语句的查询结果用UNION进行拼接；注意：每两条SELECT就要用UNION进行分隔；组合查询具有自动去重的功能，若是不想去重，想展示所有的数据，那么只需使用UNION ALL就行；排序ORDER BY只能出现在最后一条SELECT语句中；</p></li><li><p>关键字：<code>....UNION....</code>；</p></li><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2.</span>... <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span><span class="hljs-keyword">UNION</span>  //自动去重，如果不想去重，需要使用<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2.</span>... <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">2</span>....</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-8-MySQL中常用的函数"><a href="#NO2-8-MySQL中常用的函数" class="headerlink" title="NO2.8 MySQL中常用的函数"></a>NO2.8 MySQL中常用的函数</h3><p>函数主要是用来帮助用户处理表数据的。</p><ul><li><p>聚合函数：2.6中已经提到过，就不再重复提了。</p></li><li><p>数值型函数：</p><ul><li><code>ABS(x)</code>：返回x的绝对值；</li><li><code>BIN(x)</code>：返回x的二进制；</li><li><code>CEILING(x)</code>：返回大于x的最小整数值；</li><li><code>EXP(x)</code>：返回值e(自然对数的底)的x次方；</li><li><code>FLOOR(x)</code>：返回小于x的最大整数值；</li><li><code>GREATEST(x1,x2,...,xn)</code>：返回集合中最大的值；</li><li><code>LEAST(x1,x2,...,xn)</code>：返回集合中最小的值；</li><li><code>LN(x)</code>：返回x的自然对数；</li><li><code>LOG(x,y)</code>：返回x的以y为底的对数；</li><li><code>MOD(x,y)</code>：返回x/y的模(余数)；</li><li><code>PI()</code>：返回pi的值(圆周率)；</li><li><code>RAND()</code>：返回0~1内的随机值，可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值；</li><li><code>ROUND(x,y)</code>：返回参数x的四舍五入的有y位小数的值；</li><li>T<code>RUNCATE(x,y)</code>：返回数字x截短为y位小数的结果。</li></ul></li></ul><p>&nbsp;</p><ul><li>字符串函数：<ul><li><code>LENGTH(s)</code>：计算字符串长度函数，返回字符串的字节长度；</li><li><code>CONCAT(s1,s2...,sn)</code>：合并字符串函数，返回结果为连接参数产生的字符串，参数可以是一个或多个；</li><li><code>INSERT(str,x,y,instr)</code>：将字符串str从第x位置开始，y个字符长的子串替换为字符串instr，返回结果；</li><li><code>LOWER(str)</code>：将字符串中的字母转换为小写；</li><li><code>UPPER(str)</code>：将字符串中的字母转换为大写；</li><li><code>LEFT(str,x)</code>：返回字符串str中最左边的x个字符；</li><li><code>RIGHT(str,x)</code>：返回字符串str中最右边的x个字符；</li><li><code>TRIM(str)</code>：删除字符串左右两侧的空格；</li><li><code>REPLACE(str,oldStr,newStr)</code>：字符串替换函数，将str中所有的oldStr用newStr替换，返回替换后的新字符串；</li><li><code>SUBSTRING(str,x,y)</code>：截取字符串str，返回从指定x位置开始的指定y长度的字符串；</li><li><code>REVERSE(str)</code>：返回颠倒字符串str的结果。</li></ul></li></ul><p>&nbsp;</p><ul><li>日期和时间函数：<ul><li><code>CURDATE和CURRENT_DATE</code>：两个函数作用相同，返回当前系统的日期值；</li><li><code>CURTIME和CURRENT_TIME</code>：两个函数作用相同，返回当前系统的时间值；</li><li><code>NOW和SYSDATE</code>：两个函数作用相同，返回当前系统的日期和时间值；</li><li><code>UNIX_TIMESTAMP</code>：获取UNIX时间戳函数，返回一个以 UNIX 时间戳为基础的无符号整数；</li><li><code>FROM_UNIXTIME</code>：将 UNIX 时间戳转换为时间格式，与UNIX_TIMESTAMP互为反函数；</li><li><code>MONTH</code>：获取指定日期中的月份；</li><li><code>MONTHNAME</code>：获取指定日期中的月份英文名称；</li><li><code>DAYNAME</code>：获取指定曰期对应的星期几的英文名称；</li><li><code>DAYOFWEEK</code>：获取指定日期对应的一周的索引位置值；</li><li><code>WEEK</code>：获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53；</li><li><code>DAYOFYEAR</code>：获取指定曰期是一年中的第几天，返回值范围是1~366；</li><li><code>DAYOFMONTH</code>：获取指定日期是一个月中是第几天，返回值范围是1~31；</li><li><code>YEAR</code>：获取年份，返回值范围是 1970〜2069；</li><li><code>TIME_TO_SEC</code>：将时间参数转换为秒数；</li><li><code>SEC_TO_TIME</code>：将秒数转换为时间，与TIME_TO_SEC 互为反函数；</li><li><code>DATE_ADD</code>和 ADDDATE；两个函数功能相同，都是向日期添加指定的时间间隔；</li><li><code>DATE_SUB</code>和 SUBDATE：两个函数功能相同，都是向日期减去指定的时间间隔；</li><li><code>ADDTIME</code>：时间加法运算，在原始时间上添加指定的时间；</li><li><code>SUBTIME</code>：时间减法运算，在原始时间上减去指定的时间；</li><li><code>DATEDIFF</code>：获取两个日期之间间隔，返回参数 1 减去参数 2 的值；</li><li><code>DATE_FORMAT</code>：格式化指定的日期，根据参数返回指定格式的值；</li><li><code>WEEKDAY</code>：获取指定日期在一周内的对应的工作日索引。</li></ul></li></ul><p>&nbsp;</p><ul><li>流程控制函数：<ul><li><code>IF(test,t,f)</code>：如果test是真，返回t；否则返回f；</li><li><code>IFNULL(arg1,arg2)</code>：如果arg1不是空，返回arg1，否则返回arg2；</li><li><code>NULLIF(arg1,arg2)</code>：如果arg1=arg2返回NULL；否则返回arg1；</li><li><code>CASE WHEN[test1] THEN [result1]...ELSE [default] END</code>：如果testN是真，则返回resultN，否则返回default；</li><li><code>CASE [test] WHEN[val1] THEN [result]...ELSE [default]END</code>：如果test和valN相等，则返回resultN，否则返回default。</li></ul></li></ul><p>&nbsp;</p><ul><li>加密函数：<ul><li><code>ENCRYPT(str,salt)</code>：使用UNIXcrypt()函数，用关键词salt(一个可以惟一确定口令的字符串，就像钥匙一样)加密字符串str；</li><li><code>ENCODE(str,key)</code>：使用key作为密钥加密字符串str，调用ENCODE()的结果是一个二进制字符串，它以BLOB类型存储；</li><li><code>MD5()</code>：计算字符串str的MD5校验和；</li><li><code>PASSWORD(str)</code>：返回字符串str的加密版本，这个加密过程是不可逆转的，和UNIX密码加密过程使用不同的算法；</li><li><code>SHA()</code>：计算字符串str的安全散列算法(SHA)校验和。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-9-MySQL的存储引擎"><a href="#NO2-9-MySQL的存储引擎" class="headerlink" title="NO2.9 MySQL的存储引擎"></a>NO2.9 MySQL的存储引擎</h3><p>存储引擎只在MySQL中存在。</p><ul><li>常见的MySQL存储引擎有：<ul><li>InnoDB引擎(创建一张表，默认就是该引擎)：<ul><li>支持事务，是事务安全的；</li><li>提供行级锁与外键约束；</li><li>有缓冲池，用于缓存数据和索引；</li><li>常用于：事务处理，具有ACID事务支持，执行大量的INSERT和UPDATE操作。</li></ul></li><li>MyISAM引擎：<ul><li>不支持事务；</li><li>不支持外键约束和行级锁；</li><li>操作时需要锁定整张表，不过会保存表的行数，所以执行SELECT COUNT(*) FROM table特别快；</li><li>常用于：管理非事务表，提供高速检索和全文检索能力，执行大量的SELECT操作。</li><li>使用三个文件表示每个表：<ul><li>存储表结构：用“.frm”文件；</li><li>存储表数据：用“.MYD”文件；</li><li>存储表索引：用“.MYI”文件。</li></ul></li></ul></li><li>MEMORY引擎：<ul><li>数据存在于内存，精确查询访问速度非常快，且索引使用的是hash索引；</li><li>无法模糊查询；</li><li>服务器关闭，内存的数据就会丢失，因为没有存到磁盘中；</li><li>常用于：查询内容变化不频繁的表、作为中间的查找表；表的更新要谨慎，兵考虑好数据的存储。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-10-MySQL的事务"><a href="#NO2-10-MySQL的事务" class="headerlink" title="NO2.10 MySQL的事务"></a>NO2.10 MySQL的事务</h3><p>所谓事务，就是一个完整的业务逻辑单元，不可再分。如，转账功能，那么A账户的转出和B账户转入，属于一个业务逻辑，要么都成功，要么都失败。事务的存在是为了保证数据的完整性和安全性。事务只与增加、删除、修改语句相关。</p><ul><li>事务具备ACID四种特性。ACID是Atomic(原子性)、Consistency(一致性)、Isolation(隔离性)和Durability(持久性)的英文缩写。<ul><li>原子性(Atomicity)：事务最基本的操作单元，要么全部成功，要么全部失败，不会结束在中间某个环节；事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样；</li><li>一致性(Consistency)：事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态，即要么都成功的状态，要么都失败的状态；如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态；如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态；</li><li>隔离性(Isolation)：指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间；由并发事务所做的修改必须与任何其他并发事务所做的修改隔离；事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据；</li><li>持久性(Durability)：指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来；即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。</li></ul></li></ul><p>&nbsp;</p><ul><li><p>事务的安全性问题和隔离级别；</p><ul><li><p>事务的安全性问题；</p><ul><li><p>脏读：是指一个事务读到另一个事务还没有提交的数据；</p>  <pre><code class="hljs dns">事务<span class="hljs-keyword">A</span>读取了事务B更新的数据，然后B回滚操作，那么<span class="hljs-keyword">A</span>读取到的数据是脏数据；</code></pre></li><li><p>不可重复读：是指一个事务读到另一个事务已经提交的update数据，导致在当前事务中多次查询的结果不一致；</p>  <pre><code class="hljs dns">事务<span class="hljs-keyword">A</span>多次读取同一数据，事务B在事务<span class="hljs-keyword">A</span>多次读取的过程中，对数据作了更新并提交，导致事务<span class="hljs-keyword">A</span>多次读取同一数据时，结果不一致；</code></pre></li><li><p>虚读/幻读：是指一个事务读到另一个事务已经提交的insert数据，导致在当前事务中多次查询的结果不一致。</p>  <pre><code class="hljs dns">系统管理员<span class="hljs-keyword">A</span>将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员<span class="hljs-keyword">A</span>改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读；</code></pre></li></ul></li><li><p>事务的安全性问题的解决办法就是设置隔离级别：</p><p>  <img src="./Image-ms2.png" srcset="/img/loading.gif" alt="Image"></p><p>  <strong><code>说明：Y代表可能发生，N代表不会发生。</code></strong></p><ul><li><code>READ-UNCOMMITTED(读取未提交)</code>：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读；</li><li><code>READ-COMMITTED(读取已提交)</code>：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生；</li><li><code>REPEATABLE-READ(可重复读)</code>：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生；</li><li><code>SERIALIZABLE(可串行化)</code>：最高的隔离级别，完全服从ACID的隔离级别；所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul></li><li><p>MySQL默认的事务处理级别是<code>REPEATABLE-READ</code>，也就是可重复读；Oracle默认系统事务隔离级别是<code>READ COMMITTED</code>，也就是读已提交。Oracle数据库支持<code>READ COMMITTED</code>和<code>SERIALIZABLE</code>这两种事务隔离级别。</p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-11-索引：基础"><a href="#NO2-11-索引：基础" class="headerlink" title="NO2.11 索引：基础"></a>NO2.11 索引：基础</h3><p>索引其实就像目录，为了方便查询而提出的，是MySQL数据库的一个对象。</p><ul><li><p>索引：</p><ul><li><p>定义：即INDEX KEY，是存储引擎用于快速找到记录的一种数据结构；</p></li><li><p>考虑给指定字段添加索引：注意：主键和具有UNIQUE的字段会自动被添加索引。</p><ul><li>数据量庞大；</li><li>该字段很少有DML(即增删改)操作，因为字段被添加索引后，又被修改，数据库维护成本会变高；</li><li>该字段经常出现在WHERE条件中。</li></ul></li><li><p>基本语法格式：</p><ul><li><p>创建索引：</p><ul><li><p>方式一：创建表时创建；</p>  <pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名 (    字段名<span class="hljs-number">1</span>  数据类型 [完整性约束条件....],    字段名<span class="hljs-number">2</span>  数据类型 [完整性约束条件....],    [<span class="hljs-keyword">UNIQUE</span> | FULLTEXT | SPATIAL ]   <span class="hljs-keyword">INDEX</span> | <span class="hljs-keyword">KEY</span> [索引名]  (字段名[(长度)]  [<span class="hljs-keyword">ASC</span> |<span class="hljs-keyword">DESC</span>]));</code></pre></li><li><p>方式二：在已存在的表上创建索引；</p> <pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span>  [<span class="hljs-keyword">UNIQUE</span> | FULLTEXT | SPATIAL ]  <span class="hljs-keyword">INDEX</span>  索引名 <span class="hljs-keyword">ON</span> 表名 (字段名[(长度)]);</code></pre></li><li><p>方式三：ALTER TABLE在已存在的表上创建索引；</p>  <pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span>  [<span class="hljs-keyword">UNIQUE</span> | FULLTEXT | SPATIAL ] <span class="hljs-keyword">INDEX</span> 索引名 (字段名[(长度)]  [<span class="hljs-keyword">ASC</span> |<span class="hljs-keyword">DESC</span>]);</code></pre></li></ul></li><li><p>删除索引：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> 索引名 <span class="hljs-keyword">ON</span> 表名;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-12-视图"><a href="#NO2-12-视图" class="headerlink" title="NO2.12 视图"></a>NO2.12 视图</h3><p>视图，其实就是用SQL语句查询后，将查询的结果转换成一个虚拟的表。</p><ul><li><p>视图：</p><ul><li><p>定义：视图(view)是一种虚拟的表，并不在数据库中实际存在。通俗的来说，视图就是执行select语句后返回的结果；</p></li><li><p>作用：</p><ul><li>方便再次查询：常用于多表联查中，将查询结果转换为视图，方便下次再次查询；</li><li>提高安全性：使用视图的用户只能访问被允许查询的结果，使用视图可以限制用户访问一些敏感信息列，提高数据库中数据的安全性；</li><li>修改表：多表更新字段或减少冗余时，你不必修改程序，只需要更新视图即可；</li></ul></li><li><p>基本语法格式：</p><ul><li><p>创建视图：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> 视图名 <span class="hljs-keyword">AS</span> 你复杂的<span class="hljs-keyword">SQL</span>查询语句;</code></pre></li><li><p>删除视图：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> 视图名;</code></pre></li><li><p>使用视图：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> 视图名;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-13-存储过程"><a href="#NO2-13-存储过程" class="headerlink" title="NO2.13 存储过程"></a>NO2.13 存储过程</h3><p>存储过程，简单来说就是为以后的使用而保存的一条或多条MySQL语句的集合(实际上就类似于一个函数，只不过里面放的是SQL语句)；</p><ul><li><p>存储过程：</p><ul><li><p>定义：</p></li><li><p>基本语法格式：</p><ul><li><p>创建存储过程：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名称( [<span class="hljs-keyword">IN</span> | <span class="hljs-keyword">OUT</span> | INOUT ] 参数<span class="hljs-number">1</span> 数据类型, [<span class="hljs-keyword">IN</span> | <span class="hljs-keyword">OUT</span> | INOUT ] 参数<span class="hljs-number">2</span> 数据类型...)<span class="hljs-keyword">BEGIN</span>    这里放的是<span class="hljs-keyword">SQL</span>语句体<span class="hljs-keyword">END</span>;说明：所有MySQL的变量必须以@开始。而存储过程的参数使用了@xxx，因为参数就是一个变量(用来临时存储数据)；存储过程一般并不直接显示结果，而是将结果返回给你指定的变量，也就是括号中的参数；区分存储过程的参数是作为输入的参数还是输出的变量，分别用IN和OUT来区别，而INOUT表示既可以是输入的参数也可以是输出的参数。</code></pre></li><li><p>调用存储过程：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">CALL</span> 存储过程名称(@参数<span class="hljs-number">1</span>,@参数<span class="hljs-number">2.</span>..);  //此时，已经调用了存储过程，并将结果存储到了你指定的参数中<span class="hljs-keyword">SELECT</span> @你指定的参数名;  //这样就可以直接输出参数中所存的值了如：//创建存储过程例子1<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> productpricing(<span class="hljs-keyword">OUT</span> pl <span class="hljs-built_in">DECIMAL</span>(<span class="hljs-number">8</span>,<span class="hljs-number">2</span>))  //将结果输出到这个变量里pl<span class="hljs-keyword">BEGIN</span>    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">Min</span>(prod_price)    <span class="hljs-keyword">INTO</span> pl  //<span class="hljs-keyword">INTO</span>关键字就是讲结果放入到pl这个变量中的意思    <span class="hljs-keyword">FROM</span> products;<span class="hljs-keyword">END</span>;//使用存储过程，将结果返回给了变量@pricelow<span class="hljs-keyword">CALL</span> productpricing(@pricelow);//使用变量<span class="hljs-keyword">SELECT</span> @pricelow;结果为：@pricelow2.50//<span class="hljs-comment">----------------------------------------------------------</span>//创建存储过程例子2<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> ordertotal(<span class="hljs-keyword">IN</span> onumber <span class="hljs-built_in">INT</span>,  <span class="hljs-keyword">OUT</span> ototal <span class="hljs-built_in">DECIMAL</span>(<span class="hljs-number">8</span>,<span class="hljs-number">2</span>)) //需要传入的数据必须是<span class="hljs-built_in">int</span>类型的变量<span class="hljs-keyword">BEGIN</span>    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">Sum</span>(item_price*quantity)    <span class="hljs-keyword">FROM</span> orderitems    <span class="hljs-keyword">WHERE</span> order_num = onumber    <span class="hljs-keyword">INTO</span> ototal  //<span class="hljs-keyword">INTO</span>关键字就是讲结果放入到ototal这个变量中的意思<span class="hljs-keyword">END</span>;//2.使用存储过程，传入int类型的参数20005，将结果返回给了变量@ototal<span class="hljs-keyword">CALL</span> ordertotal(<span class="hljs-number">20005</span>,@total);//3.使用变量<span class="hljs-keyword">SELECT</span> @total;结果为：@total149.87</code></pre></li><li><p>删除存储过程：</p><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名称;  //如果该存储过程不存在，则会报错</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-14-游标"><a href="#NO2-14-游标" class="headerlink" title="NO2.14 游标"></a>NO2.14 游标</h3><p>游标是一块内存中的区域，存放的是按照指定要求提取出来的数据集。</p><ul><li><p>游标：</p><ul><li><p>定义：游标是一块内存中的区域，存放的是按照指定要求提取出来的数据集，然后通过游标逐条进行数据处理；</p></li><li><p>范围：只能用于存储过程中；</p></li><li><p>基本语法格式：</p>  <pre><code class="hljs sql">...存储过程头部//声明游标中要使用的变量<span class="hljs-keyword">DECLARE</span> 变量名 数据类型;....//创建游标<span class="hljs-keyword">DECLARE</span> 游标名 <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> SELECT...//开启游标<span class="hljs-keyword">OPEN</span> 游标名//从游标中取值<span class="hljs-keyword">FETCH</span> 游标名 <span class="hljs-keyword">INTO</span> 变量<span class="hljs-number">1</span>,变量<span class="hljs-number">2.</span>..//关闭游标<span class="hljs-keyword">CLOSE</span> 游标名....存储过程尾部如：<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> test4()<span class="hljs-keyword">BEGIN</span>    <span class="hljs-keyword">DECLARE</span> row_name <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>);    <span class="hljs-keyword">DECLARE</span> getRowName <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">SELECT</span> rolename <span class="hljs-keyword">FROM</span> ht_role;    OPEN getRowName;    FETCH getRowName into row_name;    <span class="hljs-keyword">SELECT</span> row_name;    close getRowName;<span class="hljs-keyword">END</span>;<span class="hljs-keyword">CALL</span> test4();  //调用存储过程，就可以调用里面的游标了</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-15-触发器"><a href="#NO2-15-触发器" class="headerlink" title="NO2.15 触发器"></a>NO2.15 触发器</h3><p>顾名思义，就是当满足条件时，触发某种机制。</p><ul><li><p>触发器：</p><ul><li><p>定义：在满足定义条件时触发，并执行触发器中定义的语句集合；</p></li><li><p>基本语法格式：</p><ul><li><p>创建触发器：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> 触发器名 [ <span class="hljs-keyword">BEFORE</span> | <span class="hljs-keyword">AFTER</span> ] [<span class="hljs-keyword">INSERT</span> | <span class="hljs-keyword">UPDATE</span> | <span class="hljs-keyword">DELETE</span> ] <span class="hljs-keyword">ON</span> 表名<span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span><span class="hljs-keyword">SQL</span>语句说明：一、 <span class="hljs-keyword">INSERT</span> | <span class="hljs-keyword">UPDATE</span> | <span class="hljs-keyword">DELETE</span>：用于触发触发器的语句。<span class="hljs-keyword">INSERT</span>：将新行插入表时激活触发器；<span class="hljs-keyword">DELETE</span>： 从表中删除某一行数据时激活触发器；<span class="hljs-keyword">UPDATE</span>：更改表中某一行数据时激活触发器；二、<span class="hljs-keyword">BEFORE</span> 和 <span class="hljs-keyword">AFTER</span>：表示该触发器是要在触发语句激活之前还是之后才生效；三、<span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span>：一条<span class="hljs-keyword">SQL</span>语句有可能影响的是数据库的一条记录，又或者是多条记录，而<span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span>就是只要影响了数据库的记录，不论一行还是多行，都会使得触发器生效，且影响多少行就触发多少次。</code></pre></li><li><p>触发器不能更新或覆盖，只能删除再重新创建，删除触发器：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> xxx;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-16-用户创建与用户权限"><a href="#NO2-16-用户创建与用户权限" class="headerlink" title="NO2.16 用户创建与用户权限"></a>NO2.16 用户创建与用户权限</h3><p>一般的开发者，是不会使用root用户来进行数据库操作的。</p><ul><li><p>创建新用户：</p><ul><li><p>关键字：CREATE USER，如果同时还需要设置密码则在创建的用户后面加上IDENTIFIED BY；</p></li><li><p>基本语法格式：</p><ul><li><p>创建用户，并设置密码：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 用户名 <span class="hljs-keyword">IDENTIFIED</span> <span class="hljs-keyword">BY</span> 密码;<span class="hljs-keyword">SET</span> <span class="hljs-keyword">PASSWORD</span> <span class="hljs-keyword">FOR</span> 用户名 = <span class="hljs-keyword">PASSWORD</span>(<span class="hljs-string">'新密码'</span>);  //root用户给其他用户重新设置密码<span class="hljs-keyword">SET</span> <span class="hljs-keyword">PASSWORD</span> = <span class="hljs-keyword">PASSWORD</span>(<span class="hljs-string">'新密码'</span>);  //重新设置当前用户的密码</code></pre></li><li><p>删除用户：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">USER</span> 用户名；</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>设置用户权限：</p><ul><li><p>关键字：GRANT；</p></li><li><p>基本语法格式：</p><ul><li><p>授予用户权限：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> 权限类型 <span class="hljs-keyword">ON</span> 数据库名/数据库名.指定表 <span class="hljs-keyword">TO</span> 用户名;说明：一、权限类型：即要给予用户哪些权限。常用的有数据库中对所有表的<span class="hljs-keyword">SELECT</span>、<span class="hljs-keyword">INSERT</span>、<span class="hljs-keyword">DELETE</span>、<span class="hljs-keyword">UPDATE</span>，对表的<span class="hljs-keyword">SELECT</span>、<span class="hljs-keyword">INSERT</span>、<span class="hljs-keyword">DELETE</span>、<span class="hljs-keyword">UPDATE</span>、<span class="hljs-keyword">DROP</span>等等；二、可以只对某个数据库，或者数据库中指定的表赋予权限；如：<span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> db_test.* <span class="hljs-keyword">TO</span> dyf  //即给予用户dyf对数据库db_test所有的表查询的权限，“.*”是指数据库下的所有表</code></pre></li><li><p>删除用户权限：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> 权限类型 <span class="hljs-keyword">ON</span> 数据库名/数据库名.指定表 <span class="hljs-keyword">FROM</span> 用户名;如：<span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> db_test.* <span class="hljs-keyword">FROM</span> dyf  //撤销用户dyf对数据库db_test下所有表的<span class="hljs-keyword">SELECT</span>(查询)权限；</code></pre><p>  <img src="./Image-ms3.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-17-数据库的维护"><a href="#NO2-17-数据库的维护" class="headerlink" title="NO2.17 数据库的维护"></a>NO2.17 数据库的维护</h3><p>专业的维护数据库，一般离不开日志。</p><p><img src="./Image-ms4.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="Lesson3-MySQL高级"><a href="#Lesson3-MySQL高级" class="headerlink" title="Lesson3 MySQL高级"></a>Lesson3 MySQL高级</h3><p>NO3.1 索引：进阶<br>索引的出现主要是为了提高查询的效率。</p><ul><li><p>索引：</p><ul><li><p>定义：索引是一种数据结构，可以理解为“排好序的、功能是快速查找的数据结构”；一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。如，MYISAM存储引擎的“.MYI”文件，就是存储的索引。</p></li><li><p>作用：帮助MySQL高效获取数据；</p></li><li><p>分类：</p><ul><li>主键索引：是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值；</li><li>唯一索引：即索引列的值必须唯一，但允许有空值；</li><li>联合索引：即该索引中包含多个列；</li><li>普通索引：是最基本的索引，它没有任何限制；</li><li>单列索引：即该索引中只包含单个列；一个表可以有多个单列索引；</li><li>全文索引：主要用来查找文本中的关键字，它更像是一个搜索引擎。</li></ul></li><li><p>基本语法格式：</p><ul><li><p>创建索引：</p><ul><li><p>方式一：在已存在的表上创建索引；</p>  <pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span>  [<span class="hljs-keyword">UNIQUE</span> | FULLTEXT | SPATIAL ]  <span class="hljs-keyword">INDEX</span>  索引名 <span class="hljs-keyword">ON</span> 表名 (字段名[(长度)]);</code></pre></li><li><p>方式二：ALTER TABLE在已存在的表上创建索引；</p>  <pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span>  [<span class="hljs-keyword">UNIQUE</span> | FULLTEXT | SPATIAL ] <span class="hljs-keyword">INDEX</span> 索引名 (字段名[(长度)]);</code></pre></li></ul></li><li><p>删除索引：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> 索引名 <span class="hljs-keyword">ON</span> 表名;</code></pre></li><li><p>查看索引：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">FROM</span> 表名;</code></pre></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>3.대학교 삼 학년</category>
      
      <category>05.数据库系统原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大三课程</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04.SpringBoot--学习笔记</title>
    <link href="/2020/07/07/SpringBoot--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/07/SpringBoot--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot–学习笔记-包含SpringBoot视频"><a href="#SpringBoot–学习笔记-包含SpringBoot视频" class="headerlink" title="SpringBoot–学习笔记(包含SpringBoot视频)"></a>SpringBoot–学习笔记(包含SpringBoot视频)</h1><h2 id="Lesson1-SpringBoot概述"><a href="#Lesson1-SpringBoot概述" class="headerlink" title="Lesson1 SpringBoot概述"></a>Lesson1 SpringBoot概述</h2><h3 id="NO1-1-SpringBoot简介与入门"><a href="#NO1-1-SpringBoot简介与入门" class="headerlink" title="NO1.1 SpringBoot简介与入门"></a>NO1.1 SpringBoot简介与入门</h3><p>SpringBoot用于快速开发单个微服务项目。</p><ul><li>SpringBoot：<ul><li>定义：SpringBoot是简化了Spring应用开发的一个框架；是整个Spring技术栈的一个大整合，J2EE开发的一站式解决方案(SpringCloud则是分布式整体解决方案)；</li><li>优点：<ul><li>快速创建独立运行的Spring项目以及与主流框架集成；</li><li>使用嵌入式的Servlet容器，应用无需打成WAR包；</li><li>starters(启动器)自动依赖与版本控制；</li><li>大量的自动配置，简化开发，也可修改默认值；</li><li>无需配置XML，无代码生成，开箱即用；</li><li>与云计算的天然集成等等。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>两种方式创建SpringBoot工程：</p><ul><li><p>普通方式创建SpringBoot工程：</p><ul><li><p>创建普通的Maven项目，在pom.xml中继承父工程依赖；</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    说明：一.groupid和artifactId被统称为“坐标”，是为了保证项目唯一性而提出的；groupId一般分为多个段，这里只说两段，第一段为域，第二段为公司名称；域又分为org、com、cn等等许多，其中org为非营利组织，com为商业组织，cn为中国；如，apache公司的tomcat项目，这个项目的groupId是org.apache，它的域是org(因为tomcat是非营利项目)，公司名称是apache，artigactId是tomcat；二.在使用Maven创建基于SpringBoot的项目后，如果父工程中SpringBoot版本为1开头的，则JDK版本最高为JDK7，尽量使用JDK7，所以需要在pom.xml中修改JDK的版本，修改为1.7；如果父工程中SpringBoot版本为2开头的，则JDK版本最低为JDK8，尽量使用JDK8；导入2开头的版本时，已经自动修改了JDK为JDK8，不需要我们手动修改JDK；但是要添加一个属性 <span class="hljs-tag">&lt;<span class="hljs-name">maven-jar-plugin.version</span>&gt;</span>，如下所示；然后右键项目，选择Maven选项，选择Update Project，更新项目(IDEA中选择Reimport就行了)，SpringBoot项目基本创建成功；<span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">maven-jar-plugin.version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">maven-jar-plugin.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>三、父项目spring-boot-starter-parent往上找，发现这个父项目还依赖另一个父项目spring-boot-starter-dependencies，而这个父项目中的<span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>标签中则管理了大量的依赖版本，这也是为什么我们导入依赖之后，不需要指定版本号的原因。</code></pre></li><li><p>导入Web的依赖(其实就是管理好的JAR包)，该依赖的作用是导入了Web模块正常运行所依赖的组件，并且使得启动项目之后会挂起而不会启动后就立马将项目关闭；</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Web依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></li><li><p>编写启动类；</p><pre><code class="hljs java"><span class="hljs-comment">//这是SpringBoot的启动类，从这里启动SpringBoot</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(app<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;注意：一、启动类一定要加注解：<span class="hljs-meta">@SpringBootApplication</span>，因为<span class="hljs-meta">@SpringBootApplication</span>是SprnigBoot项目的核心注解，目的是开启自动配置，并注明SpringBoot的启动类；二、main方法体里的“SpringApplication.run(启动类<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;”，启动类<span class="hljs-class">.<span class="hljs-keyword">class</span>中的启动类指的是当前类名，如例子中的启动类.<span class="hljs-title">class</span>则为<span class="hljs-title">app</span>.<span class="hljs-title">class</span>；</span><span class="hljs-class"></span>三、当Maven项目中的某一个JAR包报错出异常时，只需要到Maven的本地仓库(我的仓库是E:\repository)下，找到报错的JAR包所对应的上一级文件夹，把整个对应的文件夹删除，然后右键项目，选择Maven选项，选择Update Project，更新项目(IDEA中选择Reimport就行了)，就会自动下载缺失的JAR包了。</code></pre><p><strong><code>注意：启动类不能直接放在main/java下。启动类所在的包是最顶部的包，也就是说你创建好包的总路径之后，第一个创建的就是SpringBoot启动类，且启动类和controller、service、domain等等这些包必须是同一级别的，而不能放入前面说的任意一个包之中。</code></strong></p><p><img src="./Image-sb1.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb2.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li><li><p>在IDEA中使用Maven创建SpringBoot工程(推荐)；</p><ul><li><p>点击菜单栏中的file，选择new，选择project或在项目启动的时候选择new create a new project；出现如下对话框；</p><p><img src="./Image-sb3.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>设置工程信息；</p><p><img src="./Image-sb4.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>选择要导入的依赖；</p><p><img src="./Image-sb5.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>完成创建；</p><p><img src="./Image-sb6.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>工程创建后的目录结构；</p><p><img src="./Image-sb7.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb8.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>@RestController注解和@Controller注解的区别；<ul><li>@RestController注解：相当于@Controller+@ResponseBody两个注解的结合，将结果封装成json格式的数据然后再返回，且不需要在方法前面加@ResponseBody注解了，但使用@RestController这个注解，就不能返回jsp、html页面；</li><li>@Controller注解：想要返回json数据，可以跟@ResponseBody注解一起使用；想要进行视图的跳转，则返回字符串路径；</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson2-SpringBoot基础"><a href="#Lesson2-SpringBoot基础" class="headerlink" title="Lesson2 SpringBoot基础"></a>Lesson2 SpringBoot基础</h2><h3 id="NO2-1-SpringBoot的配置文件"><a href="#NO2-1-SpringBoot的配置文件" class="headerlink" title="NO2.1 SpringBoot的配置文件"></a>NO2.1 SpringBoot的配置文件</h3><p>SpringBoot的配置文件常用的主要有两种：一种是properties文件，另一种则是yml(或者yaml)文件。</p><ul><li><p>SpringBoot中允许的配置文件形式：properties配置文件、yml(或者yaml)配置文件，也就是说文件结尾分别为<code>.properties</code>和<code>.yml(或.yaml)</code>。</p><ul><li><p>properties配置文件：主要以键值对的形式进行配置；</p><pre><code class="hljs properties"><span class="hljs-attr">name</span>=<span class="hljs-string">dengyanfei</span></code></pre></li><li><p>yml配置文件(或yaml配置文件)：主要以缩进的形式来表示层级关系。</p><ul><li><p>优点：</p><ul><li>yml中解决了中文乱码问题，也不需要我们去特别的注意；</li><li>支持<code>${}</code>形式的随机数获取、配置文件里的某个属性的值获取等等。<code>如，${random.int}、${random.uuid}，${person.name:aaa}，这表示如果没有获取到person.name的值，就使用aaa作为内容替代进去</code>。</li></ul></li><li><p>基本语法格式：<code>参数名:空格 参数值</code>，即冒号后面紧跟空格，空格后再跟参数值；</p><pre><code class="hljs yaml"><span class="hljs-comment">#普通数据形式：</span><span class="hljs-attr">name:</span> <span class="hljs-string">ddd</span><span class="hljs-comment">#注意：</span><span class="hljs-string">一、字符串不用加引号。</span><span class="hljs-string">二、如果要使用引号，双引号中如果有特殊字符，则不会转义该特殊字符，特殊字符会发生作用；单引号则相反，单引号会转义特殊字符，使得特殊字符作为内容的一部分输出</span><span class="hljs-string">//----------------------------------------</span><span class="hljs-comment">#对象数据形式：分为行内写法和yml写法两种可选</span><span class="hljs-comment">#行内写法</span><span class="hljs-attr">person:</span> <span class="hljs-string">&#123;name:</span> <span class="hljs-string">dyf,</span> <span class="hljs-attr">sex:</span> <span class="hljs-string">男&#125;</span>  <span class="hljs-comment">#yml写法</span><span class="hljs-attr">person:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">dyf</span>  <span class="hljs-attr">sex:</span> <span class="hljs-string">男</span><span class="hljs-string">//----------------------------------------</span><span class="hljs-comment">#数组形式：空格之后，用-表示数组的每一个元素，同样也分为行内写法和yml写法</span><span class="hljs-comment">#行内写法</span><span class="hljs-attr">pets:</span> <span class="hljs-string">[cat,pig,dog]</span><span class="hljs-comment">#yml写法</span><span class="hljs-attr">pets:</span>    <span class="hljs-string">-cat</span>  <span class="hljs-string">-pig</span>  <span class="hljs-string">-dog</span><span class="hljs-string">//----------------------------------------</span><span class="hljs-comment">#~表示null</span><span class="hljs-attr">student:</span> <span class="hljs-string">~</span> <span class="hljs-string">//----------------------------------------</span><span class="hljs-comment">#使用yml文件也可以给Dog对象赋值</span><span class="hljs-attr">dog:</span><span class="hljs-comment">#这里使用了松散绑定，意思就是这里写的last-name，与Dog类中的lastName进行了绑定，即last-name中的-后面的字母变成了大写，这就是松散绑定</span>  <span class="hljs-attr">last-name:</span> <span class="hljs-string">wangcai</span>  <span class="hljs-attr">age:</span> <span class="hljs-number">6</span><span class="hljs-comment">#创建Dog类，并在类上使用@Component注解和@ConfigurationProperties(prefix = "dog")，前者注解的作用是告诉SpringBoot这是一个组件，扫描这个类并生成bean对象，后者注解的作用是将配置文件中的值赋值到这个注解下的类所生成的对象中去，简单说就是赋值的作用，prefix属性，用来匹配配置文件中指定的值的，即prefix属性后面的值，配置文件中必须要出现，否则会赋值失败</span><span class="hljs-string">@Component</span><span class="hljs-string">@ConfigurationProperties(prefix</span> <span class="hljs-string">=</span> <span class="hljs-string">"dog"</span><span class="hljs-string">)</span>  <span class="hljs-string">//将配置文件中dog的配置，绑定到这个这个类所产生的对象中去，简单的说就是赋值</span><span class="hljs-string">public</span> <span class="hljs-string">class</span> <span class="hljs-string">Dog</span> <span class="hljs-string">&#123;</span>    <span class="hljs-string">private</span> <span class="hljs-string">String</span> <span class="hljs-string">lastName;</span>    <span class="hljs-string">private</span> <span class="hljs-string">Integer</span> <span class="hljs-string">age;</span>    <span class="hljs-string">....get、set、toString方法....</span><span class="hljs-string">&#125;</span><span class="hljs-string">注意：</span><span class="hljs-string">一、如果application.properties全局配置文件中，没有dog类需要的对象，则使用@PropertySource注解用于加载指定的配置文件(如，dog.properties文件)，将需要的dog对象赋值到Dog类中去；</span><span class="hljs-string">二、@Import注解用来导入@Configuration注解的配置类、声明@Bean注解的bean方法、导入ImportSelector的实现类或导入ImportBeanDefinitionRegistrar的实现类，也就是为它们创建Bean对象以便容器引入；@ImportResource是引入spring配置文件.xml。</span></code></pre><p><img src="./Image-sb9.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>SpringBoot配置文件的位置：SpringBoot启动会扫描以下位置的application.yml或者 application.properties文件作为SpringBoot的默认配置文件。<strong><code>注意：配置文件的有优先级，高优先级的配置会覆盖低优先级的配置，所有的配置会形成互补配置(意思就是，除了都有的配置部分，高优先级里没配置的，恰好低优先级里又配置了的，则也会使用低优先级里的配置，这就是互补配置)。</code></strong></p><ul><li><p>项目内的配置文件位置(配置文件的读取优先级按顺序从高到低)；</p><ul><li><code>file:./config/</code>：即根目录下的config目录下。这个位置的配置文件会最先读取；</li><li><code>file:./</code>：即根目录下；</li><li><code>classpath:/config/</code>：即classpath路径下的config目录下，也就是在resources目录下创建的config目录里；</li><li><code>classpath:/</code>：即classpath路径下，也就是我们常说的resources目录里。最后读取这里的配置文件。</li></ul></li><li><p>多环境切换配置文件；</p><pre><code class="hljs yaml"><span class="hljs-comment">#我们开发中，有时候会在SpringBoot项目中放入多个配置文件。如，application.properties、application-test.properties、application-dev.properties，这个时候SpringBoot会默认启动名称为application.properties的配置文件，但是我想使用别的配置文件怎么办呢？只需要在application.properties配置文件中写入如下代码即可启用别的配置文件了，但是要创建三个不同配置文件</span><span class="hljs-comment">#这个表示在application.properties中启用别的配置文件</span><span class="hljs-string">spring.profiles.active=test</span>  <span class="hljs-string">//-----------------------------------------------------------</span><span class="hljs-comment">#在yml配置文件中极大简化了以上配置，只需要创建一个ymal配置文件即可</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><span class="hljs-comment">#使用spring.profiles.active指定生效的环境配置</span><span class="hljs-attr">spring:</span>   <span class="hljs-attr">profiles:</span>     <span class="hljs-attr">active:</span> <span class="hljs-string">test</span><span class="hljs-comment">#这里的---表示分割了一个文档模块，即---之下的是一个模块，---之上又是一个模块</span><span class="hljs-meta">---</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8082</span><span class="hljs-comment">#spring.profiles就是环境标识，即给这个环境起个名称，以供别的配置文件调用</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">test</span><span class="hljs-meta">---</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8083</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span></code></pre><p><img src="./Image-sb12.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb13.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb14.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>spring-boot-starter-parent的作用与SpringBoot自动配置源码解析；</p><ul><li><p>spring-boot-starter-parent的作用；</p><pre><code class="hljs xml">//发现每个新建的SpringBoot项目都有一个父依赖<span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>x.x.x.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>说明：一、spring-boot-starter-parent是一个SpringBoot项目，是所有SpringBoot项目的父工程，它定义了很多当前项目的规范：    1.定义了Java编译版本为1.8；    2.使用UTF-8格式编码；    3.继承自spring-boot-dependencies，这个里边定义了大量的依赖的版本号，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号；    4.执行打包操作的配置；    5.自动化的资源过滤；    6.自动化的插件配置；    7.针对application.properties和application.yml的资源过滤，包括通过profile定义的不同环境的配置文件，如，application-dev.properties 和 application-dev.yml；//------------------------------------------------------//每个SpringBoot项目中web依赖的作用<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>说明：一、web依赖中，包含了一个内置的Tomcat容器</code></pre></li><li><p>SpringBoot自动配置源码解析(重要)；</p><pre><code class="hljs java"><span class="hljs-comment">//1.我们可以发现，在使用main()方法启动SpringBoot的时候，只有一个注解@SpringBootApplication</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      SpringApplication.run(App<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;   &#125;&#125;<span class="hljs-comment">//2.我们可以点击进去@SpringBootApplication注解中看看，可以发现有三个注解是比较重要的</span><span class="hljs-meta">@Target</span>(ElementType.TYPE)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-meta">@Inherited</span><span class="hljs-meta">@SpringBootConfiguration</span>  <span class="hljs-comment">//我们点进去以后可以发现底层是Configuration注解，说白了这个注解的作用就是支持JavaConfig的方式来进行配置(也就是写一个类，在类上使用@Configuration注解来告诉容器这是一个配置类，帮我生成bean对象，而使用Configuration配置类等同于XML文件中的&lt;bean&gt;标签的使用)</span><span class="hljs-meta">@EnableAutoConfiguration</span>  <span class="hljs-comment">//该注解的作用是开启自动配置功能</span><span class="hljs-meta">@ComponentScan</span>(excludeFilters = &#123; <span class="hljs-meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>),</span><span class="hljs-class">      @<span class="hljs-title">Filter</span>(<span class="hljs-title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>) &#125;)  //这个注解的作用就是扫描注解，默认是扫描当前类下的<span class="hljs-title">package</span>，将@<span class="hljs-title">Controller</span>/@<span class="hljs-title">Service</span>/@<span class="hljs-title">Component</span>/@<span class="hljs-title">Repository</span>等注解加载到<span class="hljs-title">IOC</span>容器中</span><span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">SpringBootApplication</span> </span>&#123;    ....&#125;<span class="hljs-comment">//3.我们知道SpringBoot可以帮我们减少很多的配置，也肯定听过“约定大于配置”这么一句话，那SpringBoot是怎么做的呢？其实靠的就是@EnableAutoConfiguration注解；简单来说，这个注解可以帮助我们自动载入应用程序所需要的所有默认配置，我们点进去看一下，发现有两个比较重要的注解</span><span class="hljs-meta">@Target</span>(ElementType.TYPE)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-meta">@Inherited</span><span class="hljs-meta">@AutoConfigurationPackage</span>  <span class="hljs-comment">//这个注解的作用是自动配置包，在默认的情况下就是将：主配置类(@SpringBootApplication)的所在包及其子包里边的组件扫描到Spring容器中</span><span class="hljs-meta">@Import</span>(AutoConfigurationImportSelector<span class="hljs-class">.<span class="hljs-keyword">class</span>)  //@<span class="hljs-title">Import</span>通过快速导入的方式实现把需要的实例加入<span class="hljs-title">spring</span>的<span class="hljs-title">IOC</span>容器中，但@<span class="hljs-title">Import</span>只能用在类上</span><span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">EnableAutoConfiguration</span> </span>&#123;    <span class="hljs-comment">//自动配置的开关，当我们程序使用了@EnableAutoConfiguration，如果想要关掉自动配置，只需在application.properties文件中加上，spring.boot.enableautoconfiguration = false 或者spring.boot.enable-auto-configuration = false</span>    String ENABLED_OVERRIDE_PROPERTY = <span class="hljs-string">"spring.boot.enableautoconfiguration"</span>;    <span class="hljs-comment">//想要排除哪些自动配置类</span>    Class&lt;?&gt;[] exclude() <span class="hljs-keyword">default</span> &#123;&#125;;    <span class="hljs-comment">//同上，只不过使用类的完全限定名</span>    String[] excludeName() <span class="hljs-keyword">default</span> &#123;&#125;;&#125;<span class="hljs-comment">//4.我们回到@Import(AutoConfigurationImportSelector.class)这句代码上，再点进去AutoConfigurationImportSelector.class看看具体的实现是什么</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoConfigurationImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DeferredImportSelector</span>, <span class="hljs-title">BeanClassLoaderAware</span>,</span><span class="hljs-class">      <span class="hljs-title">ResourceLoaderAware</span>, <span class="hljs-title">BeanFactoryAware</span>, <span class="hljs-title">EnvironmentAware</span>, <span class="hljs-title">Ordered</span> </span>&#123;    ....这里省略了成员变量....    <span class="hljs-comment">//这个方法的作用是表明哪些自动配置类是要加入到容器中</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;        <span class="hljs-comment">//判断spring.boot.enable-auto-configuration属性值</span>        <span class="hljs-keyword">if</span> (!isEnabled(annotationMetadata)) &#123;                    <span class="hljs-comment">//返回一个空数组，不选择任何一个自动配置类，即关闭自动配置</span>            <span class="hljs-keyword">return</span> NO_IMPORTS;        &#125;        AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(<span class="hljs-keyword">this</span>.beanClassLoader);        <span class="hljs-comment">//这里的方法是重点</span>        AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);        <span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> AutoConfigurationEntry <span class="hljs-title">getAutoConfigurationEntry</span><span class="hljs-params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!isEnabled(annotationMetadata)) &#123;            <span class="hljs-keyword">return</span> EMPTY_ENTRY;        &#125;        AnnotationAttributes attributes = getAttributes(annotationMetadata);        <span class="hljs-comment">//这个方法的作用是，获取META-INF/spring.factories文件中，org.springframework.boot.autoconfigure.EnableAutoConfiguration属性值，也就是得到了要进行自动配置的类的名称所组成的这么一个集合，这个方法在该类的下面</span>        List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);                <span class="hljs-comment">//移除重复自动配置类</span>        configurations = removeDuplicates(configurations);        <span class="hljs-comment">//获取exclude属性以及excludeName属性指定的类，将这些自动配置类跳过</span>        Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);        <span class="hljs-comment">//校验这些排除类</span>        checkExcludedClasses(configurations, exclusions);        <span class="hljs-comment">//从自动配置类集合中移除排除的类</span>        configurations.removeAll(exclusions);        <span class="hljs-comment">//对剩下的自动配置类做一个过滤，具体不展开了</span>        configurations = filter(configurations, autoConfigurationMetadata);        fireAutoConfigurationImportEvents(configurations, exclusions);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AutoConfigurationEntry(configurations, exclusions);    &#125;        ....省略了一些其他内容<span class="hljs-comment">//-----------------------------------------------------</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title">getCandidateConfigurations</span><span class="hljs-params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;        <span class="hljs-comment">//点开方法 getCandidateConfigurations()，其中核心方法是这个</span>        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());        Assert.notEmpty(configurations, <span class="hljs-string">"No auto configuration classes found in META-INF/spring.factories. If you "</span>+ <span class="hljs-string">"are using a custom packaging, make sure that file is             correct."</span>);        <span class="hljs-keyword">return</span> configurations;    &#125;    <span class="hljs-keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;       <span class="hljs-keyword">return</span> EnableAutoConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;    &#125;&#125;<span class="hljs-comment">//-----------------------------------------------------</span><span class="hljs-comment">//点击上面的loadFactoryNames方法后跳转到这个类里面的方法里</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringFactoriesLoader</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="hljs-string">"META-INF/spring.factories"</span>;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader)</span> </span>&#123;        String factoryTypeName = factoryType.getName();        <span class="hljs-keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader) &#123;        MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);        <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> result;        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//加载的实际是这里，而FACTORIES_RESOURCE_LOCATION的值是META-INF/spring.factories，Spring启动的时候会扫描所有jar路径下的META-INF/spring.factories，将其文件包装成Properties对象，从这个Properties对象获取到key值为EnableAutoConfiguration的数据，然后添加到容器里边</span>            Enumeration&lt;URL&gt; urls = (classLoader != <span class="hljs-keyword">null</span> ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION                                               : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));            result = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();            <span class="hljs-keyword">while</span> (urls.hasMoreElements()) &#123;                URL url = urls.nextElement();                UrlResource resource = <span class="hljs-keyword">new</span> UrlResource(url);                                Properties properties = PropertiesLoaderUtils.loadProperties(resource);                   <span class="hljs-keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;                    String factoryTypeName = ((String) entry.getKey()).trim();                    <span class="hljs-keyword">for</span> (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;                        result.add(factoryTypeName, factoryImplementationName.trim());                    &#125;                &#125;            &#125;            cache.put(classLoader, result);            <span class="hljs-keyword">return</span> result;            &#125;<span class="hljs-keyword">catch</span> (IOException ex) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Unable to load factories from location ["</span> + FACTORIES_RESOURCE_LOCATION + <span class="hljs-string">"]"</span>, ex);        &#125;    &#125;<span class="hljs-comment">//5.查看一下spring.factories里面配置的所有EnableAutoConfiguration的值，以上的操作，将EnableAutoConfiguration的值加入到了容器中，spring.factories文件在org.springframework.boot:spring-boot-autoconfigure:x.x.x RELEASE这个JAR包下</span># Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveRestClientAutoConfiguration,\org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.rest.RestClientAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration<span class="hljs-comment">//6.总结：@SpringBootApplication等同于下面三个注解：@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan；其中@EnableAutoConfiguration是关键(启用自动配置)，内部实际上就去加载META-INF/spring.factories文件的信息，然后筛选出以EnableAutoConfiguration为key的数据，加载到IOC容器中，实现自动配置功能</span><span class="hljs-comment">//7.以HttpEncodingAutoConfiguration(springmvc自动配置)，来解释xxxAutoConfiguration类是如何进行自动配置, 和SpringBoot中的默认值是以什么样的方式给予他默认值的</span><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span><span class="hljs-meta">@EnableConfigurationProperties</span>(HttpEncodingProperties<span class="hljs-class">.<span class="hljs-keyword">class</span>)  //启动指定类的@<span class="hljs-title">ConfigurationProperties</span>注解的功能，也就是将全局配置文件中对应的用户设置的属性值和<span class="hljs-title">HttpEncodingProperties</span>绑定起来，并把<span class="hljs-title">HttpEncodingProperties</span>加入到<span class="hljs-title">IOC</span>容器中，也就是生成这个类的<span class="hljs-title">bean</span>对象；因为如果一个配置类只配置@<span class="hljs-title">ConfigurationProperties</span>注解，而没有使用@<span class="hljs-title">Component</span>，那么在<span class="hljs-title">IOC</span>容器中是获取不到<span class="hljs-title">properties</span>配置文件生成的<span class="hljs-title">bean</span>对象的；说白了@<span class="hljs-title">EnableConfigurationProperties</span>相当于把使用@<span class="hljs-title">ConfigurationProperties</span>注解的类进行了一次注入，也就是生成<span class="hljs-title">bean</span>对象的意思</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnWebApplication</span>(<span class="hljs-title">type</span> </span>= ConditionalOnWebApplication.Type.SERVLET)  <span class="hljs-comment">//Spring底层@Conditional注解，根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效</span><span class="hljs-meta">@ConditionalOnClass</span>(CharacterEncodingFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)  //判断应用中有没有这个类<span class="hljs-title">CharacterEncodingFilter</span>，如果有，当前配置类生效</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnProperty</span>(<span class="hljs-title">prefix</span> </span>= <span class="hljs-string">"spring.http.encoding"</span>, value = <span class="hljs-string">"enabled"</span>, matchIfMissing = <span class="hljs-keyword">true</span>)  <span class="hljs-comment">//判断在配置文件中年是否存在配置spring.http.encoding，如果不存在，则判断成立，使用默认的属性spring.http.encoding.enabled = true</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span> </span>&#123;    <span class="hljs-comment">//注入HttpEncodingProperties的</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HttpEncodingProperties properties;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span><span class="hljs-params">(HttpEncodingProperties properties)</span> </span>&#123;        <span class="hljs-comment">//参数的值从容器中取出</span>        <span class="hljs-keyword">this</span>.properties = properties;    &#125;    <span class="hljs-meta">@Bean</span>  <span class="hljs-comment">//容器中添加组件，组件的某些值要从properties获取</span>    <span class="hljs-meta">@ConditionalOnMissingBean</span>  <span class="hljs-comment">//判断有误这个组件CharacterEncodingFilter</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CharacterEncodingFilter <span class="hljs-title">characterEncodingFilter</span><span class="hljs-params">()</span> </span>&#123;        CharacterEncodingFilter filter = <span class="hljs-keyword">new</span> OrderedCharacterEncodingFilter();        filter.setEncoding(<span class="hljs-keyword">this</span>.properties.getCharset().name());        filter.setForceRequestEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(Type.REQUEST));        filter.setForceResponseEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(Type.RESPONSE));        <span class="hljs-keyword">return</span> filter;    &#125;    ....省略其他一些配置&#125;</code></pre><p><strong><code>注意：下图是常用的@Conditional注解的派生类。</code></strong></p><p><img src="./Image-sb15.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb16.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-2-SpringBoot的日志"><a href="#NO2-2-SpringBoot的日志" class="headerlink" title="NO2.2 SpringBoot的日志"></a>NO2.2 SpringBoot的日志</h3><p>Java日志框架众多，常用的有<code>java.util.logging(即JUL)</code>、<code>log4j</code>、<code>logback</code>、<code>commons-logging</code>等等。</p><ul><li><p>SpringBoot采用了<code>slf4j+logback</code>的组合形式，且SpringBoot也提供对JUL、log4j2、Logback提供了默认配置；常用日志框架，如下图所示。</p><p><img src="./Image-sb17.png" srcset="/img/loading.gif" alt="Image"></p><ul><li><p>SpringBoot的默认日志配置；如果要修改默认的日志配置，则需要在全局配置文件application.properties中进行修改；</p><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)  //该注解的作用就是一个运行器，让测试运行于<span class="hljs-title">Spring</span>测试环境，即能够获得<span class="hljs-title">Spring</span>容器并使用它</span><span class="hljs-class">@<span class="hljs-title">SpringBootTest</span></span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">SpringBootLoggerTest</span></span>&#123;    <span class="hljs-comment">//这是日志记录器对象，由日志记录器对象工厂得来</span>    Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testLogger</span><span class="hljs-params">()</span> </span>&#123;        logger.trace(<span class="hljs-string">"这是trace日志..."</span>);        logger.debug(<span class="hljs-string">"这是debug日志..."</span>);        logger.info(<span class="hljs-string">"这是info日志..."</span>);        logger.warn(<span class="hljs-string">"这是warn日志..."</span>);        logger.error(<span class="hljs-string">"这是error日志..."</span>);    &#125;&#125;说明：一、<span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)和@<span class="hljs-title">RunWith</span>(<span class="hljs-title">SpringJUnit4ClassRunner</span>.<span class="hljs-title">class</span>)，这两这的区别是，<span class="hljs-title">SpringRunner</span>继承了<span class="hljs-title">SpringJUnit4ClassRunner</span>，没有扩展任何功能；使用前者，名字简短而已；</span><span class="hljs-class"></span><span class="hljs-class">二、日志的级别：由低到高为，<span class="hljs-title">trace</span> &lt; <span class="hljs-title">debug</span> &lt; <span class="hljs-title">info</span> &lt; <span class="hljs-title">warn</span> &lt; <span class="hljs-title">error</span>，可以调整输出的日志级别，这样就会输出某个级别之后的日志信息，如<span class="hljs-title">info</span>级别，则只会输出<span class="hljs-title">info</span>级别往上的级别的信息，<span class="hljs-title">trace</span>和<span class="hljs-title">debug</span>信息就不会输出了；</span><span class="hljs-class"></span><span class="hljs-class">三、还可以在全局配置文件中，即<span class="hljs-title">application</span>.<span class="hljs-title">properties</span>中配置指定包的日志级别，<span class="hljs-title">logging</span>.<span class="hljs-title">level</span>.指定包的全路径包名</span>=日志级别，如，logging.level.cn.dyf=trace，这样就将cn.dyf包下的所有类的日志级别设置为了trace；四、SpringBoot默认给我们使用的是info级别的，如果我们没有指定级别的话就用SpringBoot默认规定的级别：root级别，其实这个root级别就是info级别，只是称呼不一样，也可以在全局配置文件中设置root级别，使用logging.level.root=日志级别；五、配置日志输出的路径或文件名称：logging.file.path或logging.file.name，前者配置日志文件的输出路径(就是把这个日志文件放到哪里去，而SpringBoot默认的日志文件名称是spring.log)，后者配置的则是输出的日志信息文件的名称，但是这两个只能配置其中一个，因为官网说明只能生效一个；六、配置日志信息的格式，使用logging.pattern.console=日志格式，这是指定控制台输出的日志信息格式；使用logging.pattern.file=日志格式，这是指定向文件中输出的日志信息格式；而日志输出格式：%d表示日期时间；%thread表示线程名；%-<span class="hljs-number">5l</span>evel表示级别从左显示<span class="hljs-number">5</span>个字符宽度；%logger&#123;<span class="hljs-number">50</span>&#125;表示logger名字最长<span class="hljs-number">50</span>个字符，否则按照句点分割；%msg：日志消息；%n是换行符，如，%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-<span class="hljs-number">5l</span>evel %logger&#123;<span class="hljs-number">50</span>&#125; - %msg%n。</code></pre></li><li><p>指定日志配置；<strong><code>注意：指定日志的配置需要在类路径(就是Resources文件夹下)的logback.xml(不同的日志框架用不同的配置文件名称就行了)中进行配置自己想要定义的配置。</code></strong></p><p><img src="./Image-sb18.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb19.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-3-SpringBoot的Web开发"><a href="#NO2-3-SpringBoot的Web开发" class="headerlink" title="NO2.3 SpringBoot的Web开发"></a>NO2.3 SpringBoot的Web开发</h3><p>SpringBoot中也提供了用于web层开发使用的一些技术栈，但web毕竟不是我们Java该干的主要事情，所以只介绍几个。</p><ul><li><p>SpringBoot对静态资源的映射，也就是对图片、js、css等资源的访问，提供了一套默认配置，一般该默认配置就足够开发使用。</p><pre><code class="hljs java"><span class="hljs-comment">//SpringBoot默认将对“/**”所有访问映射到以下目录</span>classpath:/<span class="hljs-keyword">static</span>，其实就是Maven工程里的resources文件夹下的<span class="hljs-keyword">static</span>文件夹classpath:/<span class="hljs-keyword">public</span>，其实就是Maven工程里的resources文件夹下的<span class="hljs-keyword">public</span>文件夹classpath:/resources，其实就是Maven工程里的resources文件夹下的resources文件夹classpath:/META-INF/resources，其实就是Maven工程里的resources文件夹下的META-INF文件夹下边的resources文件夹下说明：一、classpath在maven项目中指的就是resources文件夹，在不是maven的项目中指的是WEB-INF/classes；二、还可以自定义静态资源的文件夹，也就是你来定义哪个或哪些文件夹用来存放静态资源，但是这样会修改SpringBoot默认对静态资源的映射，也就是上面所提到的那些路径将不再生效，而是采用你定义的文件夹存放静态资源，使用spring.resources.<span class="hljs-keyword">static</span>-locations=classpath:/aaa,classpath:/ddd，这样就表示类路径下的aaa和ddd文件夹才是存放静态资源的文件夹了；三、所有对“/webjars<span class="hljs-comment">/**”的请求，都会去classpath:META-INF/resources/webjars文件夹下找资源；如js、css资源等等，webjars是指以JAR包的方式引入静态资源；</span><span class="hljs-comment"></span><span class="hljs-comment">四、SpringBoot访问静态资源，默认有两个默认目录,一个是classpath/static目录(src/mian/resource)，一个是ServletContext根目录下(src/main/webapp)。</span></code></pre></li></ul><p>&nbsp;</p><ul><li><p>SpringBoot中使用模板引擎Thymeleaf。</p><ul><li><p>介绍：简单的说，Thymeleaf是一个跟 Velocity、FreeMarker类似的模板引擎，它可以完全替代JSP；SpringBoot中默认的模板映射路径是：<code>src/main/resources/templates</code>，也就是说静态页面是放在这里的；</p></li><li><p>基本步骤：</p><ul><li><p>导入Thymeleaf的依赖；</p><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>把要展示的html页面放入到classpath:/templates文件夹下(也就是放入Maven工程里的resources下的templates里面，没有templates这个文件夹的话，创建一个就可以了)；</p></li><li><p>在html页面中导入Thymeleaf的命名空间；</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span></code></pre></li><li><p>最后使用Thymeleaf的语法渲染页面即可，Thymeleaf的语法前缀是：<code>th</code>；<strong><code>并且；注意：th:任意html属性，使用这种形式可以替换原生属性的值。如&lt;div id=&quot;xx&quot;&gt;，可以写成&lt;div th:id=&quot;xxx&quot;&gt;。</code></strong></p><ul><li><p>基本语法格式：</p><ul><li><p><code>th:text</code>：这个语法的基本作用就是显示文本，也可以用于一些简单的运算(加减乘除)，用于HTML标签的内部；</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;msg&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        如果需要对取出的值作字符串的拼接操作，在值前面多添加一个''就行了，也就是添加一个空字符串，如：<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"'' + $&#123;msg&#125; + '123'"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre></li><li><p><code>th:value</code>：这个语法用于给value属性赋值；</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">"$&#123;user.name&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>     等价于 <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"xxx"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></code></pre></li><li><p><code>th:if</code>：这个标签用于判断是否满足条件，还可以多条件 and，or(二元操作符)，!，not非(一元操作符)；</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"$&#123;msg&#125; == '男'"</span>&gt;</span>性别：男<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre></li><li><p><code>th:switch和th:case搭配</code>：这个标签用于多选一，即符合哪个条件就走哪里；</p><pre><code class="hljs html">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:switch</span>=<span class="hljs-string">"$&#123;msg&#125;"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">"男"</span>&gt;</span>我是男的<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">"女"</span>&gt;</span>我是女的<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></li><li><p><code>th:each</code>：该标签用于循环遍历数组，集合；<code>格式：th:each=&quot;自定义变量名,自定义状态变量名:${被遍历的数组或集合}&quot;</code>；<strong><code>注意：该语法用在哪个标签里，那么这个标签每次遍历都会新生成一次。</code></strong></p><pre><code class="hljs html">    <span class="hljs-comment">&lt;!-- 遍历普通集合 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"user,status:$&#123;userList&#125;"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;user.userId&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;user.userName&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;user.userAge&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 以下都是自定义状态变量status的属性 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;status.index&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  ---当前迭代对象的index，即索引值(从0开始计算)            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;status.count&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  ---当前迭代对象的个数，即第几个(从1开始计算)            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;status.size&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  ---被迭代的数组或集合的长度            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;status.even&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  ---当前迭代的对象是否是第偶数个(从0开始计算)            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;status.odd&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  ---当前迭代的对象是否是第奇数个(从0开始计算)            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;status.first&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  ---当前迭代的对象是否是第一个            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;status.last&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  ---当前迭代的对象是否是最后一个            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;status.current&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  ---当前迭代的对象，就是该对象的内存地址值：包名+类名@地址值；        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        //----------------------------------------------------------            <span class="hljs-comment">&lt;!-- 遍历Map集合 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"userEntrySet:$&#123;userMap&#125;"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"husbandKey:$&#123;userEntrySet&#125;"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;husbandKey.key&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"wifeValue:$&#123;userEntrySet&#125;"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;wifeValue.value.userId&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"wifeValue:$&#123;userEntrySet&#125;"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;wifeValue.value.userName&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"wifeValue:$&#123;userEntrySet&#125;"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;wifeValue.value.userAge&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        注意：Map形式的集合，获取到的是一个Key-Value的元素集合，所以需要再一次遍历这个元素集合，就可以分别获得key和value</code></pre></li><li><p><code>th:object</code>：该标签用于表单数据对象绑定，将表单绑定到后台Controller的一个JavaBean参数，常与<code>th:field</code>一起使用进行表单数据绑定；选择表达式<code>*{...}</code>一般跟在th:object后，直接取object中的属性；</p></li></ul></li><li><p>Thymeleaf的表达式；</p><ul><li><p><code>${...}</code>：该表达式为变量表达式，它的作用是从Thymeleaf上下文获取指定变量的值；Thymeleaf提供了一些预定义变量param、session和application，使用<code>${}</code>可以方便地获取这些变量的值；</p><pre><code class="hljs html">获取当前Request中名称为x的参数：$&#123;param.x&#125;获取当前Request域中名称为x的属性：$&#123;#httpServletRequest.getAttribute('x')&#125;获取当前session中名称为x的属性：$&#123;session.x&#125;获取当前ServletContext中名称为x的属性：$&#123;application.x&#125;<span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;welcome&#125;"</span>&gt;</span>这是欢迎问候<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>结果：如果当前上下文存在一个welcome变量的话，就显示这个值，否则显示默认的内容：这是欢迎问候；</code></pre></li><li><p><code>@{...}</code>：该表达式为URL表达式，它的作用相当于<code>&lt;a&gt;&lt;/a&gt;</code>标签的href属性，如果有参数，则在URL后面加个()，参数直接用,隔开即可；</p><pre><code class="hljs html">无参的URL：<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@&#123;/order/list&#125;"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>带参数的URL：<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@&#123;/order/details(id=$&#123;xxx&#125;,type=$&#123;xxx&#125;)&#125;"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>相对地址：<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@&#123;../documents/report&#125;"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>绝对地址：<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@&#123;http://www.baidu.com&#125;"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></li><li><p><code>*{...}</code>：该表达式为选择表达式，选择表达式一般跟在th:object后，直接选择object中的属性；<code>*{...}</code>表达式的值是在选定的对象；也就是说，如果没有选定的对象，<code>*{...}</code>和<code>${...}</code>没有区别；</p></li></ul></li><li><p>Thymeleaf中的常用内置对象；</p><ul><li><p><code>#dates</code>：日期格式化内置对象，具体方法可以参照java.util.Date；</p><ul><li><p>格式化日期；</p><pre><code class="hljs html">$&#123;#dates.format(XXX)&#125;，如果没有设置日期格式，默认使用浏览器默认的语言进行格式化日期$&#123;#dates.format(XXX,'yyyy年MM月dd日 HH时mm分ss秒')&#125;，指定日期格式进行格式化日期</code></pre></li></ul></li><li><p><code>#calendars</code>：类似于<code>#dates</code>，但却是java.util.Calendar类的方法；</p></li><li><p><code>#numbers</code>：数字格式化；</p></li><li><p><code>#strings</code>：字符串格式化，具体方法可以参照java.lang.String，如startsWith、contains等；</p><pre><code class="hljs smalltalk"><span class="hljs-string">$&#123;</span><span class="hljs-symbol">#strings</span>.isEmpty(<span class="hljs-type">XXX</span>)&#125;：用于判断字符串是否为空，是就返回<span class="hljs-keyword">true</span>，否则返回<span class="hljs-keyword">false</span>；<span class="hljs-string">$&#123;</span><span class="hljs-symbol">#strings</span>.contains(<span class="hljs-type">XXX</span>,<span class="hljs-string">'x'</span>)&#125;：用于判断字符串是否包含指定子字符串，包含就返回<span class="hljs-keyword">true</span>，否则返回<span class="hljs-keyword">false</span>；<span class="hljs-string">$&#123;</span><span class="hljs-symbol">#strings</span>.startsWith(<span class="hljs-type">XXX</span>,<span class="hljs-string">'x'</span>)&#125;：用于判断字符串是否以子字符串开头，是就返回<span class="hljs-keyword">true</span>，否则返回<span class="hljs-keyword">false</span>；<span class="hljs-string">$&#123;</span><span class="hljs-symbol">#strings</span>.endsWith(<span class="hljs-type">XXX</span>,<span class="hljs-string">'x'</span>)&#125;：用于判断字符串是否以子字符串结尾，是就返回<span class="hljs-keyword">true</span>，否则返回<span class="hljs-keyword">false</span>；<span class="hljs-string">$&#123;</span><span class="hljs-symbol">#strings</span>.length(<span class="hljs-type">XXX</span>)&#125;：用于获取字符串的长度；<span class="hljs-string">$&#123;</span><span class="hljs-symbol">#strings</span>.indexOf(<span class="hljs-type">XXX</span>,<span class="hljs-string">'x'</span>)&#125;：用于获取字符串中指定子字符串的索引，没有就返回<span class="hljs-number">-1</span>；</code></pre></li><li><p><code>#objects</code>：参照java.lang.Object；</p></li><li><p><code>#bools</code>：判断boolean类型的工具；</p></li><li><p><code>#arrays</code>：数组操作的工具；</p></li><li><p><code>#lists</code>：列表操作的工具，参照java.util.List；</p></li><li><p><code>#sets</code>：Set操作工具，参照java.util.Set；</p></li><li><p><code>#maps</code>：Map操作工具，参照java.util.Map；</p></li><li><p><code>#aggregates</code>：操作数组或集合的工具；</p></li><li><p><code>#messages</code>：操作消息的工具；</p></li></ul></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>SpringBoot中使用JSP。</p><ul><li><p>基本步骤：</p><ul><li><p>需要使用的依赖；</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- JSTL依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- JSP引擎：JASPER依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>在Maven项目的src/main/resource目录下创建application.properties文件，用于配置JSP的前缀和后缀，作用和SpringMVC的视图解析器配置一样。</p><pre><code class="hljs xml">spring.mvc.view.prefix=/WEB-INF/jsp/spring.mvc.view.suffix=.jsp</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>SpringBoot中使用FreeMarker。</p><ul><li><p>介绍：SpringBoot要求模板形式的视图层技术的文件必须要放到src/main/resources目录下的一个名称为templates的包下；</p></li><li><p>FreeMarker的构成：<code>由文本+插值+FTL标签+注释组成</code>；<strong><code>注意：谨记一点，就是插值只能放在文本中，不能放在FTL标签中，不然渲染模板的时候会报错。</code></strong></p><ul><li><p>文本：HTML原来的内容；</p></li><li><p>插值：<code>${}</code>或<code>#{}</code>代表的就是插值，一般来说就是后台传过来的值显示在前台用<code>${}</code>或<code>#{}</code>表示；</p></li><li><p>FTL标签：以标签中含有#的标签。<strong><code>如，&lt;#list&gt;&lt;/#list&gt;，不会显示在界面上，和html标签类似，只不过用#予以区分。</code></strong></p></li><li><p>注释：<code>&lt;#-- 注释 --&gt;</code>。</p><pre><code class="hljs html">正确的示范：<span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>$&#123;user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>错误的示范：<span class="hljs-tag">&lt;<span class="hljs-name">#if</span> $&#123;<span class="hljs-attr">user.name</span>&#125; == <span class="hljs-string">"augus"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span>注意：在FTL标签中，直接user.name即可，也就是对象.属性名称就行，不用插值(即不使用$&#123;&#125;)；实际上，使用标签时前面的#符号也可能变成@，如果该指令是一个用户指令而不是系统内建指令时，应将#符号改为@符号</code></pre></li></ul></li><li><p>定义变量；</p><ul><li><code>&lt;#assign var = value &gt;</code>：定义变量并初始化；</li><li><code>&lt;#assign str = &quot;hello world&quot; &gt;</code>：定义字符串类型；</li><li><code>&lt;#assign num = 13.2 &gt;</code>：定义数字类型；</li><li><code>&lt;#assign flag = true &gt;</code>：定义布尔类型；</li><li><code>&lt;#assign arr = [&quot;foo&quot;, &quot;boo&quot;, &quot;get&quot;]/&gt;</code>：定义数组；</li><li><code>&lt;#assign map={&quot;name&quot;:&quot;augus&quot;, &quot;age&quot;:&quot;16&quot;}&gt;</code>：定义map；</li></ul></li><li><p>标签的使用：</p><ul><li><p>if标签、比较运算符、!空值操作符；</p><pre><code class="hljs html">//if标签<span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">condition</span>&gt;</span>    if条件成立则输出这里的内容xxx<span class="hljs-tag">&lt;<span class="hljs-name">#elseif</span> <span class="hljs-attr">condition</span>&gt;</span>    elseif条件成立则输出这里的内容yyy<span class="hljs-tag">&lt;<span class="hljs-name">#else</span>&gt;</span>    上面两种都不符合，就会输出这里的内容<span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span>//-----------------------------------------//比较运算符x == y (等于)x != y(不等于)x gt y(大于)x gte y (大于等于)x lt y(小于)x lte y(小于等于)//------------------------------------------//!空值操作符，即FreeMarker针对防止null有特定的操作符，也就是说当获取的变量为null时，所采取的措施<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>$&#123;"name:" + name!&#125;<span class="hljs-tag">&lt;<span class="hljs-name">p</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>$&#123;(maxNumber!) + 1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>输出：name:1说明：在页面中并未存在name和maxNumber的，通过加!可以处理null值的存在，如果上述例子不加!操作符，模板加载时会报错 “The following has evaluated to null or missing:”//------------------------------------------//创建一个数值变量<span class="hljs-tag">&lt;<span class="hljs-name">#assign</span> <span class="hljs-attr">num</span> = <span class="hljs-string">13.2</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">num</span> <span class="hljs-attr">gt</span> <span class="hljs-attr">16</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>num大于16<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">#elseif</span> <span class="hljs-attr">num</span> <span class="hljs-attr">lt</span> <span class="hljs-attr">12</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>num小于12<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">#else</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>num在12~16的范围中<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span>输出：num在12~16的范围中</code></pre></li><li><p>FreeMarker的list标签和循环；</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">#list</span> 需要被遍历的目标 <span class="hljs-attr">as</span> 一个自定义变量名称&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span>；<span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">userlist</span> <span class="hljs-attr">as</span> <span class="hljs-attr">user</span> &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.userId&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.userName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.userAge&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span>说明：其中userlist是后台传输给前台的数据，即需要被遍历的对象，user是userlist中的遍历的每一个元素变量</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-4-SpringBoot的异常处理机制"><a href="#NO2-4-SpringBoot的异常处理机制" class="headerlink" title="NO2.4 SpringBoot的异常处理机制"></a>NO2.4 SpringBoot的异常处理机制</h3><p>SpringBoot对于异常处理提供了一些处理机制。</p><ul><li><p>SpringBoot对于处理异常，提供了五种的方式：</p><ul><li><p>自定义错误异常页面。但该方式的缺点是，无论是什么异常都会走这个error.html页面，显得不那么灵活；</p><ul><li>SpringBoot默认处理异常的机制：SpringBoot默认的已经提供了一套处理异常的机制，即一旦程序中出现了异常，SpringBoot会向RequestMappint(“/error”)的url发送请求；在SpringBoot中提供了一个叫BasicExceptionController来处理该请求，然后跳转到默认显示异常的页面来展示异常信息，但该方式通常不是我们所常用的；</li><li>一般我们所使用的就是自定义的异常页面：在src/main/resources/templates下创建一个名称必须为error.html的页面；然后对于错误页面进行一些简单的用户体验设计即可；</li></ul></li><li><p>使用@ExceptionHandler注解处理异常。但该方式的缺点是，当其他包下的Controller里也有同类型的异常时，只能使用本包下定义的@ExceptionHandler，无法使用其他包下Controller里的@ExceptionHandler，即该注解无法跨Controller，必须在本Controller中定义一个@ExceptionHandler才能解决；</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/testException"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testException</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;    <span class="hljs-keyword">int</span> v = <span class="hljs-number">5</span>/<span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;&#125;<span class="hljs-comment">//-----------------------------------------------------------------</span><span class="hljs-meta">@ExceptionHandler</span>(value= &#123;java.lang.ArithmeticException<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">ModelAndView</span> <span class="hljs-title">getException</span>(<span class="hljs-title">Exception</span> <span class="hljs-title">e</span>) </span>&#123;    ModelAndView mav = <span class="hljs-keyword">new</span> ModelAndView();        <span class="hljs-comment">//存储错误信息和跳转跳转视图</span>    mav.addObject(<span class="hljs-string">"errorMsg"</span>, e.toString());    mav.setViewName(<span class="hljs-string">"error"</span>);    <span class="hljs-keyword">return</span> mav;&#125;说明：访问<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/testException"</span>)时，会触发除数为<span class="hljs-number">0</span>的异常；在捕获异常的方法上添加<span class="hljs-meta">@ExceptionHandler</span>(value=&#123;&#125;)，value的值是一个<span class="hljs-class"><span class="hljs-keyword">class</span>数组，即可以处理多个异常，并且该方法返回了一个<span class="hljs-title">ModelAndView</span>对象，作用是封装异常信息以及设置跳转的视图。</span></code></pre></li><li><p>使用@ControllerAdvice+@ExceptionHandler注解处理异常。但是该方式的缺点是异常越多，需要添加的捕获异常的方法也就越多；</p><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionController</span> </span>&#123;    <span class="hljs-meta">@ExceptionHandler</span>(value= &#123;java.lang.ArithmeticException<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;)</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">ModelAndView</span> <span class="hljs-title">getException</span>(<span class="hljs-title">Exception</span> <span class="hljs-title">e</span>) </span>&#123;        ModelAndView mav = <span class="hljs-keyword">new</span> ModelAndView();        mav.addObject(<span class="hljs-string">"errorMsg"</span>, e.toString());        mav.setViewName(<span class="hljs-string">"error2"</span>);        <span class="hljs-keyword">return</span> mav;    &#125;&#125;说明：<span class="hljs-meta">@ControllerAdvice</span>+<span class="hljs-meta">@ExceptionHandler</span>注解处理异常，需要创建一个能够处理异常的全局异常类，即该注解的作用就是将类定义为全局异常处理类；在该类上需要添加<span class="hljs-meta">@ControllerAdvice</span> 注解，对应捕获异常的方法上添加<span class="hljs-meta">@ExceptionHandler</span>注解，这样就可以跨Controller捕获异常了。</code></pre></li><li><p>配置SimpleMappingExceptionResolver处理异常。但是该方式的缺点是无法传递异常信息；</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionController</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SimpleMappingExceptionResolver <span class="hljs-title">getException</span><span class="hljs-params">()</span> </span>&#123;        SimpleMappingExceptionResolver resolver = <span class="hljs-keyword">new</span> SimpleMappingExceptionResolver();        Properties pp = <span class="hljs-keyword">new</span> Properties();        pp.put(<span class="hljs-string">"java.lang.ArithmeticException"</span>,<span class="hljs-string">"error1"</span>);        pp.put(<span class="hljs-string">"java.lang.NullPointerException"</span>,<span class="hljs-string">"error2"</span>);        resolver.setExceptionMappings(pp);        <span class="hljs-keyword">return</span> resolver;    &#125;&#125;说明：<span class="hljs-meta">@Configuration</span>注解的类和<span class="hljs-meta">@Bean</span>注解的方法，是告诉SpringBoot在启动的时候对该类进行初始化；配置SimpleMappingExceptionResolver处理异常，必须使用<span class="hljs-meta">@Configuration</span>注解类、<span class="hljs-meta">@Bean</span>注解方法；<span class="hljs-meta">@Bean</span>注解的方法必须有返回值：SimpleMappingExceptionResolver，然后创建Properties，设置参数，参数一：异常的类型，注意必须是异常类型的全名；参数二： 视图名称。</code></pre></li><li><p>自定义HandlerExceptionResolver接口实现类来处理异常，这个比较常用(推荐)。</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerExceptionResolver</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse reponse, Object object,Exception ex)</span> </span>&#123;        ModelAndView mav = <span class="hljs-keyword">new</span> ModelAndView();        <span class="hljs-keyword">if</span>(ex <span class="hljs-keyword">instanceof</span> ArithmeticException) &#123;            mav.addObject(<span class="hljs-string">"error1"</span>, ex.toString());            mav.setViewName(<span class="hljs-string">"error1"</span>);        &#125;                <span class="hljs-keyword">if</span>(ex <span class="hljs-keyword">instanceof</span> NullPointerException) &#123;            mav.addObject(<span class="hljs-string">"error2"</span>, ex.toString());            mav.setViewName(<span class="hljs-string">"error2"</span>);        &#125;        <span class="hljs-keyword">return</span> mav;    &#125;&#125;说明：创建一个全局异常处理类实现HandlerExceptionResolver接口，重写resolveException()方法，并在全局异常处理类上使用<span class="hljs-meta">@Configuration</span>注解，resolveException()方法中的Exception ex就是异常对象，可以获得异常信息；使用ex <span class="hljs-keyword">instanceof</span> 异常种类，与异常种类进行匹配，然后进行不同页面的跳转即可。</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-5-SpringBoot注册Servlet"><a href="#NO2-5-SpringBoot注册Servlet" class="headerlink" title="NO2.5 SpringBoot注册Servlet"></a>NO2.5 SpringBoot注册Servlet</h3><p>SpringBoot中也提供了Servlet注册方式。</p><ul><li><p>SpringBoot注册Servlet，有两种方式可用：</p><ul><li><p>注解式完成Servlet的注册；</p><pre><code class="hljs java"><span class="hljs-meta">@WebServlet</span>(name=<span class="hljs-string">"HelloWorld"</span>,urlPatterns=<span class="hljs-string">"/helloWorld"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        System.out.println(<span class="hljs-string">"注解注册Serlvet..."</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(request, response);    &#125;&#125;说明：一定要配置<span class="hljs-meta">@WebServlet</span>(name=<span class="hljs-string">"HelloWorld"</span>,urlPatterns=<span class="hljs-string">"/helloWorld"</span>)注解，其中，name属性是以前&lt;servlet&gt;标签中的&lt;servlet-name&gt;，urlPatterns属性则是以前&lt;servlet&gt;标签中的&lt;url-pattern&gt;------------------------------------------------以上是Servlet的部分<span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@ServletComponentScan</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(App<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;说明：<span class="hljs-meta">@SpringBootApplication</span>，该注解是表明该类是SpringBoot的启动类；<span class="hljs-meta">@ServletComponentScan</span>，该注解则是表明SpringBoot在启动时，会自动去扫描带<span class="hljs-meta">@WebServlet</span>注解的类。------------------------------------------------以上是SpringBoot启动器的部分</code></pre></li><li><p>在配置类中配置Servlet的注册；</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        System.out.println(<span class="hljs-string">"非注解注册Serlvet..."</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(request, response);    &#125;&#125;------------------------------------------------以上是Servlet的部分<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfiguration</span></span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">getSRB</span><span class="hljs-params">()</span> </span>&#123;        ServletRegistrationBean srb = <span class="hljs-keyword">new</span> ServletRegistrationBean(<span class="hljs-keyword">new</span> HelloWorld());        srb.addUrlMappings(<span class="hljs-string">"/helloWorld"</span>);        <span class="hljs-keyword">return</span> srb;    &#125;&#125;注意：<span class="hljs-meta">@Bean</span>的作用就是执行注册Servlet的getSRB()方法，方法名可以自定义；但是返回值一定要是：ServletRegistrationBean类型</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-6-SpringBoot注册Filter"><a href="#NO2-6-SpringBoot注册Filter" class="headerlink" title="NO2.6 SpringBoot注册Filter"></a>NO2.6 SpringBoot注册Filter</h3><p>SpringBoot中也提供了Filter注册方式。</p><ul><li><p>SpringBoot中注册Filter，有两种方式可用：</p><ul><li><p>注解式完成Filter的注册；</p><pre><code class="hljs java"><span class="hljs-meta">@WebFilter</span>(filterName=<span class="hljs-string">"SBFilter"</span>,urlPatterns=<span class="hljs-string">"/helloWorld"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SBFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest arg0, ServletResponse arg1, FilterChain chain)</span><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        System.out.println(<span class="hljs-string">"注解式请求前经过过滤....."</span>);        chain.doFilter(arg0, arg1);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig arg0)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;    &#125;&#125;说明：<span class="hljs-meta">@WebFilter</span>的作用就是过滤对应的请求；urlPatterns是一个字符串数组，即可以同时过滤多种请求。如：urlPatterns=&#123;<span class="hljs-string">"*.do"</span>,<span class="hljs-string">"*.action"</span>&#125;。------------------------------------------------以上是Filter部分<span class="hljs-meta">@WebServlet</span>(name=<span class="hljs-string">"HelloWorld"</span>,urlPatterns=<span class="hljs-string">"/helloWorld"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        System.out.println(<span class="hljs-string">"注解式Filter和Servlet..."</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(request, response);    &#125;&#125;------------------------------------------------以上是Servlet部分<span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@ServletComponentScan</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(App<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;------------------------------------------------以上是SpringBoot启动器的部分</code></pre></li><li><p>在配置类中配置Filter的注册；</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SBFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest arg0, ServletResponse arg1, FilterChain chain)</span><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        System.out.println(<span class="hljs-string">"非注解式请求前经过拦截....."</span>);        chain.doFilter(arg0, arg1);            &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig arg0)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;    &#125;&#125;------------------------------------------------以上是Filter部分<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        System.out.println(<span class="hljs-string">"非注解式Filter和Servlet..."</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doGet(request, response);    &#125;&#125;------------------------------------------------以上是Servlet部分，请求的资源<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfiguration</span></span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">getSRB</span><span class="hljs-params">()</span> </span>&#123;        ServletRegistrationBean srb = <span class="hljs-keyword">new</span> ServletRegistrationBean(<span class="hljs-keyword">new</span> HelloWorld());        srb.addUrlMappings(<span class="hljs-string">"/helloWorld"</span>);        <span class="hljs-keyword">return</span> srb;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">getFRB</span><span class="hljs-params">()</span> </span>&#123;        FilterRegistrationBean frb = <span class="hljs-keyword">new</span> FilterRegistrationBean(<span class="hljs-keyword">new</span> SBFilter());        frb.addUrlPatterns(<span class="hljs-string">"/helloWorld"</span>);        <span class="hljs-keyword">return</span> frb;    &#125;&#125;说明：<span class="hljs-meta">@Bean</span>的作用就是执行注册对应的方法；ServletRegistrationBean注册Servlet需要使用的类；FilterRegistrationBean注册Filter需要使用的类。</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-7-SpringBoot注册Listener"><a href="#NO2-7-SpringBoot注册Listener" class="headerlink" title="NO2.7 SpringBoot注册Listener"></a>NO2.7 SpringBoot注册Listener</h3><p>SpringBoot中也提供了Listener注册方式。</p><ul><li><p>SpringBoot中注册Listener，有两种方式：</p><ul><li><p>注解式注册Listener；</p><pre><code class="hljs java"><span class="hljs-meta">@WebListener</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SCListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContextListener</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextDestroyed</span><span class="hljs-params">(ServletContextEvent arg0)</span> </span>&#123;        System.out.println(<span class="hljs-string">"监听到销毁了一个ServletContextEvent"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextInitialized</span><span class="hljs-params">(ServletContextEvent arg0)</span> </span>&#123;        System.out.println(<span class="hljs-string">"监听到创建了一个ServletContextEvent"</span>);    &#125;&#125;说明：主要需要添加一个<span class="hljs-meta">@WebListener</span>即可，因为以往的Listener配置也只是添加一个&lt;listener-<span class="hljs-class"><span class="hljs-keyword">class</span>&gt;，所以只需@<span class="hljs-title">WebListener</span>就行。</span><span class="hljs-class"></span><span class="hljs-class">------------------------------------------------以上是<span class="hljs-title">Listener</span>部分</span><span class="hljs-class"></span><span class="hljs-class">@<span class="hljs-title">SpringBootApplication</span></span><span class="hljs-class">@<span class="hljs-title">ServletComponentScan</span></span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(App<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;------------------------------------------------以上是SpringBoot启动器的部分</code></pre></li><li><p>配置类中配置Listener的注册；</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SCListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContextListener</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextDestroyed</span><span class="hljs-params">(ServletContextEvent arg0)</span> </span>&#123;        System.out.println(<span class="hljs-string">"监听到销毁了一个ServletContextEvent"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextInitialized</span><span class="hljs-params">(ServletContextEvent arg0)</span> </span>&#123;        System.out.println(<span class="hljs-string">"监听到创建了一个ServletContextEvent"</span>);    &#125;&#125;------------------------------------------------以上是Listener部分<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfiguration</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletListenerRegistrationBean <span class="hljs-title">getSLRB</span><span class="hljs-params">()</span> </span>&#123;        ServletListenerRegistrationBean&lt;SCListener&gt; slrb = <span class="hljs-keyword">new</span> ServletListenerRegistrationBean&lt;SCListener&gt;(<span class="hljs-keyword">new</span> SCListener());        <span class="hljs-keyword">return</span> slrb;    &#125;&#125;说明：和非注解式注册Servlet、Filter一样，在配置类中添加注册Listener方法进行注册即可；返回值必须是ServletListenerRegistrationBean。</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-8-SpringBoot的其他容器配置"><a href="#NO2-8-SpringBoot的其他容器配置" class="headerlink" title="NO2.8 SpringBoot的其他容器配置"></a>NO2.8 SpringBoot的其他容器配置</h3><p>SpringBoot中默认支持三种嵌入式Servlet容器。</p><ul><li><p>SpringBoot中使用其他的嵌入式Servlet容器；SpringBoot中默认支持三种Servlet容器，分别为Tomcat(默认使用的是这个，因为每个项目都会使用web依赖，而引入该依赖就是默认使用的Tomcat容器作为Servlet容器的)，Jetty(用于长连接)，Undertow(该容器不支持JSP)；</p><ul><li><p>Jetty容器的配置：只需要排除掉Tomcat容器，然后引入Jetty容器的依赖即可，SpringBoot自动使用该容器了；</p><p><img src="./Image-sb20.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>Undertow容器的配置：只需要排除掉Tomcat容器，然后引入Undertow容器的依赖即可，SpringBoot自动使用该容器了；</p><p><img src="./Image-sb21.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-9-SpringBoot与数据访问"><a href="#NO2-9-SpringBoot与数据访问" class="headerlink" title="NO2.9 SpringBoot与数据访问"></a>NO2.9 SpringBoot与数据访问</h3><p>数据访问就是与数据库进行交互式操作。</p><ul><li><p>SpringBoot中常用与数据库进行交互的技术栈：</p><ul><li><p>SpringBoot中使用JDBC进行数据访问；</p><ul><li><p>基本步骤：</p><ul><li><p>创建基于SpringBoot的Maven工程，导入web依赖、MySQL依赖(连接数据库的驱动等等)、jdbc依赖；</p><p><img src="./Image-sb22.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb23.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>在application.xml或者application.yaml中配置连接数据库的一些属性就行了；</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">xxxx</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://ip地址:3306/指定数据库名称</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span></code></pre><p><strong><code>注意：SpringBoot默认可以支持的数据源类型有：org.apache.tomcat.jdbc.Datasource(推荐)、HikariDataSource、BasicDatasource；也支持自定义的数据源，如下图所示。</code></strong></p><p><img src="./Image-sb24.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>使用Druid连接池；</p><ul><li><p>导入Druid连接池的依赖；</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>LATEST<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>在全局配置文件中指定连接池的类型；</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">xxxx</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://ip地址:3306/指定数据库名称</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span></code></pre></li><li><p>如果还想要配置Druid的其他参数，则可以使用如下几种方式(前提是已经引入了Druid的依赖)；</p><ul><li><p>基于配置文件的方式对Druid的属性进行配置；</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-comment"># 数据源配置</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>　　 <span class="hljs-comment"># MYSQL 5 驱动：com.mysql.jdbc.Driver，MYSQL 6+ 驱动：com.mysql.cj.jdbc.Driver</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/test?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=CONVERT_TO_NULL&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>    <span class="hljs-comment"># 连接池配置</span>    <span class="hljs-attr">druid:</span>      <span class="hljs-comment"># 初始化大小，最小，最大</span>      <span class="hljs-attr">initial-size:</span> <span class="hljs-number">5</span>      <span class="hljs-attr">min-idle:</span> <span class="hljs-number">5</span>      <span class="hljs-attr">max-active:</span> <span class="hljs-number">20</span>      <span class="hljs-comment"># 配置获取连接等待超时的时间</span>      <span class="hljs-attr">max-wait:</span> <span class="hljs-number">60000</span>      <span class="hljs-comment"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位毫秒</span>      <span class="hljs-attr">time-between-eviction-runs-millis:</span> <span class="hljs-number">60000</span>      <span class="hljs-comment"># 配置一个连接在池中最小生存时间</span>      <span class="hljs-attr">min-evictable-idle-time-millis:</span> <span class="hljs-number">300000</span>      <span class="hljs-attr">validation-query:</span> <span class="hljs-string">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-string">FROM</span> <span class="hljs-string">sys_user</span>      <span class="hljs-attr">test-while-idle:</span> <span class="hljs-literal">true</span>      <span class="hljs-attr">test-on-borrow:</span> <span class="hljs-literal">false</span>      <span class="hljs-attr">test-on-return:</span> <span class="hljs-literal">false</span>      <span class="hljs-comment"># 打开 PSCache，并且指定每个连接上 PSCache 的大小</span>      <span class="hljs-attr">pool-prepared-statements:</span> <span class="hljs-literal">true</span>      <span class="hljs-attr">max-pool-prepared-statement-per-connection-size:</span> <span class="hljs-number">20</span>      <span class="hljs-comment"># 配置监控统计拦截的 Filter，去掉后监控界面 SQL 无法统计，wall 用于防火墙</span>      <span class="hljs-attr">filters:</span> <span class="hljs-string">stat,wall,log4j</span>      <span class="hljs-comment"># 通过 connection-properties 属性打开 mergeSql 功能；慢 SQL 记录</span>      <span class="hljs-attr">connection-properties:</span> <span class="hljs-string">druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000</span>      <span class="hljs-comment"># 配置 DruidStatFilter</span>      <span class="hljs-attr">web-stat-filter:</span>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">url-pattern:</span> <span class="hljs-string">/*</span>        <span class="hljs-attr">exclusions:</span> <span class="hljs-string">.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*</span>      <span class="hljs-comment"># 配置 DruidStatViewServlet</span>      <span class="hljs-attr">stat-view-servlet:</span>        <span class="hljs-attr">url-pattern:</span> <span class="hljs-string">/druid/*</span>        <span class="hljs-comment"># IP 白名单，没有配置或者为空，则允许所有访问</span>        <span class="hljs-attr">allow:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>        <span class="hljs-comment"># IP 黑名单，若白名单也存在，则优先使用</span>        <span class="hljs-attr">deny:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.31</span><span class="hljs-number">.253</span>        <span class="hljs-comment"># 禁用 HTML 中 Reset All 按钮</span>        <span class="hljs-attr">reset-enable:</span> <span class="hljs-literal">false</span>        <span class="hljs-comment"># 登录用户名/密码</span>        <span class="hljs-attr">login-username:</span> <span class="hljs-string">root</span>        <span class="hljs-attr">login-password:</span> <span class="hljs-number">123</span></code></pre></li><li><p>基于Java方式对Druid的属性进行配置；</p><pre><code class="hljs java">spring:  datasource:    username: root    password: xxxx    url: jdbc:mysql:<span class="hljs-comment">//ip地址:3306/指定数据库名称</span>    driver-class-name: com.mysql.jdbc.Driver    type: com.alibaba.druid.pool.DruidDataSource    #数据源的其他配置    initialSize: <span class="hljs-number">5</span>    minIdle: <span class="hljs-number">5</span>    maxActive: <span class="hljs-number">20</span>    maxWait: <span class="hljs-number">60000</span>    timeBetweenEvictionRunsMillis: <span class="hljs-number">60000</span>    minEvictableIdleTimeMillis: <span class="hljs-number">300000</span>    validationQuery: SELECT <span class="hljs-number">1</span> FROM DUAL    testWhileIdle: <span class="hljs-keyword">true</span>    testOnBorrow: <span class="hljs-keyword">false</span>    testOnReturn: <span class="hljs-keyword">false</span>    poolPreparedStatements: <span class="hljs-keyword">true</span>    # 配置监控统计拦截的 filters，去掉后监控界面 sql 无法统计，'wall'用于防火墙    filters: stat,wall,log4j    maxPoolPreparedStatementPerConnectionSize: <span class="hljs-number">20</span>    useGlobalDataSourceStat: <span class="hljs-keyword">true</span>    connectionProperties: druid.stat.mergeSql=<span class="hljs-keyword">true</span>;druid.stat.slowSqlMillis=<span class="hljs-number">500</span><span class="hljs-comment">//--------------------------------------------------------------以上是application.yml配置文件</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.datasource"</span>)  <span class="hljs-comment">//将所有前缀为spring.datasource下的配置项都加载DataSource中</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">druidDataSource</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DruidDataSource();    &#125;    <span class="hljs-comment">//Druid监控的配置</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean&lt;Servlet&gt; <span class="hljs-title">druidServlet</span><span class="hljs-params">()</span> </span>&#123;        ServletRegistrationBean&lt;Servlet&gt; srb = <span class="hljs-keyword">new</span> ServletRegistrationBean&lt;&gt;(<span class="hljs-keyword">new</span> StatViewServlet(), <span class="hljs-string">"/druid/**"</span>);        <span class="hljs-comment">// 白名单</span>        srb.addInitParameter(<span class="hljs-string">"allow"</span>, <span class="hljs-string">"127.0.0.1"</span>);        <span class="hljs-comment">// 黑名单</span>        srb.addInitParameter(<span class="hljs-string">"deny"</span>, <span class="hljs-string">"192.168.31.253"</span>);        <span class="hljs-comment">// 用户名</span>        srb.addInitParameter(<span class="hljs-string">"loginUsername"</span>, <span class="hljs-string">"root"</span>);        <span class="hljs-comment">// 密码</span>        srb.addInitParameter(<span class="hljs-string">"loginPassword"</span>, <span class="hljs-string">"root"</span>);        <span class="hljs-comment">// 是否可以重置数据源</span>        srb.addInitParameter(<span class="hljs-string">"resetEnable"</span>, <span class="hljs-string">"false"</span>);        <span class="hljs-keyword">return</span> srb;    &#125;        <span class="hljs-comment">//Web监控的Filter配置</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean&lt;Filter&gt; <span class="hljs-title">filterRegistrationBean</span><span class="hljs-params">()</span> </span>&#123;        FilterRegistrationBean&lt;Filter&gt; frb = <span class="hljs-keyword">new</span> FilterRegistrationBean&lt;&gt;();        frb.setFilter(<span class="hljs-keyword">new</span> WebStatFilter());        <span class="hljs-comment">// 所有请求进行监控处理</span>        frb.addUrlPatterns(<span class="hljs-string">"/*"</span>);        <span class="hljs-comment">// 排除名单</span>        frb.addInitParameter(<span class="hljs-string">"exclusions"</span>, <span class="hljs-string">"*.js,*.gif,*.jpg,*.css,/druid/*"</span>);        <span class="hljs-keyword">return</span> frb;    &#125;&#125;<span class="hljs-comment">//最后，启动SpringBoot项目访问地址http://localhost:8080/druid/login.html进行查看登录</span></code></pre></li><li><p>基于注解的方式对Druid的属性进行配置；</p><pre><code class="hljs java">spring:  datasource:    username: root    password: xxxx    url: jdbc:mysql:<span class="hljs-comment">//ip地址:3306/指定数据库名称</span>    driver-class-name: com.mysql.jdbc.Driver    type: com.alibaba.druid.pool.DruidDataSource    #数据源的其他配置    initialSize: <span class="hljs-number">5</span>    minIdle: <span class="hljs-number">5</span>    maxActive: <span class="hljs-number">20</span>    maxWait: <span class="hljs-number">60000</span>    timeBetweenEvictionRunsMillis: <span class="hljs-number">60000</span>    minEvictableIdleTimeMillis: <span class="hljs-number">300000</span>    validationQuery: SELECT <span class="hljs-number">1</span> FROM DUAL    testWhileIdle: <span class="hljs-keyword">true</span>    testOnBorrow: <span class="hljs-keyword">false</span>    testOnReturn: <span class="hljs-keyword">false</span>    poolPreparedStatements: <span class="hljs-keyword">true</span>    # 配置监控统计拦截的 filters，去掉后监控界面 sql 无法统计，'wall'用于防火墙    filters: stat,wall,log4j    maxPoolPreparedStatementPerConnectionSize: <span class="hljs-number">20</span>    useGlobalDataSourceStat: <span class="hljs-keyword">true</span>    connectionProperties: druid.stat.mergeSql=<span class="hljs-keyword">true</span>;druid.stat.slowSqlMillis=<span class="hljs-number">500</span><span class="hljs-comment">//------------------------------------------------------------------------------------以上是application.yml配置文件</span><span class="hljs-comment">//配置WebServlet</span><span class="hljs-meta">@WebServlet</span>(urlPatterns = <span class="hljs-string">"/druid/*"</span>,             initParams=&#123;            <span class="hljs-meta">@WebInitParam</span>(name=<span class="hljs-string">"allow"</span>,value=<span class="hljs-string">"192.168.16.110,127.0.0.1"</span>),  <span class="hljs-comment">//IP白名单(没有配置或者为空，则允许所有访问)</span>            <span class="hljs-meta">@WebInitParam</span>(name=<span class="hljs-string">"deny"</span>,value=<span class="hljs-string">"192.168.16.111"</span>),  <span class="hljs-comment">//IP黑名单(存在共同时，deny优先于allow)</span>            <span class="hljs-meta">@WebInitParam</span>(name=<span class="hljs-string">"loginUsername"</span>,value=<span class="hljs-string">"admin"</span>),  <span class="hljs-comment">//用户名</span>            <span class="hljs-meta">@WebInitParam</span>(name=<span class="hljs-string">"loginPassword"</span>,value=<span class="hljs-string">"admin"</span>),  <span class="hljs-comment">//密码</span>            <span class="hljs-meta">@WebInitParam</span>(name=<span class="hljs-string">"resetEnable"</span>,value=<span class="hljs-string">"false"</span>)  <span class="hljs-comment">//禁用HTML页面上的“Reset All”功能</span>            &#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatViewServlet</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;&#125;<span class="hljs-comment">//------------------------------------------------------------------------------------</span><span class="hljs-comment">//配置WebFilter</span><span class="hljs-meta">@WebFilter</span>(filterName=<span class="hljs-string">"druidWebStatFilter"</span>,urlPatterns=<span class="hljs-string">"/*"</span>,            initParams=&#123;           <span class="hljs-meta">@WebInitParam</span>(name=<span class="hljs-string">"exclusions"</span>,value=<span class="hljs-string">"*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*"</span>)  <span class="hljs-comment">//忽略资源</span>           &#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebStatFilter</span> </span>&#123;&#125;<span class="hljs-comment">//------------------------------------------------------------------------------------</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@ServletComponentScan</span>(<span class="hljs-string">"com.uy.servlet"</span>)  <span class="hljs-comment">//扫描我们配置Servlet类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootApplication</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(SpringBootApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>; &#125; &#125;<span class="hljs-comment">//最后，启动SpringBoot项目访问地址http://localhost:8080/druid/login.html进行查看登录</span>说明：一、<span class="hljs-meta">@Component</span>注解表明一个类会作为组件类，并告知Spring要为这个类创建bean二、<span class="hljs-meta">@Bean</span>注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean，通常方法体中包含了最终产生bean实例的逻辑三、两者的目的是一样的，都是注册bean到Spring容器中，<span class="hljs-meta">@Component</span>（<span class="hljs-meta">@Controller</span>、<span class="hljs-meta">@Service</span>、<span class="hljs-meta">@Repository</span>）通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中，而<span class="hljs-meta">@Bean</span>注解通常是我们在标有该注解的方法中定义产生这个bean的逻辑</code></pre></li></ul></li></ul></li></ul></li></ul></li><li><p>SpringBoot中使用MyBatis进行数据访问；</p><ul><li><p>基本步骤：</p><ul><li><p>导入需要的Web依赖、MySQL依赖(数据库驱动)、JDBC依赖(自动配置数据源)、以及MyBatis依赖；</p><p><img src="./Image-sb25.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb26.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>在全局配置文件中配置连接数据库的基本属性；</p><pre><code class="hljs java">&lt;!--在pom.xml中引入Druid的依赖，并使用Druid连接池--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;LATEST&lt;/version&gt;&lt;/dependency&gt;<span class="hljs-comment">//-------------------------------------------------------------</span>spring:  datasource:    username: root    password: xxxx    url: jdbc:mysql:<span class="hljs-comment">//ip地址:3306/指定数据库名称</span>    driver-class-name: com.mysql.jdbc.Driver    type: com.alibaba.druid.pool.DruidDataSource    #数据源的其他配置    initialSize: <span class="hljs-number">5</span>    minIdle: <span class="hljs-number">5</span>    maxActive: <span class="hljs-number">20</span>    maxWait: <span class="hljs-number">60000</span>    timeBetweenEvictionRunsMillis: <span class="hljs-number">60000</span>    minEvictableIdleTimeMillis: <span class="hljs-number">300000</span>    validationQuery: SELECT <span class="hljs-number">1</span> FROM DUAL    testWhileIdle: <span class="hljs-keyword">true</span>    testOnBorrow: <span class="hljs-keyword">false</span>    testOnReturn: <span class="hljs-keyword">false</span>    poolPreparedStatements: <span class="hljs-keyword">true</span>    # 配置监控统计拦截的 filters，去掉后监控界面 sql 无法统计，'wall'用于防火墙    filters: stat,wall,log4j    maxPoolPreparedStatementPerConnectionSize: <span class="hljs-number">20</span>    useGlobalDataSourceStat: <span class="hljs-keyword">true</span>    connectionProperties: druid.stat.mergeSql=<span class="hljs-keyword">true</span>;druid.stat.slowSqlMillis=<span class="hljs-number">500</span><span class="hljs-comment">//----------------------------------------------------</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.datasource"</span>)  <span class="hljs-comment">//将所有前缀为spring.datasource下的配置项都加载DataSource中</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">druidDataSource</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DruidDataSource();    &#125;    <span class="hljs-comment">//Druid监控的配置</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean&lt;Servlet&gt; <span class="hljs-title">druidServlet</span><span class="hljs-params">()</span> </span>&#123;        ServletRegistrationBean&lt;Servlet&gt; srb = <span class="hljs-keyword">new</span> ServletRegistrationBean&lt;&gt;(<span class="hljs-keyword">new</span> StatViewServlet(), <span class="hljs-string">"/druid/**"</span>);        <span class="hljs-comment">// 白名单</span>        srb.addInitParameter(<span class="hljs-string">"allow"</span>, <span class="hljs-string">"127.0.0.1"</span>);        <span class="hljs-comment">// 黑名单</span>        srb.addInitParameter(<span class="hljs-string">"deny"</span>, <span class="hljs-string">"192.168.31.253"</span>);        <span class="hljs-comment">// 用户名</span>        srb.addInitParameter(<span class="hljs-string">"loginUsername"</span>, <span class="hljs-string">"root"</span>);        <span class="hljs-comment">// 密码</span>        srb.addInitParameter(<span class="hljs-string">"loginPassword"</span>, <span class="hljs-string">"root"</span>);        <span class="hljs-comment">// 是否可以重置数据源</span>        srb.addInitParameter(<span class="hljs-string">"resetEnable"</span>, <span class="hljs-string">"false"</span>);        <span class="hljs-keyword">return</span> srb;    &#125;        <span class="hljs-comment">//Web监控的Filter配置</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean&lt;Filter&gt; <span class="hljs-title">filterRegistrationBean</span><span class="hljs-params">()</span> </span>&#123;        FilterRegistrationBean&lt;Filter&gt; frb = <span class="hljs-keyword">new</span> FilterRegistrationBean&lt;&gt;();        frb.setFilter(<span class="hljs-keyword">new</span> WebStatFilter());        <span class="hljs-comment">// 所有请求进行监控处理</span>        frb.addUrlPatterns(<span class="hljs-string">"/*"</span>);        <span class="hljs-comment">// 排除名单</span>        frb.addInitParameter(<span class="hljs-string">"exclusions"</span>, <span class="hljs-string">"*.js,*.gif,*.jpg,*.css,/druid/*"</span>);        <span class="hljs-keyword">return</span> frb;    &#125;&#125;<span class="hljs-comment">//最后，启动SpringBoot项目访问地址http://localhost:8080/druid/login.html进行查看登录</span></code></pre></li><li><p>最后使用xxxMapper和xxxMapper.xml对数据库的表进行增删改查的操作即可；</p></li></ul></li></ul></li></ul></li><li><p>SpringBoot中使用JPA进行数据访问；</p><ul><li><p>介绍：SpringDataJPA，基于JPA的标准对数据进行操作；简化持久层的代码，只需要编写接口即可；</p></li><li><p>基本步骤：</p><ul><li><p>导入需要的Web依赖、JPA依赖、MySQL依赖、JDBC依赖(数据源也可以使用Druid连接池)；</p><p><img src="./image-sb27.png" srcset="/img/loading.gif" alt=""></p></li><li><p>在全局配置文件中配置连接数据库的基本属性；</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">xxxx</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://ip地址:3306/指定数据库名称</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span>        <span class="hljs-comment">#如果使用了Druid连接池就使用这个</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>  <span class="hljs-string">jpa</span>    <span class="hljs-attr">hibernate:</span>      <span class="hljs-attr">ddl-auto:</span> <span class="hljs-string">update</span>    <span class="hljs-attr">show-sql:</span> <span class="hljs-literal">true</span><span class="hljs-string">说明：</span><span class="hljs-string">一、spring-boot工程中，jpa下hibernate的ddl-auto的各种属性：</span><span class="hljs-string">ddl-auto:create：每次运行该程序，没有表格会新建表格，表内有数据会清空；</span>    <span class="hljs-string">ddl-auto:create-drop：每次程序结束的时候会清空表；</span>    <span class="hljs-string">ddl-auto:update：每次运行程序，没有表格会新建表格，表内有数据不会清空，只会更新；</span>    <span class="hljs-string">ddl-auto:validate：运行程序会校验数据与数据库的字段类型是否相同，不同会报错。</span></code></pre></li><li><p>创建pojo类；</p><pre><code class="hljs java"><span class="hljs-meta">@Entity</span><span class="hljs-meta">@Table</span>(name=<span class="hljs-string">"t_user"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue</span>(strategy=GenerationType.IDENTITY)    <span class="hljs-meta">@Column</span>(name=<span class="hljs-string">"id"</span>)    <span class="hljs-keyword">private</span> Integer id ;    <span class="hljs-meta">@Column</span>(name=<span class="hljs-string">"name"</span>)    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@Column</span>(name=<span class="hljs-string">"age"</span>)    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-meta">@Column</span>(name=<span class="hljs-string">"adress"</span>)    <span class="hljs-keyword">private</span> String adress;    get方法和set方法....&#125;说明：一、<span class="hljs-meta">@Entity</span>，标识这个实体类是一个JPA实体，告诉JPA在程序运行的时候记得生成这个实体类所对应的表；    二、<span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"自定义的表名"</span>)，自定义设置这个实体类在数据库所对应的表名；三、<span class="hljs-meta">@Id</span>，把这个类里面所在的变量设置为主键Id；        四、<span class="hljs-meta">@GeneratedValue</span>，设置主键的生成策略，这种方式依赖于具体的数据库，如果数据库不支持自增主键，那么这个类型是没法用的五、<span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"自定义对应的表的字段名"</span>，length = <span class="hljs-string">"自定义长度"</span>，nullable = <span class="hljs-string">"是否可以空"</span>，unique = <span class="hljs-string">"是否唯一"</span>，columnDefinition = <span class="hljs-string">"自定义该字段的类型和长度"</span>)，表示对这个变量所对应的表字段名进行一些个性化的设置，例如表字段的名字，表字段的长度，是否为空和是否唯一等等设置</code></pre></li><li><p>编写一个Dao层的接口继承JpaRepository，JpaRepository只是一个标记接口，里面没有任何方法，若我们编写的接口继承了JpaRepository，则该接口会被IOC容器识别为一个JpaRepository Bean纳入到IOC容器中，进而可以在该接口中定义满足一定规范的方法；</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;&#125;说明：JPA提供的父接口是标记型接口，没有任何方法，&lt;T, ID&gt;中，即父接口后面的泛型分别为：前者是持久层管理的主要实体类型，即POJO类；后者是实体类的主ID(也就是对应表的主键)</code></pre></li><li><p>编写测试类进行测试即可；</p><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(value=SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">SpringBootTest</span>(<span class="hljs-title">classes</span></span>= &#123;Starter<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">JPATest</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> UserRepository userRepository;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span>&#123;        User user = <span class="hljs-keyword">new</span> User();        user.setName(<span class="hljs-string">"邓先森"</span>);        user.setAge(<span class="hljs-number">26</span>);        user.setAdress(<span class="hljs-string">"银河系地球村"</span>);        userRepository.save(user);    &#125;&#125;</code></pre></li></ul></li><li><p>SpringData JPA提供的核心接口有以下几种；</p><ul><li><p>Repository：JPA的根接口；</p><ul><li><p>提供了根据方法名称去查询的方式：方法的名称要遵循findBy + 属性名(首字母大写)+ 查询条件(首字母大写)；<strong><code>注意：查询条件不写，默认是做相等判断。</code></strong></p><pre><code class="hljs java">findByNameLike(String name);findByAge(Integer age);</code></pre></li><li><p>基于@Query注解的查询和更新，SpringData JPA使用的是JPQL语句，该语句与HQL语法极其相似；</p><pre><code class="hljs java"><span class="hljs-meta">@Query</span>(<span class="hljs-string">"from User where name = ?1"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">queryByNameUseHQL</span><span class="hljs-params">(String name)</span></span>;<span class="hljs-meta">@Query</span>(value=<span class="hljs-string">"select * from t_user where name=?1 and age=?2"</span>,nativeQuery=<span class="hljs-keyword">true</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">queryByNameAndAge</span><span class="hljs-params">(String name,Integer age)</span></span>;<span class="hljs-meta">@Query</span>(value=<span class="hljs-string">"update t_user set name=?1 where id=?2"</span>,nativeQuery=<span class="hljs-keyword">true</span>)<span class="hljs-meta">@Modifying</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateUserById</span><span class="hljs-params">(String name,Integer id)</span></span>;说明：一、<span class="hljs-meta">@Query</span>使用JPQL语句进行查询，nativeQuery(是否不用转换成标准SQL语句)属性默认是<span class="hljs-keyword">false</span>，即需要转成标准的SQL语句；如果使用该方式进行数据访问，一定要在占位符?后面添加对应的索引，即?<span class="hljs-number">1</span>,?<span class="hljs-number">2</span>，否则不需要添加对应的索引二、<span class="hljs-meta">@Query</span>注解下使用SQL语句时，需要使用nativeQuery=<span class="hljs-keyword">true</span>属性，即告诉JPA这是SQL语句，不需要转成标准的SQL语句；如果使用该方式进行数据访问，也一定要在占位符?后面添加对应的索引，即?<span class="hljs-number">1</span>,?<span class="hljs-number">2</span>，否则不需要添加对应的索引三、做更新操作时，有更新或者删除操作时，必须要加上<span class="hljs-meta">@Modifying</span>注解才能生效，且这两项操作需要使用事务，测试类或者业务层添加<span class="hljs-meta">@Transactional</span>即可，否则报异常</code></pre></li></ul></li><li><p>CrudRepository：该接口主要完成对增删改查的操作，且该接口继承了Repository；该接口中的方法：</p><ul><li><p>save(entity)：添加一条数据；</p></li><li><p>save(entities)：添加多条数据，entities为集合，由于JDK中的集合都继承了Iterable接口，所以直接添加List即可；</p></li><li><p>findByID(id)：根据id查询一条数据；</p></li><li><p>findAll(entities)：查询全部数据；</p></li><li><p>existsById(id)：判断id是否存在；</p></li><li><p>delete(id)：根据id删除数据；</p></li><li><p>delete(entity)：根据一条数据的信息删除数据；</p></li><li><p>delete(entities)：根据多条数据的信息删除数据；</p></li><li><p>deleteAll()：删除全部信息；</p><pre><code class="hljs java">User target = test2.findById(<span class="hljs-number">6</span>).orElse(<span class="hljs-keyword">null</span>);<span class="hljs-keyword">if</span>(target!=<span class="hljs-keyword">null</span>) &#123;    System.out.println(target);&#125;<span class="hljs-comment">//-------------------------------------------------</span>test2.save(User);说明：一、findByID(id)方法返回的是Optional类型的对象，该对象有一个orElse(Object)方法，意思是：判断findByID(id)得到的结果是否为<span class="hljs-keyword">null</span>，不是就直接返回原本的值，否则返回orElse(Object)方法中的Object，而Object一般我们写成<span class="hljs-keyword">null</span>二、save方法既是添加，也是更新，在添加之前去数据库查看是否有相同的对象，没有则添加，有则更新；entity是对象；entities是一个集合，即元素是对象的集合</code></pre></li></ul></li><li><p>PagingAndSortingRepository：该接口主要提供分页和排序，该接口继承了CrudRepository。特殊方法：</p><ul><li><p>findAll(Sort sort)：这是排序；</p><pre><code class="hljs java"><span class="hljs-comment">//Sort对象的构造器里有两个参数：Direction和Properties，前者排序规则，后者是做排序的属性；</span>还可以使用Sort sort = <span class="hljs-keyword">new</span> Sort(Order order...)构造器，即放入多个Order进行多次排序，Order order = <span class="hljs-keyword">new</span> Order(Sort.Direction.DESC,<span class="hljs-string">"id"</span>)、Order order = <span class="hljs-keyword">new</span> Order(Sort.Direction.ASC,<span class="hljs-string">"name"</span>)....<span class="hljs-comment">//单次排序</span>Sort sort = <span class="hljs-keyword">new</span> Sort(Sort.Direction.DESC,<span class="hljs-string">"id"</span>);List&lt;User&gt; targetList = (List&lt;User&gt;) test3.findAll(sort);<span class="hljs-keyword">for</span> (User user : targetList) &#123;    System.out.println(user);&#125;<span class="hljs-comment">//---------------------------------------------------</span><span class="hljs-comment">//多次排序</span>Order order = <span class="hljs-keyword">new</span> Order(Direction.DESC, <span class="hljs-string">"id"</span>);Order order2 = <span class="hljs-keyword">new</span> Order(Direction.DESC, <span class="hljs-string">"age"</span>);Order order3 = <span class="hljs-keyword">new</span> Order(Direction.ASC, <span class="hljs-string">"salary"</span>);ArrayList&lt;Order&gt; list = <span class="hljs-keyword">new</span> ArrayList()&lt;&gt;;Sort sort1 = <span class="hljs-keyword">new</span> Sort(list);说明：findAll(Sort sort)，该方法需要的是一个排序的规则对象，所以创建Sort对象即可，放入findAll(Sort sort)方法中去</code></pre></li><li><p>findAll(Pageable page)：这是分页；</p><pre><code class="hljs java">Pageable pageable = <span class="hljs-keyword">new</span> PageRequest(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);Page&lt;User&gt; page = test3.findAll(pageable);<span class="hljs-keyword">for</span> (User user : page) &#123;    System.out.println(user);&#125;说明：findAll(Pageable page)，该方法需要一个分页的基本条件，即跨过前面xx页并开始，每页显示的记录数；所以创建实现了Pageable接口的PageRequest的对象即可，然后放入findAll(Pageable page)方法中；该方法返回的结果是Page类型的对象，该对象中封装了关于页面的信息；如：当前页数：page.getNumber()+<span class="hljs-number">1</span>，因为当前页是从<span class="hljs-number">0</span>开始，所以需要+<span class="hljs-number">1</span>，即当前页是第一页或n+<span class="hljs-number">1</span>页；当前页的记录数：page.getNumberOfElements()每页记录数：page.getSize()总记录数：page.getTotalElements()总页数：page.getTotalPages()当前查询的记录结果集：page.getContent()</code></pre></li><li><p>分页和排序结合；</p><pre><code class="hljs java"><span class="hljs-comment">//排序</span>Sort sort = <span class="hljs-keyword">new</span> Sort(Sort.Direction.DESC,<span class="hljs-string">"id"</span>);<span class="hljs-comment">//分页</span>Pageable pageable = <span class="hljs-keyword">new</span> PageRequest(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, sort);Page&lt;User&gt; target = test.findAll(pageable);List&lt;User&gt; content = target.getContent();<span class="hljs-keyword">for</span> (User user : content) &#123;    System.out.println(user);&#125;说明：只需要在创建Pageable的实现类对象时，使用带有sort排序参数的构造方法即可</code></pre></li></ul></li><li><p>JpaRepository：该接口继承了PagingAndSortingRepository接口，推荐使用该接口，因为这个接口包含了之前三个接口的所有方法，并对方法的返回值进行了适配(即返回值都是以<code>List&lt;T&gt;</code>形式返回的)；</p></li><li><p>JpaSpecificationExecutor，该接口主要是提供多条件查询的支持，并且可以在查询中添加分页和删除，该接口是独立的接口，该接口要和其他接口一起使用，无法单独使用；为什么该接口无法单独使用呢？因为JpaSpecificationExecutor接口是一个单独的接口，并没有继承其他接口，而在真正使用的时候，注入的却是根据SimpleJpaRepository类动态代理产生的代理对象，而要产生该类的代理对象，就必须继承Repository接口，而JpaSpecificationExecutor接口没有继承Repository，所以无法生成动态代理类的代理对象，也就无法使用；</p><pre><code class="hljs java">Specification&lt;User&gt; spec = <span class="hljs-keyword">new</span> Specification&lt;User&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Predicate <span class="hljs-title">toPredicate</span><span class="hljs-params">(Root&lt;User&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb)</span> </span>&#123;        <span class="hljs-comment">//这是单条件查询</span>        <span class="hljs-comment">//Predicate pre = cb.equal(root.get("name"), "邓燕飞");</span>        <span class="hljs-comment">//这是多条件查询</span>        List&lt;Predicate&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        list.add(cb.equal(root.get(<span class="hljs-string">"name"</span>), <span class="hljs-string">"邓燕飞"</span>));        list.add(cb.equal(root.get(<span class="hljs-string">"age"</span>), <span class="hljs-number">27</span>));        Predicate[] pre = <span class="hljs-keyword">new</span> Predicate[list.size()];        <span class="hljs-keyword">return</span> cb.and(list.toArray(pre));        <span class="hljs-comment">//以上条件可以写成这样：</span>        <span class="hljs-comment">//return cb.and(cb.equal(root.get("name"), "邓燕飞"), cb.equal(root.get("age"), 27));</span>    &#125;&#125;;List&lt;User&gt; target = test.findAll(spec);<span class="hljs-keyword">for</span> (User user : target) &#123;    System.out.println(user);&#125;       注意：Predicate：定义了查询条件，即根据对应属性和属性值去查询；Root&lt;User&gt; root：根对象；封装了查询条件的对象；CriteriaQuery&lt;?&gt; query：定义了一个基本的查询，一般不使用；CriteriaBuilder cb：创建一个查询条件；如，如下便是添加了排序和分页的查询Specification&lt;User&gt; spec = <span class="hljs-keyword">new</span> Specification&lt;User&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Predicate <span class="hljs-title">toPredicate</span><span class="hljs-params">(Root&lt;User&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb)</span> </span>&#123;        return cb.like(root.get("name").as(String.class), "邓%");    &#125;&#125;;<span class="hljs-comment">//排序</span>Sort sort = <span class="hljs-keyword">new</span> Sort(Sort.Direction.DESC,<span class="hljs-string">"id"</span>);<span class="hljs-comment">//分页</span>Pageable page = <span class="hljs-keyword">new</span> PageRequest(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>,sort);Page&lt;User&gt; target = test4.findAll(spec,page);List&lt;User&gt; content = target.getContent();<span class="hljs-keyword">for</span> (User user : content) &#123;    System.out.println(user);&#125;</code></pre></li></ul></li><li><p>SpringData JPA一对多和多对多表关系的建立与操作；</p><ul><li><p>SpringData JPA建立双向一对多关系映射；</p><ul><li><p>首先：</p><ul><li><p>在多的一方里：在实体类中添加一的一方的属性；</p></li><li><p>在一的一方里：在实体类中添加多的一方的属性；</p><pre><code class="hljs java"><span class="hljs-comment">//用户和角色，用户是多的一方，角色是一的一方</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;        ...其他成员变量    <span class="hljs-keyword">private</span> Role role;    ...get和set方法&#125;<span class="hljs-comment">//--------------------------------------------------</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> </span>&#123;        ...其他成员变量    <span class="hljs-keyword">private</span> Set&lt;User&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;User&gt;();    ...get和set方法&#125;</code></pre></li></ul></li><li><p>其次：</p><ul><li><p>在多的一方：在实体类中一的一方的属性上添加注解@ManyToOne(cascade=CascadeType.PERSIST)、cascade属性是指在操作当前POJO的对象时，也关联操作当前对象所维护的另一方的对象；@JoinColumn(name=”自定义外键名称”)，该注解放在主控方，一般该注解所在的一方能够改变关联关系，也就是说用户选择了别的角色，那么role就会变化，所以User是主控方，也就是能改变关联关系的一方；</p></li><li><p>在一的一方：在实体类中多的一方的属性上添加注解@OneToMany(mappedBy=”放入在多的一方里对应的一的一方的对象名称”)，一方设置mappedBy属性，则另一方必须添加为JoinColumn，mappedBy可以理解为一个标志，拥有mappedBy属性的POJO类就是去匹配拥有这个标志的另一个POJO类，而这个标志其实就是另一个POJO类的对象或者集合对象，且mappedBy这方不用管关联关系，关联关系交给另一方处理；</p><pre><code class="hljs java"><span class="hljs-comment">//用户和角色，用户是多的一方，角色是一的一方</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;        ...其他成员变量    <span class="hljs-meta">@ManyToOne</span>(cascade=CascadeType.PERSIST)    <span class="hljs-meta">@JoinColumn</span>(name=<span class="hljs-string">"role_id"</span>)           <span class="hljs-keyword">private</span> Role role;    ...get和set方法&#125;<span class="hljs-comment">//--------------------------------------------------------</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> </span>&#123;        ...其他成员变量    <span class="hljs-meta">@OneToMany</span>(mappedBy=<span class="hljs-string">"role"</span>)    <span class="hljs-keyword">private</span> Set&lt;User&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;User&gt;();    ...get和set方法&#125;说明：一、<span class="hljs-meta">@ManyToOne</span>(cascade=CascadeType.PERSIST)，cascade的属性是指级联操作，例如保存客户，也保存该客户所对应的订单信息等待级联信息；二、只有OneToOne，OneToMany，ManyToMany上才有mappedBy属性，ManyToOne不存在该属性；mappedBy标签一定是定义在被拥有方的，他指向拥有方；mappedBy的含义，应该理解为，拥有方能够自动维护跟被拥有方的关系，当然，如果从被拥有方，通过手工强行来维护拥有方的关系也是可以做到的；mappedBy跟joinColumn/JoinTable总是处于互斥的一方，可以理解为正是由于拥有方的关联被拥有方的字段存在，拥有方才拥有了被拥有方；mappedBy这方定义JoinColumn/JoinTable总是失效的，不会建立对应的字段或者表；mappedBy表示声明自己不是一对多的关系维护端，由对方来维护，是在一的一方进行声明的；mappedBy的值应该为一的一方的某个对应的名称</code></pre></li></ul></li><li><p>最后，测试操作；</p><pre><code class="hljs java"><span class="hljs-comment">//创建一个User</span>User user = <span class="hljs-keyword">new</span> User();user.setName(<span class="hljs-string">"邓GM"</span>);user.setAge(<span class="hljs-number">26</span>);user.setAdress(<span class="hljs-string">"太阳系"</span>);<span class="hljs-comment">//创建一个Roler</span>Role role = <span class="hljs-keyword">new</span> Role();role.setRolename(<span class="hljs-string">"游戏创建者"</span>);<span class="hljs-comment">//互相关联操作，其实就是在各自的对象中，添加相应的属性即可；</span>user.setRole(role);Set&lt;User&gt; userSet = role.getUserSet();userSet.add(user);userRepository.save(user);</code></pre></li></ul></li><li><p>SpringDataJPA建立双向多对多关系映射；</p><ul><li><p>在A方：在实体类中添加B的一方的对象集合，并加上对应的注解即可；在B方：在实体类中添加A的一方的对象集合，并加上对应的注解即可；</p><pre><code class="hljs java"><span class="hljs-comment">//菜单和角色</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> </span>&#123;    ...其他成员变量    <span class="hljs-meta">@ManyToMany</span>(cascade=CascadeType.PERSIST, fectch=FetchType.EAGER)    <span class="hljs-meta">@JoinTable</span>(name=<span class="hljs-string">"t_role_menu"</span>, joinColumns=<span class="hljs-meta">@JoinColumn</span>(name=<span class="hljs-string">"roles_id"</span>), inverseJoinColumns=<span class="hljs-meta">@JoinColumn</span>(name=<span class="hljs-string">"menu_id"</span>))    <span class="hljs-keyword">private</span> Set&lt;Menu&gt; menuSet = <span class="hljs-keyword">new</span> HashSet&lt;Menu&gt;();    ...get和set方法&#125;<span class="hljs-comment">//--------------------------------------------------------------------------------</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Menu</span> </span>&#123;    ...其他成员变量    <span class="hljs-meta">@ManyToMany</span>(mappedBy=<span class="hljs-string">"menuSet"</span>)    <span class="hljs-keyword">private</span> Set&lt;Role&gt; roleSet = <span class="hljs-keyword">new</span> HashSet&lt;Role&gt;();    ...get和set方法&#125;说明：在多对多关系映射中，两边都要添加<span class="hljs-meta">@ManyToMany</span>()注解；<span class="hljs-meta">@JoinTable</span>是指创建一个中间表，属性name=<span class="hljs-string">"XXX"</span>是设置中间表的名称，属性joinColumns=<span class="hljs-meta">@JoinColumn</span>(name=<span class="hljs-string">"XXX"</span>)是设置当前表主键在中间表的外键的名称，属性inverseJoinColumns=<span class="hljs-meta">@JoinColumn</span>(name=<span class="hljs-string">"XXX"</span>)是设置中间表中，另一个外键的名称，即另一个实体类的主键在中间表的外键名称；<span class="hljs-meta">@JoinTable</span>可以在任意一方的实体类中添加，因为都是多对多；另一方只需设置<span class="hljs-meta">@ManyToMany</span>(mappedBy=<span class="hljs-string">"XXX"</span>)即可，属性mappedBy是指要放入的另一方的对象集合即可；fectch属性是设置放弃延迟加载而改用立即加载，因为级联查询会需要Session去查询级联信息，该属性默认会使用延迟加载，这样级联信息就查询不到了</code></pre></li><li><p>代码测试；</p><pre><code class="hljs java">Menu menu = <span class="hljs-keyword">new</span> Menu();menu.setMenuname(<span class="hljs-string">"角色信息"</span>);menu.setMenuurl(<span class="hljs-string">"www.jianling.com"</span>);menu.setFatherid(<span class="hljs-number">66</span>);Role role = <span class="hljs-keyword">new</span> Role();role.setRolename(<span class="hljs-string">"开发者"</span>);menu.getRoleSet().add(role);role.getMenuSet().add(menu);Role target = Repository.findById(<span class="hljs-number">2</span>).orElse(<span class="hljs-keyword">null</span>);<span class="hljs-keyword">if</span>(target!=<span class="hljs-keyword">null</span>) &#123;    System.out.println(target);    <span class="hljs-keyword">for</span> (Menu me: target.getMenuSet()) &#123;        System.out.println(me);    &#125;&#125;</code></pre></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-10-SpringBoot整合SpringMVC、MyBatis"><a href="#NO2-10-SpringBoot整合SpringMVC、MyBatis" class="headerlink" title="NO2.10 SpringBoot整合SpringMVC、MyBatis"></a>NO2.10 SpringBoot整合SpringMVC、MyBatis</h3><p>这三个框架的整合，开发中我们也会经常遇到。</p><ul><li><p>基本步骤：</p><ul><li><p>创建基于SpringBoot的Maven工程，导入Web和MyBatis的依赖、数据库驱动依赖等等；<strong><code>注意：Web依赖里面包含有SpringMVC的JAR包，所以不需要添加额外的依赖。</code></strong></p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Web依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- Thymeleaf依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- MyBatis依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 数据库驱动依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 连接池依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>在src/main/resources下创建包templates存放静态资源、创建SpringBoot全局配置文件application.properties配置数据库；</p><pre><code class="hljs properties"><span class="hljs-comment">#配置链接数据库的四大要素</span><span class="hljs-meta">spring.datasource.driverClassName</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/数据库名称?serverTimezone=UTC</span><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">Deng521314</span><span class="hljs-comment">#配置德鲁伊数据源</span><span class="hljs-meta">spring.datasource.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><span class="hljs-comment">#配置别名，即在Mapper.xml中，参数或返回值类型，不需要再写全包名路径</span><span class="hljs-meta">mybatis.type-aliases-package</span>=<span class="hljs-string">com.dyf.pojo</span></code></pre></li><li><p>在Controller中，尽量使用RESTful风格进行开发；</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/&#123;page&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">showPage</span><span class="hljs-params">(@PathVariable String page)</span> </span>&#123;    <span class="hljs-keyword">return</span> page;&#125;注意：直接输入页面名称即可</code></pre></li><li><p>记得要在启动器类里，再配置一个扫描器，用于扫描MyBatis的Mapper接口；</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@MapperScan</span>(<span class="hljs-string">"com.dyf.mapper"</span>)  <span class="hljs-comment">//该注解用于扫描MyBatis的Mapper接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(App<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;说明：一、<span class="hljs-meta">@Mapper</span>一般我们用在接口上，代码如下：<span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from user where name = #&#123;name&#125;"</span>)    <span class="hljs-function">User <span class="hljs-title">find</span><span class="hljs-params">(String name)</span></span>;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from user where name = #&#123;name&#125; and pwd = #&#123;pwd&#125;"</span>)  <span class="hljs-comment">//对于多个参数来说，每个参数之前都要加上@Param注解，要不然会找不到对应的参数进而报错</span>    <span class="hljs-function">User <span class="hljs-title">login</span><span class="hljs-params">(@Param(<span class="hljs-string">"name"</span>)</span>String name, @<span class="hljs-title">Param</span><span class="hljs-params">(<span class="hljs-string">"pwd"</span>)</span>String pwd)</span>;&#125;使用 <span class="hljs-meta">@Mapper</span>，最终MyBatis会有一个拦截器，会自动的把<span class="hljs-meta">@Mapper</span>注解的接口生成动态代理类；这点可以在 MapperRegistry 类中的源代码中查看；<span class="hljs-meta">@Mapper</span>注解针对的是一个一个的类，相当于是一个一个Mapper.xml 文件；而一个接口一个接口的使用 <span class="hljs-meta">@Mapper</span>，太麻烦了，于是<span class="hljs-meta">@MapperScan</span>就应用而生了；二、<span class="hljs-meta">@MapperScan</span>配置一个或多个包路径，自动的扫描这些包路径下的类，自动的为它们生成代理类；代码如下：<span class="hljs-meta">@SpringBootApplication</span>  <span class="hljs-meta">@MapperScan</span>(&#123;<span class="hljs-string">"cn.dyf.mapper"</span>,<span class="hljs-string">"com.dxe.dao"</span>&#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XttblogApp</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;         SpringApplication.run(XttblogApp<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;      &#125;  &#125;当使用了<span class="hljs-meta">@MapperScan</span>注解，将会生成MapperFactoryBean，如果没有标注<span class="hljs-meta">@MapperScan</span>也就是没有MapperFactoryBean的实例，就走<span class="hljs-meta">@Import</span>里面的配置，具体可以在AutoConfiguredMapperScannerRegistrar和 MybatisAutoConfiguration类中查看源代码进行分析；由此可见，动态代理和AOP知识非常的重要，各种框架都在大量的使用三、SpringBoot默认的上传文件的大小为：<span class="hljs-number">10</span>M，要修改该限制，只需要在application.properties全局配置文件中配置即可；配置如下内容：spring.http.multipart.maxFileSize=设置单个文件的大小.MBspring.http.multipart.maxRequestSize = 设置单次请求的文件的总大小.MB    注意：一定要写单位的全称，即MB，GB等等，如果是想要不限制文件上传的大小，那么就把两个值都设置为-<span class="hljs-number">1</span></code></pre></li><li><p>其他的整合思路，与SpringMVC+Spring+MyBatis的思路相差无几；</p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-11-SpringBoot的启动器原理"><a href="#NO2-11-SpringBoot的启动器原理" class="headerlink" title="NO2.11 SpringBoot的启动器原理"></a>NO2.11 SpringBoot的启动器原理</h3><ul><li><p>SpringBoot的启动器原理解析；</p><pre><code class="hljs java"><span class="hljs-comment">//1.这是SpringBoot的入口类</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(App<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;<span class="hljs-comment">//2.点击SpringBoot入口类中的run()方法，进入到下面</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt; primarySource, String... args)</span> </span>&#123;   <span class="hljs-keyword">return</span> run(<span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123; primarySource &#125;, args);&#125;<span class="hljs-comment">//3.再进入返回值中“return run(new Class&lt;?&gt;[] &#123; primarySource &#125;, args);”的run()方法，进入到下面；也就是说运行到这里，启动SpringBoot的入口类后，new了个SpringApplication对象，并调用了run()方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SpringApplication(primarySources).run(args);&#125;<span class="hljs-comment">//4.我们先看看new SpringApplication()方法中，做了哪些事情，点击SpringApplication()方法，进入到下面</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(Class&lt;?&gt;... primarySources)</span> </span>&#123;   <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, primarySources);&#125;<span class="hljs-comment">//5.再点击“this()构造方法”，进入到下面</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;        <span class="hljs-keyword">this</span>.resourceLoader = resourceLoader;    Assert.notNull(primarySources, <span class="hljs-string">"PrimarySources must not be null"</span>);    <span class="hljs-comment">//保存主配置类</span>    <span class="hljs-keyword">this</span>.primarySources = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));    <span class="hljs-comment">//调用deduceFromClasspath()方法，检测当前环境是否为Web环境</span>    <span class="hljs-keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();    <span class="hljs-comment">//也就是说，通过getSpringFactoriesInstances(ApplicationContextInitializer.class)方法可以知道，其实该方法就是找到类路径下的META-INF/spring.factories文件中配置了的所有ApplicationContextInitializer，然后保存起来</span>    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;    <span class="hljs-comment">//同理getSpringFactoriesInstances(ApplicationListener.class)方法可以知道，其实该方法就是找到类路径下的META-INF/spring.factories文件中配置了的所有ApplicationListener，然后保存起来</span>    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;    <span class="hljs-comment">//这个方法则是能够检测出那个配置类中有“main”方法的标志，则哪个类是主程序的入口</span>    <span class="hljs-keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();&#125;<span class="hljs-comment">//5.1.这是deduceFromClasspath()方法</span><span class="hljs-function"><span class="hljs-keyword">static</span> WebApplicationType <span class="hljs-title">deduceFromClasspath</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="hljs-keyword">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="hljs-keyword">null</span>)         &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="hljs-keyword">null</span>)) &#123;      <span class="hljs-keyword">return</span> WebApplicationType.REACTIVE;   &#125;   <span class="hljs-keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;      <span class="hljs-keyword">if</span> (!ClassUtils.isPresent(className, <span class="hljs-keyword">null</span>)) &#123;         <span class="hljs-keyword">return</span> WebApplicationType.NONE;      &#125;   &#125;   <span class="hljs-keyword">return</span> WebApplicationType.SERVLET;&#125;<span class="hljs-comment">//5.2.这是getSpringFactoriesInstances()方法</span><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">Collection&lt;T&gt; <span class="hljs-title">getSpringFactoriesInstances</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>&#123;   <span class="hljs-keyword">return</span> getSpringFactoriesInstances(type, <span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123;&#125;);&#125;<span class="hljs-comment">//5.3.这是getSpringFactoriesInstances()方法</span><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">Collection&lt;T&gt; <span class="hljs-title">getSpringFactoriesInstances</span><span class="hljs-params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;   ClassLoader classLoader = getClassLoader();   <span class="hljs-comment">// Use names and ensure unique to protect against duplicates</span>   Set&lt;String&gt; names = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));   List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);   AnnotationAwareOrderComparator.sort(instances);   <span class="hljs-keyword">return</span> instances;&#125;<span class="hljs-comment">//5.4.这是loadFactoryNames()方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader)</span> </span>&#123;   String factoryTypeName = factoryType.getName();   <span class="hljs-keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());&#125;<span class="hljs-comment">//5.5.这是loadSpringFactories()方法</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader) &#123;   MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);   <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> result;   &#125;   <span class="hljs-keyword">try</span> &#123;      Enumeration&lt;URL&gt; urls = (classLoader != <span class="hljs-keyword">null</span> ?            <span class="hljs-comment">//这个变量的值其实就是META-INF/spring.factories，因为该类中的成员变量FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";</span>            classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :            ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));      result = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();      <span class="hljs-keyword">while</span> (urls.hasMoreElements()) &#123;         URL url = urls.nextElement();         UrlResource resource = <span class="hljs-keyword">new</span> UrlResource(url);         Properties properties = PropertiesLoaderUtils.loadProperties(resource);         <span class="hljs-keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;            String factoryTypeName = ((String) entry.getKey()).trim();            <span class="hljs-keyword">for</span> (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;               result.add(factoryTypeName, factoryImplementationName.trim());            &#125;         &#125;      &#125;      cache.put(classLoader, result);      <span class="hljs-keyword">return</span> result;   &#125;   <span class="hljs-keyword">catch</span> (IOException ex) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Unable to load factories from location ["</span> +            FACTORIES_RESOURCE_LOCATION + <span class="hljs-string">"]"</span>, ex);   &#125;&#125;<span class="hljs-comment">//5.6.这是deduceMainApplicationClass()方法</span><span class="hljs-keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;   <span class="hljs-keyword">try</span> &#123;      StackTraceElement[] stackTrace = <span class="hljs-keyword">new</span> RuntimeException().getStackTrace();      <span class="hljs-keyword">for</span> (StackTraceElement stackTraceElement : stackTrace) &#123;         <span class="hljs-keyword">if</span> (<span class="hljs-string">"main"</span>.equals(stackTraceElement.getMethodName())) &#123;            <span class="hljs-keyword">return</span> Class.forName(stackTraceElement.getClassName());         &#125;      &#125;   &#125;   <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;      <span class="hljs-comment">// Swallow and continue</span>   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<span class="hljs-comment">//6.接下来，退回到第3步，再来看看run()方法中做了哪些事情</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SpringApplication(primarySources).run(args);&#125;<span class="hljs-comment">//7.点击run()方法，进入后，发现下面</span><span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> </span>&#123;   StopWatch stopWatch = <span class="hljs-keyword">new</span> StopWatch();   stopWatch.start();   ConfigurableApplicationContext context = <span class="hljs-keyword">null</span>;   Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   configureHeadlessProperty();   <span class="hljs-comment">//获取SpringApplicationRunListeners，怎么获取的呢？点击getRunListeners()方法</span>   SpringApplicationRunListeners listeners = getRunListeners(args);   <span class="hljs-comment">//回调所有获取到的SpringApplicationRunListeners的starting()方法</span>   listeners.starting();   <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">//封装命令行参数</span>      ApplicationArguments applicationArguments = <span class="hljs-keyword">new</span> DefaultApplicationArguments(args);      <span class="hljs-comment">//准备环境，在创建环境完成后回调SpringApplicationRunListeners.environmentPrepared()方法，这个方法就表示环境准备完成了的意思</span>      ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);      configureIgnoreBeanInfo(environment);      Banner printedBanner = printBanner(environment);      <span class="hljs-comment">//创建ApplicationContext，也就是IOC容器，该方法会判断生成哪一种环境，是Web的IOC环境还是普通的IOC环境</span>      context = createApplicationContext();      exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span>            new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);      <span class="hljs-comment">//准备上下文环境，将Environment保存到IOC中，并回调之前保存的ApplicationContextInitializers的initializer()方法和SpringApplicationRunListener的contextPrepared()方法；最后该方法执行完成后会回调SpringApplicationRunListeners的contextLoaded()方法</span>      prepareContext(context, environment, listeners, applicationArguments, printedBanner);      <span class="hljs-comment">//刷新容器，初始化IOC容器(如果是Web应用还好创建嵌入式的Tomcat)，该方法执行完成后，IOC容器初始化完成</span>      refreshContext(context);      afterRefresh(context, applicationArguments);      stopWatch.stop();      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;         <span class="hljs-keyword">new</span> StartupInfoLogger(<span class="hljs-keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);      &#125;      listeners.started(context);      <span class="hljs-comment">//点击查看该方法，发现该方法从IOC容器中获取所有的ApplicationRunner(先调用)和CommandLineRunner(后调用)进行回调</span>      callRunners(context, applicationArguments);   &#125;   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      handleRunFailure(context, ex, exceptionReporters, listeners);      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);   &#125;   <span class="hljs-keyword">try</span> &#123;      listeners.running(context);   &#125;   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      handleRunFailure(context, ex, exceptionReporters, <span class="hljs-keyword">null</span>);      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);   &#125;   <span class="hljs-keyword">return</span> context;&#125;<span class="hljs-comment">//7.1.这是getRunListeners()方法，发现调用了也是从getSpringFactoriesInstances()方法中获取的，也就说从类路径下的META-INF/spring.factories里获取的</span><span class="hljs-function"><span class="hljs-keyword">private</span> SpringApplicationRunListeners <span class="hljs-title">getRunListeners</span><span class="hljs-params">(String[] args)</span> </span>&#123;   Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SpringApplicationRunListeners(logger, getSpringFactoriesInstances(SpringApplicationRunListener<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">types</span>, <span class="hljs-title">this</span>, <span class="hljs-title">args</span>))</span>;&#125;<span class="hljs-comment">//7.2.这是prepareEnvironment()方法</span><span class="hljs-function"><span class="hljs-keyword">private</span> ConfigurableEnvironment <span class="hljs-title">prepareEnvironment</span><span class="hljs-params">(SpringApplicationRunListeners listeners,</span></span><span class="hljs-function"><span class="hljs-params">      ApplicationArguments applicationArguments)</span> </span>&#123;      <span class="hljs-comment">//创建或者配置(在拥有环境的前提下)一个环境</span>   ConfigurableEnvironment environment = getOrCreateEnvironment();   configureEnvironment(environment, applicationArguments.getSourceArgs());   ConfigurationPropertySources.attach(environment);   listeners.environmentPrepared(environment);   bindToSpringApplication(environment);   <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isCustomEnvironment) &#123;      environment = <span class="hljs-keyword">new</span> EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,            deduceEnvironmentClass());   &#125;   ConfigurationPropertySources.attach(environment);   <span class="hljs-keyword">return</span> environment;&#125;<span class="hljs-comment">//7.3.这是createApplicationContext()方法</span><span class="hljs-function"><span class="hljs-keyword">protected</span> ConfigurableApplicationContext <span class="hljs-title">createApplicationContext</span><span class="hljs-params">()</span> </span>&#123;   Class&lt;?&gt; contextClass = <span class="hljs-keyword">this</span>.applicationContextClass;   <span class="hljs-keyword">if</span> (contextClass == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.webApplicationType) &#123;         <span class="hljs-keyword">case</span> SERVLET:            contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> REACTIVE:            contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);         &#125;      &#125;      <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(               <span class="hljs-string">"Unable create a default ApplicationContext, please specify an ApplicationContextClass"</span>, ex);      &#125;   &#125;   <span class="hljs-comment">//利用工具和反射创建IOC环境</span>   <span class="hljs-keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);&#125;<span class="hljs-comment">//7.4.这是prepareContext()方法</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareContext</span><span class="hljs-params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span><span class="hljs-function"><span class="hljs-params">      SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;   context.setEnvironment(environment);   postProcessApplicationContext(context);       <span class="hljs-comment">//点进去查看这个方法发现，这个方法主要是回调了之前保存的ApplicationContextInitializer的initializer()方法</span>   applyInitializers(context);   <span class="hljs-comment">//点击这个方法发现，这个方法也是回调了之前保存的SpringApplicationRunListener的contextPrepared()方法</span>   listeners.contextPrepared(context);   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;      logStartupInfo(context.getParent() == <span class="hljs-keyword">null</span>);      logStartupProfileInfo(context);   &#125;   <span class="hljs-comment">// Add boot specific singleton beans</span>   ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();   beanFactory.registerSingleton(<span class="hljs-string">"springApplicationArguments"</span>, applicationArguments);   <span class="hljs-keyword">if</span> (printedBanner != <span class="hljs-keyword">null</span>) &#123;      beanFactory.registerSingleton(<span class="hljs-string">"springBootBanner"</span>, printedBanner);   &#125;   <span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> DefaultListableBeanFactory) &#123;      ((DefaultListableBeanFactory) beanFactory)            .setAllowBeanDefinitionOverriding(<span class="hljs-keyword">this</span>.allowBeanDefinitionOverriding);   &#125;   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lazyInitialization) &#123;      context.addBeanFactoryPostProcessor(<span class="hljs-keyword">new</span> LazyInitializationBeanFactoryPostProcessor());   &#125;   <span class="hljs-comment">// Load the sources</span>   Set&lt;Object&gt; sources = getAllSources();   Assert.notEmpty(sources, <span class="hljs-string">"Sources must not be empty"</span>);   load(context, sources.toArray(<span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>]));   listeners.contextLoaded(context);&#125;<span class="hljs-comment">//7.5.这是applyInitializers()方法</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyInitializers</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> </span>&#123;   <span class="hljs-keyword">for</span> (ApplicationContextInitializer initializer : getInitializers()) &#123;      Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),            ApplicationContextInitializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;      Assert.isInstanceOf(requiredType, context, <span class="hljs-string">"Unable to call initializer."</span>);      initializer.initialize(context);   &#125;&#125;<span class="hljs-comment">//7.6.这是contextPrepared()方法</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextPrepared</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> </span>&#123;   <span class="hljs-keyword">for</span> (SpringApplicationRunListener listener : <span class="hljs-keyword">this</span>.listeners) &#123;      listener.contextPrepared(context);   &#125;&#125;<span class="hljs-comment">//7.7.这是callRunners()方法</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callRunners</span><span class="hljs-params">(ApplicationContext context, ApplicationArguments args)</span> </span>&#123;   List&lt;Object&gt; runners = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   runners.addAll(context.getBeansOfType(ApplicationRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">values</span>())</span>;   runners.addAll(context.getBeansOfType(CommandLineRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">values</span>())</span>;   AnnotationAwareOrderComparator.sort(runners);   <span class="hljs-keyword">for</span> (Object runner : <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(runners)) &#123;      <span class="hljs-keyword">if</span> (runner <span class="hljs-keyword">instanceof</span> ApplicationRunner) &#123;         callRunner((ApplicationRunner) runner, args);      &#125;      <span class="hljs-keyword">if</span> (runner <span class="hljs-keyword">instanceof</span> CommandLineRunner) &#123;         callRunner((CommandLineRunner) runner, args);      &#125;   &#125;&#125;</code></pre></li></ul><p>&nbsp;</p><ul><li><p>SpringBoot自定义Starter；</p><ul><li><p>Starter的原理；Spring Boot Starter的工作原理如下；</p><ul><li>Spring Boot 在启动时扫描项目所依赖的JAR包，寻找包含spring.factories文件的JAR；</li><li>根据spring.factories配置加载AutoConfigure类；</li><li>根据 @Conditional注解的条件，进行自动配置并将Bean注入Spring Context；</li></ul></li><li><p>自定义Starter；一个完整的SpringBootStarter可能包含以下组件：即starter模块(提供对autoconfigure模块的依赖，以及一些其它的依赖)和autoconfigure模块(包含自动配置的代码)；</p><ul><li><p>命名：模块名称不能以spring-boot开头，如，你为“mystarter”创建了一个starter，那么你的auto-configure模块可以命名为mystarter-spring-boot-autoconfigure，starter模块可以命名为mystarter-spring-boot-starter；如果你只有一个模块包含这两部分，那么你可以命名为acme-spring-boot-starter；</p></li><li><p>starter模块：事实上，starter是一个空jar；它唯一的目的是提供这个库所必须的依赖；你的starter必须直接或间接引用核心的SpringBoot的starter(即spring-boot-starter)；</p></li><li><p>autoconfigure模块：建议在autoconfigure模块中包含下列依赖；</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>编写自定义的MyStarter；</p><ul><li><p>新建一个Maven项目，选择Empty Project，并命名为SpringBoot-createmystarter；mystarter-spring-boot-starter；</p><p><img src="./Image-sb28.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb29.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>在打开的Empty Project中，分别创建两个模块，即starter模块和autoconfigure模块，我们先创建前者，再创建后者；注意：Project Structure对话框在创建Empty Project后会自动打开；</p><p><img src="./Image-sb30.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb31.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb32.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb33.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb34.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb35.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb36.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb37.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>在starter模块的pom.xml中引入autoconfigure模块；</p><p><img src="./Image-sb38.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>删除autoconfigure模块中多余的启动器，和全局配置文件；并在autoconfigure</p><p><img src="./Image-sb39.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb40.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>首先编写三个文件，MyStarterService，MyStarterProperties，MyStarterAutoConfiguration；</p><pre><code class="hljs java"><span class="hljs-comment">//这是MyStarterService类，这个类主要调用Properties类里面的方法或属性</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStarterService</span> </span>&#123;    <span class="hljs-comment">//注入MyStarterProperties</span>    MyStarterProperties myStarterProperties;    <span class="hljs-function"><span class="hljs-keyword">public</span> MyStarterProperties <span class="hljs-title">getMyStarterProperties</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> myStarterProperties;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMyStarterProperties</span><span class="hljs-params">(MyStarterProperties myStarterProperties)</span> </span>&#123;        <span class="hljs-keyword">this</span>.myStarterProperties = myStarterProperties;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">helloMyStarter</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> myStarterProperties.getName()+<span class="hljs-string">"-左边名称，右边描述-"</span>+myStarterProperties.getDesc();    &#125;&#125;<span class="hljs-comment">//-------------------------------------------------------</span><span class="hljs-comment">//这是MyStarterProperties类，也就是配置类，当用户在application.properties或application.yaml全局配置文件中，使用this.is.mystarter的前缀给属性进行配置时，其实实际上是在给MyStarterProperties的属性赋值，而其赋值原理是使用了Setter方法</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"this.is.mystarter"</span>)  <span class="hljs-comment">//该注解会将用户在全局配置文件中配置的属性，赋值到该类中</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStarterProperties</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String desc;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDesc</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> desc;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDesc</span><span class="hljs-params">(String desc)</span> </span>&#123;        <span class="hljs-keyword">this</span>.desc = desc;    &#125;&#125;<span class="hljs-comment">//-------------------------------------------------------</span><span class="hljs-comment">//这是MyStarterAutoConfiguration类，也就是自动配置类，该类的主要作用是对MyStarterService和MyStarterProperties两个类进行注册，也就是生成bean对象</span><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">//告知Spring这是一个配置类</span><span class="hljs-meta">@ConditionalOnWebApplication</span>  <span class="hljs-comment">//判断当前是否是web环境，如果不是，那么该自动配置类就不会生效</span><span class="hljs-meta">@EnableConfigurationProperties</span>(MyStarterProperties<span class="hljs-class">.<span class="hljs-keyword">class</span>)  //该注解使得<span class="hljs-title">MyStarterProperties</span>类生效，也就是生成<span class="hljs-title">bean</span>对象，放入到容器中</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">MyStarterAutoConfiguration</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MyStarterProperties myStarterProperties;    <span class="hljs-meta">@Bean</span>  <span class="hljs-comment">//注册Bean对象</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> MyStarterService <span class="hljs-title">myStarterService</span><span class="hljs-params">()</span></span>&#123;        MyStarterService service = <span class="hljs-keyword">new</span> MyStarterService();        service.setMyStarterProperties(myStarterProperties);        <span class="hljs-keyword">return</span> service;    &#125;&#125;</code></pre></li><li><p>当完成上面的步骤后，需要在类路径下(也就是Resources文件夹下)创建一个文件夹，名为META-INF，并在该文件夹下创建一个文件，名为spring.factories，并在该文件中将我们自动配置类的全包名路径放入即可，这样基本的Starter我们就自定义完成了，接下来只要使用Maven进行部署并测试就行了；</p><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span>.EnableAutoConfiguration=\xx<span class="hljs-selector-class">.xx</span><span class="hljs-selector-class">.xx</span>.xxxxAutoConfiguration</code></pre></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-12-SpringBoot与缓存"><a href="#NO2-12-SpringBoot与缓存" class="headerlink" title="NO2.12 SpringBoot与缓存"></a>NO2.12 SpringBoot与缓存</h3><p>SpringBoot中也整合了缓存。</p><ul><li><p>SpringBoot的缓存；</p><ul><li><p>JavaCache(简称JCache)，它定义了供开发人员使用的标准Java缓存API和供实现者使用的标准SPI(“服务提供者接口”)，并为Java提供了通用的方法来创建，访问，更新和删除缓存中的条目(entries)；JCache主要定义了5个接口来规范缓存的生命周期；</p><ul><li><code>CacheingProvider</code>：管理多个CacheManager，制定建立，配置，请求机制；</li><li><code>CacheManager</code>：管理多个Cache，制定建立，配置，请求机制，只有一个对应的CacheProvider；</li><li><code>Cache</code>：对缓存操作，是一个像Map一样的数据结构，它允许基于Key的临时存储；只有一个对应的CacheManager；</li><li><code>Cache.Entry</code>：是被Cache存储的单个key-value对；Cache接口的内部接口，真正的存储实体；</li><li><code>ExpiryPolicy</code>：控制缓存的过期时间；</li></ul></li><li><p>Spring的缓存抽象：</p><ul><li><p>定义：缓存抽象，也就是，每次调用目标方法时，抽象都会去缓存中查看是否有同样的查询；如果有，则返回缓存的结果，而不必执行实际的方法；如果没有，则执行方法，缓存结果并返回给用户，以便在下次调用方法时返回缓存的结果；这样，对于给定的一组参数，方法只能执行一次，并且结果可以重用，而不必实际再次执行该方法；</p></li><li><p>核心：抽象的核心是将缓存应用于Java方法，从而减少了基于缓存中可用信息的执行次数；</p></li><li><p>抽象实现：就像Spring里Framework中的其他服务一样，缓存服务是一种抽象(不是缓存实现)，需要使用实际存储来存储缓存数据，也就是说，抽象使开发人员不必编写缓存逻辑，但抽象不提供实际的存储；这种抽象由org.springframework.cache.Cache和org.springframework.cache.CacheManager这两个接口实现；这个抽象的一些实现可以直接使用：基于JDK java.util.concurrent.ConcurrentMap的缓存(即默认的缓存是基于JVM的ConcurrentMap)、Ehcache 2.x、Gemfire缓存、符合Caffeine和JSR-107的缓存(如，Ehcache 3.x)；对于缓存声明，抽象提供了一组Java注释，如下所示；</p></li><li><p>Spring缓存抽象中的几个重要概念和缓存注解；</p><ul><li><p><code>Cache</code>：指缓存接口，定义缓存操作，实现有：RedisCache、EhCache、ConcurrentMapCache等；</p></li><li><p><code>CacheManage</code>：指缓存管理器，用于管理各种缓存(Cache)组件；</p></li><li><p><code>@Cacheable</code>：就是指将该数据存储于缓存中，主要针对方法配置，能够根据方法的请求参数对其结果进行缓存；<strong><code>注意：@Cacheable不能用#result，且该注解会先去查询缓存再去运行方法。</code></strong></p><ul><li><p><code>cacheNames/value</code>：该属性值必须提供，指定缓存组件(也就是Cache)的名字，将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存。<code>如：cacheNames = &quot;product&quot;或者cacheNames = {&quot;product1&quot;,&quot;product2&quot;}</code>；</p></li><li><p><code>key</code>：缓存数据使用的key，不指定key则默认使用的是方法参数的值，该属性值支持SpEL表达式。<strong><code>注意：当我们要使用root对象的属性作为key时我们也可以将“#root”省略，因为Spring默认使用的就是root对象的属性。如，@Cacheable(key = &quot;targetClass + methodName + #p0&quot;)</code></strong>；使用方法参数时我们可以直接使用<code>#参数名</code>或者<code>#p参数的索引值(或者#a参数的索引值)</code>；<code>如，@Cacheable(value=&quot;users&quot;, key=&quot;#id&quot;)、@Cacheable(value=&quot;users&quot;, key=&quot;#p0&quot;)</code>；</p><p><img src="./Image-sb41.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p><code>cacheManager</code>：指定缓存管理器；或者cacheResolver指定获取解析器；</p></li><li><p><code>condition</code>：指定符合条件的情况下才缓存；<code>如，@Cacheable(condition = &quot;#id&gt;0&quot;)，表示当id大于0时，才进行缓存</code>；</p></li><li><p><code>unless</code>：否定缓存；当unless指定的条件为true，方法的返回值就不会被缓存；可以在获取到结果后进行判断，<code>unless = &quot;#result == null&quot;</code>，也可以，<code>unless = &quot;#a0==2&quot;</code>：如果第一个参数的值是2，结果不缓存；</p></li><li><p><code>sync</code>：是否使用异步模式；默认是为false，即使用同步模式，也就是说得到方法的结果之后，才会进行缓存；但是当该属性设置为true时，unless就不会生效；</p></li></ul></li><li><p><code>@CacheEvict</code>：指清空缓存；</p></li><li><p><code>@CachePut</code>：指保证方法被调用，又希望结果被缓存，相当于缓存的修改操作，该注解先执行方法，后更新缓存；<strong><code>注意：查询方法上缓存用的key要和修改方法上缓存所使用的key要相同。</code></strong></p><pre><code class="hljs java"><span class="hljs-meta">@Cacheable</span>(cacheNames=<span class="hljs-string">"xxx"</span> key=<span class="hljs-string">"#id"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUserById</span><span class="hljs-params">(Integer id)</span></span>&#123;    ....&#125;<span class="hljs-meta">@CachPut</span>(cacheNames=<span class="hljs-string">"xxx"</span> key=<span class="hljs-string">"#user.id"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">updateUser</span><span class="hljs-params">(User user)</span></span>&#123;    ....    <span class="hljs-keyword">return</span> user;&#125;</code></pre></li><li><p><code>@EnableCaching</code>：指开启基于注解的缓存，一般在启动类中进行添加；</p></li><li><p><code>@Caching</code>：重新组合要在方法上应用的多个缓存操作，也就是说你可以同时组合使用多个缓存的注解；</p><p><img src="./Image-sb42.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb43.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p><code>@CacheConfig</code>：在类级别共享一些常见的缓存相关设置；</p><p><img src="./Image-sb44.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p><code>keyGenerator</code>：指缓存时key的生成策略，可以自定义key的生成策略(也就是生成Cache中的Key值，用于缓存获取值使用)，可作为@Cacheable、@CachePut、@CacheConfig注解的属性；一般key和keyGenerator属性二选一即可；</p><pre><code class="hljs java"><span class="hljs-comment">//自定义Key的生成策略</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCacheConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"myKeyGenerator"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> KeyGenerator <span class="hljs-title">keyGenerator</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> KeyGenerator() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">generate</span><span class="hljs-params">(Object target, Method method, Object... params)</span> </span>&#123;                <span class="hljs-keyword">return</span> method.getName()+<span class="hljs-string">"["</span>+Arrays.asList(params).toString() +<span class="hljs-string">"]"</span>;            &#125;        &#125;;    &#125;&#125;<span class="hljs-comment">//在使用缓存的方法声明上，使用自己的key生成策略即可，也就是keyGenerator的值等于@Bean注解生成Bean对象的id就行了 </span><span class="hljs-meta">@Cacheable</span>(cacheNames = <span class="hljs-string">"users"</span>,keyGenerator = <span class="hljs-string">"myKeyGenerator"</span>)</code></pre></li><li><p><code>serialize</code>：指缓存数据时value序列化策略，可作为@Cacheable、@CachePut、@CacheConfig注解的属性；</p><p><img src="./Image-sb45.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li><li><p>创建基于SpringBoot的Maven工程后(一定要导入Cache的依赖)，只需要在启动类上使用@EnableCaching注解就表示开启了缓存，以及在需要使用缓存的方法上添加@Cacheable注解表示对该方法的结果进行缓存处理；</p><p><img src="./Image-sb46.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb47.png" srcset="/img/loading.gif" alt=""></p></li></ul></li><li><p>缓存工作原理，以及@Cacheable注解的运行流程；</p><ul><li><p>缓存工作原理；</p><ul><li><p>SpringBoot加载缓存的自动配置类：CacheAutoConfiguration；该自动配置类中主要是导入了<code>CacheConfigurationImportSelector</code>，这个类的作用是给容器中导入一些缓存的配置组件；</p><p><img src="./Image-sb48.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>CacheConfigurationImportSelector导入的缓存的配置类主要如下所示；通过在全局配置文件中添加debug=true(可以查看默认导入了哪些自动配置)，可以发现默认生效的是SimpleCacheConfiguration缓存配置类；这个默认生效的SimpleCacheConfiguration的作用其实就是给容器注册了一个CacheManager：ConcurrentMapCacheManager；最后在ConcurrentMapCacheManager中，根据方法获取或创建ConcurrentMapCache类型的缓存组件，它的作用是将数据保存在ConcurrentMap中；</p><pre><code class="hljs java">org.springframework.boot.autoconfigure.cache.GenericCacheConfigurationorg.springframework.boot.autoconfigure.cache.JCacheCacheConfigurationorg.springframework.boot.autoconfigure.cache.EhCacheCacheConfigurationorg.springframework.boot.autoconfigure.cache.HazelcastCacheConfigurationorg.springframework.boot.autoconfigure.cache.InfinispanCacheConfigurationorg.springframework.boot.autoconfigure.cache.CouchbaseCacheConfigurationorg.springframework.boot.autoconfigure.cache.RedisCacheConfigurationorg.springframework.boot.autoconfigure.cache.CaffeineCacheConfigurationorg.springframework.boot.autoconfigure.cache.GuavaCacheConfigurationorg.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration(默认加载的是这个缓存配置类)org.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration<span class="hljs-comment">//-----------------------------------------------------------------------</span><span class="hljs-comment">//1.这是默认生效的SimpleCacheConfiguration缓存配置类</span><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)<span class="hljs-meta">@ConditionalOnMissingBean</span>(CacheManager<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">Conditional</span>(<span class="hljs-title">CacheCondition</span>.<span class="hljs-title">class</span>)</span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">SimpleCacheConfiguration</span> </span>&#123;   <span class="hljs-meta">@Bean</span>   <span class="hljs-function">ConcurrentMapCacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">(CacheProperties cacheProperties,</span></span><span class="hljs-function"><span class="hljs-params">         CacheManagerCustomizers cacheManagerCustomizers)</span> </span>&#123;      ConcurrentMapCacheManager cacheManager = <span class="hljs-keyword">new</span> ConcurrentMapCacheManager();      List&lt;String&gt; cacheNames = cacheProperties.getCacheNames();      <span class="hljs-keyword">if</span> (!cacheNames.isEmpty()) &#123;         cacheManager.setCacheNames(cacheNames);      &#125;      <span class="hljs-keyword">return</span> cacheManagerCustomizers.customize(cacheManager);   &#125;&#125;<span class="hljs-comment">//------------------------------------------------------------------------</span><span class="hljs-comment">//2.ConcurrentMapCacheManager类实现了CacheManager接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentMapCacheManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CacheManager</span>, <span class="hljs-title">BeanClassLoaderAware</span> </span>&#123;    ....这里省略了一些代码....    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;String, Cache&gt; cacheMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">16</span>);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> dynamic = <span class="hljs-keyword">true</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@Nullable</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Cache <span class="hljs-title">getCache</span><span class="hljs-params">(String name)</span> </span>&#123;        Cache cache = <span class="hljs-keyword">this</span>.cacheMap.get(name);        <span class="hljs-keyword">if</span> (cache == <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.dynamic) &#123;            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.cacheMap) &#123;                cache = <span class="hljs-keyword">this</span>.cacheMap.get(name);                <span class="hljs-keyword">if</span> (cache == <span class="hljs-keyword">null</span>) &#123;                    cache = createConcurrentMapCache(name);                    <span class="hljs-keyword">this</span>.cacheMap.put(name, cache);                &#125;            &#125;        &#125;           <span class="hljs-keyword">return</span> cache;    &#125;    <span class="hljs-comment">//这是createConcurrentMapCache方法()，作用是生成了一个ConcurrentMapCache组件</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Cache <span class="hljs-title">createConcurrentMapCache</span><span class="hljs-params">(String name)</span> </span>&#123;        SerializationDelegate actualSerialization = (isStoreByValue() ? <span class="hljs-keyword">this</span>.serialization : <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcurrentMapCache(name, <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">256</span>), isAllowNullValues(), actualSerialization);    &#125;&#125;<span class="hljs-comment">//2.1.CacheManager接口中的方法有两个，一个是getCache()方法，返回值是一个Cache组件(该组件的值可以为null)，另一个getCacheNames()方法这是获取此CacheManager中已知的缓存的名称的集合</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CacheManager</span> </span>&#123;    <span class="hljs-meta">@Nullable</span>    <span class="hljs-function">Cache <span class="hljs-title">getCache</span><span class="hljs-params">(String var1)</span></span>;    <span class="hljs-function">Collection&lt;String&gt; <span class="hljs-title">getCacheNames</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//2.2.这是ConcurrentMapCache类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentMapCache</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractValueAdaptingCache</span> </span>&#123;   ....这里省略了一些代码....    <span class="hljs-comment">//实际new的是子类ConcurrentHashMap</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;Object, Object&gt; store;      <span class="hljs-comment">//这个是查询的方法，也就是从成员变量ConcurrentMap中根据key获取值</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@Nullable</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">lookup</span><span class="hljs-params">(Object key)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.store.get(key);    &#125;    <span class="hljs-comment">//这个方法是保存缓存数据的</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Object key, @Nullable Object value)</span> </span>&#123;        <span class="hljs-keyword">this</span>.store.put(key, toStoreValue(value));    &#125;    <span class="hljs-comment">//这个方法是删除指定键的缓存</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">evict</span><span class="hljs-params">(Object key)</span> </span>&#123;        <span class="hljs-keyword">this</span>.store.remove(key);    &#125;    <span class="hljs-comment">//这个方法是清空缓存</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.store.clear();    &#125;&#125;说明：这个默认生效的SimpleCacheConfiguration类中的方法，最终返回了一个ConcurrentMapCacheManager，也就是说这个默认生效的缓存配置类，主要的作用就是注册了一个ConcurrentMapCacheManager，并放到了容器中；而在ConcurrentMapCacheManager中，最主要的作用就是获取(根据Cache名称获取，有就获取)或者创建一个ConcurrentMapCache类型的Cache组件，该ConcurrentMapCache就是增删以及清空缓存的主要对象</code></pre></li></ul></li><li><p>运行流程如下；</p><ul><li>添加了@Cacheable注解的方法，在方法运行之前，会先去缓存里查询，按照cacheNames指定的名字获取，也就是CacheManager先获取相应的缓存；第一次获取缓存，如果没有Cache组件，会自动创建；</li><li>然后去Cache中查找缓存的内容，使用一个key，这个key默认就是方法的参数，key是按照某种策略生成的，默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key；说明：SimpleKeyGenerator生成key的默认策略：如果没有参数：key=new SimpleKey()；如果有一个参数：key=参数的值；如果有多个参数：key=new SimpleKey(params)；</li><li>没有查到缓存就调用目标方法；</li><li>将目标方法返回的结果，放进缓存中；</li><li>总结：@Cacheable标注的方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存，如果没有就运行方法并将结果放入缓存，以后再来调用就可以直接使用缓存中的数据；</li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>SpringBoot中整合Redis缓存；</p><ul><li><p>基本步骤：</p><ul><li><p>安装虚拟机，并在虚拟机中安装Redis以及Redis可视化界面程序：Redis-desktop-Manager，或者也可以使用Windows版本的redis，这样就不用安装虚拟机；</p></li><li><p>在SpringBoot中添加Redis依赖；</p><pre><code class="hljs xml">    <span class="hljs-comment">&lt;!-- Redis的依赖 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- jackson序列化 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>将Redis的属性配置编写到SpringBoot的全局配置文件Application.properties当中；</p><pre><code class="hljs properties">    <span class="hljs-meta">spring.redis.pools.min-idle</span>=<span class="hljs-string">5</span>    <span class="hljs-meta">spring.redis.pools.max-idle</span>=<span class="hljs-string">10</span>    <span class="hljs-meta">spring.redis.pools.max-total</span>=<span class="hljs-string">20</span>    <span class="hljs-meta">spring.redis.hostName</span>=<span class="hljs-string">127.0.0.1</span><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span></code></pre></li><li><p>编写测试类进行测试；</p><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">SpringBootTest</span>(<span class="hljs-title">classes</span></span>=App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-comment">//导入RedisTemplate对象进行对缓存操作即可</span>    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String,Object&gt; rt;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//存储</span>        rt.opsForValue().set(<span class="hljs-string">"dyf"</span>, <span class="hljs-string">"邓燕飞"</span>);                <span class="hljs-comment">//获取</span>        Object obj = rt.opsForValue().get(<span class="hljs-string">"dyf"</span>);        System.out.println(obj.toString());    &#125;&#125;注意：以上示例是存入一个键值对到Redis缓存中，以及根据Key从Redis取出对应的值</code></pre></li><li><p>在SpringBoot中使用Redis来存取对象，就需要在实体类上添加Serializable序列化接口，然后在进行存取值时，SpringBoot会默认使用JDK的对象序列化器，即new JdkSerializationRedisSerializer()，但是该序列化的缺点是，显示的数据是以Hex形式显示(就是<code>\xxxx\xxx\xxx</code>这样的形式)，且会浪费较多存储空间；由于JDK本身的序列化器比较占用空间且数据形式不直观，所以，我们把序列化器换成了<code>new Jackson2JsonRedisSerializer&lt;&gt;(实体类.class)</code>去替代上面的序列化器即可；</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;          ......&#125;<span class="hljs-comment">//---------------------------------------------------</span><span class="hljs-comment">//这是SpringBoot2.0版本中使用Jackson2序列化器的配置方法</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> CacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;    <span class="hljs-comment">//初始化一个RedisCacheWriter</span>    RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(connectionFactory);    Jackson2JsonRedisSerializer serializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    RedisSerializationContext.SerializationPair&lt;Object&gt; pair = RedisSerializationContext.SerializationPair.fromSerializer(serializer);    RedisCacheConfiguration defaultCacheConfig=RedisCacheConfiguration.defaultCacheConfig().serializeValuesWith(pair);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RedisCacheManager(redisCacheWriter, defaultCacheConfig);&#125;<span class="hljs-comment">//---------------------------------------------------</span><span class="hljs-meta">@Resource</span><span class="hljs-keyword">private</span> RedisTemplate&lt;String,Object&gt; rt;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    User user = <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">"邓先森"</span>, <span class="hljs-number">26</span>);    rt.opsForValue().set(<span class="hljs-string">"testUser"</span>, user);    User obj = (User)rt.opsForValue().get(<span class="hljs-string">"testUser"</span>);    System.out.println(obj);&#125;注意：一定要在需要序列化的实体类上实现Serializable接口</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>SpringBoot与Ehcache缓存；</p><ul><li><p>基本步骤：</p><ul><li><p>添加Ehcache依赖；</p><pre><code class="hljs xml">    <span class="hljs-comment">&lt;!-- SpringBoot缓存依赖 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>               <span class="hljs-comment">&lt;!-- Ehcache缓存依赖 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.sf.ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>在src/main/resources下创建Ehcache的配置文件，配置文件名称为：ehcache.xml；</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ehcache</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">          <span class="hljs-attr">xsi:noNamespaceSchemaLocation</span>=<span class="hljs-string">"../config/ehcache.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">diskStore</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"java.io.tmpdir"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">defaultCache</span> <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">"10000"</span> <span class="hljs-attr">eternal</span>=<span class="hljs-string">"false"</span></span><span class="hljs-tag">        <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">"120"</span> <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">"120"</span></span><span class="hljs-tag">        <span class="hljs-attr">maxElementsOnDisk</span>=<span class="hljs-string">"10000000"</span> <span class="hljs-attr">diskExpiryThreadIntervalSeconds</span>=<span class="hljs-string">"120"</span></span><span class="hljs-tag">        <span class="hljs-attr">memoryStoreEvictionPolicy</span>=<span class="hljs-string">"LRU"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">persistence</span> <span class="hljs-attr">strategy</span>=<span class="hljs-string">"localTempSwap"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">defaultCache</span>&gt;</span>           <span class="hljs-comment">&lt;!-- 自定义缓存策略 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user"</span></span><span class="hljs-tag">        <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">"10000"</span> <span class="hljs-attr">eternal</span>=<span class="hljs-string">"false"</span></span><span class="hljs-tag">        <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">"120"</span> <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">"120"</span></span><span class="hljs-tag">        <span class="hljs-attr">maxElementsOnDisk</span>=<span class="hljs-string">"10000000"</span> <span class="hljs-attr">diskExpiryThreadIntervalSeconds</span>=<span class="hljs-string">"120"</span></span><span class="hljs-tag">        <span class="hljs-attr">memoryStoreEvictionPolicy</span>=<span class="hljs-string">"LRU"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">persistence</span> <span class="hljs-attr">strategy</span>=<span class="hljs-string">"localTempSwap"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">cache</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ehcache</span>&gt;</span>注意：可以自定义缓存策略</code></pre></li><li><p>在application.properties配置文件中，配置缓存信息，让SpringBoot在启动的时候方便找到缓存配置文件并解析；</p><pre><code class="hljs properties"><span class="hljs-meta">spring.cache.ehcache.config</span>=<span class="hljs-string">classpath:ehcache.xml</span></code></pre></li><li><p>在启动类上添加一个注解；</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableCaching</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 启动类</span>&#123;    ...&#125;</code></pre></li><li><p>编写Service层和ServiceImpl实现类，编写测试类并进行测试缓存，在ServiceImpl实现类中对需要使用缓存的方法添加<code>@Cacheable(value=&quot;自定义的缓存策略名称&quot;)</code>注解，该注解就是开启缓存；</p><pre><code class="hljs java">......ServiceImpl实现类         <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@Cacheable</span>(value=<span class="hljs-string">"user"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">findUserById</span><span class="hljs-params">(Integer id)</span> </span>&#123;    User user = userRepository.findById(id).orElse(<span class="hljs-keyword">null</span>);    <span class="hljs-keyword">return</span> user;<span class="hljs-comment">//--------------------------------------------------------------</span>......测试类    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cacheTest</span><span class="hljs-params">()</span> </span>&#123;        User target1 = userService.findUserById(<span class="hljs-number">1</span>);        System.out.println(target1);        User target2 = userService.findUserById(<span class="hljs-number">1</span>);        System.out.println(target2);    &#125;&#125;注意：一般来说，查询两次，会出现两条SQL语句，使用缓存后，只会出现一条SQL语句，即开启缓存后，会将返回值存入缓存当中，下次查询根据缓存中是否有相同的key，决定是否直接从缓存中获取，有相同的key则从缓存中去值，没有则去数据库查询；测试后发现会报错NotSerializableException，即查询的对象实体类没有实现Serializable接口，因为被缓存的对象可以存储到本地文件当中(其实就是序列化)，所以只需要实体类实现Serializable接口即可；<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;    ....&#125;必须指定value属性，即将返回值存储到value定义的这个缓存当中</code></pre><ul><li><p>@Cacheable和@CacheEvict的区别；</p><ul><li><p>@Cacheable注解：</p><ul><li><p>是开启缓存的注解，可以写在方法上，即对该方法开启缓存；也可以写在类上，即对该类下所有方法都开启缓存；</p></li><li><p>该注解中的value属性必须要设置，即开启缓存必须指定将值存入一个缓存中；</p></li><li><p>缓存方法的返回值是以键值对进行缓存的，该注解中的key属性，就是用来指定缓存方法的返回结果时对应的key的；key的属性有两种定义方式：</p><ul><li>一是自定义；<code>如，使用方法参数就用&quot;#参数名&quot;</code>；</li><li>二是使用默认的root对象的属性；<code>如，使用当前方法参数组成的数组#root.args[0]等</code>。</li></ul></li><li><p>condition属性指定缓存发生的条件，即当满足condition属性设置的条件时(为true时)，才会触发缓存，否则不触发缓存；</p><pre><code class="hljs java"><span class="hljs-comment">//当id是偶数时才触发缓存</span><span class="hljs-meta">@Cacheable</span>(value=&#123;<span class="hljs-string">"user"</span>&#125;, key=<span class="hljs-string">"#user.id"</span>, condition=<span class="hljs-string">"#user.id%2==0"</span>)</code></pre></li></ul></li><li><p>@CacheEvict注解：</p><ul><li><p>是清除缓存的注解，写在方法上则清除该方法的缓存，写在类上则该类下所有方法的都会执行清除缓存操作；</p></li><li><p>value属性和key属性和@Cacheable相似，只是清除指定缓存下指定key所对应的缓存；</p></li><li><p>allEntries：该属性表示是否清除缓存中所有元素，默认是false；在使用了缓存之后，一定要记得清除缓存，否则会有数据库与缓存不同步的状况发生；</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-meta">@Cacheable</span>(value=<span class="hljs-string">"user"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">findUserAll</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> userRepository.findAll();&#125;注意：该方法使用了缓存<span class="hljs-comment">//------------------------------------------------------------</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cacheTest</span><span class="hljs-params">()</span> </span>&#123;        List&lt;User&gt; target = userService.findUserAll();    System.out.println(target.size());    User user = <span class="hljs-keyword">new</span> User();    user.setName(<span class="hljs-string">"小呜呜"</span>);    user.setAge(<span class="hljs-number">23</span>);    user.setAdress(<span class="hljs-string">"黄土高坡"</span>);    userService.saveUser(user);        List&lt;User&gt; target2 = userService.findUserAll();    System.out.println(target2.size());&#125;注意：这里出现了数据库与缓存不同步的问题，即两次调用findUserAll()，得到的结果都是相同的，但由于我们中间添加了一条记录，所以，数据库中的数据是要比缓存中多一条数据，但测试后得到结果都相同，所以两者不同步；解决方法如下<span class="hljs-meta">@Override</span><span class="hljs-meta">@CacheEvict</span>(value=<span class="hljs-string">"user"</span>,allEntries=<span class="hljs-keyword">true</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveUser</span><span class="hljs-params">(User user)</span> </span>&#123;    userRepository.save(user);&#125;解决：在saveUser()方法上添加<span class="hljs-meta">@CacheEvict</span>(value=<span class="hljs-string">"user"</span>,allEntries=<span class="hljs-keyword">true</span>)注解，并设置value和allEntries属性即可测试后，成功解决不同步的情况；解决思想：因为当方法开启缓存后，每次查询都会去缓存里查询是否有对应的值缓存，当添加新的记录时，由于添加方法增加了清除缓存的操作，所以再次调用查询方法时，发现没有缓存了，就只能去数据库获取数据，之后再次将查询结果放入缓存中，就解决了缓存与数据库不同步的问题</code></pre></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-13-SpringBoot与消息"><a href="#NO2-13-SpringBoot与消息" class="headerlink" title="NO2.13 SpringBoot与消息"></a>NO2.13 SpringBoot与消息</h3><p>SpringBoot中也有与消息中间件的整合。</p><ul><li><p>消息中间件；</p><ul><li><p>定义：什么是消息中间件？其实就是关注于数据的发送和接收，利用高效可靠的异步消息传递机制集成分布式系统；常用于异步处理、应用的解耦、流量的削峰、日志处理、以及纯粹的消息通信等等；</p></li><li><p>优点：</p><ul><li><p>异步通信：有些业务不想也不需要立即处理消息，消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它；想要往队列中放入多少消息就放多少，然后在需要的时候再去处理它们；</p></li><li><p>解耦：降低工程间的强依赖程度，针对异构系统进行适配；在项目启动之初来预测将来项目会碰到什么需求，是极其困难的；通过消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，当应用发生变化时，可以独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束；</p></li><li><p>冗余：有些情况下，处理数据的过程会失败，除非数据被持久化，否则将造成丢失；消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险；许多消息队列所采用的“插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕；</p></li><li><p>扩展性：因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可；不需要改变代码、不需要调节参数，便于分布式扩容；</p></li><li><p>过载保护：在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量无法提取预知；如果以为了能处理这类瞬间峰值访问为标准来投入资源随时待命无疑是巨大的浪费；使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃；</p></li><li><p>可恢复性：系统的一部分组件失效时，不会影响到整个系统；消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理；</p></li><li><p>顺序保证；在大多使用场景下，数据处理的顺序都很重要；大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理；</p></li><li><p>缓冲：在任何重要的系统中，都会有需要不同的处理时间的元素；消息队列通过一个缓冲层来帮助任务最高效率的执行，该缓冲有助于控制和优化数据流经过系统的速度，以调节系统响应时间；</p></li><li><p>数据流处理：分布式系统产生的海量数据流，如，业务日志、监控数据、用户行为等，针对这些数据流进行实时或批量采集汇总，然后进行大数据分析是当前互联网的必备技术，通过消息队列完成此类数据收集是最好的选择；</p><p><img src="./Image-sb49.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb50.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb51.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li><li><p>消息服务中心有两个重要的概念：消息代理(message broker)和目的地(destination)。意思就是说，当消息发送者发送消息后，消息将由消息代理接管，消息代理保证消息传递到目的地；消息代理主要有两种形式的目的地：队列(queue)和主题(topic)；</p><ul><li>点对点式：即点对点式消息通信；<ul><li>消息发送者发布消息，消息代理将其放入一个队列，消息接收者从队列中获取消息，消息被读取后则移除消息队列中的消息；</li><li>消息只有唯一的发送者和接受者，但并不是只有唯一的接收者。<strong><code>如，A是消息发送者，而B是实际接受者，但是消息其实也可以被B、C、D、E所接受，只是最后实际接收消息的是B</code></strong>；</li></ul></li><li>发布订阅式：即发布和订阅消息通信；<ul><li>发布者发送消息到主题，如果多个接受者(订阅者)监听(订阅)这个主题，那么所有接受者会在消息到达时同时接到消息。</li></ul></li></ul></li><li><p>什么是JMS？指的是Java消息服务(Java Message Service)，基于JVM的消息代理规范，是一个Java平台中关于面向消息中间件的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信；ActiveMQ、HornetMQ都是JMS的实现；</p></li><li><p>什么是AMQP？AMQP(advanced message queuing protocol)，即高级消息队列协议，兼容JMS，是应用层协议的一个开放标准，为面向消息的中间件设计；消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然；RabbitMQ是AMQP的实现；</p><p><img src="./Image-sb52.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb53.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>SpringBoot整合RabbitMQ消息中间件：</p><ul><li><p>介绍：RabbitMQ是一个开源的消息代理和队列服务器，RabbitMQ是使用Erlang语言来编写的，基于AMQP协议在完全不同的应用之间共享数据(RabbitMQ能够实现跨语言跨平台的机制)，本身支持很多的协议：AMQP、XMPP、SMTP、STOMP，也正是如此，使的它变的非常重量级，同时也实现了Broker架构，核心思想是生产者不会将消息直接发送给队列，消息在发送给客户端时先在中心队列排队；对路由(Routing)，负载均衡(Load balance)、数据持久化都有很好的支持，多用于进行企业级的ESB整合，以及用于在分布式系统中存储转发消息；</p></li><li><p>RabbitMQ的核心概念：</p><ul><li><code>Server</code>：又称为Broker，接收客户端的连接，实现AMQP实体服务，简单来说就是消息队列服务器实体；</li><li><code>Connection</code>：连接，应用程序与broker的网络连接；</li><li><code>Channel</code>：消息通道，几乎所有的操作都在Chanel中进行，Channel是进行消息读写的通道；客户端可建立多个Channel，每个Channel代表一个会话任务；</li><li><code>Message</code>：消息，服务器和应用程序之间传送的数据，由Properties和Body组成；Properties可以对消息进行修饰，比如消息的优先级，延迟等高级特性；而Body就是消息体内容；</li><li><code>Virtual host</code>：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离和逻辑隔离，是最上层的消息路由；一个vhost里面可以有若干个Exchange和Queue，同一个vhost里面不能有相同名称的exchange或queue(用于隔离不同的项目和应用的);</li><li><code>Exchange</code>：消息交换机，它指定消息按什么规则，路由到哪个队列；Exchange有多种类型，类型不同，Message的分发机制不同，主要有以下几种类型；<ul><li><code>fanout</code>：广播模式，这种类型的Exchange会将Message分发到绑定了该Exchange的所有Queue，所以写不写Routingkey绑定Queue都可以，因为是广播模式，只要绑定了广播模式的交换器，那么这些队列都可以接受到消息；</li><li><code>direct</code>：单播模式，这种类型的Exchange会根据Routing key(点对点精确匹配，将Message分发到指定的Queue)，默认使用该机制；</li><li><code>Topic</code>：主题模式，这种类型的Exchange会根据Routing key(模糊匹配，将Message分发到合适的Queue)；能够识别两个通配符：<code>符号“#”</code>和<code>符号“*”</code>，其中<code>#</code>匹配0个或多个单词，<code>*</code>匹配一个单词；</li><li><code>headers</code>：与主题交换机有点相似，但是不同于主题交换机的路由是基于路由键，头交换机的路由值基于消息的header数据；主题交换机路由键只有是字符串，而头交换机可以是整型和哈希值，该方式不常用；</li></ul></li><li><code>Binding</code>：绑定，它的作用就是把exchange和queue按照路由规则绑定起来；</li><li><code>Routing key</code>：路由关键字，exchange根据这个关键字进行消息投递；</li><li><code>Queue</code>：消息队列载体，每个消息都会被投入到一个或多个队列，保存消息并将它们转发给消费者，消费者直接监听队列就能收到消息了；<ul><li><code>name</code>：队列名称；</li><li><code>durable</code>：持久化消息队列，rabbitmq重启的时候不需要创建新的队列，默认true；</li><li><code>auto-delete</code>：表示消息队列没有在使用时将被自动删除，默认是false；</li><li><code>exclusive</code>：表示该消息队列是否只在当前connection生效，默认是false；</li></ul></li><li><code>producer</code>：消息生产者，就是投递消息的程序；</li><li><code>consumer</code>：消息消费者，就是接受消息的程序；</li></ul></li><li><p>基本步骤：</p><ul><li><p>分别安装Erlang语言(因为这个RabbitMQ是基于这个语言写的，需要Erlang的语言库，就像JAVA需要JVM一样)和RabbitMQ；</p><ul><li><p>下载并安装Erlang语言；</p><p><img src="./Image-sb54.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>下载并安装RabbitMQ；</p><p><img src="./Image-sb55.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>安装管理界面(插件)，进入RabbitMQ的安装目录的sbin目录；</p><p><img src="./Image-sb56.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>在地址栏输入cmd打开命令窗口，输入命令：rabbitmq-plugins enable rabbitmq_management，并回车；</p><p><img src="./Image-sb57.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>出现如下界面后，重启RabbitMQ服务；如果不行，则再次执行一次rabbitmq-plugins enable rabbitmq_management命令后，重启RabbitMQ服务；</p><p><img src="./Image-sb58.png" srcset="/img/loading.gif" alt=""></p></li><li><p>打开浏览器，输入地址+端口，查看RabbitMQ管理界面<code>http://localhost:15672/</code>，进行登录，用户名：guest，密码：guest，登录成功后可看到如下界面；至此RabbitMQ已经全部安装完成；</p><p><img src="./Image-sb59.png" srcset="/img/loading.gif" alt=""></p></li></ul></li><li><p>创建一个基于SpringBoot的Maven项目，并导入RabbitMQ所需要的依赖，然后在测试中导入RabbitTemplate模板(这个模板是操作消息的发送与接收的)进行测试即可；</p><ul><li><p>工程创建完成后，导入RabbitMQ的依赖，为了测试方便，也可以引入Web依赖；</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>由于在RabbitAutoConfiguration自动配置类中，许多需要的组件都已经被配置好了，像CachingConnectionFactory(用于连接到RabbitMQ的连接对象)、RabbitTemplate(用于给RabbitMQ发送和接收消息)、AmqpAdmin(RabbitMQ系统管理功能组件)等等，且RabbitProperties封装了RabbitMQ配置，在application.properties(或xxx.ymal)中配置RabbitMQ基本连接信息就可以了；</p><pre><code class="hljs properties"><span class="hljs-comment">#配置RabbitMQ的主机地址，不配置的话就默认是本机地址，也就是localhost</span><span class="hljs-meta">spring.rabbitmq.host</span>=<span class="hljs-string">xxx.xxx.xxx.xxx</span><span class="hljs-meta">spring.rabbitmq.port</span>=<span class="hljs-string">15672</span><span class="hljs-meta">spring.rabbitmq.username</span>=<span class="hljs-string">wang</span><span class="hljs-meta">spring.rabbitmq.password</span>=<span class="hljs-string">123</span></code></pre><p><img src="./Image-sb60.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb61.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb62.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>在测试类中可以直接使用RabbitTemplate进行测试收发消息(前提已经配置好了RabbitMQ)；</p><pre><code class="hljs java"><span class="hljs-comment">//这是发送消息</span><span class="hljs-meta">@SpringBootTest</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootCacheApplicationTests</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RabbitTemplate rt;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//该方法用的比较少，因为创建message这个对象比较麻烦，</span>        rt.send(exchange,routingKey,message);        <span class="hljs-comment">//我们一般常用这个方法，参数从左到右依次是交换器，路由键，消息对象</span>        rt.convertAndSend(exchange,routingKey,Object);    &#125;&#125;<span class="hljs-comment">//-------------------------------------------------------------------</span><span class="hljs-comment">//我们也可以自己配置一个消息序列化器，让消息可视化，一般使用Jackson2JsonMessageConverter序列化器</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAMQPConfig</span></span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title">messageConverter</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Jackson2JsonMessageConverter();    &#125;&#125;<span class="hljs-comment">//---------------------------------------------------------------------</span><span class="hljs-comment">//这是接收消息</span><span class="hljs-meta">@SpringBootTest</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootCacheApplicationTests</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RabbitTemplate rt;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">receiveMessage</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//我们一般常用这个方法接收某个指定队列里的消息</span>        rt.reciveAndConver(queueName);    &#125;&#125;说明：上述发送消息的方法中的message参数，也就是需要发送的消息内容，其中创建该Message类的对象，需要封装两个参数，一是需要发送的内容，将其转为一个字节数组，二是MessageProperties对象，这个对象是用来设置消息的一些属性，如，消息的优先级等等，所以我们一般很少用这个方法，常用的是converAndSend()方法，一般用带三个参数的方法，分别是交换器名称，路由键，消息内容即可，但要注意的是，该方法发送消息会自动序列化消息内容，默认使用的是SimpleMessageConverter，也就是在消息队列里查看消息的话，是一串我们看不懂的数据，所以我们也可以自己编写一个配置类，然后设置序列化器，；而在接收消息的方法里，也就是reciveAndConver()方法，只需要填入需要接收的消息队列的名称就行了</code></pre><p><img src="./Image-sb63.png" srcset="/img/loading.gif" alt=""></p></li></ul></li><li><p>还可以在Java中直接配置Exchange、Queue、Routingkey，这样就会在RabbitMQ的Broker中，生成你配置的这些组件，这与你在Broker设置并生成的组件是一样的；</p><pre><code class="hljs java">#配置要连接的RabbitMQ服务器的账号和密码；spring.rabbitmq.username=guestspring.rabbitmq.password=guest#host属性不配置，默认是本机，也就是localhost；#spring.rabbitmq.host=localhost#port属性，默认配置的是5672，也就是RabbitMQ的端口#spring.rabbitmq.port=5672<span class="hljs-comment">//-----------------------------------------------------------</span><span class="hljs-comment">//这是基于Java进行配置Exchange、Queue、Binding</span><span class="hljs-keyword">import</span> org.springframework.amqp.core.Binding;<span class="hljs-keyword">import</span> org.springframework.amqp.core.BindingBuilder;<span class="hljs-keyword">import</span> org.springframework.amqp.core.DirectExchange;<span class="hljs-keyword">import</span> org.springframework.amqp.core.Queue;<span class="hljs-keyword">import</span> org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;<span class="hljs-keyword">import</span> org.springframework.amqp.support.converter.MessageConverter;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRabbitConfig</span> </span>&#123;    <span class="hljs-comment">//创建一个Json的序列化器，这样发送和接收的消息就会是一个Json字符串</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title">myMessageConverter</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Jackson2JsonMessageConverter();    &#125;    <span class="hljs-comment">//创建一个Queue</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">myQueue</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">"dyfQueue"</span>,<span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-comment">//创建一个Direct类型的Exchange</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">myDirectExchange</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(<span class="hljs-string">"dyfExchange"</span>);    &#125;    <span class="hljs-comment">//创建一个Binding，并绑定到Queue和Exchange</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">myBinding</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(myQueue()).to(myDirectExchange()).with(<span class="hljs-string">"dyf"</span>);    &#125;&#125;<span class="hljs-comment">//----------------------------------------------------------------</span><span class="hljs-comment">//测试发送数据</span><span class="hljs-meta">@SpringBootTest</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitmqApplicationTests</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RabbitTemplate rt;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;        rt.convertAndSend(<span class="hljs-string">"dyfExchange"</span>,<span class="hljs-string">"dyf"</span>,<span class="hljs-string">"你好啊，RabbitMQ！"</span>);    &#125;&#125;<span class="hljs-comment">//测试从Queue中接收数据</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;    Object msg = rt.receiveAndConvert(<span class="hljs-string">"dyfQueue"</span>);    System.out.println(msg);&#125;控制台成功输出：你好啊，RabbitMQ！</code></pre></li><li><p>使用监听器进行监听队列，当队列收到消息时，则会进行某些操作，监听机制需要使用注解@RabbitListener和@RabbitHandler搭配使用，但是要注意的是，监听队列的方法也会消费消息，也就是说，也相当于一个消息消费者；</p><ul><li><p>@RabbitListener注解可以标注在类上面，需配合@RabbitHandler注解一起使用。当@RabbitListener标注在类上面，表示当有收到消息的时候，就交给@RabbitHandler的方法处理，具体使用哪个方法处理，根据MessageConverter转换后的参数类型；</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListener</span> </span>&#123;    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"dyfQueue"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenQueue</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"监听到消息了..."</span>);    &#125;&#125;<span class="hljs-comment">//--------------------------------------------------</span><span class="hljs-meta">@EnableRabbit</span>  <span class="hljs-comment">//该注解的作用就是开启基于注解RabbitMQ模式</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitmqApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(RabbitmqApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;说明：一、<span class="hljs-meta">@RabbitListener</span>注解的queues属性是一个数组，可以写多个需要监听队列名称；二、要使用监听机制监听消息，必须在启动类上添加注解<span class="hljs-meta">@EnableRabbit</span>，该注解的作用就是开启基于注解的RabbitMQ模式。</code></pre></li></ul></li><li><p>AmqpAdmin对象的使用：这个对象是用于管理RabbitMQ中的组件的，也就是创建Exchange、Queue、Binding等等；</p><pre><code class="hljs java"><span class="hljs-comment">//declare方法里面是创建一些组件,相反的有一些remove方法和delete方法，用来删除</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;    ad.declareExchange(<span class="hljs-keyword">new</span> FanoutExchange(<span class="hljs-string">"selfExchange"</span>));    ad.declareQueue(<span class="hljs-keyword">new</span> Queue(<span class="hljs-string">"selfQueue"</span>,<span class="hljs-keyword">true</span>));    ad.declareBinding(            <span class="hljs-keyword">new</span> Binding(<span class="hljs-string">"selfQueue"</span>, Binding.DestinationType.QUEUE,                    <span class="hljs-string">"selfExchange"</span>,                    <span class="hljs-string">"#.dec"</span>,                    <span class="hljs-keyword">null</span>)    );    System.out.println(<span class="hljs-string">"创建成功啦"</span>);&#125;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-14-SpringBoot与检索"><a href="#NO2-14-SpringBoot与检索" class="headerlink" title="NO2.14 SpringBoot与检索"></a>NO2.14 SpringBoot与检索</h3><p>你知道我们常用的百度搜索等搜索引擎，到底使用的什么搜索吗？其实是ElasticSearch。</p><ul><li><p>ElasticSearch：</p><ul><li><p>介绍：Elasticsearch是一个开源的分布式、RESTful风格的搜索和数据分析引擎，它的底层是开源库Apache Lucene；Lucene可以说是当下最先进、高性能、全功能的搜索引擎库——无论是开源还是私有，但它也仅仅只是一个库；为了充分发挥其功能，你需要使用Java并将Lucene直接集成到应用程序中；为了解决Lucene使用时的繁复性，于是ElasticSearch便应运而生；它使用Java编写，内部采用Lucene做索引与搜索，但是它的目标是使全文检索变得更简单，简单来说，就是对Lucene做了一层封装，它提供了一套简单一致的RESTful风格的API来帮助我们实现存储和检索；当然，Elasticsearch不仅仅是Lucene，并且也不仅仅只是一个全文搜索引擎，它可以被这样准确地形容：一个分布式的实时文档存储，每个字段可以被索引与搜索；一个分布式实时分析搜索引擎；能胜任上百个服务节点的扩展，并支持PB级别的结构化或者非结构化数据；由于Elasticsearch的功能强大和使用简单，维基百科、卫报、StackOverflow、GitHub等都纷纷采用它来做搜索。现在，Elasticsearch已成为全文搜索领域的主流软件之一；</p></li><li><p>ElasticSearch的安装；</p><ul><li><p>到官网根据系统下载ES的zip包即可；</p><p><img src="./Image-sb64.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>解压到自定义的指定目录下(注意目录的路径不要有中文)；</p></li><li><p>进入ES的bin目录，双击elasticsearch.bat启动服务，默认端口是9200；</p><p><img src="./Image-sb65.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>启动完成之后，在浏览器中访问<code>http://localhost:9200/</code>，出现如下图所示内容表明ES启动成功；</p><p><img src="./Image-sb66.png" srcset="/img/loading.gif" alt=""></p></li></ul></li><li><p>ES的核心概念；</p><ul><li><code>节点&amp;集群(Node&amp;Cluster)</code>：ES本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个ES实例；单个ES实例称为一个节点(Node)，一组节点构成一个集群(Cluster)；</li><li><code>索引(Index)</code>：ES数据管理的顶层单位就叫做Index，相当于关系型数据库里的数据库的概念；另外，每个Index的名字必须是小写；</li><li><code>类型(Type)</code>：Document可以分组；如，employee这个Index里面，可以按部门分组，也可以按职级分组，这种分组就叫做Type，它是虚拟的逻辑分组，用来过滤Document，类似关系型数据库中的数据表；不同的 Type应该有相似的结构(Schema)，性质完全不同的数据(如，products和logs)应该存成两个Index，而不是一个Index里面的两个Type(虽然可以做到)；</li><li><code>文档(Document)</code>：Index里面单条的记录称为Document(相当于数据库里表的记录)；许多条Document构成了一个Index；Document使用JSON格式表示；同一个Index里面的Document，不要求有相同的结构(scheme)，但是最好保持相同，这样有利于提高搜索效率；</li><li><code>字段(Fields)</code>：每个Document都类似一个JSON结构，它包含了许多字段，每个字段都有其对应的值，多个字段组成了一个Document，可以类比关系型数据库数据表中的字段；</li><li><code>文档元数据(Document metadata)</code>：文档元数据为<code>_index</code>、<code>_type</code>、<code>_id</code>，这三者可以唯一表示一个文档，<code>_index</code>表示文档在哪存放，<code>_type</code>表示文档的对象类别，<code>_id</code>为文档的唯一标识；</li></ul></li><li><p>SpringBoot整合ElasticSearch；</p><ul><li><p>Java存在三种ES的客户端；造成这种混乱的原因是ES开始是没有Java版的客户端，但Java自己是可以简单的支持ES的API，所以有了第一种客户端(Transport Client)；后来官方推出了第二种版本(Java Low Level Rest Client)，但缺点也是显而易见的，因为从第一种版本迁移到第二版本工作量是比较的大的，官方还特意出一堆文档来提供参考；而第三种版本的客户端是兼容两种客户端的优点，他是在第二种版本的基础上进行了封装，也让代码迁移变得更方便，但依然存在缺点，小的版本更新频繁，经常出现莫名其妙的错误，我们尽量保持客户端和服务器相同的版本；</p><ul><li>Transport Client；</li><li>Java Low Level Rest Client；</li><li>Java High Level Rest Client；</li></ul></li><li><p>创建基于SpringBoot的Maven工程后，引入ES依赖，然后创建EsConfig配置类；</p><pre><code class="hljs java">&lt;!--ES引入--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;    &lt;version&gt;6.6.2&lt;/version&gt;&lt;/dependency&gt;<span class="hljs-comment">//-----------------------------------------------------------</span><span class="hljs-keyword">import</span> org.apache.http.HttpHost;<span class="hljs-keyword">import</span> org.elasticsearch.client.RestClient;<span class="hljs-keyword">import</span> org.elasticsearch.client.RestHighLevelClient;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EsConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestHighLevelClient <span class="hljs-title">restHighLevelClient</span><span class="hljs-params">()</span></span>&#123;        RestHighLevelClient client = <span class="hljs-keyword">new</span> RestHighLevelClient(                RestClient.builder(<span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"10.105.9.119"</span>, <span class="hljs-number">9200</span>, <span class="hljs-string">"http"</span>))        );        <span class="hljs-keyword">return</span> client;    &#125;&#125;</code></pre></li><li><p>执行增删改查；</p><ul><li><p>查询；</p><p><img src="./Image-sb67.png" srcset="/img/loading.gif" alt="Image"></p><pre><code class="hljs java"><span class="hljs-comment">//查询id为1的记录</span><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RestHighLevelClient client;<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/teacher"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">get</span><span class="hljs-params">(@RequestParam(value = <span class="hljs-string">"id"</span>,defaultValue = <span class="hljs-string">""</span>)</span> String id) <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (id.isEmpty())&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity(HttpStatus.NOT_FOUND);        &#125;        <span class="hljs-comment">//封装具体的查询条件</span>        GetRequest request = <span class="hljs-keyword">new</span> GetRequest(<span class="hljs-string">"user"</span>,<span class="hljs-string">"teacher"</span>,id);        GetResponse result = client.get(request, RequestOptions.DEFAULT);        <span class="hljs-keyword">if</span> (!result.isExists())&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity(HttpStatus.NOT_FOUND);        &#125;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity(result.getSource(),HttpStatus.OK);        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><p><img src="./Image-sb68.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>增加；</p><pre><code class="hljs java"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/add"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">add</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            @RequestParam String name,</span></span><span class="hljs-function"><span class="hljs-params">            @RequestParam String gender,</span></span><span class="hljs-function"><span class="hljs-params">            @RequestParam <span class="hljs-keyword">int</span> age,</span></span><span class="hljs-function"><span class="hljs-params">            @RequestParam String country,</span></span><span class="hljs-function"><span class="hljs-params">            @RequestParam String date )</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder()                .startObject()                .field(<span class="hljs-string">"name"</span>,name)                .field(<span class="hljs-string">"gender"</span>,gender)                .field(<span class="hljs-string">"age"</span>,age)                .field(<span class="hljs-string">"country"</span>,country)                .field(<span class="hljs-string">"date"</span>,date)                .endObject();    IndexRequest indexRequest = <span class="hljs-keyword">new</span> IndexRequest(<span class="hljs-string">"user"</span>,<span class="hljs-string">"teacher"</span>);    indexRequest.source(xContentBuilder);    IndexResponse response = client.index(indexRequest,RequestOptions.DEFAULT);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity(response.getId(),HttpStatus.OK);&#125;</code></pre><p><img src="./Image-sb69.png" srcset="/img/loading.gif" alt=""></p></li><li><p>修改；</p><pre><code class="hljs java"><span class="hljs-meta">@PutMapping</span>(<span class="hljs-string">"/update/teacher"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">update</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            @RequestParam(name = <span class="hljs-string">"id"</span>)</span> String id,</span><span class="hljs-function">            @<span class="hljs-title">RequestParam</span><span class="hljs-params">(name = <span class="hljs-string">"name"</span>,required = <span class="hljs-keyword">false</span>)</span> String name,</span><span class="hljs-function">            @<span class="hljs-title">RequestParam</span><span class="hljs-params">(name = <span class="hljs-string">"gender"</span>,required = <span class="hljs-keyword">false</span>)</span> String gender ) <span class="hljs-keyword">throws</span> IOException </span>&#123;    UpdateRequest updateRequest = <span class="hljs-keyword">new</span> UpdateRequest(<span class="hljs-string">"user"</span>,<span class="hljs-string">"teacher"</span>,id);    XContentBuilder xContentBuilder = XContentFactory.jsonBuilder()                .startObject()                .field(<span class="hljs-string">"name"</span>,name)                .field(<span class="hljs-string">"gender"</span>,gender)                .endObject();    updateRequest.doc(xContentBuilder);    UpdateResponse result = client.update(updateRequest,RequestOptions.DEFAULT);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity(result.getId(),HttpStatus.OK);&#125;</code></pre><p><img src="./Image-sb70.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>删除；</p><pre><code class="hljs java"><span class="hljs-meta">@DeleteMapping</span>(<span class="hljs-string">"/delete/teacher"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">delete</span><span class="hljs-params">(@RequestParam(name = <span class="hljs-string">"id"</span>)</span> String id) <span class="hljs-keyword">throws</span> IOException </span>&#123;    DeleteRequest deleteRequest = <span class="hljs-keyword">new</span> DeleteRequest(<span class="hljs-string">"user"</span>,<span class="hljs-string">"teacher"</span>,id);    DeleteResponse deleteResponse = client.delete(deleteRequest,RequestOptions.DEFAULT);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity(deleteResponse.status(),HttpStatus.OK);&#125;</code></pre><p><img src="./Image-sb71.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-15-SpringBoot与任务"><a href="#NO2-15-SpringBoot与任务" class="headerlink" title="NO2.15 SpringBoot与任务"></a>NO2.15 SpringBoot与任务</h3><p>SpringBoot中的有异步、定时任务的配置；</p><ul><li><p>SpringBoot中的异步任务；</p><ul><li><p>同步和异步：</p><ul><li>同步：就是整个处理过程顺序执行，当各个过程都执行完毕，并返回结果；</li><li>异步：异步调用则是只是发送了调用的指令，调用者无需等待被调用的方法完全执行完毕，而是继续执行下面的流程；基于@Async标注的方法，称之为异步方法；这些方法将在执行的时候，将会在独立的线程中被执行，调用者无需等待它的完成，即可继续其他的操作。</li></ul></li><li><p>SpringBoot中的异步任务的使用：</p><ul><li><p>在SpringBoot中使用异步任务，需要先开启异步任务(使用的是Spring中自带的)，使用注解@EnableAsync表示支持异步任务，也就是开启异步任务，将该注解用在SpringBoot的启动类上就行了；SpringBoot对于异步、定时、缓存、切面等的配置都是通过在启动类上加@EnableXXX来配置的；</p><pre><code class="hljs java"><span class="hljs-meta">@EnableAsync</span>  <span class="hljs-comment">//表示开启异步任务</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;注意：有两种方式开启异步任务，如下所示：一、基于Java配置的启用方式；<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableAsync</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringAsyncConfig</span> </span>&#123; ... &#125;二、基于XML配置文件的启用方式，配置如下；&lt;task:executor id=<span class="hljs-string">"myexecutor"</span> pool-size=<span class="hljs-string">"5"</span>  /&gt;&lt;task:annotation-driven executor=<span class="hljs-string">"myexecutor"</span>/&gt;</code></pre></li><li><p>需要使用异步的方法添加@Async注解，这表示该方法会异步执行，也就是说主线程会直接跳过该方法，而是使用线程池中的线程来执行该方法；@Async注解使用条件：</p><ul><li><p>@Async注解一般用在类的方法上，如果用在类上，那么这个类所有的方法都是异步执行的；</p></li><li><p>使用@Async注解的方法所在的类的对象应该是Spring容器管理的bean对象；</p></li><li><p>调用异步方法类上需要配置上注解@EnableAsync</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.scheduling.annotation.Async;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-meta">@Component</span><span class="hljs-meta">@Async</span>  <span class="hljs-comment">//用在了类上，表示该类下的所有方法都是需要异步执行的</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncTask</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">task1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();        Thread.sleep(<span class="hljs-number">3000</span>);        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();        System.out.println(<span class="hljs-string">"当前线程："</span> + Thread.currentThread().getName() + <span class="hljs-string">"，"</span> + <span class="hljs-string">"任务一耗时："</span> + (end - start) + <span class="hljs-string">"ms"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">task2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();        Thread.sleep(<span class="hljs-number">3000</span>);        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();        System.out.println(<span class="hljs-string">"当前线程："</span> + Thread.currentThread().getName()  + <span class="hljs-string">"，"</span> + <span class="hljs-string">"任务二耗时："</span> + (end - start) + <span class="hljs-string">"ms"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">task3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();        Thread.sleep(<span class="hljs-number">3000</span>);        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();        System.out.println(<span class="hljs-string">"当前线程："</span> + Thread.currentThread().getName() + <span class="hljs-string">"，"</span> + <span class="hljs-string">"任务三耗时："</span> + (end - start) + <span class="hljs-string">"ms"</span>);    &#125;&#125;</code></pre></li></ul></li><li><p>调用异步任务，以及测试结果；</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> AsyncTask asyncTask;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/taskService"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doTask</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();        asyncTask.task1();        asyncTask.task2();        asyncTask.task3();        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();        System.out.println(<span class="hljs-string">"任务总耗时："</span> + (end - start) + <span class="hljs-string">"ms"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">"任务总耗时："</span> + (end - start) + <span class="hljs-string">"ms"</span>;    &#125;&#125;拓展：SpringBoot异步任务默认使用的线程池为SimpleAsyncTaskExecutor，其特点如下：一、默认定义多少异步任务，创建多少线程(创建线程数量太多，占用内存过大，会造成OutOfMemoryError)；二、SimpleAsyncTaskExecutor不提供拒绝策略机制；三、SimpleAsyncTaskExecutor可通过设置参数concurrencyLimit(值为大于或等于<span class="hljs-number">0</span>的整数)，指定启用的线程数目，默认concurrencyLimit取值为-<span class="hljs-number">1</span>，即不启用资源，目的为了节流；</code></pre><p><img src="./Image-sb72.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>SpringBoot中的定时任务(Spring中自带的Scheduled)；</p><ul><li><p>Scheduled只适合处理简单的计划任务，不能处理分布式计划任务；</p><ul><li>优势：是spring框架提供的计划任务，开发简单，执行效率比较高；</li><li>劣势：且在计划任务数量太多的时候，可能出现阻塞，崩溃，延迟启动等问题。</li></ul></li><li><p>基本步骤：</p><ul><li><p>要启用Scheduled定时任务，则需要在启动类上增加注解@EnableScheduling，代表启用Scheduled定时任务机制；</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableScheduling</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppStarter</span> </span>&#123;　　<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;　　　　SpringApplication.run(AppStarter<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;　　&#125;&#125;</code></pre></li><li><p>Scheduled定时任务的核心在于注解@Scheduled，这个注解的核心属性是cron，代表定时任务的触发计划表达式；这个表达式的格式为：</p><ul><li><p>第一种：@Scheduled(cron=”seconds minutes hours day month week”)；</p></li><li><p>第二种：@Scheduled(cron=”seconds minutes hours day month week year”)。推荐使用第一种表达式形式，因为在很多其他技术中都有不同的定时任务机制，其中用于设置触发计划的表达式都是第一种cron表达式，第二种表达式不能说是Spring Scheduled特有的，也是只有少数技术支持的；cron表达式解析：</p><p><img src="./Image-sb73.png" srcset="/img/loading.gif" alt="Image"></p><pre><code class="hljs java">说明：一、符号说明    <span class="hljs-number">1</span>.逗号(,)：表达一个列表值。如，在星期字段中使用“MON,WED,FRI”，则表示星期一，星期三和星期五；    <span class="hljs-number">2</span>.减号(-)：表达一个范围。如，在小时字段中使用“<span class="hljs-number">10</span>-<span class="hljs-number">12</span>”，则表示从<span class="hljs-number">10</span>到<span class="hljs-number">12</span>点，即<span class="hljs-number">10</span>，<span class="hljs-number">11</span>，<span class="hljs-number">12</span>；    <span class="hljs-number">3</span>.星号(*)：可用在所有字段中，表示对应时间域的每一个时刻。例如，*在分钟字段时，表示“每分钟”；    <span class="hljs-number">4</span>.斜杠(/)：x/y表达一个等步长序列，x为起始值，y为增量步长值。如，在秒数字段中使用<span class="hljs-number">0</span>/<span class="hljs-number">15</span>，则表示为<span class="hljs-number">0</span>、<span class="hljs-number">15</span>、<span class="hljs-number">30</span>和<span class="hljs-number">45</span>秒，而<span class="hljs-number">5</span>/<span class="hljs-number">15</span>在分钟字段中表示<span class="hljs-number">5</span>、<span class="hljs-number">20</span>、<span class="hljs-number">35</span>、<span class="hljs-number">50</span>，你也可以使用*/y，它等同于<span class="hljs-number">0</span>/y；    <span class="hljs-number">5</span>.问号(?)：该字符只在day和week字段中使用，它通常指定为“无意义的值”，相当于占位符。二、特殊说明<span class="hljs-number">1</span>.L：该字符只在day和week字段中使用，代表“Last”的意思，但它在两个字段中意思不同；L在日期字段中，表示这个月份的最后一天，如一月的<span class="hljs-number">31</span>号，非闰年二月的<span class="hljs-number">28</span>号；如果L用在星期中，则表示星期六，等同于<span class="hljs-number">7</span>；但是，如果L出现在星期字段里，而且在前面有一个数值X，则表示“这个月的最后X天”，如，<span class="hljs-number">6L</span>表示该月的最后星期五<span class="hljs-number">2</span>.W：该字符只能出现在day字段里，是对前导日期的修饰，表示离该日期最近的工作日；如，<span class="hljs-number">15</span>W表示离该月<span class="hljs-number">15</span>号最近的工作日，如果该月<span class="hljs-number">15</span>号是星期六，则匹配<span class="hljs-number">14</span>号星期五；如果<span class="hljs-number">15</span>日是星期日，则匹配<span class="hljs-number">16</span>号星期一；如果<span class="hljs-number">15</span>号是星期二，那结果就是<span class="hljs-number">15</span>号星期二；但必须注意关联的匹配日期不能够跨月，如，你指定<span class="hljs-number">1</span>W，如果<span class="hljs-number">1</span>号是星期六，结果匹配的是<span class="hljs-number">3</span>号星期一，而非上个月最后的那天；W字符串只能指定单一日期，而不能指定日期范围<span class="hljs-number">3</span>.LW组合：在日期字段可以组合使用LW，它的意思是当月的最后一个工作日4.井号(#)：该字符只能在week字段中使用，表示当月的第几个周几；如，6#3表示当月的第三个星期五(6表示星期五，#3表示当前的第三个)，而4#5表示当月的第五个星期三，假设当月没有第五个星期三，忽略不触发<span class="hljs-number">5</span>.C：该字符只在日期和星期字段中使用，代表“Calendar”的意思；它的意思是计划所关联的日期，如果日期没有被关联，则相当于日历中所有日期。例如<span class="hljs-number">5</span>C在日期字段中就相当于日历<span class="hljs-number">5</span>日以后的第一天。<span class="hljs-number">1</span>C在星期字段中相当于星期日后的第一天三、Cron表达式对特殊字符的大小写不敏感，对代表星期的缩写英文大小写也不敏感四、示例每隔<span class="hljs-number">5</span>秒执行一次：*/<span class="hljs-number">5</span> * * * * ?每隔<span class="hljs-number">1</span>分钟执行一次：<span class="hljs-number">0</span> */<span class="hljs-number">1</span> * * * ?每天<span class="hljs-number">23</span>点执行一次：<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">23</span> * * ?每天凌晨<span class="hljs-number">1</span>点执行一次：<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> * * ?每月<span class="hljs-number">1</span>号凌晨<span class="hljs-number">1</span>点执行一次：<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> * ?每月最后一天<span class="hljs-number">23</span>点执行一次：<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">23</span> L * ?每周星期六凌晨<span class="hljs-number">1</span>点实行一次：<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> ? * L在<span class="hljs-number">26</span>分、<span class="hljs-number">29</span>分、<span class="hljs-number">33</span>分执行一次：<span class="hljs-number">0</span> <span class="hljs-number">26</span>,<span class="hljs-number">29</span>,<span class="hljs-number">33</span> * * * ?每天的<span class="hljs-number">0</span>点、<span class="hljs-number">13</span>点、<span class="hljs-number">18</span>点、<span class="hljs-number">21</span>点都执行一次：<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>,<span class="hljs-number">13</span>,<span class="hljs-number">18</span>,<span class="hljs-number">21</span> * * ?如：<span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Controller</span> </span>&#123;        <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/test"</span>)        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doTask</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;            test2();        &#125;        <span class="hljs-comment">//添加定时任务，每五秒触发一次</span>        <span class="hljs-meta">@Scheduled</span>(cron = <span class="hljs-string">"0/5 * * * * ?"</span>)        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(<span class="hljs-string">"执行静态定时任务时间: "</span> + LocalDateTime.now());        &#125;&#125;</code></pre><p><img src="./Image-sb74.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>SpringBoot中使用邮件服务；</p><ul><li><p>首先是引入邮件服务的依赖；</p><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>在邮箱中开启POP3/SMTP/IMAP服务后，点击生产一个授权码，这个授权码，等一会在配置文件中需要使用；</p><p><img src="./Image-sb75.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb76.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>配置application.properties；</p><pre><code class="hljs properties"><span class="hljs-comment">    #发件人邮箱</span>    <span class="hljs-meta">spring.mail.username</span>=<span class="hljs-string">xxxxxxx@qq.com</span>    <span class="hljs-comment">    #生成的授权码，就是开启POP3/SMTP/IMAP服务后，点击生成授权码产生的一串字符，相当于我们登录邮箱使用的密码</span>    <span class="hljs-meta">spring.mail.password</span>=<span class="hljs-string">lojwzgpnrpzmifgg</span>    <span class="hljs-comment">    #QQ的SMIP地址，用不同的邮箱发送，SMIP地址也会不一样</span>    <span class="hljs-meta">spring.mail.host</span>=<span class="hljs-string">smtp.qq.com</span>    <span class="hljs-comment">    #配置安全连接，如果不配置，会报错</span><span class="hljs-meta">spring.mail.properties.mail.smtp.ssl.enable</span>=<span class="hljs-string">true</span></code></pre></li><li><p>测试发送邮件；</p><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">SpringBootTest</span></span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">Tests</span> </span>&#123;　　<span class="hljs-comment">//注入邮件发送器　</span>    <span class="hljs-meta">@Autowired</span>    JavaMailSenderImpl mailSender;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMail</span><span class="hljs-params">()</span></span>&#123;　　　　 <span class="hljs-comment">//发送简单的邮件</span>        SimpleMailMessage message=<span class="hljs-keyword">new</span> SimpleMailMessage();　　　　 <span class="hljs-comment">//邮件的一些设置</span>　　　　 <span class="hljs-comment">//标题</span>        message.setSubject(<span class="hljs-string">"注意"</span>);　　　　 <span class="hljs-comment">//内容</span>        message.setText(<span class="hljs-string">"有内鬼，终止交易"</span>);　　　　 <span class="hljs-comment">//发送人</span>        message.setFrom(<span class="hljs-string">"xxxxx@qq.com"</span>);　　　　 <span class="hljs-comment">//收件人</span>        message.setTo(<span class="hljs-string">"xxxxxx@gmail.com"</span>);        mailSender.send(message);    &#125;　　    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tesr01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;　　　　 <span class="hljs-comment">//复杂邮件发送</span>        MimeMessage mimeMessage=mailSender.createMimeMessage();　　　　 <span class="hljs-comment">//使用helper上传文件，后面的true参数就是表示要上传文件</span>        MimeMessageHelper helper=<span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage,<span class="hljs-keyword">true</span>);        helper.setSubject(<span class="hljs-string">"注意"</span>);　　　　 <span class="hljs-comment">//可以HTML样式，后面的true参数表示，我发送的这段内容是html，你要帮我解析</span>        helper.setText(<span class="hljs-string">"&lt;b style='color:blue'&gt;有内鬼，终止交易&lt;/b&gt;"</span>,<span class="hljs-keyword">true</span>);　　　　 <span class="hljs-comment">//上传文件，可以上传多个</span>        helper.addAttachment(<span class="hljs-string">"1.jpg"</span>,<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\Jump\\Pictures\\1.jpg"</span>));        helper.setFrom(<span class="hljs-string">"xxxxx@qq.com"</span>);        helper.setTo(<span class="hljs-string">"xxxxxx@qq.com"</span>);        mailSender.send(mimeMessage);    &#125;&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-16-SpringBoot与安全"><a href="#NO2-16-SpringBoot与安全" class="headerlink" title="NO2.16 SpringBoot与安全"></a>NO2.16 SpringBoot与安全</h3><ul><li><p>SpringBoot中的安全机制；</p><ul><li><p>介绍：常用的安全框架，一个是Shiro，一个就是Spring Security：Shiro安全框架在另一篇笔记中有详细的介绍与使用，这里主要介绍Spring Security在SpringBoot中的使用；Spring Security是一种基于SpringAOP和Servlet过滤器的安全框架，它可以在web请求级别和方法调用级别处理身份和授权，它是基于AspectJ的切面进行配置的；</p></li><li><p>Spring Security的核心功能主要包括：认证(你是谁)、授权(你能干什么)、攻击防护(防止伪造身份)；其核心就是一组过滤器链，项目启动后将会自动配置；最核心的就是Basic Authentication Filter，是用来认证用户的身份的；<strong><code>注意：绿色的过滤器可以配置是否生效，其他的都不能控制。</code></strong></p><p><img src="./Image-sb77.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>SpringBoot中使用Spring Security；</p><ul><li><p>创建基于SpringBoot的Maven工程后，引入Spring Security；</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>使用类来配置最简单的安全性配置，所以我们需要编写一个配置类；当我们需要指定Web的安全细节，则需要重写WebSecurityConfigurationAdapter的一些方法。<code>如，configure方法，其中configure(WebSecurity)配置Security的filter链、configure(HttpSecurity)配置哪些请求需要验证，哪些请求不需要验证，以及需要的权限、configure(AuthenticationManagerBuilder)配置user-detail服务</code>；</p><pre><code class="hljs java"><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;      <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <span class="hljs-comment">//该方法用来配置登录验证的逻辑，简单地说，就是哪些请求你要拦截，哪些请求不拦截</span>        http.authorizeRequests()                .antMatchers(<span class="hljs-string">"/"</span>, <span class="hljs-string">"/home"</span>).permitAll()  <span class="hljs-comment">//这里的“/”和“/home”路径被配置为不需要任何身份验证，所有其他路径必须经过身份验证</span>                .anyRequest().authenticated()  <span class="hljs-comment">//其他任何请求都需要认证，也就是登录后才可以进行操作</span>                .and()            .formLogin()  <span class="hljs-comment">//开启自动配置的登录功能，即如果没有登录、没有权限时就会来到登录页面</span>                .loginPage(<span class="hljs-string">"/aaa"</span>).permitAll()  <span class="hljs-comment">//用户未登录时，访问任何资源都转跳到该路径，即自定义的登录页面“/aaa”，且访问登录页面时不需要验证，否则就会死循环</span>                .and()            .logout().logoutSuccessUrl(<span class="hljs-string">"xxx"</span>);  <span class="hljs-comment">//开启自动配置的注销功能，访问“/logout”，表示用户注销，即清空Session，后面的logoutSuccessUrl()则表示，退出后，跳转到那个页面去</span>            .rememberMe();  <span class="hljs-comment">//开启记住我功能，其原理其实就是服务端根据来访的客户端，分别给它们创建一个SessionID，</span>    &#125;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureGlobal</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth            .inMemoryAuthentication()                .withUser(<span class="hljs-string">"user"</span>).password(<span class="hljs-string">"password"</span>).roles(<span class="hljs-string">"USER"</span>);  <span class="hljs-comment">//将单个用户设置在内存中，该用户的用户名为“user”，密码为“password”，角色为“USER”</span>    &#125;&#125;说明：一、<span class="hljs-meta">@EnableWebSecurity</span>注解，用在实现了接口WebSecurityConfigurer或者继承自WebSecurityConfigurerAdapter的Web安全配置类上，该注解有两个作用，一是加载了WebSecurityConfiguration配置类，配置安全认证策略；二是加载了AuthenticationConfiguration，配置了认证信息；说白了，就是启用Web安全，也就是启用了Spring Security二、上面需要注意的是.loginPage(<span class="hljs-string">"/aaa"</span>)方法中，表示的是跳转到自定义的登录页面去，但是，如果要发登录请求，会默认以post形式访问“/aaa”这个url进行登录验证，也就是说，在前端的登录页面中，提交登录请求的url也要写成“/aaa”，只不过提交方法变成了post形式而已；如果你想自定义登录验证的url，也就是你来指定让登录请求去访问哪个接口，还可以使用方法loginProcessingUrl(<span class="hljs-string">"xxx"</span>)；并且在这里还可以设置两个方法，也就是usernameParameter(<span class="hljs-string">"xxx"</span>)和passwordParameter(<span class="hljs-string">"xxx"</span>)，指定提交过来的账号和密码是两个什么样的参数名；</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>JSR303校验：</p><ul><li><p>定义：JSR是Java Specification Requests的缩写，意思是Java规范提案，是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。任何人都可以提交JSR，以向Java平台增添新的API和服务；JSR已成为Java界的一个重要标准；</p><p><img src="./Image-sb10.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-sb11.png" srcset="/img/loading.gif" alt="Image"></p></li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;    <span class="hljs-meta">@Email</span>  <span class="hljs-comment">//这个就是JSR303校验所使用的注释，被标注的元素必须是电子邮箱格式，否则会抛出异常</span>    <span class="hljs-meta">@value</span>(<span class="hljs-string">"dyf"</span>)    <span class="hljs-keyword">private</span> String lastName;    ....get、set、toString方法.... &#125;</code></pre></li></ul><p>&nbsp;</p><ul><li><p>SpringBoot与hibernate-validator参数校验；</p><ul><li><p>SpringBoot默认集成了hibernate-validator，因为在Web依赖中就已经包含了它，且默认是生效的，可以直接使用；</p><ul><li><p>使用hibernate-validator主要分为两大步骤；</p><ul><li><p>.在对象型参数的POJO类里的属性上添加校验注解。<code>如，@NotBlank等</code>；</p></li><li><p>使用@Valid，去注解Controller方法里需要校验的对象型参数；</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;        <span class="hljs-meta">@NotBlank</span>(message=<span class="hljs-string">"用户名不允许为空！"</span>)    <span class="hljs-keyword">private</span> String username;    <span class="hljs-meta">@NotBlank</span>(message=<span class="hljs-string">"密码不允许为空！"</span>)    <span class="hljs-keyword">private</span> String password;    <span class="hljs-meta">@NotNull</span>    <span class="hljs-meta">@Range</span>(min=<span class="hljs-number">0</span>,max=<span class="hljs-number">120</span>)    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-comment">//下面是对应的get()和set()方法...</span>&#125;<span class="hljs-comment">//------------------------------------------------------------------------</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/insertUser"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">insertUser</span><span class="hljs-params">(@Valid User user)</span> </span>&#123;    System.out.println(user);    <span class="hljs-keyword">return</span> <span class="hljs-string">"ok"</span>;&#125;注意：在JavaBean中的对应的属性上添加校验的注解类型即可，如上所示；在Controller里自定义处理参数的对应方法声明上，要添加一个<span class="hljs-meta">@Valid</span>注解，即开启该对象的字段校验</code></pre></li></ul></li><li><p>当校验出现不符合规则的数据时，需要一个对象去收集错误信息，并作出相应的提示信息，这个对象就是BindingResult；</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/insertUser"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">insertUser</span><span class="hljs-params">(@Valid User user, BindingResult result)</span> </span>&#123;    <span class="hljs-comment">//判断收集错误信息的对象是否有接收到异常信息</span>    <span class="hljs-keyword">if</span>(result.hasErrors()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"insertUserPage"</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-string">"ok"</span>;&#125;说明：一、<span class="hljs-meta">@Validated</span>：是Spring validator里的注解，可以用在类型、方法和方法参数上，但是不能用在成员属性上；<span class="hljs-meta">@Valid</span>：是Hibernate validation里的注解，可以用在方法、构造函数、方法参数和成员属性上；这两者并没有使用上的差别      (<span class="hljs-number">2</span>).BindingResult，就是获取校验信息的对象，如果没有写这个对象的话，一旦校验出有数据是有问题的，那么服务器会直接抛异常MethodArgumentNotValidException，写上该对象的话则会将错误信息收集，然后交给调用者自己处理；hasErrors()方法就是判断是否有校验出错的信息；当某个字段出现不符合校验规则的情况时，会创建一个与该字段名称一样的同名属性伪变量，并将错误信息作为值，存储到伪变量中；然后，ModelAndView会创建一个与被校验的对象一模一样的同名伪对象，存入Attribute中，传到前端并展示；以上所述：即当被校验的user对象中的name属性不符合校验规则时，会创建一个同名的name变量，错误信息作为值，再创建一个与被校验的对象一模一样的伪对象user，将name属性存入user中，用于在前端展示</code></pre></li><li><p>前端使用th:errors进行获取错误的校验信息即可；</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">"@&#123;/insertUser&#125;"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>          用户名：          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"red"</span> <span class="hljs-attr">th:errors</span>=<span class="hljs-string">"$&#123;user.username&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span>                           密码：          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"red"</span> <span class="hljs-attr">th:errors</span>=<span class="hljs-string">"$&#123;user.password&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span>                             年龄：          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"red"</span> <span class="hljs-attr">th:errors</span>=<span class="hljs-string">"$&#123;user.age&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span>                             <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"保存"</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>注意：th:errors="$&#123;user.username&#125;"中的user并不是被校验的user对象，而是由于本体user对象属性校验出错，ModelAndView重新创建的一个与被校验的对象同名的伪对象；同理，username也不是本体user的username属性，而是用来存储校验错误信息的伪同名属性，将该伪同名属性存入上面的伪对象中，用于在前端反馈错误信息；但是，当第一次访问页面时，并没有user对象，因为没有产生校验的错误信息，也就获取不到相应的各种校验错误的信息；针对这种情况，可以按照下面的方式解决；      @RequestMapping("/insertUserPage")      public String insertUserPage(User user) &#123;          return "insertUserPage";      &#125;在跳转页面后，一定要注入一个User user，因为当出现不符合校验规则的情况出现时，需要一个伪对象user去获取错误信息并展示出来，在跳转页面时，如果没有注入一个User user，则会出现异常，因为Attribute中并没有user这个对象，也就无法获取对应的校验属性的信息</code></pre></li><li><p>hibernate-validator中常用的校验注解；</p><p><img src="./Image-sb78.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>区分@NotNull，@NotEmpty，@NotBlank，3个注解的区别；</p><ul><li>@NotNull：不能为null，但可以为空格字符串和empty(即可以是空字符串)；</li><li>@NotEmpty：不能为null、空字符串，而且长度必须大于0，但可以是空格符串；</li><li>@NotBlank：只能用于字符串，不能为null，并且字符串trim()以后length要大于0，即不允许空字符串和空格字符串；</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>1.대학교 일 학년</category>
      
      <category>03.Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大一课程</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03.SSM框架--学习笔记</title>
    <link href="/2020/07/03/SSM%E6%A1%86%E6%9E%B6--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/03/SSM%E6%A1%86%E6%9E%B6--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="SSM框架–学习笔记-包含SSM视频"><a href="#SSM框架–学习笔记-包含SSM视频" class="headerlink" title="SSM框架–学习笔记(包含SSM视频)"></a>SSM框架–学习笔记(包含SSM视频)</h1><h2 id="Lesson1-Spring框架"><a href="#Lesson1-Spring框架" class="headerlink" title="Lesson1 Spring框架"></a>Lesson1 Spring框架</h2><h3 id="NO1-1-Spring概述"><a href="#NO1-1-Spring概述" class="headerlink" title="NO1.1 Spring概述"></a>NO1.1 Spring概述</h3><p>Spring是service层的框架。</p><ul><li>Spring框架：<ul><li>定义：该框架是一个轻量级的、开源的Java EE框架；</li><li>应用：解决企业应用开发的复杂性；</li><li>核心：<code>IOC和AOP</code>，即控制反转和面向切面编程；</li><li>特点：<ul><li>方便解耦，简化开发；</li><li>兼容与其他框架的开发；</li><li>便捷的事务操作。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>入门案例：</p><ul><li><p>使用IDEA创建一个Java工程，下载Spring5.x版本的JAR包，或者使用Maven导入Spring5的依赖即可；</p><p><img src="./image-ssm1.png" srcset="/img/loading.gif" alt="image-20200704004514715"></p></li><li><p>创建包路径：cn.dyf.domain，然后再domain包中，创建一个User类；</p></li><li><p>在项目中你自定义的包路径下，创建Spring的核心配置文件：<code>applicationContext.xml</code>；我这里创建的是cn.dyf.domain，所以我打算把Spirng配置文件放在cn.dyf包下(入门案例，你放哪里都行)。Spring配置文件的标准头信息如下：</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">"http://www.springframework.org/schema/p"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/context</span></span><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span><span class="hljs-comment">&lt;!--配置了一个User类的对象，对象名为user，然后Spring中不叫对象名，而是叫id，所以，配置了一个id为user的User类的对象--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.dyf.domain.User"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></li><li><p>编写一个测试类：</p><pre><code class="hljs java">piblic  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//加载Spring的配置文件applicationContext.xml，获得</span>ClassPathXmlApplicationContext cac = <span class="hljs-keyword">new</span>ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:applicationContext.xml"</span>);        <span class="hljs-comment">//获取你刚刚配置的user对象</span>User u= cac.getBean(<span class="hljs-string">"user"</span>,User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-comment">//输出了u对象，这个u对象，其实就是刚刚配置的user对象</span>System.out.println(u);&#125;&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-2-IOC和DI"><a href="#NO1-2-IOC和DI" class="headerlink" title="NO1.2 IOC和DI"></a>NO1.2 IOC和DI</h3><p>IOC极大的提高了Java的编程效率。</p><ul><li><p>IOC：</p><ul><li><p>定义：即控制反转，也就是将创建对象的操作交给Spring去管理；</p></li><li><p>底层原理：</p><ul><li>首先，将配置在applicationContext.xml中的<code>&lt;bean&gt;</code>标签进行解析，也就是告诉Spring要生成哪些类的对象；</li></ul></li><li><p>然后，Spring中有个工厂类，这个工厂类会根据xml文件解析出的结果来创建对象，没错，这个工厂类就是专门用于创建某一类对象的工厂；</p></li><li><p>最后，在工厂类中，通过反射的方式来获取xml文件解析结果中要求创建的类的对象，这就是<code>&lt;bean&gt;</code>标签中，class属性的作用，为反射提供了类，而反射会根据类获得该类的字节码文件对象，然后该类的字节码文件对象使用newInstance()方法就能够得到你配置在xml文件中的类的对象了。</p></li><li><p>两个接口：IOC思想基于IOC容器，而IOC容器的底层就是能够创建对象的工厂类；</p><ul><li><p><code>BeanFactory</code>：该接口就是IOC容器的基本实现，即创建对象的功能就是这个接口的一个方法。但该接口是Spring内部接口，常常是Spring内部在使用，所以一般我们开发者不使用该接口来创建工厂实现类；</p></li><li><p><code>ApplicationContext</code>：是BeanFactory的子接口，但添加了更多更强大的功能在该接口中，一般开发者实现的就是这个接口来创建工厂类。</p><pre><code class="hljs lasso">拓展：BeanFactory与ApplicationContext的区别一、BeanFactory创建的实现类在加载Spring的<span class="hljs-built_in">xml</span>配置文件时，是不会立即生成你要求创建的那些类的对象，也就是说只有到真正用到的时候，才会创建；二、ApplicationContext则是在加载<span class="hljs-built_in">xml</span>配置文件时就完成了创建对象工作，因为我们在真实的开发中一般都希望将耗费时间和资源的事情在开启服务器时就完成，而不是等到用户真正去使用时，才去创建要用的对象，这对用户体验很不友好。<span class="hljs-comment">//============================================================</span>拓展：ApplicationContext的两个实现类的区别一、FileSystemXmlApplicationContext，该实现类用于加载Spring的核心配置文件applicationContext.<span class="hljs-built_in">xml</span>，但路径名称必须写该配置文件在你电脑上的绝对路径，也就是带盘符的路径二、ClassPathXmlApplicationContext，该实现类也是用于加载Spring的核心配置文件，但不同的是，加载的是这个配置文件在当前项目中的位置，也就是相对路径。</code></pre></li></ul></li><li><p>基本语法格式：</p><ul><li><p>创建Spring的核心配置文件：<code>applicationContext.xml</code>文件；</p></li><li><p>在applicationContext配置文件中配置类：要想实现IOC，只需要把自己写的类在<code>applicationContext.xml</code>中配置一下即可；</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"你想要创建的对象的名称"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"你想要创建对象的所属类的全包名路径"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><ul><li><code>&lt;bean&gt;</code>标签解析：<ul><li><code>id</code>：被Spring管理的类所生成的对象的名称；如果是通过类型获取bean的过程中，则可以不设置，也就是说当使用ac.getBean(xxx.class)这种方式获取bean对象时，id属性可以不用设置，但只能有一个这样的类，即被管理的User类只能写一个；</li><li><code>name(了解)</code>：和id属性拥有同样的效果，只不过name属性中还可以添加一些符合，而id属性则不可以，该属性一般用于和Struts框架整合使用，但现在一般不用Struts框架了，name属性也就不再使用了；</li><li><code>scope</code>：配置bean的作用范围。该属性取值：<ul><li><code>singleton</code>：单例模式，不设置则默认是该值；</li><li><code>prototype</code>：多例模式</li><li><code>request</code>：应用在Web项目中，Spring创建该类对象后，会存入request域中</li><li><code>session</code>：应用在Web项目中，Spring创建该类对象后，会存入session域中</li><li><code>globalsession</code>：应用在Web项目中，必须在porlet环境下使用，即配置后，在子资源中不需要重复做某些操作。<code>如，重复登录</code>。</li></ul></li><li><code>init-method</code>：bean的初始方法，在创建好bean后会调用该方法；</li><li><code>destory-method</code>：bean的销毁方法，在销毁bean之前调用该方法，一般在该方法中释放资源；</li><li><code>autowire</code>：表示bean的自动装配。autowire的值有：<ul><li><code>no</code>：默认值，不进行自动装配；</li><li><code>byName</code>：根据名称自动装配。某行代码需要装配某个对象，那么这个对象肯定有个名称，然后根据这个名称，去容器中查找与之名称相同的bean，相同就装配，不相同就不装配；</li><li><code>byType</code>：如果容器中存在一个与需要装配的对象，类型相同的bean，那么将与该属性自动装配。如果存在多个该类型bean，那么抛出异常，并指出不能使用byType方式进行自动装配；如果没有找到相匹配的bean，则什么事都不发生，也可以通过设置dependency-check=”objects” 让Spring抛出异常(该值允许自动装配的bean对象有继承或有接口实现关系，也就是说该bean对象可以是父类对象或接口对象)；</li><li><code>constructor</code>：与byType方式类似，不同之处在于它应用于构造器参数；如果容器中没有找到与构造器参数类型一致的bean， 那么抛出异常；</li><li><code>autodetect</code>：通过bean类的内省机制(introspection)来决定是使用constructor还是byType方式进行自动装配；如果发现默认的构造器，那么将使用byType方式，否则采用constructor；</li><li><code>default</code>：由上级标签的default-autowire属性确定。</li></ul></li></ul></li></ul></li><li><p>如果是想要在测试类中获取bean对象：通过配置文件初始化Spring容器，然后通过反射获取类的实例：</p><pre><code class="hljs java">ApplicationContext ac= <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"applicationContext.xml"</span>);类名 对象名 = ac.getBean(<span class="hljs-string">"配置文件中你想要获取的类的bean标签的id"</span>,你想要获取的类<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>DI：</p><ul><li><p>定义：是指依赖注入。前提是必须要有IOC的环境，让Spring来管理类时，会将类所依赖的属性(属性中可能会有基本数据类型或引用类型)也一起设置进来；</p></li><li><p>基本语法格式：</p><ul><li><p>这是set()方法注入属性(推荐该方式)；</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--普通类型：使用value赋值--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"被Spring管理的类的对象的名称"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"被Spring管理的类的全包名路径"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"依赖的属性名"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"依赖的属性的值"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>//----------------------------------------------------------------<span class="hljs-comment">&lt;!--对象类型：使用ref赋值，值一般是其他对象的id或者name--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"被Spring管理的类的对象的名称"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"被Spring管理的类的全包名路径"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"依赖的属性名"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"依赖的属性的对象的id"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>拓展：设置null值和含有特殊符号的值一、设置null值，如下所示：<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"依赖的属性名"</span> &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">null</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>二、设置包含特殊符号的值，如下所示：<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"依赖的属性名"</span> &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">![CTATA[这里填含有特殊符号的值]]</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>//----------------------------------------------------------------<span class="hljs-comment">&lt;!--集合类型：在&lt;property&gt;标签中使用&lt;list&gt;标签(或&lt;array&gt;标签或&lt;set&gt;标签或&lt;map&gt;标签，根据需要选择就行)，然后赋值即可--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"被Spring管理的类的对象的名称"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"被Spring管理的类的全包名路径"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"依赖的属性名"</span> &gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>            <span class="hljs-comment">&lt;!--集合里面是普通元素用value标签--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>666<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>666<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-comment">&lt;!--集合里面是对象元素用ref标签--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"要引用的bean的id值"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"要引用的bean的id值"</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>                <span class="hljs-comment">&lt;!--map标签--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>            <span class="hljs-comment">&lt;!--使用这种--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">entry</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>111<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span>                        <span class="hljs-comment">&lt;!--或者使用这种--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">""</span> <span class="hljs-attr">value</span>=<span class="hljs-string">""</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>拓展：提取公共集合一、添加名称空间http://www.springframework.org/schema/utilhttp://www.springframework.org/schema/util/spring-util.xsd二、在xml中添加标签：<span class="hljs-tag">&lt;<span class="hljs-name">util:集合名称</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">util:集合名称</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">util:集合名称</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"给这个集合取个名称"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 下面二选一即可 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">util:集合名称</span>&gt;</span></code></pre></li><li><p>这是有参构造方法注入属性；</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--普通类型：使用value赋值；其他类型就用ref，参考上方的set()方法注入属性--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"被Spring管理的类的对象的名称"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"被Spring管理的类的全包名路径"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"依赖的属性名"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"依赖的属性的值"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 当注入的属性是一个对象时，使用ref属性即可</span><span class="hljs-comment">    &lt;constructor-arg name="依赖的属性名" ref="依赖的对象的id"&gt;&lt;/constructor-arg&gt;</span><span class="hljs-comment">    --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></li><li><p>P命名空间注入属性；</p><pre><code class="hljs xml">//在xml中添加命名空间xmlns:p="http://www.springframework.org/schema/p"//-----------------------------------------------------//使用p命名空间为属性赋值<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.dyf.domain.User"</span></span><span class="hljs-tag">    <span class="hljs-attr">p:name</span>=<span class="hljs-string">"hanyan"</span> <span class="hljs-attr">p:age</span>=<span class="hljs-string">"24"</span> <span class="hljs-attr">p:product</span>=<span class="hljs-string">"product对象的id值"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>FactoryBean：</p><ul><li><p>定义：是一个工厂Bean，可以生成某一个类型Bean实例；</p></li><li><p>作用：可以让我们自定义Bean的创建过程。BeanFactory是Spring容器中的一个基本类也是很重要的一个类，在BeanFactory中可以创建和管理Spring容器中的Bean，它对于Bean的创建有一个统一的流程；</p><pre><code class="hljs java"><span class="hljs-comment">//FactoryBean是一个接口</span>                <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;                    <span class="hljs-comment">//返回的对象实例</span>            <span class="hljs-function">T <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;                    <span class="hljs-comment">//Bean的类型</span>            Class&lt;?&gt; getObjectType();                    <span class="hljs-comment">//true是单例，false是非单例。在Spring5.0中此方法利用了JDK1.8的新特性变成了default方法，返回true</span>            <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span></span>;        &#125;                <span class="hljs-comment">//--------------------------------------------</span>                <span class="hljs-comment">//FactoryBean接口的实现类</span>                <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span> </span>&#123;                        <span class="hljs-comment">//Bean实例</span>            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        <span class="hljs-comment">//这个Bean是我们自己new的，这里我们就可以控制Bean的创建过程了</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-string">"小明"</span>,<span class="hljs-number">11</span>);            &#125;                    <span class="hljs-comment">//Bean类型</span>            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;                <span class="hljs-keyword">return</span> User<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;            &#125;                    <span class="hljs-comment">//是否单例</span>            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;                <span class="hljs-comment">//--------------------------------------------</span>                &lt;!--配置MyFactory的bean--&gt;                &lt;bean id="myFactory" class="cn.dyf.domain.MyFactory"&gt;&lt;/bean&gt;                <span class="hljs-comment">//--------------------------------------------</span>                <span class="hljs-meta">@Test</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;                        ClassPathXmlApplicationContext cac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:applicationContext.xml"</span>);                MyFactory mf= cac.getBean(MyFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;                System.out.println(mf);            &#125;                <span class="hljs-comment">//--------------------------------------------</span>                测试结果：User [name = 小明， age= <span class="hljs-number">11</span>]                说明：配置的是MyFactory，也就是本该生成的应该是MyFactory的bean，却得到了MyFactory工厂里生产的User对象，其原因是MyFactory实现了FactoryBean接口</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>Spring中bean的生命周期。</p><p><img src="./Image-ssm2.png" srcset="/img/loading.gif" alt="Image"></p><ul><li>Spring中的bean在创建过程中大概分为以下几个步骤：实例化-&gt;填充属性-&gt;执行Aware接口-&gt;初始化-&gt;可用状态-&gt;销毁；解析过程：<ul><li>实例化：就是调用类的构造器进行对象创建的过程；</li><li>填充属性：是指注入bean的依赖或者给属性赋值，一般会调用set方法；</li><li>Aware接口：是Spring中的“觉醒”接口，是Spring容器通过回调向bean注入相关对象的接口；<ul><li>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法；</li><li>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</li><li>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来；</li><li>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法，即初始化之前对bean进行操作；</li><li>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用；</li><li>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法，即初始化之后对bean进行操作；</li></ul></li><li>初始化：是指完成bean的创建和依赖注入后进行的一个回调，可以利用这个回调进行一些自定义的工作，实现初始化的方式有三种，分别是实现InitializingBean接口、使用@PostConstruct注解和xml中通过init-method属性指定初始化方法;</li><li>可用状态：是指bean已经准备就绪，可以被应用程序使用了，此时bean会一直存在于Spring容器中；</li><li>销毁：是指这个bean从Spring容器中消除，这个操作往往伴随着Spring容器的销毁。实现销毁方法的方式有3中，分别为实现DisposableBean接口、使用@PreDestroy注解和xml中通过destroy-method属性指定</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>分模块开发：</p><ul><li><p>定义：是指开发者一般会负责不同的功代码编写，因此可能会需要引入外部文件或引入不同的配置文件。<code>如，数据库配置文件等等</code>；</p></li><li><p>解决引入外部资源文件的问题：</p><ul><li><p>引入context名称空间；</p><pre><code class="hljs xml">//先添加这个    xmlns:context="http://www.springframework.org/schema/context        //后添加这个http://www.springframework.org/schema/context    http://www.springframework.org/schema/context/spring-context.xsd</code></pre></li><li><p>使用标签<code>&lt;context:property-placeholder&gt;</code>。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:外部配置文件名称，要带上后缀"</span>&gt;</span>    说明：location属性，是指加载指定位置下的配置文件</code></pre></li></ul></li><li><p>解决存在多个配置文件的问题：</p><ul><li><p>在生产环境中：在applicationContext.xml主配置文件中使用标签引入分配置文件即可(推荐)；</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"需要引入的其他的配置文件"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>;</code></pre></li><li><p>在测试类中：创建Spring的工厂对象时，只需要多写几个配置文件参数即可；</p><pre><code class="hljs java">ApplicationContext springFactory = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"applicationContext1.xml,applicationContext2.xml"</span>);</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>使用Spring的IOC注解开发(推荐)：</p><ul><li><p>在applicationContext配置文件中，引入context名称空间后，需要配置扫描组件标签；</p><pre><code class="hljs xml">//引入context名称空间//先添加这个xmlns:context="http://www.springframework.org/schema/context//后添加这个http://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd//---------------------------------------<span class="hljs-comment">&lt;!--这个标签是用于扫描类里的注解--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"配置需要扫描的包的路径"</span> /&gt;</span></code></pre><ul><li><code>&lt;context:component-scan&gt;</code>标签解析：<ul><li><code>use-default-filters</code>：是否使用默认的扫描进行过滤，而默认扫描就是扫描base-pachage属性的值；另外该属性默认是true；如果是false，那么就表示要用自己的扫描规则。<code>&lt;context:component-scan&gt;</code>中有两个子标签：<ul><li><code>&lt;context:include-filter&gt;</code>：在base-package属性的范围下，用来告知哪些类需要注册成Bean对象，使用该子标签type和expression属性一起协作来定义组件扫描策略。使用这个子标签的时候，use-default-filters属性必须设置为false；<ul><li>type：<ul><li>annotation：扫描指定注解所标注的类。通过expression属性指定要扫描的注解；</li><li>assignable：扫描派生于expression属性所指定类型的那些类；</li><li>aspectj：扫描与expression属性所指定的AspectJ表达式所匹配的那些类</li><li>custom：使用自定义的org.springframework.core.type.TypeFliter实现类，该类由expression属性指定；</li><li>regex：过滤器扫描类的名称与expression属性所指定正则表示式所匹配的那些类。</li></ul></li></ul></li><li><code>&lt;context:exclude-filter&gt;</code>：在base-package属性的范围下，用来告知哪些类不需要注册成Bean对象，使用type和expression属性一起协作来定义组件扫描策略。使用这个子标签的时候，use-default-filters属性必须设置为true。</li></ul></li></ul></li></ul></li><li><p>在需要使用注解开发的类的上面一行，添加注解：</p><ul><li><p>@Component：用于告诉Spring，这是一个组件，你只管帮我生成对应的bean对象即可；</p></li><li><p>@Controller：用于Web层；</p></li><li><p>@Service：用于Service层；</p></li><li><p>@Repository：用于Dao层。</p><pre><code class="hljs java">拓展：<span class="hljs-meta">@Component</span>、<span class="hljs-meta">@Controller</span>、<span class="hljs-meta">@Service</span>、<span class="hljs-meta">@Repository</span>四个注解的区别一、这四个注解没区别，功能都是为注解的类生成bean对象；即哪怕你用<span class="hljs-meta">@Controller</span>、<span class="hljs-meta">@Service</span>、<span class="hljs-meta">@Repository</span>注解的类都用<span class="hljs-meta">@Component</span>去注解，完全没有问题；二、你硬要说区别的话，那就是让开发人员分清楚，哪一层是哪一层，明确的分清每一层的作用。    三、这四个注解中都有一个value属性，就是当前注解的类所生成的对象的名称。不写的话，默认是当前类名首字母小写。如，User类，生成的对象名称为user。</code></pre></li></ul></li><li><p>如果有代码需要DI，意思就是某一行代码需要用到某个对象，则在xml中为那个对象的所属类进行配置<code>&lt;bean&gt;</code>标签即可；然后在需要用到的地方，使用以下注解引用即可：</p><ul><li><p>普通类型：</p><ul><li><p>@Value：即为变量中注入一个值，使用value属性写入要注入的值。<code>如，@Value(value=&quot;aaa&quot;)，表示给当前注解的变量注入了字符串aaa</code>；其他形式：</p><ul><li><p><code>@Value(&quot;#{}&quot;)</code>：该形式其实是SpEL表达式，可以表示常量的值，或者获取bean中的属性；</p><pre><code class="hljs java"><span class="hljs-meta">@Value</span>(<span class="hljs-string">"#&#123;4&#125;"</span>)  <span class="hljs-comment">//获取数字4</span>                    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;                                          <span class="hljs-meta">@Value</span>(<span class="hljs-string">"#&#123;'hello world!'&#125;"</span>)  <span class="hljs-comment">//获取字符串常量</span>                    <span class="hljs-keyword">private</span> String str;                                        <span class="hljs-meta">@Value</span>(<span class="hljs-string">"#&#123;user.name&#125;"</span>)  <span class="hljs-comment">//获取bean的属性</span>                    <span class="hljs-keyword">private</span> String username;</code></pre></li><li><p><code>@Value(&quot;${}&quot;)</code>：该形式用于获取配置文件中的属性值，通常用于获取写在xxx.properties中的内容。</p><pre><code class="hljs java"><span class="hljs-comment">//xxx.properties文件中的值</span>                jdbc.driverClass=aaadbc.url=aaajdbc.user=ccc<span class="hljs-comment">//--------------------------</span><span class="hljs-comment">//类中可以通过@Value("$&#123;&#125;")来获取相应的值</span><span class="hljs-meta">@Value</span>(<span class="hljs-string">""</span>$&#123;jdbc.user&#125;)<span class="hljs-keyword">private</span> String name;</code></pre></li></ul></li></ul></li><li><p>对象类型：</p><ul><li><p><code>@Autowired(推荐)</code>：根据需要注入的对象的Class类型，进行自动装配；</p></li><li><p><code>@Qualifier</code>：根据需要注入的对象的名称，进行自动装配；该注解一般和<code>@Autowired</code>注解一起使用；具有属性：</p><ul><li><p>value：注入指定名称的bean对象；</p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-meta">@Qualifier</span>(“value=user”)  <span class="hljs-comment">//在容器中找一个bean的id为user的对象，注入到这下面的</span><span class="hljs-keyword">private</span> User user;</code></pre></li></ul></li><li><p><code>Resource</code>：根据对象的Class类型或名称，进行自动装配，该是Javax包中的注解；根据名称注入时，需要添加一个name属性来指定要注入到当前对象中的bean的id；</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span></span>&#123;<span class="hljs-meta">@Resources</span>  <span class="hljs-comment">//引用UserService的bean对象，这时是按类型自动装配</span>UserService userService;<span class="hljs-meta">@Resources</span>(name=<span class="hljs-string">"userDao"</span>)  <span class="hljs-comment">//这时是按名称自动装配，将容器中bean的id为userDao的对象，注入到当前ud对象中去</span>UserDao ud;....&#125;</code></pre></li></ul></li></ul></li><li><p>xml文件也可以用配置类来进行替换，需要使用到注解：</p><ul><li><p><code>@Configuration</code>：用于类上，告诉Spring，当前使用该注解的类是一个配置类，且也会生成bean对象，因为该注解中包含了@Conponent注解；</p></li><li><p><code>@ComponentScan</code>：扫描指定包下的@Component注解并生成相应的bean对象；除此之外还可以使用@Bean注解来指定生成某些类的bean对象；</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ComponentScan</span>(basePackage=<span class="hljs-string">"要扫描的包路径"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfig</span></span>&#123;    <span class="hljs-meta">@Bean</span>  <span class="hljs-comment">//可以自己手动添加要生成的bean对象</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User;    &#125;&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p></li><li><p>Spring也集合了Test，也支持测试类的注解开发，只需导入相应的test的JAR包或依赖，然后再在测试类上面添加相应的<code>@Runwith</code>和<code>@ContextConfiguration</code>注解即可；</p><pre><code class="hljs java"><span class="hljs-meta">@Runwith</span>(SpringJUnit4ClassRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>@ContextConfiguration("classpath:applicationContext.xml")<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;    ...&#125;说明：也就是说有了注解之后可以不需要创建工厂获取实例，意思就是不需要再写ApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"applicationContext1.xml,applicationContext2.xml"</span>)和ac.getBean(<span class="hljs-string">"xxx"</span>)这两个方法了</code></pre></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-3-AOP"><a href="#NO1-3-AOP" class="headerlink" title="NO1.3 AOP"></a>NO1.3 AOP</h3><p>AOP是Spring的特性之一。</p><ul><li><p>AOP：</p><ul><li><p>定义：是指面向切面编程；</p></li><li><p>作用：降低业务逻辑各部分之间的耦合度，提高程序的可重用性；</p></li><li><p>影响：AOP是OOP(面向对象)的扩展和延伸，解决OOP开发遇到的问题；Spring中的AOP可以理解为是一种思想，而AspectJ则是这种AOP思想的具体实现，因为Spring的AOP开发，使用的是基于AspectJ的AOP开发；</p></li><li><p>底层原理：</p><ul><li><p>问题的提出：当我们在项目开发中遇到一个问题：我想给用户登陆接口添加一些别的功能，像什么权限校验功能，日志记录功能等等，但又不能改动源码，这怎么办呢？这个时候，AOP就可以为这种问题提供解决的办法；</p></li><li><p>Spring中的AOP其实是基于动态代理来实现的，什么叫动态代理呢？个人理解为，就是让系统实时地为你创建一个动态代理类，而这个类实现了你想要的基本功能和增强功能，两者兼具。<code>如，上面登录接口中的登录功能就是该接口中基本的功能，而像什么权限校验功能，日志记录功能等等，这些就是增强的功能</code>；而在Spring中，动态代理有两种，默认如果目标对象是个接口，则使用JDK动态代理，否则使用CGLIB来生成代理类：</p><ul><li><p><code>JDK动态代理</code>：一般用于接口的动态代理。其实，所谓的JDK动态代理，如上面所说，就是系统实时的帮你造一个动态代理类，实现了目标接口，并且实现类中有你想要的基本功能和增强功能；</p><pre><code class="hljs java"><span class="hljs-comment">//登录接口</span>                <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Login</span></span>&#123;                <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String username,String password)</span></span>;                &#125;                                <span class="hljs-comment">//------------------------</span>                                <span class="hljs-comment">//登录接口的实现类</span>                <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Login</span></span>&#123;                                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String username,String password)</span></span>&#123;                <span class="hljs-comment">//登录代码</span>                &#125;                &#125;                                 <span class="hljs-comment">//------------------------</span>                                <span class="hljs-comment">//JDK动态代理类</span>                <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Login</span></span>&#123;                                <span class="hljs-comment">//权限校验功能</span>                                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String username,String password)</span></span>&#123;                <span class="hljs-comment">//登录代码</span>                &#125;                                <span class="hljs-comment">//日志记录功能</span>                &#125;</code></pre></li><li><p><code>CGLIB动态代理</code>：一般用于非接口的动态代理。既然用于非接口，那么肯定就是用于一个类，所以CGLIB的动态代理，就是继承了目标类而产生的动态代理类，当然，新产生的这个动态代理类中肯定也包含了基本功能和增强功能；</p></li></ul></li></ul></li><li><p>JDK动态代理具体实现：</p><ul><li><p>如上面原理所说，JDK动态代理就是让系统实时的帮你创建一个类，然后该类中实现类你想要的基本功能以及增强功能。当然，实际的动态代理不可能两行代码搞定，所以我们需要手动创建JDK动态代理来学习动态代理的实现；</p></li><li><p>首先，JDK动态代理要使用到一个类：Proxy，这个类就是动态代理类，该类有以下方法：</p><ul><li>protected Proxy(InvocationHandler h)：构造函数，用于给内部的h赋值；</li></ul></li><li><p>static Class getProxyClass (ClassLoaderloader, Class[] interfaces)：获得一个代理类，其中loader是类加载器，interfaces是目标类所拥有的全部接口的class的数组；</p></li><li><p>static Object newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)：返回代理类生成的一个对象；前两个参数我们都了解过了，第三个参数就是你想要的增强的功能所在的对象(意思就是把增强的功能放到了h对象里)，但InvocationHandler是一个接口，所以我们需要创建一个InvocationHandler接口的实现类才能使用。</p></li></ul></li><li><p>然后，创建InvocationHandler接口的实现类；该接口要重写一个invoke方法，即<code>invoke(Object obj,Method method, Object[] args)</code>；</p><pre><code>-   obj：一般是指被代理类的真正对象；</code></pre><ul><li><p>method：是被代理类所拥有的方法；</p><ul><li>args：被代理类的方法的参数数组。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;                <span class="hljs-comment">//这个就是我们要代理的真正的对象</span>        <span class="hljs-keyword">private</span> Object obj;                 <span class="hljs-comment">//构造方法，给我们要代理的真实对象赋初值</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InvocationHandlerImpl</span><span class="hljs-params">(Object obj)</span></span>&#123;            <span class="hljs-keyword">this</span>.obj = obj;        &#125;            <span class="hljs-comment">//在这个方法里写如增强的功能，以及调用被代理类的基本功能</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable</span>&#123;                        <span class="hljs-comment">//在调用代理的真正对象的基本功能前，我们可以添加一些自己的操作，也就是增强功能1</span>            System.out.println(<span class="hljs-string">"这是基本功能前的增强功能"</span>);                 System.out.println(<span class="hljs-string">"Method:"</span> + method);                 <span class="hljs-comment">//调用被代理的真正对象中的方法</span>            Object res = method.invoke(obj, args);                 <span class="hljs-comment">//增强功能2</span>            System.out.println(<span class="hljs-string">"这是基本功能后的增强功能"</span>);                 <span class="hljs-keyword">return</span> res;        &#125;    &#125;</code></pre></li></ul></li><li><p>之后，调用Proxy类中的newProxyInstance()方法，生成动态代理类的一个对象；最后生成测试类，测试。</p><pre><code><pre><code class="hljs java"><span class="hljs-comment">//登录接口</span>    <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Login</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String username,String password)</span></span>;    &#125;        <span class="hljs-comment">//------------------------</span>        <span class="hljs-comment">//登录接口的实现类，也就是需要被代理的类</span>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Login</span></span>&#123;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String username,String password)</span></span>&#123;    System.out.println(<span class="hljs-string">"登录成功"</span>);    &#125;    &#125;         <span class="hljs-comment">//---------------------------</span>        <span class="hljs-comment">//JDK动态代理类</span>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyProxy</span></span>&#123;        <span class="hljs-comment">//被代理类所实现的接口的Class对象数组</span>    <span class="hljs-keyword">private</span> Class[] interfaces;        <span class="hljs-comment">//被代理类想要增强的功能所在的代理类</span>    <span class="hljs-keyword">private</span> InvocationHandler h;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyProxy</span><span class="hljs-params">(Class[] interfaces,InvocationHandler h)</span></span>&#123;    <span class="hljs-keyword">this</span>.interfaces = interfaces;    <span class="hljs-keyword">this</span>.h = h;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-keyword">static</span> <span class="hljs-title">getTargetProxy</span><span class="hljs-params">()</span></span>&#123;                <span class="hljs-comment">//调用Proxy类中的newProxyInstance()方法</span>    Proxy.newProxyInstance(    MyProxy<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getClassLoader</span>(),</span><span class="hljs-class">    <span class="hljs-title">interfaces</span>,</span><span class="hljs-class">    <span class="hljs-title">h</span></span><span class="hljs-class">    )</span>;    &#125;    &#125;         <span class="hljs-comment">//---------------------------</span>        <span class="hljs-comment">//测试类</span>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span></span>&#123;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;                        <span class="hljs-comment">//这个是需要被代理的对象</span>            LoginImpl myLogin = <span class="hljs-keyword">new</span> LoginImpl();                        <span class="hljs-comment">//这个是需要被代理的对象，其类所实现的接口</span>            Class[] interfaces = &#123;Login<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;</span>;                        <span class="hljs-comment">//先创建一个Handler对象，该类实现了接口InvocationHandler</span>            Handler hand = <span class="hljs-keyword">new</span> Handler(myLogin);                        <span class="hljs-comment">//创建MyProxy类，生成代理类对象</span>            Login mp = (Login)<span class="hljs-keyword">new</span> MyProxy(hand, interfaces);                        <span class="hljs-comment">//调用登录方法</span>            mp.login(“dyf”,<span class="hljs-string">"666"</span>);        &#125;    &#125;        输出结果：    这是基本功能前的增强功能    login    登录成功    这是基本功能后的增强功能</code></pre></code></pre></li></ul></li><li><p>AOP中的概念：</p><ul><li><p><code>Joinpoint</code>：连接点，其实就是方法，意思就是理论上只要是个方法都可以被增强；</p></li><li><p><code>Pointcut</code>：切入点，即在实际开发中，实际被增强了的方法，则该方法就是切入点；</p></li><li><p><code>Advice</code>：通知或者增强，即对被增强的方法，加入想要增强的代码，这部分代码就是通知或者增强；</p><ul><li><p><code>前置通知(使用@before注解)</code>：在连接点前面执行，前置通知不会影响连接点的执行，除非此处抛出异常；</p></li><li><p><code>后置通知(使用@after-returning注解)</code>：在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行；</p></li><li><p><code>最终通知(使用@after注解)</code>：在连接点执行完成后执行，不管是正常执行完成，还是抛出异常，都会执行最终通知中的内容；</p></li><li><p><code>异常通知</code>：在连接点抛出异常后执行(使用@after-throwing注解)；</p></li><li><p><code>环绕通知(使用@around注解)</code>：环绕通知围绕在连接点前后。这是最强大的通知类型，能在方法调用前后自定义一些操作；环绕通知还需要负责决定是继续处理join point(调用ProceedingJoinPoint的proceed方法)还是中断执行。</p><p><img src="./Image-ssm3.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-ssm4.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li><li><p><code>Introduction</code>：引介，即类层面的增强，往类里面添加新的属性、新的方法等；</p></li><li><p><code>Target</code>：被增强的对象；</p></li><li><p><code>Weaving</code>：织入，即将想要增强的代码应用到目标对象的过程；</p></li><li><p><code>proxy</code>：代理对象，即增强后所产生的代理类对象；</p></li><li><p><code>Aspect</code>：切面，即多个通知和多个切入点的组合；</p></li></ul></li><li><p>AOP开发，包括两种方式：</p><ul><li><p>与XML方式：</p><ul><li><p>创建项目后，导入跟AOP和IOC相关的JAR包或依赖；</p></li><li><p>编写切面类，即编写一个普通类，里面定义切入点和通知；</p><pre><code><pre><code class="hljs java"><span class="hljs-comment">//这就是切面类，里面包含了增强的功能方法</span>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspectXML</span></span>&#123;            <span class="hljs-comment">//切入点</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">anyMethod</span><span class="hljs-params">()</span></span>&#123;&#125;            <span class="hljs-comment">//前置通知：可以获得切入点信息，增强方法需要JoinPoint类型的参数joinPoint，就是会把目标对象方法的一些信息封装到这个对象里面，供你使用</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeTest</span><span class="hljs-params">(JoinPoint joinPoint)</span></span>&#123;                System.out.println(<span class="hljs-string">"前置-----权限校验"</span>+joinPoint);        &#125;            <span class="hljs-comment">//后置通知：可以通过AOP配置里的属性：returning获得方法返回值；</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterTest</span><span class="hljs-params">(Object result)</span></span>&#123;                System.out.println(<span class="hljs-string">"后置-----记录运行日志"</span>+result);        &#125;            <span class="hljs-comment">//最终通知，无论是否会发生异常，都会执行的通知</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finallyTest</span><span class="hljs-params">()</span></span>&#123;                System.out.println(<span class="hljs-string">"最终-----通知运行完毕"</span>);        &#125;            <span class="hljs-comment">//异常通知：可以通过AOP配置里的属性：throwing属性获得异常的返回信息，并将其封装到了ex这个变量中；</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceTest</span><span class="hljs-params">(Exception ex)</span></span>&#123;                System.out.println(<span class="hljs-string">"异常-----出现异常了"</span>+ex);        &#125;            <span class="hljs-comment">//环绕通知：该通知必须返回Object，增强方法需要参数ProceedingJoinPoint，并用该类的对象调用proceed()方法代执行目标方法</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">roundTest</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span></span>&#123;                System.out.println(<span class="hljs-string">"环绕-----测试1"</span>);                <span class="hljs-keyword">try</span>&#123;                            <span class="hljs-comment">//代执行目标方法，且有可能目标方法有返回值，用Object接收</span>                Object obj = joinPoint.proceed();                &#125; <span class="hljs-keyword">catch</span> (Throwable e)&#123;                e.printStackTrance();            &#125;                System.out.println(<span class="hljs-string">"环绕-----测试2"</span>);        &#125;    &#125;</code></pre></code></pre></li><li><p>在applicationContext.xml中，通过AOP标签的配置完成对目标类产生代理；</p><ul><li><p>首先，添加AOP的XML配置根标签：<code>&lt;aop:config&gt;</code>，表示要对AOP进行配置；</p><pre><code><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>    <span class="hljs-comment">&lt;!--所有的AOP配置均在该标签下完成--&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre></code></pre></li><li><p>其次，在AOP根标签中，添加标签：<code>&lt;aop:pointcut&gt;</code>，表示要给哪些方法进行增强；可以定义多个该标签，以满足业务逻辑需要；</p><pre><code><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>        <span class="hljs-comment">&lt;!--该标签配置的是哪些方法需要进行增强--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> </span><span class="hljs-tag">    <span class="hljs-attr">expression</span>=<span class="hljs-string">"切入点表达式"</span></span><span class="hljs-tag">            <span class="hljs-attr">id</span>=<span class="hljs-string">"切入点id"</span> /&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre></code></pre><ul><li><p><code>&lt;aop:pointcut&gt;</code>标签解析：</p><ul><li><p><code>expression</code>：该属性表示需要写入一个切入点表达式，用于指定具体要增强的方法；基本语法格式：</p><pre><code class="hljs java">expression([权限修饰符] 方法返回值 包名路径.类名.方法名(参数))            说明：    一、权限修饰符我们一般都写*，即任意权限修饰符；        二、方法返回值可以省略不写，也可以写*，即不管你方法有没有返回值；            三、参数一般用..代替，即表示任意参数；返回值用*，表示任意返回值；</code></pre></li><li><p><code>id</code>：即切入点的id，用于通知标签中的<code>pointcut-ref</code>属性；也就是说，到时候增强会根据这个id来找到需要增强的方法；</p></li></ul></li></ul></li><li><p>然后，仍然在AOP根标签中，添加标签：<code>&lt;aop:aspect&gt;</code>，表示增强方法的具体配置，即增强的功能都在这里面进行详细配置；</p><pre><code><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>        <span class="hljs-comment">&lt;!--该标签配置的是哪些方法需要进行增强--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> </span><span class="hljs-tag">    <span class="hljs-attr">expression</span>=<span class="hljs-string">"切入点表达式"</span></span><span class="hljs-tag">            <span class="hljs-attr">id</span>=<span class="hljs-string">"切入点id"</span> /&gt;</span>​    ​    <span class="hljs-comment">&lt;!--该标签是给上面需要增强的方法，配置使用哪种增强的功能--&gt;</span>​    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"切面类的引用"</span>&gt;</span>​    ​            <span class="hljs-comment">&lt;!--前置通知标签，增强的功能在目标方法之前触发，</span><span class="hljs-comment">​              可以获得切入点信息(增强方法需要参数JoinPoint)--&gt;</span>​            <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> </span><span class="hljs-tag">​            <span class="hljs-attr">method</span>=<span class="hljs-string">"切面类中增强方法的名称"</span> </span><span class="hljs-tag">​            <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">"上面切入点的id"</span> /&gt;</span>​                <span class="hljs-comment">&lt;!--后置通知标签，可以通过returning属性获得方法返回值--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-returning</span> </span><span class="hljs-tag">            <span class="hljs-attr">method</span>=<span class="hljs-string">"切面类中增强方法的名称"</span> </span><span class="hljs-tag">            <span class="hljs-attr">pointcut</span>=<span class="hljs-string">"expression表达式"</span> </span><span class="hljs-tag">            <span class="hljs-attr">returning</span>=<span class="hljs-string">"result"</span> /&gt;</span>                <span class="hljs-comment">&lt;!--环绕通知(增强方法需要参数ProceedingJoinPoint，</span><span class="hljs-comment">            并用该类的对象调用proceed()方法代执行目标方法)--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:around</span> </span><span class="hljs-tag">            <span class="hljs-attr">method</span>=<span class="hljs-string">"切面类中增强方法的名称"</span> </span><span class="hljs-tag">            <span class="hljs-attr">pointcut</span>=<span class="hljs-string">"expression表达式"</span> /&gt;</span>                <span class="hljs-comment">&lt;!--最终通知，无论是否有异常，都会执行通知里面的代码--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> </span><span class="hljs-tag">            <span class="hljs-attr">method</span>=<span class="hljs-string">"切面类中增强方法的名称"</span> </span><span class="hljs-tag">            <span class="hljs-attr">pointcut</span>=<span class="hljs-string">"expression表达式"</span> /&gt;</span>                <span class="hljs-comment">&lt;!--异常通知，出现异常时，会执行异常通知里面的代码，</span><span class="hljs-comment">            通过throwing属性获取异常的信息--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-throwing</span> </span><span class="hljs-tag">            <span class="hljs-attr">method</span>=<span class="hljs-string">"切面类中增强方法的名称"</span> </span><span class="hljs-tag">            <span class="hljs-attr">pointcut</span>=<span class="hljs-string">"expression表达式"</span> </span><span class="hljs-tag">            <span class="hljs-attr">throwing</span>=<span class="hljs-string">"ex"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre>-   `&lt;aop:aspect&gt;`标签解析：</code></pre><ul><li>ref：该属性用于切面类的引入，即告知Spring，你写的切面类放在哪个位置；一般切面类交给Spring管理后，只需要写bean的id就行，@Component注解生成bean的id一般为类名的首字母小写。</li></ul></li></ul><pre><code class="hljs xml">注意：<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> /&gt;</span>这个就是配置切入点的标签，该标签中：expression表达式，是指需要为满足该表达式下的方法们进行增强；id属性，是指为这些需要增强的方法名创建一个切面id；<span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> /&gt;</span>这个就是配置切面类的标签，标签中：ref属性，是指切面类的类名；<span class="hljs-tag">&lt;<span class="hljs-name">aop:通知类型</span> /&gt;</span>这个就是配置通知类型，标签中：method属性，是指切面类中，具体的增强方法的方法名；pointcut-ref属性，是指给哪些需要增强的方法进行增强，即切入点的id；</code></pre></li></ul></li><li><p>AOP开发(注解方式，推荐该方式)：</p><ul><li><p>编写目标类(也就是需要被增强的类)并在applicationContext.xml中配置，交给Spring管理，即在目标类上添加@Component注解；</p></li><li><p>编写切面类(即包含增强功能和切入点的类)并在applicationContext.xml中配置，交给Spring管理，即在切面类上添加@Component注解；</p></li><li><p>在applicationContext.xml中，开启AOP注解开发，使用标签：</p><pre><code><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--该标签就表示开启AspectJ的自动代理功能--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span> /&gt;</span></code></pre></code></pre></li><li><p>再在切面类上添加切面注解：@Aspect，Spring会自动识别该注解，并将该注解下注明的类认为是切面类；<strong><code>注意：如果有多个切面，有默认的先后执行顺序；但是可以用@Order(num)定义优先级，num越小，也就是数字越小(但不能为负数)，优先级越高。</code></strong></p></li><li><p>在增强方法上配置通知类型注解：</p><pre><code><pre><code class="hljs java"><span class="hljs-meta">@Before</span>(value=<span class="hljs-string">"execution(* com.dyf.CustomerDao.*(..))"</span>)    <span class="hljs-keyword">public</span> ..... &#123;  <span class="hljs-comment">//这里是增强功能</span>        ....    &#125;</code></pre></code></pre></li><li><p>另外，还可以提取一个公共切入点，公共切入点的注解格式：</p><ul><li><p>基本语法格式：</p><pre><code><pre><code class="hljs java"><span class="hljs-meta">@Pointcut</span>(value=<span class="hljs-string">"execution(* com.dyf.CustomerDao.*(..)"</span>)    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pointcut</span><span class="hljs-params">()</span></span>&#123;        ...    &#125;</code></pre></code></pre></li><li><p>而增强方法上注解则变成：@Before(value=”切面类名.切入点名”)，即可；</p></li><li><p><code>@pointcut</code>注解的实质是：将某一类需要增强的方法们，放在了一个@Pointcut注解标记的方法上；然后，当这类方法需要不同的通知时，只需修改通知上调用的@Pointcut方法即可；</p><pre><code><pre><code class="hljs java"><span class="hljs-comment">//这是通知和切点紧密联系在一起</span>    <span class="hljs-meta">@Before</span>(value = <span class="hljs-string">"execution(* com.dyf.Dao.*(..))"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;            System.out.println(<span class="hljs-string">"我是前置通知！"</span>);    &#125;        <span class="hljs-comment">//=========================================================</span>        <span class="hljs-comment">//定义切点1</span>    <span class="hljs-meta">@Pointcut</span>(value = <span class="hljs-string">"execution(* com.dyf.Dao.update())"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyPoint1</span><span class="hljs-params">()</span></span>&#123;&#125;        <span class="hljs-comment">//定义切点2</span>    <span class="hljs-meta">@Pointcut</span>(value = <span class="hljs-string">"execution(* com.dyf.Dao.delete())"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Mypoint2</span><span class="hljs-params">()</span></span>&#123;&#125;        <span class="hljs-comment">//---------------------------------------------------------</span>        <span class="hljs-comment">//AfterReturning通知有返回值，使用returning来接受返回值</span>    <span class="hljs-meta">@AfterReturning</span>(value = <span class="hljs-string">"Mypoint2()"</span>,returning = <span class="hljs-string">"element"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">After</span><span class="hljs-params">(Object element)</span></span>&#123;            <span class="hljs-comment">//打印输出了返回值</span>        System.out.println(<span class="hljs-string">"我删除了"</span>+element);    &#125;        <span class="hljs-meta">@Around</span>(value=<span class="hljs-string">"MyPoint1()"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span></span>&#123;            Object obj=<span class="hljs-keyword">null</span>;            System.out.println(<span class="hljs-string">"环绕前"</span>);            <span class="hljs-keyword">try</span> &#123;                obj=joinPoint.proceed();            &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;                throwable.printStackTrace();            &#125;            System.out.println(<span class="hljs-string">"环绕后"</span>);            <span class="hljs-keyword">return</span> obj;    &#125;</code></pre></code></pre></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-4-Jdbc-Template"><a href="#NO1-4-Jdbc-Template" class="headerlink" title="NO1.4 Jdbc Template"></a>NO1.4 Jdbc Template</h3><p>Jdbc Template其实是Spring框架对JDBC的封装。</p><ul><li><p>JDBC Template：</p><ul><li><p>使用Jdbc模板操作数据库：</p><ul><li><p>创建项目，并导入数据库JAR包或依赖；然后创建连接池(druid连接池、C3P0连接池、JDBC内置连接池均可)，获取连接池对象；一般的，有关连接池之类的属性，我们会放在单独的属性文件中，这时就需要在Spring中引入属性文件；<strong><code>注意：该步骤可以交给Spring管理。</code></strong></p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--使用该标签引用数据库的属性文件--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:jdbc.properties"</span>&gt;</span>    //---------------------------------------------    <span class="hljs-comment">&lt;!--交给Spring管理--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"连接池变量名"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"连接池类的全包名路径"</span>&gt;</span>    <span class="hljs-comment">&lt;!--在其中注入数据库的四大要素：驱动、url、账号、密码即可--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClassName"</span> </span><span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.driverClassName&#125;"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.url&#125;"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.username&#125;"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.password&#125;"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></li><li><p>创建Jdbc模板；<strong><code>注意：该步骤可以交给Spring管理。</code></strong></p><pre><code class="hljs xml">原本需要自己写：JdbcTemplate jdbcTemplate = new JdbcTemplate(连接池对象);//--------------------------------------------------------------------<span class="hljs-comment">&lt;!--交给Spring管理--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jdbc模板的变量名"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"jdbc模板类的全包名路径"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"连接池对象名"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"需要注入的真正连接池对象"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    注意：这里jdbc模板类的全包名路径一般为：org.springframework.jdbc.core.JdbcTemplate</code></pre></li><li><p>JdbcTemple中常用方法语句；</p><pre><code class="hljs java">增删改：jdbcTemplate.update(sql语句,可变参数);如：String sql = <span class="hljs-string">"insert into emp values(null,?,?,?)"</span>;jdbcTemplate.update(sql,<span class="hljs-string">"邓先森"</span>,<span class="hljs-number">27</span>,<span class="hljs-string">"男"</span>);<span class="hljs-comment">//------------------------------------------------------------</span>查询：jdbcTemplate.queryForObject(sql语句,RowMapper&lt;T&gt;接口的实现类对象,可变参数);String sql = <span class="hljs-string">"select eid,ename,age,sex from emp"</span>;RowMapper&lt;Emp&gt; rowMapper = <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Emp<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;List&lt;Emp&gt; list = jdbcTemplate.update(sql,rowMapper);<span class="hljs-comment">//遍历list</span>....说明：常用查询方法：一、<span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">queryForObject</span><span class="hljs-params">(String sql, Class&lt;T&gt; requiredType)</span>：执行sql查询语句，返回一个指定类型的数据，即方法中第二个参数就是知道返回值的类型</span><span class="hljs-function"></span><span class="hljs-function">二、<span class="hljs-keyword">public</span> T <span class="hljs-title">queryForObject</span><span class="hljs-params">(String sql, RowMapper&lt;T&gt; rm, Object... args)</span>：执行查询语句，返回一个指定类型的对象</span><span class="hljs-function">    </span><span class="hljs-function">三、<span class="hljs-keyword">public</span> List&lt;T&gt; <span class="hljs-title">query</span><span class="hljs-params">(String sql, RowMapper&lt;T&gt; rm, Object... args)</span>：执行查询语句，返回一个集合  </span><span class="hljs-function">    </span><span class="hljs-function">四、<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">batchUpdate</span><span class="hljs-params">(String sql,List&lt;Object[]&gt; args)</span>：批量操作，一般做批量添加操作较多；第二个参数为批量添加的多个记录数组</span></code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-5-事务"><a href="#NO1-5-事务" class="headerlink" title="NO1.5 事务"></a>NO1.5 事务</h3><p>大家所了解的事务(Transaction)，它是一些列严密的操作，要么操作都完成，要么操作都回滚撤销。</p><ul><li><p>Spring事务：</p><ul><li><p>定义：就是逻辑上一组操作，要么都成功，要么都失败，不存在一半成功，一半失败。另外Spring的事务管理是基于底层数据库本身的事务处理机制。数据库事务的基础，是掌握Spring事务管理的基础；</p></li><li><p>事务的ACID四种特性：ACID是Atomic(原子性)、Consistency(一致性)、Isolation(隔离性)和Durability(持久性)的英文缩写；</p><ul><li><code>原子性(Atomicity)</code>：事务最基本的操作单元，要么全部成功，要么全部失败，不会结束在中间某个环节；事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样；</li><li><code>一致性(Consistency)</code>：指的是在一个事务执行之前和执行之后，数据库都必须处于一个正确的状态，什么叫正确的状态呢，就是满足预订的约束就叫做正确的状态。<strong><code>如，如果事务成功地完成，那么系统中所有变化将正确地应用，此时数据库就处于正确的状态；如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态，这时数据库也是正确的状态，也就是说，要么不改变，要么按照开发者的要求进行改变，这就是正确的状态。</code></strong></li><li><code>隔离性(Isolation)</code>：指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间；由并发事务所做的修改必须与任何其他并发事务所做的修改隔离；事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据；</li><li><code>持久性(Durability)</code>：指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来；即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态；</li></ul></li><li><p>Spring中事务的两种实现方式：</p><ul><li><p>编程式事务管理(了解)；</p><ul><li><p>在Spring中配置平台事务管理器；</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"事务管理器的名称"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"事务管理器类全包名路径"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"连接池名"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"连接池bean对象的id"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></li><li><p>配置事务管理的模板类；</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"事务管理模板的名称"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"事务管理模板类的全包名路径"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"事务管理器的名称"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"事务管理器bean对象id"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></li><li><p>在Service层添加事务模板对象，并调用方法：</p><pre><code class="hljs java">transactionTemplate.execute(    <span class="hljs-keyword">new</span> TransactionCallbackWithoutResult()&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInTransactionWithoutResult</span><span class="hljs-params">(TransactionStatus arg0)</span></span>&#123;        这里放入需要加入事务的代码体；    &#125;&#125;);</code></pre></li></ul></li><li><p>声明式事务管理(推荐)；</p><ul><li><p>XML文件形式：</p><ul><li><p>在Spring中配置平台事务管理器；</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置事务管理器--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"事务管理器的名称"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"事务管理器类全包名路径"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"连接池名"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"连接池bean对象的id"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></li><li><p>添加事务名称空间，然后配置事务的属性；</p><pre><code class="hljs xml">//先添加这个xmlns:tx="http://www.springframework.org/schema/tx//后添加这个http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd//----------------------------------------------<span class="hljs-comment">&lt;!--配置事务属性--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> </span><span class="hljs-tag"><span class="hljs-attr">id</span>=<span class="hljs-string">"事务的id"</span> </span><span class="hljs-tag"><span class="hljs-attr">transactions-manager</span>=<span class="hljs-string">"事务管理器对象id"</span>&gt;</span>    <span class="hljs-comment">&lt;!--确定哪些方法需要使用事务功能之后，再用这个标签进一步细分到每一个要使用事务功能的方法上&gt;</span><span class="hljs-comment">    &lt;tx:attributes&gt;</span><span class="hljs-comment">        &lt;tx:method name="需要使用事务的方法"&gt;</span><span class="hljs-comment">    &lt;tx:attributes&gt;</span><span class="hljs-comment"></span><span class="hljs-comment">&lt;/tx:advice&gt;</span></code></pre></li><li><p>配置事务的切入点，以及把事务和切入点关联起来；</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置事务切入点，以及把事务切入点和事务关联起来--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>    <span class="hljs-comment">&lt;!--配置事务切入点，就是告诉Spring哪些方法需要使用事务--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> </span><span class="hljs-tag">      <span class="hljs-attr">expression</span>=<span class="hljs-string">"execution(切入点表达式)"</span> </span><span class="hljs-tag">      <span class="hljs-attr">id</span>=<span class="hljs-string">"切入点id，自定义"</span> /&gt;</span>    <span class="hljs-comment">&lt;!--把需要使用事务功能的方法和切入点关联起来，也就是说&lt;aop:pointcut&gt;这个标签下表示大概有哪些方法要用事务，&lt;tx:advice&gt;这个标签则在&lt;aop:pointcut&gt;标签的范围下具体确定哪些方法要使用事务功能，然后把这两者关联起来的意思--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advicor</span> </span><span class="hljs-tag">     <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">"&lt;tx:advice&gt;标签的id"</span> </span><span class="hljs-tag">     <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">"就上面这个id，意思是把增强的功能放到这个id上的方法里"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre></li></ul></li><li><p>注解形式：</p><ul><li><p>在Spring中配置平台事务管理器；</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"事务管理器的名称"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"事务管理器类全包名路径"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"连接池名"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"连接池bean对象的id"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></li><li><p>开启注解事务；</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"事务管理器对象"</span>&gt;</span></code></pre></li><li><p>在Service层上添加@Transactional注解即可开启事务。@Transactional注解解析：<strong><code>注意：如果该注解用在类上，则对类中所有方法都使用事务功能；用在方法上则只对该方法使用事务功能。</code></strong></p><ul><li><p><code>readOnly</code>：该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false；简单的说，就是设置为true之后，访问数据不会加锁，提高查询效率，但会只允许查询操作；</p><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>(readOnly=<span class="hljs-keyword">true</span>)</code></pre></li><li><p><code>rollbackFor</code>：该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚；</p><pre><code class="hljs java">指定单一异常类：<span class="hljs-meta">@Transactional</span>(rollbackFor=RuntimeException<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"></span><span class="hljs-class">指定多个异常类：</span><span class="hljs-class">@<span class="hljs-title">Transactional</span>(<span class="hljs-title">rollbackFor</span></span>=&#123;RuntimeException<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Exception</span>.<span class="hljs-title">class</span>&#125;)</span></code></pre></li><li><p><code>rollbackForClassName</code>：该属性用于设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚；</p><pre><code class="hljs java">指定单一异常类名称：<span class="hljs-meta">@Transactional</span>(rollbackForClassName=<span class="hljs-string">"RuntimeException"</span>)指定多个异常类名称：<span class="hljs-meta">@Transactional</span>(rollbackForClassName=&#123;<span class="hljs-string">"RuntimeException"</span>,<span class="hljs-string">"Exception"</span>&#125;)</code></pre></li><li><p><code>noRollbackFor</code>：该属性用于设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，不进行事务回滚；</p><pre><code class="hljs java">指定单一异常类：<span class="hljs-meta">@Transactional</span>(noRollbackFor=RuntimeException<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"></span><span class="hljs-class">指定多个异常类：</span><span class="hljs-class">@<span class="hljs-title">Transactional</span>(<span class="hljs-title">noRollbackFor</span></span>=&#123;RuntimeException<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Exception</span>.<span class="hljs-title">class</span>&#125;)</span></code></pre></li><li><p><code>noRollbackForClassName</code>：该属性用于设置不需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，不进行事务回滚；</p><pre><code class="hljs java">指定单一异常类名称：<span class="hljs-meta">@Transactional</span>(noRollbackForClassName=<span class="hljs-string">"RuntimeException"</span>)指定多个异常类名称：<span class="hljs-meta">@Transactional</span>(noRollbackForClassName=&#123;<span class="hljs-string">"RuntimeException"</span>,<span class="hljs-string">"Exception"</span>&#125;)</code></pre></li><li><p><code>propagation</code>：该属性用于设置事务的传播行为，具体取值可参考下一个小节；</p><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>(propagation=Propagation.NOT_SUPPORTED,readOnly=<span class="hljs-keyword">true</span>)</code></pre></li><li><p><code>isolation</code>：该属性用于设置底层数据库的事务隔离级别，事务隔离级别用于处理多事务并发的情况，通常使用数据库的默认隔离级别即可，基本不需要进行设置；</p></li><li><p><code>timeout</code>：该属性用于设置事务的超时秒数，即如果超过规定时间则进行事务回滚操作；默认值为-1表示永不超时。</p></li></ul></li></ul></li></ul></li></ul></li><li><p>Spring事务的传播行为：</p><ul><li><p>定义：指的就是当一个事务方法去调用另一个事务方法时，当前的事务方法应该如何进行；</p></li><li><p>Spring定义的七种传播行为：</p><ul><li><p><code>PROPAGATION_REQUIRED(常用)</code>：是指如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中；这是最常见的选择，也是Spring默认的传播行为；</p><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>(propagation = Propagation.REQUIRED)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;        methodB();    <span class="hljs-comment">// do something</span>&#125;<span class="hljs-comment">// 事务属性为REQUIRED</span><span class="hljs-meta">@Transactional</span>(propagation = Propagation.REQUIRED)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// do something</span>&#125;说明：一、单独调用methodB方法时，因为当前上下文不存在事务，所以会开启一个新的事务；        二、调用methodA方法时，因为当前上下文不存在事务，所以会开启一个新的事务；当执行到methodB时，methodB发现当前上下文有事务，因此就加入到当前事务中来。</code></pre></li><li><p><code>PROPAGATION_REQUIRES_NEW(常用)</code>：是指无论当前是否有事务，开启一个新的事务；如果当前有事务，则先将这个存在的事务挂起；</p><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>(propagation = Propagation.REQUIRED)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;doSomeThingA();methodB();doSomeThingB();<span class="hljs-comment">// do something else</span>&#125;<span class="hljs-comment">// 事务属性为REQUIRES_NEW</span><span class="hljs-meta">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// do something</span>&#125;说明：一、当单独调用methodB时，会创建新的事务；二、当调用methodA，执行到methodB时，总是会单独给methodB创建一个新的事务，并挂起methodA的事务；当methodB执行完成后，回到methodA的事务中，无论methodA的事务是否成功，methodB的事务都不会受其影响(即该提交提交，该回滚回滚)，反过来，methodB事务也是一样的，也就是这两者的事务都不会互相干扰。</code></pre></li><li><p><code>PROPAGATION_SUPPORTS</code>：是指如果当前有事务，就加入当前事务，如果当前没有事务，就以非事务方式执行；</p><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>(propagation = Propagation.REQUIRED)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;    methodB();    <span class="hljs-comment">// do something</span>&#125;<span class="hljs-comment">//事务属性为SUPPORTS</span><span class="hljs-meta">@Transactional</span>(propagation = Propagation.SUPPORTS)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// do something</span>&#125;说明：单纯的调用methodB时，methodB方法是非事务执行的；当调用methdA时，methodB则加入了methodA的事务中；</code></pre></li><li><p><code>PROPAGATION_NOT_SUPPORTED</code>：是指总是以非事务的方式执行，如果当前有事务，则挂起事务；</p><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>(propagation = Propagation.REQUIRED)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;    doSomeThingA();    methodB();    doSomeThingB();    <span class="hljs-comment">// do something else</span>&#125;<span class="hljs-comment">// 事务属性为NOT_SUPPORTED</span><span class="hljs-meta">@Transactional</span>(propagation = Propagation.NOT_SUPPORTED)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// do something</span>&#125;说明：单独调用methodB，以非事务的状态执行；调用methodA，执行到methodB时，methodB以非事务的方式执行，并挂起methodA的事务，当methodB执行完成后，回到methodA中，继续执行methodA的事务</code></pre></li><li><p><code>PROPAGATION_MANDATORY</code>：是指如果当前有事务，则加入当前事务；如果没有事务，则抛出异常；即该传播行为，必须有事务；</p><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>(propagation = Propagation.REQUIRED)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;    methodB();    <span class="hljs-comment">// do something</span>&#125;<span class="hljs-comment">// 事务属性为MANDATORY</span><span class="hljs-meta">@Transactional</span>(propagation = Propagation.MANDATORY)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// do something</span>&#125;说明：当单独调用methodB时，因为当前没有一个活动的事务，则会抛出异常<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalTransactionStateException，即不合法事务状态异常；当调用methodA时，methodB则加入到methodA的事务中</code></pre></li><li><p><code>PROPAGATION_NEVER</code>：是指总是以非事务的方式执行，如果当前有事务，则抛出异常；</p><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>(propagation = Propagation.REQUIRED)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;    methodB();    <span class="hljs-comment">// do something</span>&#125;<span class="hljs-comment">// 事务属性为NEVER</span><span class="hljs-meta">@Transactional</span>(propagation = Propagation.NEVER)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// do something</span>&#125;说明：单独调用methodB时，以非事务的方式执行；调用methodA，执行到methodB时，发现当前有事务，则抛出异常；发现没有事务时，则继续执行；总之，就是不支持事务</code></pre></li><li><p><code>PROPAGATION_NESTED</code>：是指当前有事务，仍然创建事务后，并加入当前事务；没有事务则创建新的事务；但是，加入事务后，子事务失败并回滚，当前事务却不回滚；</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;    doSomeThingA();    methodB();    doSomeThingB();    <span class="hljs-comment">// do something else</span>&#125;<span class="hljs-comment">// 事务属性为NOT_NESTED</span><span class="hljs-meta">@Transactional</span>(propagation = Propagation.NESTED)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// do something</span>&#125;说明：单独调用methodB时，创建事务，按照事务的正常流程执行；调用methodA，执行到methodB时，methodB会创建一个事务，成功则提交，失败则回滚；无论methodB事务是哪种结果，都不会影响methodA的事务结果</code></pre></li></ul></li></ul></li><li><p>事务的安全性问题与隔离级别：</p><ul><li><p>安全性问题：</p><ul><li><p>定义：如果不考虑事务的隔离性，那么将产生安全性问题；</p></li><li><p>种类：</p><ul><li><p>脏读：是指一个事务读到另一个事务还没有提交的数据；</p><pre><code class="hljs java">事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据；</code></pre></li><li><p>不可重复读：是指一个事务读到另一个事务已经提交的update数据，导致在当前事务中多次查询的结果不一致；</p><pre><code class="hljs java">事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致；</code></pre></li><li><p>虚读/幻读：是指一个事务读到另一个事务已经提交的insert数据，导致在当前事务中多次查询的结果不一致；</p><pre><code class="hljs java">系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读；</code></pre></li></ul></li></ul></li><li><p>隔离级别：</p><ul><li><p>定义：为了解决事务的安全性问题而提出的解决方法；</p></li><li><p>种类：</p><ul><li><p><code>READ-UNCOMMITTED(读取未提交)</code>：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读；</p></li><li><p><code>READ-COMMITTED(读取已提交)</code>：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生；</p></li><li><p><code>REPEATABLE-READ(可重复读)</code>：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生；</p></li><li><p><code>SERIALIZABLE(可串行化)</code>：最高的隔离级别，完全服从ACID的隔离级别；所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读；</p><p><img src="./Image-ssm5.png" srcset="/img/loading.gif" alt="Image"></p><p><code>说明：Y代表可能发生，N代表不会发生。</code></p><pre><code class="hljs java">拓展：MySQL和Oracle的事务处理级别一、MySQL默认的事务处理级别是<span class="hljs-string">'REPEATABLE-READ'</span>,也就是可重复读；二、Oracle默认系统事务隔离级别是READ COMMITTED,也就是读已提交；Oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别。</code></pre></li></ul></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;&nbsp;</p><p>&nbsp;</p><h2 id="Lesson2-MyBatis框架"><a href="#Lesson2-MyBatis框架" class="headerlink" title="Lesson2 MyBatis框架"></a>Lesson2 MyBatis框架</h2><h3 id="NO2-1-全局配置文件与映射文件"><a href="#NO2-1-全局配置文件与映射文件" class="headerlink" title="NO2.1 全局配置文件与映射文件"></a>NO2.1 全局配置文件与映射文件</h3><p>MyBatis是dao的框架。</p><ul><li><p>MyBatis框架：</p><ul><li><p>定义：是持久层的框架，对JDBC操作数据库的过程进行了封装，是一个半自动ORM框架；</p></li><li><p>核心文件：MyBatis全局配置文件和映射文件；</p><ul><li><p>MyBatis核心配置文件：自定义名称即可，但一般定义为<code>sqlMapConfig.xml</code>或者<code>mybatis-config.xml</code>。可以用来配置连接数据库的环境，以及配置要使用的POJO类的映射文件；</p><ul><li><p>创建一个xml文件，并引入MyBatis全局配置文件的文件头；</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><span class="hljs-meta">  <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><span class="hljs-meta">  <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-comment">&lt;!--在这里面进行MyBatis框架的配置--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></li><li><p>由于MyBatis是持久层的框架，也就是常常与数据库进行交互，所以常常要用到数据库连接池；</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入连接数据库所需要的“xxx.properties”资源配置文件--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"db.properties"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>说明：一、resource：该属性是指调用类路径下的资源文件；一般src下就是类路径，所以只有放入src下即可；二、url：该属性是指调用网络路径下或磁盘路径下进行访问。//------------------------------------------------------<span class="hljs-comment">&lt;!--配置连接数据库的环境--&gt;</span><span class="hljs-comment">&lt;!--这个environments标签就是用于配置连接数据库的环境，可以配置多个，一般只配置一个；default属性是指，默认使用值为xxx作为连接数据库的环境--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"development"</span>&gt;</span>        <span class="hljs-comment">&lt;!--environment标签用于，配置某一个具体的数据库连接环境；id属性则是指这个配置环境的唯一标识，不能重复，以供environments标签使用--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"development"</span>&gt;</span>        <span class="hljs-comment">&lt;!--配置事务管理，type属性有两个值：一个是JDBC，是指使用JDBC进行事务管理；二是使用MANAGED，是指谁能够管理事务就让谁来管理--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span> /&gt;</span>        <span class="hljs-comment">&lt;!-- 配置数据库连接信息，type属性有三个值：POOLED(指使用MyBatis自带的数据库连接池)、UNPOOLED(不使用数据库连接池)、JNDI(使用JNDI实现的数据源，该方式用的比较少) --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.driver&#125;"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.url&#125;"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.name&#125;"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.password&#125;"</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>    <span class="hljs-comment">&lt;!--第二个连接数据库的环境配置--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"connectB"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span> /&gt;</span>        <span class="hljs-comment">&lt;!-- 配置数据库连接信息 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.driver&#125;"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.url&#125;"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.name&#125;"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.password&#125;"</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span></code></pre></li><li><p>映射文件配置；</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入要使用的映射文件，即告诉MyBatis这是一个映射文件--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"即xxxMapper.xml文件"</span>/&gt;</span>    <span class="hljs-comment">&lt;!--还可以使用package标签集体引入某一个包下的xxxMapper.xml文件，但是要求xxxMapper.xml文件和对应接口文件必须在同一个包下，所以我们一般把放这两个文件的包路径名都设置的是一样的，也就是说，这两种文件可以不需要紧挨在一起，只要包路径名相同即可--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cn.dyf.xxxMapper"</span> /&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre></li><li><p>其他配置标签；</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 该标签用于全局设置某个属性。如，cacheEnabled属性(缓存是否可用)，mapUnderscoreToCamelCase属性(将数据库字段的下划线转换为驼峰命名)等等；</span><span class="hljs-comment">     常用的属性，一般配置lazyLoadingEnabled(是否执行懒加载)、aggressiveLazyLoading(是否查询所有数据)，这两个属性一般一起使用；</span><span class="hljs-comment"> --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"lazyLoadingEnabled"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"aggressiveLazyLoading"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"false"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><span class="hljs-comment">&lt;!-- 该标签用于为类型设置别名，type属性设置Java类型，如果只设置了type，默认的别名就是类型，且不区分大小写；alias属性就是为type的类型设置一个别名，这样在xml文件中就可以直接填入“u”，而不是“cn.dyf.domain.User”了 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"cn.dyf.domain.User"</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"u"</span> /&gt;</span>    <span class="hljs-comment">&lt;!--为该包路径下的所有类都设置别名，默认为类名小写，不区分大小写--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cn.dyf.domain"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span></code></pre></li></ul></li><li><p>MyBatis映射文件：一般自定义名称为xxxMapper.xml格式；其实映射文件就是Dao层中接口的实现类；另外，映射文件都要在核心配置文件中进行声明，也就是使用<code>&lt;mappers&gt;</code>标签，注册xxxMapper.xml文件，告诉MyBatis，这是映射文件；xxxMapper.xml文件中主要用标签的形式来书写sql语句；</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"这里填入，该映射文件对应的接口的全包名路径"</span>&gt;</span>    <span class="hljs-comment">&lt;!--这是查询标签--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"接口中对应的方法名"</span> </span><span class="hljs-tag">            <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"参数的数据类型"</span> </span><span class="hljs-tag">            <span class="hljs-attr">resultType</span>=<span class="hljs-string">"结果的数据类型(如果是POJO类则填类的全包名路径)"</span>&gt;</span>        这里写sql语句，一般占位符用#&#123;&#125;，特殊情况用$&#123;&#125;(这是连接符，详情看下个小节)    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">            如果添加一条数据之后，立马需要查询该条记录的自增主键值，有两种方式：</span><span class="hljs-comment">            1.这是Oracle数据库使用，即没有自增主键的数据库使用，可以使用标签：</span><span class="hljs-comment">            &lt;selectKey resultType="返回值类型" keyProperty="返回值放入到POJO的哪个属性里" order="只有BEFORE和AFTER，即在sql语句之前获取或sql语句之后获取"&gt;&lt;/selectKey&gt;</span><span class="hljs-comment"></span><span class="hljs-comment">            2.这是MySQl数据库使用，即有自增主键的数据库使用，直接在&lt;insert&gt;标签中，多添加两个属性即可，就是useGeneratedKeys(是否需要返回该条记录的自增主键值)和keyProperty(将该记录的主键值赋值到传过来的对象参数的哪个属性上)，返回的自增主键值就赋值在了你传过来的对象参数里你设定的某一个属性上，一般都设置为id属性：</span><span class="hljs-comment">            &lt;insert id="xxx" useGeneratedKeys="true" keyProperty="xxx"&gt;xxxx&lt;/insert&gt;</span><span class="hljs-comment">            </span><span class="hljs-comment">     --&gt;</span>    <span class="hljs-comment">&lt;!--这是添加标签：&lt;insert&gt;内容参考上面的查询和普通sql语句&lt;/insert&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--这是修改标签：&lt;update&gt;内容参考上面的查询和普通sql语句&lt;/update&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--这是删除标签：&lt;delete&gt;内容参考上面的查询和普通sql语句&lt;/delete&gt;--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre><ul><li><p>测试代码；</p><pre><code class="hljs java"><span class="hljs-comment">//获得能够创建sqlSessionFactory的工程师对象</span>SqlSessionFactoryBuilder builder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<span class="hljs-comment">//从全局配置文件sqlMapConfig.xml中获得工厂的图纸</span>InputStream factoryMap = Resources.getResourceAsStream(<span class="hljs-string">"sqlMapConfig.xml"</span>);<span class="hljs-comment">//创建sqlSessionFactory工厂</span>SqlSessionFactory sqlSessionFactoyr = builder.buil(factoryMap);<span class="hljs-comment">//获得sqlSession对象，openSession()方法还可以多添加一个“true”参数，即自动提交事务    </span>sqlSession sqlSession = sqlSessionFactory.openSession();<span class="hljs-comment">//操作语句，根据sqlSession获得接口的代理实现对象；</span>接口名 mapper = sqlSession.getMapper(需要代理的接口的<span class="hljs-class"><span class="hljs-keyword">class</span>文件，即：<span class="hljs-title">xxx</span>.<span class="hljs-title">class</span>)</span>;<span class="hljs-comment">//操作方法</span>mapper.方法();<span class="hljs-comment">//提交事务</span>sqlSession.commit();</code></pre></li></ul></li></ul></li><li><p>映射文件中sql语句的占位符号：#{}和${}的区别；</p><ul><li><p><code>#{}</code>：将传入的数据都当成一个字符串，会对传入的数据自动加一个引号。#{}底层是使用的是PreparedStatement对象操作的SQL语句；</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span></span>&#123;    queryUserById(<span class="hljs-keyword">int</span> id);  <span class="hljs-comment">//当接口参数为一个非对象类型的值时</span>&#125;select.... where id = #&#123;xxx&#125; 说明：如果传入的值是<span class="hljs-number">111</span>，那么解析成sql时的值为select... where id = <span class="hljs-string">"111"</span>如果传入的值是abc，则解析成的sql为select... where id = <span class="hljs-string">"abc"</span><span class="hljs-comment">//-------------------------------------------------</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span></span>&#123;    updateUser(User user);  <span class="hljs-comment">//当接口参数为一个对象类型的值时</span>&#125;update.... where id = #&#123;yyy&#125;  说明：由于接口参数是一个对象类型，而yyy是该对象的一个属性，那么可以直接获取到该对象的yyy属性的值，假设yyy属性是id属性且值为<span class="hljs-number">2</span>，则sql解析为order by <span class="hljs-string">"2"</span><span class="hljs-comment">//--------------------------------------</span>拓展：map作为参数一、和对象作为参数意义，#&#123;map的key值&#125;就可以直接获取对应key中所存放的值。</code></pre></li><li><p><code>${}</code>：将传入的数据直接显示在生成的sql中。${}底层是使用的是Statement对象操作的SQL语句；</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span></span>&#123;    queryUserById(<span class="hljs-keyword">int</span> id);  <span class="hljs-comment">//当接口参数为一个非对象类型的值时</span>&#125;select.... where id = $&#123;xxx&#125;说明：如果传入的值是<span class="hljs-number">111</span>，只能以$&#123;value&#125;或者$&#123;_parameter&#125;获取值，那么解析成sql时的值为select... where id = <span class="hljs-number">111</span>；如果传入的值是abc，只能以$&#123;value&#125;或者$&#123;_parameter&#125;获取值，则解析成的sql为select... where id = abc。<span class="hljs-comment">//-------------------------------------------------</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span></span>&#123;    updateUser(User user);  <span class="hljs-comment">//当接口参数为一个对象类型的值时</span>&#125;update.... where id = $&#123;yyy&#125;  说明：由于接口参数是一个对象类型，而yyy是该对象的一个属性，那么可以直接获取到该对象的yyy属性的值；假设yyy属性是id属性且值为<span class="hljs-number">2</span>，则sql解析为order by <span class="hljs-number">2</span><span class="hljs-comment">//-------------------------------------------------------------</span>拓展：#&#123;&#125;和$&#123;&#125;的其他注意点一、#&#123;&#125;方式能够很大程度防止sql注入，$&#123;&#125;方式无法防止Sql注入，一般能用#&#123;&#125;的就别用$&#123;&#125;；二、$&#123;&#125;方式一般用于传入数据库的对象。如，传入表名等等；三、MyBatis排序时使用order by，需要注意，排序的字段用$&#123;&#125;而不是#&#123;&#125;。</code></pre></li></ul></li><li><p>映射文件中sql语句的参数：</p><ul><li><p>当sql语句中只有一个参数时(基本数据类型或引用数据类型)：</p><ul><li><code>#{}</code>内的参数名称可以是任意名称，符合命名规范就行；</li><li><code>${}</code>内的参数名称则只能使用<code>${value}</code>或<code>${_parameter}</code>来获取参数。</li></ul></li><li><p>当sql语句里需要多个参数时：MyBatis默认会将多个参数放入一个Map中；当参数是集合或者数组时，也会默认放到一个Map中，而List的键是list，Array的键则是array；</p><ul><li><p>一种是根据参数索引0、1、2、3…获取，<code>#{0}</code>、<code>#{1}</code>，这种只有<code>#{}</code>方式可以使用；</p></li><li><p>另一种则根据param1、param2…获取，<code>${param1}</code>或<code>#{param1}</code>，<code>#{}</code>与<code>${}</code>都可以使用；</p></li><li><p><code>使用注解@Param(&quot;xxx&quot;)(推荐)</code>：该注解的效果相当于为指定的参数设置一个指定名称的“键”，而值则是该注解后面的参数；该注解不仅提供了名称命名参数的功能，即为参数创建了一个名称，以便在映射文件中方便的使用，而且同时还提供了使用param1，param2…paramN命名参数的功能，也就是说这一个注解同时做了这两件事情，你选择哪一个都可以获取到你想要的参数。<code>#{}</code>和<code>${}</code>都可以使用这种方式，但是<code>${}</code>要注意引号的问题。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(@Param(<span class="hljs-string">"aaa"</span>)</span><span class="hljs-keyword">int</span> id, </span><span class="hljs-function">    @<span class="hljs-title">Param</span><span class="hljs-params">(<span class="hljs-string">"bbb"</span>)</span>String name)</span>;  &#125;说明：<span class="hljs-meta">@Param</span>注解中，分别将两个键值对，一个键为aaa，一个键为bbb，放入了一个Map中，这样映射文件中直接可以根据键名称获取到对应的值了</code></pre></li></ul></li></ul></li><li><p>MyBatis中与数据库的交互，使用的是mapper代理形式，即接口+映射文件的形式；开发规范如下：</p><ul><li>接口的全包名路径要和映射文件的namespace属性值保持一致；</li><li>接口的方法名要和映射文件的id属性值保持一致；</li><li>接口的参数类型、返回值类型要和映射文件的parameterType、resultType保持一致；</li><li>接口和映射文件的名称最好保持一致；</li><li>接口和映射文件最好放到同一目录。</li></ul></li><li><p>注解@MapKey(“xxx”)的使用；</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名</span>&#123;    <span class="hljs-meta">@MapKey</span>(<span class="hljs-string">"xxx"</span>);  <span class="hljs-comment">//该注解的作用是，指定一个字段(也就是括号中的“xxx”)作为Map中的Key；由于获取的是对象类型，所以放入Map中的值位置，而键需要我们指定，但又不能重复，所有我们使用User中的id属性来充当键就行了</span>    <span class="hljs-function">Map&lt;String, Object&gt; <span class="hljs-title">getAllUser</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//获取所有的User对象，放将数据放入Map中，对象作为值</span>&#125;</code></pre></li><li><p><code>&lt;resultMap&gt;</code>标签的高级自定义映射功能：resultType可以把查询结果封装到pojo类型中，但要求pojo类的属性名和查询到的数据库表的字段名一致；如果sql查询到的字段与pojo的属性名不一致，则需要使用resultMap将字段名和属性名对应起来，进行手动配置封装，将结果映射到pojo中；</p><pre><code class="hljs xml">//在映射文件中，配置resultMap标签，映射不同的字段和属性名    <span class="hljs-comment">&lt;!-- resultMap标签，常用于多对一的表关系，作用是将结果映射到pojo上，</span><span class="hljs-comment">         type属性就是指定映射到哪一个pojo，</span><span class="hljs-comment">         id属性就表示ResultMap的id --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Emp"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"empMap"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- id标签定义主键，非常重要；如果是多个字段,则定义多个id；</span><span class="hljs-comment">             property属性，就是指主键在pojo中的属性名，</span><span class="hljs-comment"> column属性，就是主键在数据库中的列名 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"eid"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"eid"</span> /&gt;</span>        <span class="hljs-comment">&lt;!-- result标签定义普通属性，</span><span class="hljs-comment"> property属性，普通属性在pojo类中的名称</span><span class="hljs-comment"> column属性则是指，普通属性在数据库的名称--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"ename"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"ename"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"age"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sex"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>        <span class="hljs-comment">&lt;!--处理某个对象类型的属性，有三种方式--&gt;</span>    <span class="hljs-comment">&lt;!--第一种方式，直接使用result标签--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Emp"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"empMap"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"eid"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"eid"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"ename"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"ename"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"age"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sex"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"did"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"dept.did"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"dname"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"dept.dname"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>    <span class="hljs-comment">&lt;!--第二种方式，使用&lt;association&gt;标签</span><span class="hljs-comment">        association标签的作用是，处理单一的关联对象或处理单一属性的关联关系；</span><span class="hljs-comment">        javaType属性，是指把sql语句查询出的结果集，封装给哪个类的对象；</span><span class="hljs-comment">    --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Emp"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"empMap"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"eid"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"eid"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"ename"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"ename"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"age"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sex"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"dept"</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">"xxx.xxx.Dept"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"did"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"did"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"dname"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"dname"</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>    <span class="hljs-comment">&lt;!--第三种方式，分步查询</span><span class="hljs-comment">        association标签的作用是，处理单一的关联对象或处理单一属性的关联关系；</span><span class="hljs-comment">        javaType属性，是指把sql语句查询出的结果集，封装给哪个类的对象；</span><span class="hljs-comment">        select属性，是指当使用分步查询(和sql子查询类似)时，你要调用哪一个sql，格式为：namespace.你要调用那一条sql的id；</span><span class="hljs-comment">        column属性，是指分步查询时，你要调用的那一条sql，需要参数时，就使用这个属性，该参数的值会从当前的sql语句获取；</span><span class="hljs-comment">        property属性，是指你需要将查询出来的结果注入到哪个属性中；</span><span class="hljs-comment">    --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Emp"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"empMap"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"eid"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"eid"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"ename"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"ename"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"age"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sex"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"dept"</span> <span class="hljs-attr">select</span>=<span class="hljs-string">"cn.dyf.mapper.DeptMapper.getDeptById"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"did"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>    <span class="hljs-comment">&lt;!--当出现一对多或者多对多的情况时，则使用&lt;collection&gt;标签，如一个部门有多个职员；ofType属性，是指集合中的元素的类型--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Dept"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"deptMap"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"did"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"did"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"dname"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"dname"</span> /&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"emps"</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">"Emp"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"eid"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"eid"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"ename"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"ename"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"age"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sex"</span> /&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>    <span class="hljs-comment">&lt;!--同样的，在&lt;collection&gt;标签中也可以使用分步查询，也就是说里面也有select和column属性，且column属性的值可以是一个Map，即放入多个值，如，例中的did=did，前者是键did，后者是值did，分布查询后面的sql语句的参数要和这里的键名称相同，也就是说变成id=did，则分步查询的后一条sql语句的参数一定是#&#123;id&#125;或$&#123;id&#125;；fetchType属性用于指定该条sql语句是否要执行懒加载，该属性只有两个值，lazy或eager--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Dept"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"deptMapStep"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"did"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"did"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"dname"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"dname"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"emps"</span> <span class="hljs-attr">select</span>=<span class="hljs-string">"cn.dyf.mapper.getEmpListByDid"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"&#123;did=did,...&#125;"</span> <span class="hljs-attr">fetchType</span>=<span class="hljs-string">"eager"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>//---------------------------------------------------------------------------//先在映射文件中，配置基本的sql语句<span class="hljs-comment">&lt;!-- resultMap属性，即填入配置的resultMap标签的id值就行 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getAllEmp"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"empMap"</span>&gt;</span>    SELECT e.eid, e.ename, e.age, e.sex, e.did, d.dname    FROM emp e    LEFT JOIN    dept d    ON e.did = d.did<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-comment">&lt;!--根据部门id查询职员信息--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getEmpListByDid"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"empMap"</span>&gt;</span>    SELECT eid, ename, age, sex FROM emp where did = #&#123;did&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-comment">&lt;!--根据id查询部门信息--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getDeptByDid"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"deptMapStep"</span>&gt;</span>    SELECT did, dname FROM dept where did = #&#123;did&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-2-动态SQL与缓存"><a href="#NO2-2-动态SQL与缓存" class="headerlink" title="NO2.2 动态SQL与缓存"></a>NO2.2 动态SQL与缓存</h3><p>动态sql是为了解决sql语句拼接问题。</p><ul><li><p>动态sql：</p><ul><li><p>定义：传统的使用JDBC的方法，相信大家在组合复杂的的sql语句的时候，需要去拼接，稍不注意哪怕少了个空格，都会导致错误；Mybatis的动态sql功能正是为了解决这种问题，其通过if、choose、when、otherwise、trim、where、set、foreach标签，可组合成非常灵活的sql语句，从而提高开发人员的效率；</p></li><li><p>if和where标签：</p><ul><li><p><code>where</code>：去除where关键字之后的第一个and或者or，但是不会去除条件后面的AND或者OR；</p></li><li><p><code>if</code>：判断。该标签里有个test属性，该属性就是用于判断指定的表达式是否成立，成立则if标签中的语句有效，否则就无效；</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"xxx"</span>&gt;</span>    SELECT * FROM user    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"username !=null and username !=''"</span>&gt;</span>            AND username LIKE '%$&#123;username&#125;%'        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"sex !=null and sex !=''"</span>&gt;</span>            AND sex = #&#123;sex&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"address !=null and address !=''"</span>&gt;</span>            AND address = #&#123;address&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></li></ul></li><li><p>foreach标签：</p><ul><li><p><code>foreach</code>：用于遍历数组、集合；属性有：</p><ul><li><p><code>collection</code>：要遍历的数组或集合；</p></li><li><p><code>item</code>：表示集合中每一个元素进行迭代时的别名；</p></li><li><p><code>index</code>：用于表示在迭代过程中，每次迭代到的位置；</p></li><li><p><code>open</code>：表示该语句以什么开始；</p></li><li><p><code>separator</code>：表示在每次进行迭代之间以什么符号作为分隔符；</p></li><li><p><code>close</code>：表示以什么结束。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"xxx"</span>&gt;</span>    SELECT * FROM user    WHERE age IN    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> </span><span class="hljs-tag">    <span class="hljs-attr">collection</span>=<span class="hljs-string">"通过参数传过来的数组"</span> </span><span class="hljs-tag">    <span class="hljs-attr">open</span>=<span class="hljs-string">"("</span> <span class="hljs-attr">close</span>=<span class="hljs-string">")"</span> </span><span class="hljs-tag">    <span class="hljs-attr">separator</span>=<span class="hljs-string">","</span> <span class="hljs-attr">item</span>=<span class="hljs-string">"age"</span> &gt;</span>        #&#123;age&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>//------------------------------------拓展：批量修改使用<span class="hljs-tag">&lt;<span class="hljs-name">foreach</span>&gt;</span>标签，需要注意的是，MyBatis的预编译对象不允许一次执行多条sql语句，所以为了解决这个问题，需要在连接地址url的后面添加参数：?allowMultiQueries=true<span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"xxx"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> </span><span class="hljs-tag">    <span class="hljs-attr">collection</span>=<span class="hljs-string">"array"</span>  </span><span class="hljs-tag">    <span class="hljs-attr">item</span>=<span class="hljs-string">"emp"</span>&gt;</span>        UPDATE emp SET ename=#&#123;emp.ename&#125;,         age=#&#123;emp.age&#125;,         sex=#&#123;emp.sex&#125;,         where eid=#&#123;emp.eid&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></code></pre></li></ul></li></ul></li><li><p>set标签：</p><ul><li><p><code>set</code>：去除最后一个“,”，即去除最后一个逗号。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"xxx"</span>&gt;</span>    UPDATE user    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"username!=null and username!=''"</span>&gt;</span>            username = #&#123;username&#125;,        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"username!=null and username!=''"</span>&gt;</span>            sex = #&#123;sex&#125;,        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"username!=null and username!=''"</span>&gt;</span>            address = #&#123;address&#125;,        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>    WHERE id =#&#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></li></ul></li><li><p>trim标签：</p><ul><li><p><code>trim</code>：一般用于去除sql语句中多余的and关键字，逗号，或者给sql语句前拼接“where”、“set”以及“values”等后缀(或后缀)，可用于选择性插入、更新、删除或者条件查询等操作。属性有：</p><ul><li><p><code>prefixOverrides</code>：前缀覆盖，就是去除第一个条件之前的相应内容；</p></li><li><p><code>suffixOverrides</code>：后缀覆盖，覆盖最后一个条件之后的相应内容；</p></li><li><p><code>prefix</code>：前缀，在第一个条件之前添加的内容；</p></li><li><p><code>suffix</code>：后缀，在最后一个条件之后添加的内容。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"xxx"</span>&gt;</span>    SELECT * FROM user    <span class="hljs-comment">&lt;!--这里的suffixOverrides属性为“AND/OR”，表示把多余的AND或者OR都去除掉--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"WHERE"</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">"AND/OR"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"username !=null and username !=''"</span>&gt;</span>            username LIKE '%$&#123;username&#125;%' AND        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"sex !=null and sex !=''"</span>&gt;</span>            sex = #&#123;sex&#125; or        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"address !=null and address !=''"</span>&gt;</span>            address = #&#123;address&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></li></ul></li></ul></li><li><p>choose标签：</p><ul><li><p><code>choose</code>：按顺序判断其内部when标签中的test条件出否成立，如果有一个成立，则choose结束，也就不会拼接其他条件，只有一个条件会成立；当choose中所有when的条件都不满则时，则执行otherwise中的sql。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"xxx"</span>&gt;</span>      SELECT *      FROM user u       <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"username != null"</span>&gt;</span>                  u.username LIKE '%$&#123;username&#125;%')              <span class="hljs-tag">&lt;/<span class="hljs-name">when</span> &gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"sex != null and sex != ''"</span>&gt;</span>                  AND u.sex = #&#123;sex&#125;              <span class="hljs-tag">&lt;/<span class="hljs-name">when</span> &gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"birthday != null"</span>&gt;</span>                  AND u.birthday = #&#123;birthday&#125;              <span class="hljs-tag">&lt;/<span class="hljs-name">when</span> &gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span>                 u.age = #&#123;age&#125;             <span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></li></ul></li><li><p>sql标签：</p><ul><li><p><code>sql</code>：这个标签用于设置一条公用的sql语句，也就是说任意的其他sql都可以使用这条sql语句，只要本身的sql里包含有这条sql语句就行了。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"empColumn"</span>&gt;</span>SELECT ename,age,sex FROM emp<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"xxx"</span>&gt;</span>      <span class="hljs-comment">&lt;!--这里引用了公共的sql语句，所以使用&lt;include&gt;标签来引用公共的sql，而refid属性则是填入这个公共sql的id值就行了--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">"empColumn"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>    WHERE eid=#&#123;eid&#125;      <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>MyBatis缓存：</p><ul><li><p>目的：为了提高查询效率；</p></li><li><p>MyBatis为我们提供了一级缓存(默认开启)和二级缓存(手动配置开启)：</p><p><img src="./Image-ssm7.png" srcset="/img/loading.gif" alt="Image"></p><ul><li><p><code>一级缓存是SqlSession级别的缓存</code>： 其实指的就是MyBatis中sqlSession对象(该对象类似于JDBC的Connection对象)的缓存，当我们执行查询以后，查询的结果会同时存入到SqlSession为我们提供的一块区域中，该区域的结构是一个Map，当我们再次查询同样的数据(如果查询的数据不同，则不会有缓存)，MyBatis会先去sqlsession中查询是否有，有的话直接拿出来用；不同的sqlSession之间拥有不同的一级缓存；</p><ul><li><p>一级缓存的销毁：当SqlSession对象消失时，MyBatis的一级缓存也就消失了；</p></li><li><p>一级缓存失效情况：</p><ul><li>不同的SqlSession对象，且分别第一次调用某个方法时，一级缓存无效。因为是不同的SqlSession对象，且是第一次查询；</li><li>同一个SqlSession对象，同一个查询方法，但查询条件不一样。<code>如，第一次通过id=1去查询，第二次通过id=2去查询，当然也没有缓存</code>；</li><li>同一个SqlSession对象，同一个查询方法，调用两次之间，穿插调用了同一个SqlSession的修改、添加、删除等方法(即第一次查询后去执行了增删改方法，而后又以和第一次相同的条件执行查询)，那么一级缓存也会失效；commit(提交)、close(关闭)、</li><li>clearCache(手动清空一级缓存)，就会清空一级缓存。</li></ul></li><li><p>底层数据结构： MyBatis内部存储缓存(无论一级缓存还是二级缓存)使用的是一个HashMap，key为hashCode+sqlId+Sql语句，value为从查询出来映射生成的java对象或查询结果的普通数据。</p><pre><code class="hljs java"><span class="hljs-comment">//domain类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> Date birthday;    <span class="hljs-keyword">private</span> String sex;    <span class="hljs-keyword">private</span> String address;        get和set方法省略.....&#125;<span class="hljs-comment">//----------------------------------------------</span><span class="hljs-comment">//Dao接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;    <span class="hljs-comment">//查询所有的用户</span>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//根据Id查询用户</span>    <span class="hljs-function">User <span class="hljs-title">findById</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-comment">//更新用户</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(User user)</span></span>;&#125;<span class="hljs-comment">//----------------------------------------------</span><span class="hljs-comment">//Dao接口对应的Mapper.xml</span>&lt;mapper namespace=<span class="hljs-string">"cn.dyf.dao.UserDao"</span>&gt;    &lt;select id=<span class="hljs-string">"findAll"</span> resultType=<span class="hljs-string">"cn.dyf.domain.User"</span>&gt;        SELECT * FROM USER;    &lt;/select&gt;    &lt;select id=<span class="hljs-string">"findById"</span> resultType=<span class="hljs-string">"cn.dyf.domain.User"</span>&gt;        SELECT * FROM  USER  WHERE ID = #&#123;ID&#125;    &lt;/select&gt;    &lt;update id=<span class="hljs-string">"updateUser"</span> parameterType=<span class="hljs-string">"cn.dyf.domain.User"</span>&gt;        UPDATE USER        &lt;set&gt;            &lt;if test="username != null"&gt;username=#&#123;username&#125;,&lt;/if&gt;            &lt;if test="password != null"&gt;birthday=#&#123;birthday&#125;,&lt;/if&gt;            &lt;if test="sex != null"&gt;sex=#&#123;sex&#125;,&lt;/if&gt;            &lt;if test="address != null"&gt;address=#&#123;address&#125;,&lt;/if&gt;        &lt;/set&gt;        WHERE id=#&#123;id&#125;    &lt;/update&gt;&lt;/mapper&gt;<span class="hljs-comment">//----------------------------------------------</span><span class="hljs-comment">//测试代码</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findByIdTest</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//获得能够创建sqlSessionFactory的工程师对象</span>    SqlSessionFactoryBuilder builder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();    <span class="hljs-comment">//从全局配置文件sqlMapConfig.xml中获得工厂的图纸</span>    InputStream factoryMap = Resources.getResourceAsStream(<span class="hljs-string">"sqlMapConfig.xml"</span>);    <span class="hljs-comment">//创建sqlSessionFactory工厂</span>    SqlSessionFactory sqlSessionFactoyr = builder.buil(factoryMap);    SqlSession session =sqlSessionFactoyr.openSession();    UserDao userDao = session.getMapper(UserDao<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">//第一次获取该用户</span>    User user1 = userDao.findById(<span class="hljs-number">45</span>);    System.out.println(user1);    第二次获取该用户    User user2 = userDao.findById(<span class="hljs-number">45</span>);    System.out.println(user2);    System.out.println(user1 == user2);    session.close();&#125;</code></pre></li></ul></li><li><p><code>二级缓存是mapper级别的缓存</code>：多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的；<code>如，UserMapper有一个二级缓存区域(按namespace分)，其它mapper也有自己的二级缓存区域(按namespace分)</code>。每一个namespace的mapper都有一个二级缓存区域，两个mapper的namespace如果相同，这两个mapper执行sql查询到数据将存在相同的二级缓存区域中；通俗的理解就是，二级缓存的配置完成后，可以有多个SqlSession，但是必须操作同一个namespace，并执行查询相同的数据，这样结果数据就会进行缓存；</p><pre><code class="hljs java">&lt;!--第一步，让Mybatis框架支持二级缓存(在Mybatis的全局配置文件中进行配置)--&gt;&lt;setting name=<span class="hljs-string">"cacheEnabled"</span> value=<span class="hljs-string">"true"</span>/&gt;<span class="hljs-comment">//----------------------------------------------------</span>&lt;!--第二步，让当前的映射文件支持二级缓存(在xxxMapper.xml映射文件中配置)，只需要写上&lt;cache /&gt;标签，这个mapper就开启了二级缓存--&gt;&lt;cache /&gt;<span class="hljs-comment">//----------------------------------------------------</span><span class="hljs-comment">//第三步，二级缓存需要查询结果所映射的pojo对象实现java.io.Serializable接口来实现序列化和反序列化操作。注意：如果存在父类、成员pojo都需要实现序列化接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;    ....&#125;说明：二级缓存必须在SqlSession关闭或提交之后才会生效<span class="hljs-comment">//----------------------------------------------------</span><span class="hljs-comment">//测试代码</span><span class="hljs-comment">//获取session1</span>SqlSession session1 = sqlSessionFactory.openSession();UserMapper userMapper = session1.getMapper(UserMapper<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-comment">//使用session1执行第一次查询</span>User user1 = userMapper.findUserById(<span class="hljs-number">1</span>);System.out.println(user1);<span class="hljs-comment">//关闭session1</span>session1.close();<span class="hljs-comment">//获取session2</span>SqlSession session2 = sqlSessionFactory.openSession();UserMapper userMapper2 = session2.getMapper(UserMapper<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-comment">//使用session2执行第二次查询，由于开启了二级缓存这里从缓存中获取数据不再向数据库发出sql</span>User user2 = userMapper2.findUserById(<span class="hljs-number">1</span>);System.out.println(user2);<span class="hljs-comment">//关闭session2</span>session2.close();拓展：增删改和查询语句中的useCache属性、flushCache属性一、select标签语句中：<span class="hljs-number">1</span>.都有useCache属性，且默认为<span class="hljs-keyword">true</span>，表示会将本条语句的结果进行二级缓存；<span class="hljs-number">2</span>.都有flushCache属性，且默认为<span class="hljs-keyword">false</span>，表示任何时候语句被调用，都不会去清空   本地(一级)缓存和二级缓存。二、每条insert、update、delete语句中：<span class="hljs-number">1</span>.useCache属性，在以上三个标签语句中没有；<span class="hljs-number">2</span>.都有flushCache属性，且默认为<span class="hljs-keyword">true</span>，表示任何时候语句被调用，都会导致本地  (一级)缓存和二级缓存被清空。三、sqlSession.clearCache()方法只能清空本地(一级)缓存的。</code></pre><p><img src="./Image-ssm8.png" srcset="/img/loading.gif" alt="Image"></p><p><code>说明：以上属性是第二步中的&lt;cache&gt;标签中的属性。</code></p></li><li><p>第三方缓存：为了提高扩展性，MyBatis定义了缓存接口Cache，我们可以通过实现Cache接口来实现自己的缓存逻辑；EhCache是一个分布式缓存框架，EhCache是一个纯Java的进程内缓存框架，是一种广泛使用的开源Java分布式缓存，具有快速、精干等特点，是Hibernate中默认的CacheProvider。要整合EhCache，要准备以下步骤：</p><ul><li><p>第一步，准备JAR包或者maven依赖；</p><pre><code class="hljs css"><span class="hljs-selector-tag">mybatis-ehcache-1</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.3</span><span class="hljs-selector-class">.jar</span><span class="hljs-selector-tag">ehcache-core-2</span><span class="hljs-selector-class">.6</span><span class="hljs-selector-class">.8</span><span class="hljs-selector-class">.jar</span><span class="hljs-selector-tag">slf4j-api-1</span><span class="hljs-selector-class">.6</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.jar</span>其中，<span class="hljs-selector-tag">mybatis</span>本身已经带了<span class="hljs-selector-tag">slf4j-api</span>包，所以只需要拷贝前两个<span class="hljs-selector-tag">jar</span>包即可</code></pre></li><li><p>第二步，在项目的src目录下，新建ehcache.xml文件，文件内容如下：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ehcache</span>&gt;</span>    <span class="hljs-comment">&lt;!--表示硬盘上保存缓存的位置，默认是临时文件夹--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">diskStore</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"D:\cache"</span>/&gt;</span>    <span class="hljs-comment">&lt;!--默认缓存配置，如果类没有做特定的设置，则使用这里配置的缓存属性</span><span class="hljs-comment">       maxElementsInMemory：设置缓存中允许保存的最大对象(pojo)数量</span><span class="hljs-comment">       eternal：设置对象是否永久保存，如果为true，则缓存中的数据永远不销毁，一直保存</span><span class="hljs-comment">       timeToIdleSeconds：设置空闲销毁时间。只有eternal为false时才起作用。表示从现在到上次访问时间如果超过这个值，则缓存数据销毁</span><span class="hljs-comment">       timeToLiveSeconds：设置活动销毁时间。表示从现在到缓存创建时间如果超过这个值，则缓存自动销毁</span><span class="hljs-comment">       overflowToDisk：设置是否在超过保存数量时，将超出的部分保存到硬盘上--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">defaultCache</span></span><span class="hljs-tag">        <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">"1500"</span></span><span class="hljs-tag">        <span class="hljs-attr">eternal</span>=<span class="hljs-string">"false"</span></span><span class="hljs-tag">        <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">"120"</span></span><span class="hljs-tag">        <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">"300"</span></span><span class="hljs-tag">        <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">"true"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 也可以通过name设置针对某个类的缓存配置 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cn.sz.po.Emp"</span></span><span class="hljs-tag">        <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">"1000"</span></span><span class="hljs-tag">        <span class="hljs-attr">eternal</span>=<span class="hljs-string">"true"</span></span><span class="hljs-tag">        <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">"0"</span></span><span class="hljs-tag">        <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">"0"</span></span><span class="hljs-tag">        <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">"false"</span></span><span class="hljs-tag">        /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ehcache</span>&gt;</span></code></pre></li><li><p>第三步，最后在xxxMapper.xml映射文件中添加一个<cache>标签即可，就相当于用第三方缓存来替代MyBatis的二级缓存；</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"org.mybatis.caches.ehcache.LoggingEhcache"</span> &gt;</span>        <span class="hljs-comment">&lt;!--这下面的内容，是和ehcache.xml文件中的配置差不多，只不过是用于实时配置--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"timeToIdleSeconds"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"3600"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"timeToLiveSeconds"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"3600"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 同ehcache参数maxElementsInMemory--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"maxEntriesLocalHeap"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1000"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 同ehcache参数maxElementsOnDisk --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"maxEntriesLocalDisk"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"10000000"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"memoryStoreEvictionPolicy"</span> </span><span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">"LRU"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cache</span>&gt;</span></code></pre></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson3-Spring-MVC框架"><a href="#Lesson3-Spring-MVC框架" class="headerlink" title="Lesson3 Spring MVC框架"></a>Lesson3 Spring MVC框架</h2><h3 id="NO3-1-Spring-MVC概述与运行原理"><a href="#NO3-1-Spring-MVC概述与运行原理" class="headerlink" title="NO3.1 Spring MVC概述与运行原理"></a>NO3.1 Spring MVC概述与运行原理</h3><p>Spring MVC是web层的框架</p><ul><li><p>Spring MVC：</p><ul><li><p>定义：是一个严格遵循MVC设计模式的框架。说其是一个框架，那么Spring MVC框架中就应该有与Model，View，Controller相对应的组件：分别是Model模型对象，视图解析器，Controller控制器；Spring MVC的请求流程图：</p><p><img src="./Image-ssm9.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>优点：</p><ul><li>支持Restful风格；</li><li>采用松散耦合可插拔组件结构，比其他MVC框架更具扩展性和灵活性等等。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-2-Spring-MVC框架解析"><a href="#NO3-2-Spring-MVC框架解析" class="headerlink" title="NO3.2 Spring MVC框架解析"></a>NO3.2 Spring MVC框架解析</h3><ul><li><p>入门案例：</p><ul><li><p>创建项目，并导入需要的JAR包或者使用Maven导入需要的依赖；</p><p><img src="./Image-ssm10.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-ssm11.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>在web.xml中配置好DispatcherServlet的<code>&lt;servlet&gt;&lt;/servlet&gt;</code>导向后，因为还要创建Spring MVC的配置文件，但该配置文件是默认放在/WEB-INF/下，默认名称是<code>&lt;servlet-name&gt;-servlet.xml</code>，所以需要在<code>&lt;servlet&gt;</code>标签里的<code>&lt;init-param&gt;</code>子标签下修改默认配置文件的位置，我们一般放在固定的config目录下；</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置DispatcherServlet的作用是为了加载配置文件，Spring MVC会加载默认位置的配置文件，但我们一般都会给它修改到config目录下去，这样它就会加载config下的配置文件了--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>        xxx    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>        org.springframework.web.servlet.DispatcherServlet    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>    <span class="hljs-comment">&lt;!--这是修改默认的加载配置文件的位置，原本默认加载/WEB-INF/XXX-servlet.xml位置的配置文件，修改成如下 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 原本Servlet是在第一次被访问时，才会被加载，设置了该标签以后则会将Servlet的加载时间提前到项目启动时，标签中写负整数时，相当于没有设置该标签，只有设置0或正整数才能使该标签生效，且值越小，优先级越高，即0&gt;1&gt;2... --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>        xxx    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-comment">&lt;!--该标签表示对哪些指定的请求进行处理，而“/”值，表示只对所有的请求进行拦截处理，页面不会进行拦截处理--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>        /    <span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></li><li><p>编写并配置Controller类；</p><ul><li><p>编写一个普通Java类，并在类上添加注解：@Controller，然后创建一个返回值是ModelAndView的方法，在方法上添加注解：@RequestMapping(“/请求的资源名”)；</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/xx"</span>)  <span class="hljs-comment">//该标签在类上的作用是，添加一个主路由，意思就是要想访问这个控制层下的方法，必须加上这里的这个路径名，如访问test方法，这里加了个user，所以访问路径就变成了localhost:8080/web01/user/test，而不是原来的localhost:8080/web01/test</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">xxxController</span></span>&#123;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/请求的url资源名，不要带后缀，根据资源名会找对应方法去执行"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">XXX</span><span class="hljs-params">(HttpServletRequest request,HttpServletReponse reponse)</span></span>&#123;...&#125;&#125;</code></pre><ul><li>注解@RequestMapping解析：<ul><li><code>value</code>：就是指定处理某个请求的url，也就是当请求的资源名和这个属性值对应时，DispatcherServlet会调用这个注解下的方法对请求进行处理，有多个值时，必须将value写出来，即value={“aa”,”bb”}；</li><li><code>method</code>：该属性用来表示该方法仅仅处理哪些HTTP请求方式，常用的请求方式有GET、POST、DELETE、PUT等等；</li><li><code>params</code>：该属性指定，请求中必须包含params属性规定的参数时，才能执行该请求。<code>如，当params=&quot;flag&quot;时，请求中必须包含flag参数，flag参数值不做要求，而当params=&quot;flag=true&quot;时，则参数flag的值也必须为true才能调用方法执行该请求，params=!flag则表示请求中不能包含flag参数</code>；</li><li><code>headers</code>：该属性指定，请求中必须包含某些指定的header值，才能够让该方法处理请求。<code>如，headers=&quot;Referer=http://www.xxx.com&quot;，表明请求的header中必须满足，指定的请求头&quot;Referer&quot;和值为&quot;http://www.xxx.com&quot;时，才能执行该请求</code>；</li></ul></li></ul></li><li><p>将带@Controller注解的类配置到Spring MVC.xml中，也就是开启注解扫描，然后再配置视图解析器，用于解析你要跳转的页面；</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 扫描注解 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"需要扫描的Controller全包名路径"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span>//--------------------------------------<span class="hljs-comment">&lt;!-- 视图解析器 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"viewResolver"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 前缀 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/WEB-INF/view"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 后缀 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".jsp"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></li><li><p>获取请求需要的数据后，创建一个ModelAndView，即：</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/请求的url资源名"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">XXX</span><span class="hljs-params">(HttpServletRequest request,HttpServletReponse reponse)</span></span>&#123;    <span class="hljs-comment">//创建一个modelAndView</span>    ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView();    <span class="hljs-comment">//相当于把数据放入了request域中</span>    modelAndView.addObject(name,value);    <span class="hljs-comment">//设置要跳转的页面，即JSP路径即可</span>    modelAndView.setViewName(viewName);&#125;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>Spring MVC请求路径风格：</p><ul><li><p>Spring MVC支持Ant风格的通配符：其实就是@RequestMapping注解的value值多加一层路径；</p><ul><li><p><code>?</code>：匹配一个任意字符；</p></li><li><p><code>*</code>：匹配0或多个任意字符；</p></li><li><p><code>**</code>：匹配0或多层路径。</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AntMaskTest</span> </span>&#123;        <span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/?/test"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">TestAntMask</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;    &#125;&#125;说明：一、<span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/?/test"</span>)注解使用了Ant风格的匹配符，那么在浏览器中输入的url就变为了：localihost:<span class="hljs-number">8080</span>/项目名/a/test，也可以是localihost:<span class="hljs-number">8080</span>/项目名/v/test，因为使用了?，只能匹配一个任意字符；二、<span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/*/test"</span>)，则可以输入为localihost:<span class="hljs-number">8080</span>/项目名/aaa/test或localihost:<span class="hljs-number">8080</span>/项目名/test；三、<span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/**/test"</span>)，则是localihost:<span class="hljs-number">8080</span>/项目名/aaa/bbb/test或localihost:<span class="hljs-number">8080</span>/项目名/test都行。</code></pre></li></ul></li><li><p><code>Spring支持的RESTful风格(推荐)</code>：其实这种风格就是把参数写到url后面并用{}括起来，多个参数用“/”隔开；但是该风格需要配合@PathVariable(XXX)注解一起使用</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user/&#123;id&#125;/&#123;otherParam&#125;"</span>)<span class="hljs-meta">@ResponseBody</span>  <span class="hljs-comment">//该注解会将返回的对象转换成JSON格式的数据后传给前台</span><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUser</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id, @<span class="hljs-title">PathVariable</span><span class="hljs-params">(<span class="hljs-string">"otherParam"</span>)</span>String param) </span>&#123;    User user = <span class="hljs-keyword">new</span> User();    <span class="hljs-keyword">if</span>(<span class="hljs-string">"123"</span>.equals(id)) &#123;        user.setUsername(<span class="hljs-string">"nlskyfree"</span>);    &#125;    <span class="hljs-keyword">return</span> user;&#125;说明：一、<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user/&#123;id&#125;/&#123;otherParam&#125;"</span>)，通过URL中的&#123;XXX&#125;表示占位符，与<span class="hljs-meta">@PathVariable</span>(XXX)注解配合建立URL路径到参数的绑定关系。</code></pre><ul><li><p>SpringMVC过滤器HiddenHttpMethodFilter的使用：</p><ul><li><p>问题：浏览器不支持以PUT、DELETE方式提交请求。一般使用Restful风格的url，都会遇到这个问题：即一般来说，资源操作有新增，删除，更改，查询四种类型，对应HTTP协议中四类请求：<code>POST</code>，<code>DELETE</code>，<code>PUT</code>，<code>GET</code>；未声明情况下浏览器默认使用GET提交请求；需要注意的是，普通浏览器只支持GET，POST方式，其他请求方式，像DELETE或PUT必须通过过滤器的支持才能实现；</p></li><li><p>解决：Spring自带了一个过滤器HiddenHttpMethodFilter，支持GET、POST、PUT、DELETE请求。HiddenHttpMethodFilter的父类是OncePerRequestFilter，它继承了父类的doFilterInternal方法，工作原理是将jsp页面的form表单的method属性值在doFilterInternal方法中转化为标准的Http方法，即GET、POST、HEAD、OPTIONS、PUT、DELETE、TRACE，然后到Controller中找到对应的方法；</p><pre><code class="hljs java"><span class="hljs-comment">//首先，在web.xml中增加过滤器，&lt;filter&gt;标签必须放在&lt;servlet&gt;标签之前</span>&lt;!-- 增加HiddenHttpMethodFilte过滤器：给普通浏览器增加put或delete请求方式 --&gt;&lt;filter&gt;    &lt;filter-name&gt;HiddenHttpMethodFilte&lt;/filter-name&gt;    &lt;filter-<span class="hljs-class"><span class="hljs-keyword">class</span>&gt;<span class="hljs-title">org</span>.<span class="hljs-title">springframework</span>.<span class="hljs-title">web</span>.<span class="hljs-title">filter</span>.<span class="hljs-title">HiddenHttpMethodFilter</span>&lt;/<span class="hljs-title">filter</span>-<span class="hljs-title">class</span>&gt;</span><span class="hljs-class">&lt;/<span class="hljs-title">filter</span>&gt;</span><span class="hljs-class">    </span><span class="hljs-class">&lt;<span class="hljs-title">filter</span>-<span class="hljs-title">mapping</span>&gt;</span><span class="hljs-class">    &lt;<span class="hljs-title">filter</span>-<span class="hljs-title">name</span>&gt;<span class="hljs-title">HiddenHttpMethodFilte</span>&lt;/<span class="hljs-title">filter</span>-<span class="hljs-title">name</span>&gt;</span><span class="hljs-class">    &lt;!-- 过滤所有：/*--&gt;</span><span class="hljs-class">    &lt;<span class="hljs-title">url</span>-<span class="hljs-title">pattern</span>&gt;/*&lt;/<span class="hljs-title">url</span>-<span class="hljs-title">pattern</span>&gt;</span><span class="hljs-class">&lt;/<span class="hljs-title">filter</span>-<span class="hljs-title">mapping</span>&gt;       </span><span class="hljs-class"></span><span class="hljs-class"></span><span class="hljs-class">//----------------------------------</span><span class="hljs-class"></span><span class="hljs-class">//其次，往<span class="hljs-title">JSP</span>中添加一个隐藏域，然后设置隐藏域的<span class="hljs-title">name</span>属性(值为<span class="hljs-title">_method</span>)和<span class="hljs-title">value</span>值(值为<span class="hljs-title">DELETE</span>或<span class="hljs-title">PUT</span>)</span><span class="hljs-class">&lt;<span class="hljs-title">form</span> <span class="hljs-title">action</span></span>=<span class="hljs-string">"/testRest/1234"</span> method=<span class="hljs-string">"post"</span>&gt;    &lt;input type=<span class="hljs-string">"hidden"</span>  name=<span class="hljs-string">"_method"</span> value=<span class="hljs-string">"DELETE"</span>/&gt;    &lt;input type=<span class="hljs-string">"submit"</span> value=<span class="hljs-string">"删"</span>&gt;&lt;/form&gt;<span class="hljs-comment">//----------------------------------</span><span class="hljs-comment">//Controller层</span><span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"testRest/&#123;id&#125;"</span>,method=RequestMethod.DELETE)<span class="hljs-function"><span class="hljs-keyword">public</span> String  <span class="hljs-title">testDelete</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> Integer id) </span>&#123;    System.out.println(<span class="hljs-string">"delete：删 "</span> +id);    <span class="hljs-comment">//Service层省略</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span> ;&#125;<span class="hljs-comment">//-------------------------------------------</span>说明：HiddenHttpMethodFilter的实现原理其实就是新建了个HttpMethodRequestWrapper类，覆写了getMethod()方法，也就是将原来本身的HTTP请求方式(POST)给隐藏掉了<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HiddenHttpMethodFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OncePerRequestFilter</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_METHOD_PARAM = <span class="hljs-string">"_method"</span>;    <span class="hljs-keyword">private</span> String methodParam = DEFAULT_METHOD_PARAM;        <span class="hljs-comment">//这个方法，其实就是Filter中的doFilter(...)方法，也就是请求放行的方法</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">//获取到"_method"对应的value值</span>        String paramValue = request.getParameter(<span class="hljs-keyword">this</span>.methodParam);        <span class="hljs-comment">//如果是POST请求，就将POST请求包装成需要转换的请求</span>        <span class="hljs-keyword">if</span> (<span class="hljs-string">"POST"</span>.equals(request.getMethod()) &amp;&amp; StringUtils.hasLength(paramValue)) &#123;            <span class="hljs-comment">//toUpperCase方法是将字符串转换成大写的英文字符串</span>            String method = paramValue.toUpperCase(Locale.ENGLISH);            <span class="hljs-comment">//通过调用包装方法将请求以及我们要转换的请求方式一起包装成新的请求</span>            HttpServletRequest wrapper = <span class="hljs-keyword">new</span> HttpMethodRequestWrapper(request, method);            <span class="hljs-comment">//转换完成，请求放行</span>            filterChain.doFilter(wrapper, response);        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//如果不是POST请求(那就只有GET请求了)，就直接放行</span>            filterChain.doFilter(request, response);        &#125;    &#125;<span class="hljs-comment">//----------------------------------------------</span>    <span class="hljs-comment">//该类将重新包装请求，请求的内容并没有变化，只是将POST请求转换成了前端传过来的指定请求类型值</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpMethodRequestWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServletRequestWrapper</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String method;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpMethodRequestWrapper</span><span class="hljs-params">(HttpServletRequest request, String method)</span> </span>&#123;            <span class="hljs-keyword">super</span>(request);            <span class="hljs-keyword">this</span>.method = method;        &#125;        <span class="hljs-comment">//通过覆写了getMethod方法，后期再调用getMethod方法的时候获取到的就是我们转换之后的method</span>        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMethod</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.method;        &#125;    &#125;&#125;<span class="hljs-comment">//-------------------------------------------</span>说明：一、使用HiddenHttpMethodFilter对浏览器传来的请求进行处理，也就是转换成PUT或DELETE请求，需要：<span class="hljs-number">1</span>.在web.xml中配置HiddenHttpMethodFilter过滤器；<span class="hljs-number">1</span>.请求的方式必须是POST；<span class="hljs-number">2</span>.请求中必须包含参数<span class="hljs-string">"_method"</span>，且有对应的值为<span class="hljs-string">"PUT"</span>或<span class="hljs-string">"DELETE"</span>；</code></pre></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>Spring MVC获取前台传递的数据：</p><ul><li><p>在处理请求的方法声明上，加入形参的时候，只要形参的名称和前台传来的数据的名称相对应，就可以自动赋值；</p><ul><li>如果处理方法的方法声明上需要的是一个普通类型；</li></ul><pre><code class="hljs java"><span class="hljs-comment">//JSP页面</span>&lt;form action=<span class="hljs-string">"/param"</span> method=<span class="hljs-string">"post"</span>&gt;    用户名：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"username"</span> /&gt;    密码：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"password"</span> /&gt;    年龄：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"age"</span> /&gt;    &lt;input type=<span class="hljs-string">"submit"</span> value=<span class="hljs-string">"提交"</span>&gt;&lt;/form&gt;<span class="hljs-comment">//----------------------------------------------------</span><span class="hljs-comment">//Controller层</span><span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/param"</span>,method=RequestMethod.POST)<span class="hljs-function"><span class="hljs-keyword">public</span> String  <span class="hljs-title">testParam</span><span class="hljs-params">(String username, String password, Integer age)</span> </span>&#123;  <span class="hljs-comment">//在这个方法声明里，这里的形参名称和前台传来的参数名称一致，所以可以自动赋值</span>    System.out.println(<span class="hljs-string">"结果为："</span> + username + password + age);    <span class="hljs-comment">//Service层省略</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span> ;&#125;</code></pre><ul><li><p>如果前台传来的数据是一个pojo对象，那么只需要在处理方法的方法声明上添加这个pojo对象所属类的形参即可，但必须要求pojo类对象的属性名称和前台的页面中的表单元素的name属性一致，且还要注意对象的一些属性可能会是一个对象的情况；<strong><code>注意：当前台传过来的数据是JSON对象时，是无法使用该方式进行获取数据的。</code></strong></p><pre><code class="hljs java"><span class="hljs-comment">//JSP页面</span>&lt;!--表单封装了一个User对象--&gt;&lt;form action=<span class="hljs-string">"/param"</span> method=<span class="hljs-string">"post"</span>&gt;        用户名：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"username"</span> /&gt;    密码：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"password"</span> /&gt;    年龄：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"age"</span> /&gt;    &lt;!--下面三个属性是User对象中的address属性，而Address又是一个对象，所以需要加上address属性进行限定--&gt;    所在省：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"address.province"</span> /&gt;    所在城市：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"address.city"</span> /&gt;    所在街道：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"address.street"</span> /&gt;        &lt;!--封装成一个list，表示将这两个属性封装成一个对象，然后存入list--&gt;    aaa：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"list[0].xxx"</span> /&gt;bbb：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"list[0].xxx"</span> /&gt;        &lt;!--封装成一个map，表示将key和后面的xxx封装成一个键值对，存入map--&gt;    aaa：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"map['key'].xxx"</span> /&gt;bbb：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"map['key'].xxx"</span> /&gt;        &lt;input type=<span class="hljs-string">"submit"</span> value=<span class="hljs-string">"提交"</span>&gt;&lt;/form&gt;<span class="hljs-comment">//----------------------------------------------------</span><span class="hljs-comment">//pojo类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> integer id;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-keyword">private</span> integer age;    <span class="hljs-keyword">private</span> Address address;        ...&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span></span>&#123;    <span class="hljs-keyword">private</span> String province;    <span class="hljs-keyword">private</span> String city;    <span class="hljs-keyword">private</span> String street;        ...&#125;<span class="hljs-comment">//------------------------------------------------------</span><span class="hljs-comment">//Controller层</span><span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/param"</span>,method=RequestMethod.POST)<span class="hljs-function"><span class="hljs-keyword">public</span> String  <span class="hljs-title">testParam</span><span class="hljs-params">(User user)</span> </span>&#123;  <span class="hljs-comment">//在这个方法声明里，需要一个User对象，传过来的数据名称和User对象属性名称一致的，就会自动赋值，如果名称不一致的，就需要提前在页面中就行限定了</span>    System.out.println(<span class="hljs-string">"结果为："</span> + user);    <span class="hljs-comment">//Service层省略</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span> ;&#125;</code></pre></li></ul></li><li><p>在处理方法的方法声明中使用注解@RequestBody或@RequestParam。</p><ul><li><p>前端传来的是普通形式的字参数时，则使用@RequestParam注解；</p><pre><code class="hljs java"><span class="hljs-comment">//JSP页面</span>&lt;form action=<span class="hljs-string">"/param"</span> method=<span class="hljs-string">"post"</span>&gt;    用户名：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"name"</span> /&gt;    密码：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"password"</span> /&gt;    年龄：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"age"</span> /&gt;    &lt;input type=<span class="hljs-string">"submit"</span> value=<span class="hljs-string">"提交"</span>&gt;&lt;/form&gt;<span class="hljs-comment">//----------------------------------------------------</span><span class="hljs-comment">//Controller层</span><span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/param"</span>,method=RequestMethod.POST)<span class="hljs-function"><span class="hljs-keyword">public</span> String  <span class="hljs-title">testParam</span><span class="hljs-params">(@RequestParam(value=<span class="hljs-string">"name"</span>, required=<span class="hljs-keyword">false</span>, defaultValue=<span class="hljs-string">"xxx"</span>)</span> String username) </span>&#123;    System.out.println(<span class="hljs-string">"结果为："</span> + username + password + age);    <span class="hljs-comment">//Service层省略</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span> ;&#125;</code></pre><ul><li>@RequestParam注解解析：<ul><li><code>value</code>：用于指定前台的某个参数和注解后面的形参进行映射，就是把前台的某个指定名称的参数赋值到该注解后面的形参中去；</li><li><code>required</code>：默认为true)是指，value属性指定的参数不是一定要出现在前台传来的数据当中，即不一定要有value属性指定的参数，有就赋值，没有也可以；</li><li><code>defaultValue</code>：是指，当value属性指定的参数不存在时，即形参的值为null时，为该注解后面的形参设置一个默认值；</li></ul></li></ul></li><li><p>前端传来的是JSON格式的数据对象时，那么就需要用到注解@RequestBody了，因为目前前端传对象数据，哪怕是注册用户也好，还是修改用户信息也罢，都会封装成一个JSON对象进行传递，而不是放到form表单中进行传递(form表单中的数据格式并不是一个JSON)。</p><pre><code class="hljs java"><span class="hljs-comment">//Controller层</span><span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/param"</span>,method=RequestMethod.POST)<span class="hljs-function"><span class="hljs-keyword">public</span> String  <span class="hljs-title">testParam</span><span class="hljs-params">(@RequestBody User user)</span> </span>&#123;  <span class="hljs-comment">//该注解就会将前端传来的JSON格式的数据，封装成User，前提是传来的参数名称要和User中的属性名称一一对应才行，因为原理是使用的User中Setter方法进行设置值</span>    System.out.println(<span class="hljs-string">"结果为："</span> + username + password + age);    <span class="hljs-comment">//Service层省略</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span> ;&#125;拓展：<span class="hljs-meta">@RequestHeader</span>注解与<span class="hljs-meta">@CookieValue</span>注解与<span class="hljs-meta">@RequestParam</span>()注解类似的，<span class="hljs-meta">@RequestHeader</span>注解是用来获取请求头中的某个参数的值，该注解的属性和<span class="hljs-meta">@RequestParam</span>()注解一样，都有value、required、defaultValue属性，且意思一样，只不过获取参数的区域是从请求头中获取；    二、<span class="hljs-meta">@CookieValue</span>注解则是获取Cookie中的参数信息的，也有value、required、defaultValue属性，如JSESSIONID等等；    三、<span class="hljs-meta">@ResponseBody</span>注解，用在方法上，将方法的返回值一JSON的形式返回给前台。</code></pre><ul><li>@RequestBody注解解析：GET方式无请求体，所以使用@RequestBody接收数据时，前端不能使用GET方式提交数据，而是用POST方式进行提交。在后端的同一个接收方法里，@RequestBody与@RequestParam()可以同时使用，@RequestBody最多只能有一个，而@RequestParam()可以有多个。</li></ul></li></ul></li><li><p>使用Servlet的原生API获取参数；</p><pre><code class="hljs java"><span class="hljs-comment">//Controller层</span><span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/param"</span>,method=RequestMethod.POST)<span class="hljs-function"><span class="hljs-keyword">public</span> String  <span class="hljs-title">testParam</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;    <span class="hljs-comment">//获取前台传过来的参数</span>    String param = request.getParameter(<span class="hljs-string">"xxxx"</span>);        System.out.println(<span class="hljs-string">"结果为："</span> + param);    <span class="hljs-comment">//Service层省略</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span> ;&#125;拓展：MVC中Handler方法可以接受的ServletAPI类型的参数，说白了就是处理方法中可以直接获取并使用的参数：一、HttpServletRequest、HttpServletResponse、HttpServletSession二、java.security.Principal、Locale、InputStream、OutPutStream、Reader、Writer。</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>乱码问题：</p><ul><li><p>请求或响应的乱码问题：当前台JSP页面和Java代码中使用了不同的字符集进行编码的时候就会出现表单提交的数据或者上传/下载中文名称文件出现乱码的问题；</p></li><li><p>解决请求或响应的乱码问题：使用<code>CharacterEncodingFilter(编码过滤器)</code>，是Spring内置过滤器的一种，用来指定请求或者响应的编码格式；</p><pre><code class="hljs xml">//在web.xml中配置编码过滤器，一定要在所有的filter的最前面配置该过滤器<span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>SpringEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>    <span class="hljs-comment">&lt;!--为CharacterEncodingFilter类中的encoding的属性赋值，该属性的作用是指定request的编码格式--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-comment">&lt;!--forceEncoding属性则表示，是否强制response的编码格式也是encoding属性值的编码格式--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>SpringEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>        <span class="hljs-comment">&lt;!--Filter中的“/*”就等于是DispatcherServlet中“/”，也就是对所有请求进行过滤--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>返回数据给前台：使用ModelAndView对象，该对象是往Request作用域中存储处理完后的结果数据，以及返回要显示的视图；</p><pre><code class="hljs arduino"><span class="hljs-comment">//Controller层</span>@RequestMapping(value=<span class="hljs-string">"/test"</span> , method=RequestMethod.POST)<span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//创建一个ModelAndView对象</span>    ModelAndView mav = <span class="hljs-keyword">new</span> ModelAndView();    <span class="hljs-comment">//省略Service层    </span>    <span class="hljs-comment">//存储数据，即存储放回的数据结果</span>    mav.addObject(<span class="hljs-string">"username"</span>, <span class="hljs-string">"root"</span>);        <span class="hljs-comment">//设置一个要返回的视图</span>    mav.setViewName(<span class="hljs-string">"success"</span>);        <span class="hljs-comment">//如果需要转发请求，或重定向，则</span>    mav.setViewName(<span class="hljs-string">"forward:/路径"</span>);    mav.setViewName(<span class="hljs-string">"redirect:/路径"</span>);    <span class="hljs-keyword">return</span> mav ;&#125;拓展：除了使用ModelAndView往Request域中传输数据以外，也可以使用以下三种方式<span class="hljs-comment">//方式一</span>@RequestMapping(value=<span class="hljs-string">"/test"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">test</span><span class="hljs-params">(Map&lt;<span class="hljs-keyword">String</span>, Object&gt; <span class="hljs-built_in">map</span>)</span> </span>&#123;        <span class="hljs-comment">//使用一个Map也可以往Request域中传值，但该方式最终仍然会封装成一个ModelAndView方式进行存储数据</span>    <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">"username"</span>,<span class="hljs-string">"admin"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;&#125;<span class="hljs-comment">//方式二</span>@RequestMapping(value=<span class="hljs-string">"/test"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">test</span><span class="hljs-params">(Model model)</span> </span>&#123;        <span class="hljs-comment">//使用一个Model对象也可以往Request域中传值，该方式最终也会转封装成一个ModelAndView方式进行存储数据</span>    model.addAttribute(<span class="hljs-string">"username"</span>,<span class="hljs-string">"张三"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;&#125;<span class="hljs-comment">//方式三</span>@RequestMapping(value=<span class="hljs-string">"/test"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">test</span><span class="hljs-params">(HttpServletRequest req)</span> </span>&#123;        <span class="hljs-comment">//Servlet原生API往Request域中传值</span>    req.setAttribute(<span class="hljs-string">"username"</span>,<span class="hljs-string">"张三"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;&#125;</code></pre></li></ul><p>&nbsp;</p><ul><li>Spring MVC三大核心组件：<ul><li><code>处理器映射器(即HandlerMapping)</code>：用来帮助我们找到响应的Controller；</li><li><code>处理器适配器(即HandlerAdapter)</code>：帮助我们找到请求的资源所对应的方法；</li><li><code>视图解析器(即ViewResolver)</code>：获取ModelAndView之后，用视图解析器渲染HTML页面；</li></ul></li></ul><p>&nbsp;</p><ul><li><p><code>&lt;mvc:annotation-driven&gt;和&lt;mvc:default-servlet-handler/&gt;</code>标签的作用；</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在SpringMVC.xml中配置标签就可以使用最新的核心组件，当然还有其他重要的功能，暂时不讲--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><span class="hljs-comment">&lt;!--</span><span class="hljs-comment">    SpringMVC将接收到的所有请求都看作是一个普通的请求，包括对于静态资源的请求；这样一来，所有对于静态资源的请求都会被看作是一个普通的后台控制器请求，导致请求找不到而报404异常错误；对于这个问题SpringMVC在全局配置文件中提供了一个&lt;mvc:default-servlet-handler/&gt;标签；在WEB容器启动的时候会在上下文中定义一个DefaultServletHttpRequestHandler，它会对DispatcherServlet的请求进行处理，如果该请求已经作了映射(就是在Controller层中找到了方法对该请求进行处理)，那么会接着交给后台对应的处理程序，如果没有作映射(也就是说可能是一个对静态资源的请求)，就交给 WEB 应用服务器默认的 Servlet 处理，从而找到对应的静态资源，只有再找不到资源时才会报错</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span></code></pre></li></ul><p>&nbsp;</p><ul><li><p>JSON的使用：</p><ul><li><p>定义：JSON是一种简单的数据交换格式；</p></li><li><p>种类：JSON中只有两种数据基本结构：</p><ul><li>一种是MAP(或者叫对象，即常说的JSON对象)；<ul><li>JSON对象：类似于java中的Map，标准的格式是“{}”，里面的内容是键值对，即key:value，中间是：号隔开，如果是不同的object，则它们之间用逗号隔开。<code>如，Var user = {name:hujie , age:21}，获取某个值的方式为user.name</code>；</li></ul></li><li>另一种是Array(即常说的JSON数组)。<ul><li>JSON数组：标准的格式为“[]”。<code>如，[value1, value2 ,value3...]</code>。</li></ul></li></ul></li><li><p>Java对象与JSON的转换：</p><ul><li>Bean和Map都转换为JSON对象。<code>如，Var user = {name:hujie , age:21}</code>；</li><li>List转换为JSON数组。<code>如，[value1, value2 ,value3...]</code>；</li></ul></li><li><p>在Spring MVC中使用JSON；</p><pre><code class="hljs java"><span class="hljs-comment">//首先，导入Jackson的JAR包或者依赖</span>&lt;!--对json的支持--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.9.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;    &lt;version&gt;2.9.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;    &lt;version&gt;2.9.9&lt;/version&gt;&lt;/dependency&gt;<span class="hljs-comment">//-----------------------------------------------------</span><span class="hljs-comment">//其次，配置SpringMVC对Jackson的支持，在web.xml中配置一个标签就行</span>&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;<span class="hljs-comment">//-----------------------------------------------------</span>三、使用<span class="hljs-meta">@ResponseBody</span>注解<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/getuser"</span>)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserById</span><span class="hljs-params">()</span></span>&#123;    User user = <span class="hljs-keyword">new</span> User();    <span class="hljs-keyword">return</span> user;&#125;说明：<span class="hljs-meta">@responseBody</span>注解的作用是将Controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据；但要注意，在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据</code></pre></li></ul></li></ul><ul><li><p>文件下载：</p><ul><li><p>了解：Http请求或响应报文其实都是字符串，当请求报文到Java程序会被封装为一个ServletInputStream流，开发人员再读取报文，响应报文则通过ServletOutputStream流，来输出响应报文；从流中只能读取到原始的字符串报文，同样输出流也是；那么在报文到达Spring MVC/SpringBoot和从Spring MVC/SpringBoot出去，都存在一个字符串到Java对象的转化问题；这一过程，在Spring MVC/SpringBoot中，是通过HttpMessageConverter来解决的；</p><p><img src="./Image-ssm12.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>Spring MVC实现文件下载的两种方式；</p><ul><li><p>基于ResponseEntity实现；</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/testHttpMessageDown"</span>)<span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-keyword">byte</span>[]&gt; download(HttpServletRequest request) <span class="hljs-keyword">throws</span> IOException &#123;    File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"E://123.jpg"</span>);    InputStream is = <span class="hljs-keyword">new</span> FileInputStream(file);    <span class="hljs-comment">//创建一个字节数组</span>    <span class="hljs-keyword">byte</span>[] body = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">//获取所读取的文件所有的字节个数</span>    body = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[is.available()];    is.read(body);    <span class="hljs-comment">//设置响应头信息</span>    HttpHeaders headers = <span class="hljs-keyword">new</span> HttpHeaders();    <span class="hljs-comment">//attchement是必须要设置的，告诉浏览器以附件的形式打开，也就是下载啦</span>    headers.add(<span class="hljs-string">"Content-Disposition"</span>, <span class="hljs-string">"attchement;filename="</span> + file.getName());    HttpStatus statusCode = HttpStatus.OK;    ResponseEntity&lt;<span class="hljs-keyword">byte</span>[]&gt; entity = <span class="hljs-keyword">new</span> ResponseEntity&lt;<span class="hljs-keyword">byte</span>[]&gt;(body, headers, statusCode);    <span class="hljs-keyword">return</span> entity;&#125;</code></pre></li><li><p>Java通用下载实现(推荐使用这个)；</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">download</span><span class="hljs-params">(String fileName, String filePath, HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">//声明本次下载状态的记录对象</span>    DownloadRecord downloadRecord = <span class="hljs-keyword">new</span> DownloadRecord(fileName, filePath, request);    <span class="hljs-comment">//设置响应头和客户端保存文件名</span>    response.setCharacterEncoding(<span class="hljs-string">"utf-8"</span>);    response.setContentType(<span class="hljs-string">"multipart/form-data"</span>);    response.setHeader(<span class="hljs-string">"Content-Disposition"</span>, <span class="hljs-string">"attachment;fileName="</span> + fileName);    <span class="hljs-comment">//用于记录已完成的下载的数据量，单位是byte</span>    <span class="hljs-keyword">long</span> downloadedLength = <span class="hljs-number">0l</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//打开本地文件流</span>        InputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(filePath);        <span class="hljs-comment">//根据reponse对象获得一个输出流，激活下载操作</span>        OutputStream os = response.getOutputStream();        <span class="hljs-comment">//循环写入输出流</span>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2048</span>];        <span class="hljs-keyword">int</span> length;        <span class="hljs-keyword">while</span> ((length = inputStream.read(b)) &gt; <span class="hljs-number">0</span>) &#123;            os.write(b, <span class="hljs-number">0</span>, length);            downloadedLength += b.length;        &#125;        <span class="hljs-comment">// 这里主要关闭。</span>        os.close();        inputStream.close();    &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;        downloadRecord.setStatus(DownloadRecord.STATUS_ERROR);        <span class="hljs-keyword">throw</span> e;    &#125;    downloadRecord.setStatus(DownloadRecord.STATUS_SUCCESS);    downloadRecord.setEndTime(<span class="hljs-keyword">new</span> Timestamp(System.currentTimeMillis()));    downloadRecord.setLength(downloadedLength);    <span class="hljs-comment">//存储记录</span>&#125;</code></pre></li></ul></li><li><p>Spring MVC实现文件上传的方式；</p> <pre><code class="hljs java"><span class="hljs-comment">//一、导入依赖或JAR包，即commons-fileupload和commons-io，但是commons-io可以不用自己导入，maven会自动导入对应版本的JAR</span>&lt;dependency&gt;     &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;     &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;     &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt;<span class="hljs-comment">//---------------------------------------------------</span><span class="hljs-comment">//二、input的type设置为file、form表单的method设为post、form表单的enctype设置为multipart/form-data(意思是以二进制的形式传输数据)</span>&lt;%@ page language=<span class="hljs-string">"java"</span> contentType=<span class="hljs-string">"text/html; charset=UTF-8"</span>      pageEncoding=<span class="hljs-string">"UTF-8"</span>%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;  &lt;meta charset=<span class="hljs-string">"ISO-8859-1"</span>&gt;  &lt;title&gt;Insert title here&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;      &lt;form action=<span class="hljs-string">"/ssm/file/imgUpload"</span> enctype=<span class="hljs-string">"multipart/form-data"</span> method=<span class="hljs-string">"post"</span>&gt;          图片<span class="hljs-number">1</span>：&lt;input type=<span class="hljs-string">"file"</span> name=<span class="hljs-string">"file"</span>&gt;          &lt;!--如果有批量上传图片：name属性必须一致          图片<span class="hljs-number">2</span>：&lt;input type=<span class="hljs-string">"file"</span> name=<span class="hljs-string">"file"</span>&gt;          图片<span class="hljs-number">3</span>：&lt;input type=<span class="hljs-string">"file"</span> name=<span class="hljs-string">"file"</span>&gt; --&gt;          &lt;input type=<span class="hljs-string">"submit"</span> value=<span class="hljs-string">"上传"</span>&gt;      &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;<span class="hljs-comment">//---------------------------------------------------</span><span class="hljs-comment">//三、Springmvc.xml配置CommonsMultipartResolver，该解析器的作用是将用户上传的file文件转换成MultipartFile</span>&lt;bean id=<span class="hljs-string">"multipartResolver"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;    &lt;!--上传文件的最大大小，单位为字节 --&gt;    &lt;property name="maxUploadSize" value="17367648787"&gt;&lt;/property&gt;         &lt;!-- 上传文件的编码 --&gt;    &lt;property name="defaultEncoding" value="UTF-8"&gt;&lt;/property&gt;&lt;/bean&gt;<span class="hljs-comment">//---------------------------------------------------</span><span class="hljs-comment">//四、使用MultipartFile对象作为参数，接收前端发送过来的文件，将文件写入本地文件中，就完成了上传操作</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/upload"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upload</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"file"</span>)</span> MultipartFile file, HttpServletRequest req) <span class="hljs-keyword">throws</span> IllegalStateException, IOException </span>&#123;  <span class="hljs-comment">//接收批量图片，把MultipartFile改成MultipartFile[]就行，然后遍历MultipartFile数组，逐个复制就行了</span>    <span class="hljs-comment">// 判断文件是否为空，空则返回失败页面</span>    <span class="hljs-keyword">if</span> (file.isEmpty()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"failed"</span>;    &#125;    <span class="hljs-comment">// 获取文件存储路径（绝对路径）</span>    String path = req.getServletContext().getRealPath(<span class="hljs-string">"/WEB-INF/file"</span>);    <span class="hljs-comment">// 获取原文件名</span>    String fileName = file.getOriginalFilename();    <span class="hljs-comment">// 创建文件实例</span>    File filePath = <span class="hljs-keyword">new</span> File(path, fileName);    <span class="hljs-comment">// 如果文件目录不存在，创建目录</span>    <span class="hljs-keyword">if</span> (!filePath.getParentFile().exists()) &#123;        filePath.getParentFile().mkdirs();        System.out.println(<span class="hljs-string">"创建目录"</span> + filePath);    &#125;    <span class="hljs-comment">// 写入文件</span>    file.transferTo(filePath);    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>Spring MVC是单例模式的原因；</p><ul><li><p>原因：Spring MVC默认是单例的，不需要每次请求都要创建对象，因为都是通过Spring管理的，直接通过注入的方式获取对象；Spring MVC变成(Controller)多例的解决方案：</p><ul><li><p>通过注解<code>@Scope(“prototype”)</code>，将其设置为多例模式(但是这样效率不高，不建议这样做)；</p><ul><li><p>影响：对于多例情况普通属性是不会共用的，不会产生影响，对于静态属性会去共用这个属性；对于单例情况普通属性和静态属性都会被共用；</p><pre><code class="hljs java"><span class="hljs-comment">//Controller多例模式</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/test"</span>)<span class="hljs-meta">@Scope</span>(value=<span class="hljs-string">"prototype"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-title">UserController</span><span class="hljs-params">(）&#123;</span></span><span class="hljs-function"><span class="hljs-params"></span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;</span></span><span class="hljs-function"><span class="hljs-params"></span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> staticIndex = <span class="hljs-number">0</span>;</span></span><span class="hljs-function"><span class="hljs-params"></span></span><span class="hljs-function"><span class="hljs-params">    System.out.println(<span class="hljs-string">"普通属性："</span>+(index++)</span>+"--------分割线--------"+"静态属性："+<span class="hljs-params">(staticIndex++)</span>)</span>;    <span class="hljs-comment">//输出结果为</span>    <span class="hljs-comment">//普通属性：0--------分割线--------静态属性：0</span>    <span class="hljs-comment">//普通属性：0--------分割线--------静态属性：1</span>    <span class="hljs-comment">//普通属性：0--------分割线--------静态属性：2</span>    <span class="hljs-comment">//普通属性：0--------分割线--------静态属性：3</span>&#125;<span class="hljs-comment">//-----------------------------------------------------------------</span><span class="hljs-comment">//Controller单例模式</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/test"</span>)<span class="hljs-meta">@Scope</span>(value=<span class="hljs-string">""</span>singleton)<span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-title">UserController</span><span class="hljs-params">(）&#123;</span></span><span class="hljs-function"><span class="hljs-params"></span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;</span></span><span class="hljs-function"><span class="hljs-params"></span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> staticIndex = <span class="hljs-number">0</span>;</span></span><span class="hljs-function"><span class="hljs-params"></span></span><span class="hljs-function"><span class="hljs-params">    System.out.println(<span class="hljs-string">"普通属性："</span>+(index++)</span>+"--------分割线--------"+"静态属性："+<span class="hljs-params">(staticIndex++)</span>)</span>;    <span class="hljs-comment">//输出结果为</span>    <span class="hljs-comment">//普通属性：0--------分割线--------静态属性：0</span>    <span class="hljs-comment">//普通属性：1--------分割线--------静态属性：1</span>    <span class="hljs-comment">//普通属性：2--------分割线--------静态属性：2</span>    <span class="hljs-comment">//普通属性：3--------分割线--------静态属性：3</span>&#125;说明：尽量不要在Controller里面去定义属性，如果在特殊情况需要定义属性的时候，那么就在类上面加上注解<span class="hljs-meta">@Scope</span>(<span class="hljs-string">"prototype"</span>)改为多例的模式，但是不建议这么做，因为，一旦Controller中定义了许多属性，那么单例访问就会出现安全问题，所以在Controller中定义了属性，就添加<span class="hljs-meta">@Scope</span>(<span class="hljs-string">"prototype"</span>)注解，使得Controller变成多例</code></pre></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>Spring MVC的自定义拦截器的使用和理解；</p><ul><li><p>Spring MVC的拦截器主要作用也是在服务端真正处理请求前后进行一些相关的操作。<code>如，初始化资源，权限监控，会话设置，菜单获取，资源清理等</code>；</p><ul><li><p>自定义拦截器一般继承自HandlerInterceptorAdapter或者实现HandlerInterceptor接口。</p><ul><li><p>实现接口需要实现对应的3个方法，也就是preHandle，postHandle，afterCompletion这三个方法，所以我们首先需要编写一个普通类实现上面提到的拦截器接口或者继承拦截器类即可。</p></li><li><p>继承父类只需要实现需要的方法即可。</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.dyf.interceptor<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HandlerInterceptorAdapter</span> </span>&#123;     <span class="hljs-comment">//preHandle方法是进行处理器拦截用的，顾名思义，该方法将在Controller处理之前进行调用，SpringMVC中的Interceptor拦截器是链式的，可以同时存在多个Interceptor，然后SpringMVC会根据声明的前后顺序一个接一个的执行，而且所有的Interceptor中的preHandle方法都会在Controller方法调用之前调用；SpringMVC的这种Interceptor链式结构也是可以进行中断的，这种中断方式是令preHandle的返回值为false，当preHandle的返回值为false的时候整个请求就结束了；这种方式，如果返回false，一般情况需要重定向或者转发到其他页面，采用request的转发或者response的重定向即可</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;&#125;     <span class="hljs-comment">//这个方法只会在当前这个Interceptor的preHandle方法返回值为true的时候才会执行；postHandle是进行处理器拦截用的，它的执行时间是在处理器进行处理之后，也就是在Controller的方法调用之后执行，但是它会在DispatcherServlet进行视图的渲染之前执行，也就是说在这个方法中你可以对ModelAndView进行操作；这个方法的链式结构跟正常访问的方向是相反的，也就是说先声明的Interceptor拦截器该方法反而会后调用，这跟Struts2里面的拦截器的执行过程有点像，只是Struts2里面的intercept方法中要手动的调用ActionInvocation的invoke方法，Struts2中调用ActionInvocation的invoke方法就是调用下一个Interceptor或者是调用action，然后要在Interceptor之前调用的内容都写在调用invoke之前，要在Interceptor之后调用的内容都写在调用invoke方法之后</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;&#125;    <span class="hljs-comment">//该方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行；该方法将在整个请求完成之后，也就是DispatcherServlet渲染了视图执行， 这个方法的主要作用是用于清理资源的</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;&#125;&#125;说明：HandlerInterceptor接口的方法(或者说继承自HandlerInterceptorAdapter类需要重写的三个方法)一、preHandle：在handler方法之前被调用；<span class="hljs-number">1</span>.返回值为<span class="hljs-keyword">true</span>：继续调用后续的其他拦截器和目标方法<span class="hljs-number">2</span>.返回值为<span class="hljs-keyword">false</span>：不继续调用后续的其他拦截器和目标方法<span class="hljs-number">3</span>.使用场景：权限检查、日志、事务。二、postHandle：调用handler方法之后，渲染视图之前被调用；<span class="hljs-number">1</span>.使用场景：修改请求域属性,修改视图三、afterCompletion：渲染视图之后被调用；<span class="hljs-number">1</span>.使用场景：释放资源</code></pre></li></ul></li><li><p>在SpringMVC的配置文件中配置自定义好的拦截器后，并声明和添加过滤规则。</p><pre><code class="hljs java">&lt;mvc:interceptors&gt;    &lt;!-- 这种方式表示默认拦截所有请求 --&gt;    &lt;bean id=<span class="hljs-string">"xxx"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"cn.dyf.interceptor.MyInterceptor"</span>/&gt;    &lt;!--这种方式也是默认拦截所有请求，但是要求拦截器类上必须要有<span class="hljs-meta">@Component</span>注解，该注解的作用是告诉Spring这是一个普通的组件类，帮我生成对应的bean对象即可，id默认是类名首字母小写。如，MyInterceptor拦截器类的默认生成的bean的id为myInterceptor--&gt;    &lt;ref bean=<span class="hljs-string">"myInterceptor"</span>&gt;    &lt;!--设置自定义要拦截的方式--&gt;    &lt;mvc:interceptor&gt;        &lt;!--对特定的请求进行拦截--&gt;        &lt;mvc:mapping path=<span class="hljs-string">"/**"</span> /&gt;        &lt;!-- 排除拦截的链接 --&gt;        &lt;mvc:exclude-mapping path=<span class="hljs-string">"/static/**"</span> /&gt;        &lt;bean <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"要使用的某个指定的拦截器"</span> /&gt;    &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;</code></pre></li></ul></li><li><p>多个拦截器的执行流程图；</p><p><img src="./Image-ssm13.png" srcset="/img/loading.gif" alt="Image"></p><pre><code class="hljs java">说明：拦截器<span class="hljs-number">1</span>的preHandle方法执行，不符合请求规则的返回<span class="hljs-keyword">false</span>，不走后台去处理，否则就返回<span class="hljs-keyword">true</span>；拦截器<span class="hljs-number">2</span>的preHandle方法执行，不符合请求规则的返回<span class="hljs-keyword">false</span>，不走后台去处理，否则就返回<span class="hljs-keyword">true</span>；拦截器<span class="hljs-number">2</span>的preHandle方法为<span class="hljs-keyword">true</span>后，交给后台处理请求，得到响应的数据(此时还没有渲染视图)，调用拦截器<span class="hljs-number">2</span>的postHandle方法；拦截器<span class="hljs-number">2</span>的postHandle方法调用完毕，再调用拦截器<span class="hljs-number">1</span>的postHandle方法；调用拦截器<span class="hljs-number">2</span>的afterCompletion方法，最后调用拦截器<span class="hljs-number">1</span>的afterCompletion方法，返回用户想要的响应；</code></pre></li><li><p>过滤器和拦截器的区别以及各自的执行顺序；</p><p><img src="./Image-ssm14.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-ssm15.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-ssm16.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>Spring MVC对异常的处理方式：</p><ul><li><p>第一种是使用HandlerExceptionResolver接口，并且Spring已经提供默认的实现类SimpleMappingExceptionResolver；我们一般在项目中使用第一种方式；</p><pre><code class="hljs java"><span class="hljs-comment">//使用这种方式只需要实现resolveException方法，该方法返回一个ModelAndView对象，在方法内部对异常的类型进行判断，然后返回合适的ModelAndView对象，如果该方法返回了null，则Spring会继续寻找其他的实现了HandlerExceptionResolver接口的Bean；换句话说，Spring会搜索所有注册在其环境中的实现了HandlerExceptionResolver接口的Bean，逐个执行，直到返回了一个ModelAndView对象；</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">xxxExceptionHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerExceptionResolver</span> </span>&#123;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object object, Exception exception)</span> </span>&#123;          <span class="hljs-keyword">if</span>(exception <span class="hljs-keyword">instanceof</span> IOException)&#123;              <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">"ioexp"</span>);          &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(exception <span class="hljs-keyword">instanceof</span> SQLException)&#123;              <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">"sqlexp"</span>);          &#125;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      &#125;  &#125;<span class="hljs-comment">//------------------------------------------------------------------------</span><span class="hljs-comment">//这个类必须声明到Spring配置文件中，或者使用@Component标签，让Spring管理它；同时Spring也提供默认的实现类SimpleMappingExceptionResolver，需要使用时只需要使用注入到Spring配置文件进行声明即可；自定义实现类与默认的实现类，可同时使用</span>&lt;!-- 自定义的异常实现类注入 --&gt;&lt;bean id=<span class="hljs-string">"exceptionHandler"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"cn.dyf.exception.xxExceptionHandler"</span>/&gt;&lt;!-- 默认的异常实现类注入 --&gt;&lt;bean <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"</span>&gt;      &lt;!-- 为所有的异常定义默认的异常处理页面，exceptionMappings未定义的异常使用本默认配置 --&gt;      &lt;property name="defaultErrorView" value="error"&gt;&lt;/property&gt;      &lt;!-- 定义异常处理页面用来获取异常信息的变量名，也就是你要获取异常信息的时候，需要一个变量名来获取，而这个默认的变量名为exception，也可以自定义 --&gt;      &lt;property name="exceptionAttribute" value="ex"&gt;&lt;/property&gt;      &lt;!--　　　　定义需要特殊处理的异常，用类名或完全路径名作为key，异常页文件名作为值，　　　　将不同的异常映射到不同的页面上。　　 --&gt;      &lt;property name=<span class="hljs-string">"exceptionMappings"</span>&gt;          &lt;props&gt;              &lt;prop key="IOException"&gt;error/ioexp&lt;/prop&gt;              &lt;prop key="java.sql.SQLException"&gt;error/sqlexp&lt;/prop&gt;          &lt;/props&gt;      &lt;/property&gt;  &lt;/bean&gt;</code></pre></li><li><p>另一种使用@ExceptionHandler注解实现异常处理，需每一个controller都继承自该类，但对于代码的侵入性大，一般不用。</p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson4-SSM整合"><a href="#Lesson4-SSM整合" class="headerlink" title="Lesson4 SSM整合"></a>Lesson4 SSM整合</h2><h3 id="NO4-1-SSM基本代码整合"><a href="#NO4-1-SSM基本代码整合" class="headerlink" title="NO4.1 SSM基本代码整合"></a>NO4.1 SSM基本代码整合</h3><p>整合SSM框架是必备的知识。</p><ul><li><p>SSM框架整合：</p><ul><li><p>首先创建项目；</p></li><li><p>导入SSM整合的JAR包；</p></li><li><p>在src下创建com.dyf.mapper(即原Dao)、com.dyf.service(即原Service)、com.dyf.controller(即原Web)的包结构；</p></li><li><p>在项目下创建Source Folder专门放置配置文件，即：MyBatis的核心配置文件sqlMapConfig.xml和applicationContext-dao.xml(这是整合spring后，分层)、Spring的核心配置文件applicationContext-service.xml、Spring MVC的Spring MVC.xml、日志信息log4j.properties、阿里巴巴德鲁伊连接池配置文件druid.properties；</p></li><li><p>在Spring整合MyBatis的核心配置文件applicationContext-dao.xml中，管理MyBatis的一些数据；</p><ul><li><p>加载数据库配置；</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 1.加载数据库的druid.properties配置文件，四要素：驱动、请求资源、数据库账号、数据库密码 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:druid.properties"</span> /&gt;</span><span class="hljs-comment">&lt;!-- 1.1配置阿里巴巴的druid连接池 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.alibaba.druid.pool.DruidDataSource"</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">"close"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClassName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;driverClassName&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;url&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;usernames&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;password&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></li><li><p>配置sqlSessionFactory和mapper代理开发；</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 2.这是配置sqlSessionFactory和mapper代理开发 --&gt;</span><span class="hljs-comment">&lt;!-- 2.1.1.配置spring管理sqlSessionFactory --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sqlSessionFactory"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 2.1.2.让spring管理sqlSessionFactory，就需要数据库连接池 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!-- 2.2.1.这是配置mapper代理形式 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"basePackage"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"dyf.mapper"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></li><li><p>在Spring的核心配置文件applicationContext-service.xml中配置；</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 1.只需要配置Service的IOC注解开发的扫描器即可 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"com.dyf.service"</span> /&gt;</span><span class="hljs-comment">&lt;!-- 2.配置事务平台管理器 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"transactionManager"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!-- 开启注解事务 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span> /&gt;</span><span class="hljs-comment">&lt;!--上面和下面二选一，即注解事务，和XML事务二选一--&gt;</span><span class="hljs-comment">&lt;!-- 配置事务的属性 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txAdvice"</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 配置事务的传播行为 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"save*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"insert*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"add*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"create*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"delete*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"update*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"find*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"SUPPORTS"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"true"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"select*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"SUPPORTS"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"true"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"get*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"SUPPORTS"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"true"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><span class="hljs-comment">&lt;!-- 配置事务的切入点，以及把事务与切入点关联起来 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">"txAdvice"</span> <span class="hljs-attr">pointcut</span>=<span class="hljs-string">"execution(* dyf.*.*(..))"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre></li><li><p>在Spring MVC的Spring MVC.xml中：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 1.配置SpringMVC的Controller注解扫描 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"dyf.controller"</span> /&gt;</span><span class="hljs-comment">&lt;!-- 2.配置使用最新的处理器映射器、处理器适配器 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> /&gt;</span><span class="hljs-comment">&lt;!-- 3.配置视图处理器：jsp --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jspViewResolver"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 3.1配置输入资源地址时：直接输入/页面 ，即可 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/WEB-INF/jsp/"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".jsp"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></li><li><p>最后，在web.xml中，配置Spring MVC的前端控制器DispatcherServlet以及监听器(为了在加载Spring工厂时，只生产一个工厂，并将工厂放入servletContext，后面直接获取即可)；</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 1.配置SpringMVC的前端控制器DispatcherServlet --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>SpringMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>    <span class="hljs-comment">&lt;!--1.1这是修改初始化默认加载配置文件的位置，原本默认加载/WEB-INF/XXX-servlet.xml位置的配置文件，修改成如下 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>SpringMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.action<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-comment">&lt;!-- 2.配置监听器，加载Spring工厂，是为了只生产一个工厂，并将工厂放入servletContext --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><span class="hljs-comment">&lt;!-- 2.1指定加载的Spring配置文件 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext-*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span></code></pre></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>1.대학교 일 학년</category>
      
      <category>03.Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大一课程</tag>
      
      <tag>SSM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01.前端基础--学习笔记</title>
    <link href="/2020/07/03/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/03/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="前端基础–学习笔记-包含前端视频"><a href="#前端基础–学习笔记-包含前端视频" class="headerlink" title="前端基础–学习笔记(包含前端视频)"></a>前端基础–学习笔记(包含前端视频)</h1><h2 id="Lesson1-前端基础"><a href="#Lesson1-前端基础" class="headerlink" title="Lesson1 前端基础"></a>Lesson1 前端基础</h2><h3 id="NO1-1-HTML"><a href="#NO1-1-HTML" class="headerlink" title="NO1.1 HTML"></a>NO1.1 HTML</h3><p>HTML说白了，就是我们常见的网页，这一个个网页就是由HTML语言书写构成。</p><ul><li>HTML<ul><li>定义：是指超文本标记语言。超文本是指页面内可以包含图片、链接等非文字元素，HTML用于编写网页，且HTML文件的格式后缀都以.html或者.htm结尾；</li><li>组成：HTML文件只有一个根标签<code>&lt;html&gt;&lt;/html&gt;</code>，其下由头标签<code>&lt;head&gt;&lt;/head&gt;</code>和体标签<code>&lt;body&gt;&lt;/body&gt;</code>两部分组成；</li><li>基本语法格式：<ul><li>HTML标签的书写格式：<code>属性名=&quot;属性值&quot;</code>。</li></ul></li><li>常用标签：<ul><li><code>&lt;title&gt;xxx&lt;/title&gt;</code>：HTML网页的页面标题标签，即打开HTML页面后，你所看到的网页的标题，一个HTML只能有一个该标签；</li><li><code>&lt;hn&gt;&lt;/hn&gt;</code>：普通标题标签，n取值：1到6，字体逐渐变小，且自动换行；</li><li><code>&lt;hr /&gt;</code>：水平线标签，即在HTML页面中创建一条水平分割线；<ul><li><code>size属性</code>：水平线的大小，单位是像素px；</li><li><code>noshade属性</code>：没有阴影效果，取值：noshade，表示显示纯色，不设置该属性，则显示一个阴影；</li></ul></li><li><code>&lt;font&gt;&lt;/font&gt;</code>：字体标签；<ul><li><code>color属性</code>：设置字体颜色；</li><li><code>size属性</code>：设置字体大小，值越大，字体越大，取值1到7；</li></ul></li><li><code>&lt;b&gt;&lt;/b&gt;</code>：粗体标签；即字体变粗；</li><li><code>&lt;i&gt;&lt;/i&gt;</code>：斜体标签；即字体倾斜；</li><li><code>&lt;p&gt;&lt;/p&gt;</code>：段落标签，前后换行隔开；</li><li><code>&lt;br&gt;&lt;/br&gt;</code>：换行标签；即插入单个换行；</li><li><code>&lt;img /&gt;</code>：图片标签；<ul><li><code>src属性</code>：即图片的加载路径；</li><li><code>width属性</code>：图片宽度像素值或百分比；</li><li><code>height属性</code>：图片高度像素值或百分比；</li><li><code>alt属性</code>：图片提示信息，即当图片加载不出来，放在图片旁边的说明；</li><li><code>title属性</code>：当鼠标放到照片上，会显示出来的信息；</li></ul></li><li><code>&lt;ul&gt;&lt;/ul&gt;</code>：无序列表标签；必须和<li></li>配合使用才有意义；<ul><li><code>type属性</code>：用于设置列表前面的标志，即实心小圆圈(disc)，空心小圆圈(circle)，正方形小圆圈(square)；</li></ul></li><li><code>&lt;ol&gt;&lt;/ol&gt;</code>：有序列表标签；必须和<li></li>配合使用才有意义；<ul><li><code>start属性</code>：表示从哪个顺序开始，如start=4，则从4开始，如start=5，从5开始；</li><li><code>reversed属性</code>：倒序标记，即从start设置的数字，倒着标记，例如4321标记；</li><li><code>type属性</code>：设置顺序的数字，1，a，A等等，按着顺序标记；</li></ul></li><li><code>&lt;a&gt;&lt;/a&gt;</code>：超链接标签；<ul><li><code>href属性</code>：表示要跳转的地址；</li><li><code>target属性</code>：跳转到新地址时，根据取值决定是否打开一个新的页面；</li></ul></li><li><code>&lt;table&gt;&lt;/table&gt;</code>：表格标签，必须和行标签<code>&lt;tr&gt;&lt;/tr&gt;</code>、列标签<code>&lt;td&gt;&lt;/td&gt;</code>配合使用，还可以配合一种单元格，即<code>&lt;th&gt;&lt;/th&gt;</code>使用，这个标签叫做表头标签；<ul><li><code>border属性</code>：设置表格边框的像素，即边框的粗细；</li><li><code>width属性</code>：表格宽度，单位为像素值或百分比；</li><li><code>height属性</code>：表格高度，单位为像素值或百分比；</li><li><code>align属性</code>：设置表格位置，即居中，靠左，靠右；</li><li><code>bgcolor属性</code>：设置表格颜色；</li><li><code>cellspacing属性</code>：设置表格中每个单元格之间的距离，单位为像素px；</li><li><code>cellpadding属性</code>：设置表格中每个单元格与其内容之间的距离，单位为像素px；</li></ul></li><li><code>&lt;tr&gt;&lt;/tr&gt;</code>：行标签；<ul><li><code>rowspan属性</code>：跨行合并，rowspan”2”，合并2个单元格，再将对应的被合并的单元格删除即可；</li><li><code>align属性</code>：设置单元格里的内容位置，即居中，靠左，靠右；</li></ul></li><li><code>&lt;td&gt;&lt;/td&gt;</code>：列标签；<ul><li><code>colspan属性</code>：跨列合并，colspan=”2”，合并2个单元格，再将对应的被合并的单元格删除即可；</li><li><code>align属性</code>：设置单元格里的内容位置，即居中，靠左，靠右；    </li></ul></li><li><code>&lt;th&gt;&lt;/th&gt;</code>：表头标签，内容默认加粗，居中；</li><li><code>&lt;form&gt;&lt;/form&gt;</code>：表单标签，主要用来收集用户数据，所有需要提交到服务器端的表单项必须用表单标签括起来；<ul><li><code>action属性</code>：整个表单提交的位置，即将表单提交给某处；</li><li><code>method属性</code>：表单提交的方式(方式有7种，常见的是get，post)；</li><li>form表单标签中常用的子标签：<ul><li><code>&lt;input /&gt;</code>：输入框，一般用于用户输入数据；<ul><li><code>type属性(10种取值，9种值常用)</code>：<ul><li><code>text</code>：文本输入框，value设置默认值；</li><li><code>password</code>：密码输入框，以*号代替文本，value设置默认值；</li><li><code>radio</code>：单选框，checked设置默认值；</li><li><code>checkbox</code>：复选框，checked设置默认值；</li><li><code>button</code>：普通按钮；</li><li><code>reset</code>：重置按钮，清空表单；</li><li><code>submit</code>：提交按钮，提交表单数据给服务端；</li><li><code>image</code>：图片按钮，按钮是一张图片(不常用)；</li><li><code>hidden</code>：隐藏域，数据会提交，但是页面上看不到；</li><li><code>file</code>：文件上传；</li></ul></li><li><code>name属性</code>：<ul><li>用于给标签起名字；</li><li>还可以给单选框或者复选框分组(这两个必须要分组，name相同的为一组)；</li><li>最重要的是，表单提交时，有name属性的数据才会被提交；</li></ul></li><li><code>value属性</code>：<ul><li>给按钮类的属性值文字赋值，即按钮上显示文字；</li><li>用于表单提交时，单选框和复选框填写的内容被服务端准确的获取；</li><li>用于表单提交时，下拉框选择的内容被服务端准确的获取；</li></ul></li></ul></li></ul></li><li><code>&lt;select&gt;&lt;/select&gt;</code>：下拉框，一般用于用户选择某个选项；<ul><li><code>&lt;option&gt;&lt;/option&gt;</code>：下拉框的内容，即下拉框的子标签，两者需要配合使用才有意义；<ul><li><code>selected属性</code>：设置默认值；</li></ul></li></ul></li><li><code>&lt;textarea&gt;&lt;/textarea&gt;</code>：文本域，一般用于用户输入大量的文字信息，例如自我介绍；<ul><li><code>rows属性</code>：设置行数；</li><li><code>cols属性</code>：设置列数；</li></ul></li></ul></li><li><code>&lt;div&gt;&lt;/div&gt;</code>：div标签，是一个块级元素，特点是自动换行，常作为一个容器使用；</li><li><code>&lt;span&gt;&lt;/span&gt;</code>：span标签，是一个行内元素，特点是不换行；</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO-1-2-CSS"><a href="#NO-1-2-CSS" class="headerlink" title="NO.1.2 CSS"></a>NO.1.2 CSS</h3><p>CSS，你可以理解为静态渲染HTML页面。</p><ul><li><p>CSS：</p><ul><li><p>定义：是指层叠样式表，主要用于渲染HTML中的文本内容、图片、以及版面布局等外观显示样式；</p></li><li><p>基本语法格式：</p><pre><code class="hljs html">选择器&#123;属性名:属性值;属性名:属性值;&#125;</code></pre></li><li><p>在HTML中引入CSS代码：</p><ul><li><code>行内样式</code>：在标签的style属性中写CSS代码，此时只需要写： 属性名:属性值; 属性名:属性值; 即可，但是只对该标签有效；</li><li><code>内部样式</code>：在head标签的子标签style标签中写CSS代码，按照CSS正常格式写即可；</li><li><code>外部样式</code>：将CSS代码写在单独的文件中，后缀名以.css结尾，在head标签中通过link标签引入.css文件即可；</li></ul></li><li><p>选择器：用于选中某个或者某些标签，以便于我们给这些标签设置CSS样式；</p><ul><li><p>标签选择器：选择指定的标签；</p><pre><code class="hljs html">标签名&#123;属性名:属性值;&#125;</code></pre></li><li><p>id选择器：选择拥有指定id值的标签；(注意：该方式必须为标签添加一个id属性)</p><pre><code class="hljs html">#id值&#123;属性名:属性值;&#125;</code></pre></li><li><p>class选择器：选择拥有指定class值的标签；</p><pre><code class="hljs html">.class值&#123;属性名:属性值;&#125;</code></pre></li><li><p>属性选择器：即选择拥有指定属性的标签；</p><pre><code class="hljs html">标签名[属性名:属性值]&#123;属性名:属性值;&#125;</code></pre></li><li><p>后代选择器：即父标签包含后代标签；</p><pre><code class="hljs html">选择器1 选择器2&#123;属性名:属性值;&#125;</code></pre></li></ul></li><li><p>CSS中常见的属性名：</p><ul><li><code>border属性</code>：边框样式，有三个值，值之间用空格隔开；<code>如，border:1px solid red</code>；</li><li><code>width属性</code>：宽度；</li><li><code>height属性</code>：高度；</li><li><code>color属性</code>：内容的颜色；</li><li><code>font-size</code>：内容文字的大小</li><li><code>.background-color</code>：背景颜色；</li><li><code>display</code>：转换样式，即块级元素和行内元素的互相转换，以及隐藏所选标签元素；</li><li><code>float</code>：设置div浮动效果，默认向上飘后，向左飘，知道碰到其他标签；</li><li><code>clear</code>：清除元素两边的浮动效果，值只选择both；</li></ul></li><li><p>CSS盒子模型：CSS将每一个标签都认为是一个盒子，其拥有两个边距：</p><ul><li><code>内边距</code>：即元素和边框的距离，属性名padding，默认元素与边框是重合的，即padding=0px，内边距越大，边框越大；</li><li><code>外边距</code>：即边框和其他边框的距离，属性名margin。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO-1-3-JavaScript"><a href="#NO-1-3-JavaScript" class="headerlink" title="NO.1.3 JavaScript"></a>NO.1.3 JavaScript</h3><p>JS，你可以理解为动态渲染HTML页面。</p><ul><li><p>JavaScript(以下简称Js)：</p><ul><li><p>定义：是一种嵌入式脚本编程语言，用于开发交互式的web页面，使用JavaScript可以添加动画效果，提升用户操作体验；</p></li><li><p>应用：</p><ul><li>嵌入动态文本于HTML页面中；</li><li>对浏览器事件做出相应；</li><li>读写HTML元素；</li><li>验证提交数据；</li><li>检测访客的浏览器信息等；</li></ul></li><li><p>组成：</p><ul><li>ECMAScript：Js的核心语法；</li><li>BOM：浏览器对象；</li><li>DOM：操作文档中的元素和内容；</li></ul></li><li><p>引入方式：</p><ul><li><p>内嵌式：</p><ul><li><p>必须在<code>&lt;script&gt;&lt;/script&gt;</code>标签中写入Js代码；</p></li><li><p>格式为：</p><pre><code class="hljs js">&lt;script type=<span class="hljs-string">"text/javascript"</span>&gt;js代码&lt;<span class="hljs-regexp">/script&gt;</span></code></pre></li></ul></li><li><p>外联式：</p><ul><li><p>在后缀名为.js的文件中写入，但是要在<code>&lt;script&gt;&lt;/script&gt;</code>标签中引入外联的.js文件；</p></li><li><p>格式为：</p><pre><code class="hljs js">&lt;script type=<span class="hljs-string">"text/javascript"</span> src=<span class="hljs-string">"外联文件.js的路径"</span> charset=<span class="hljs-string">"UTF-8"</span>&gt;&lt;<span class="hljs-regexp">/script&gt;</span></code></pre></li></ul></li></ul></li><li><p>常用语法：</p><ul><li><p><code>var 变量名</code>：创建一个变量；<strong><code>注意：Js中变量如果没有赋值，默认undefined。</code></strong></p></li><li><p>数据类型：</p><ul><li>基本类型：<ul><li><code>Undefined</code>：只有一个值undefined，当定义的变量未被赋值时，默认值就是undefined；</li><li><code>Null</code>：只有一个值null，空值，但是在ECMAScript中，定义了undefined和null相等(从根本上还是不相等的)；</li><li><code>Boolean</code>：有两个值true和false；</li><li><code>Number</code>：表示任意数字，包括整数、小数等，都用Number表示；</li><li><code>String</code>：字符串用””或’’声明；Js中没有字符类型；</li></ul></li><li>引用类型：<ul><li>是一种叫做类(class)的东西，但我们一般不会自己创建对象，而是直接使用，Js<br>已经给我们准备好了，所以说Js是基于对象，而不是面向对象；</li></ul></li></ul></li><li><p>Js中用alert()方法直接弹出你想要输出的结果；</p></li><li><p>Js中的<code>==</code>和<code>===</code>的区别：</p><ul><li><p><code>==</code>：只比较数值；</p><p>例如：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a= <span class="hljs-string">"10"</span>;<span class="hljs-keyword">var</span> b= <span class="hljs-number">10</span>;alert(a==b);#弹出结果为true，因为a和b的的数值都是10，所以为true；</code></pre><p><code>===</code>：既比较数值，也比较类型，都相同才是全等。</p></li></ul></li><li><p>Js中参数类型转为Boolean值：</p><ul><li><code>Undefined</code>：转为Boolean结果为false；</li><li><code>Null</code>：转为Boolean结果为false；</li><li><code>Number</code>：如果参数为+0、-0、NaN(即不是一个数字)，转为Boolean结果为false；否则为true；</li><li><code>String</code>：如果参数为空字符串，则结果为false；否则为true；</li><li><code>Object</code>：对象类型都为true。</li></ul></li><li><p>Boolean类型参与运算：<code>false是0，true是1</code>；</p></li><li><p>Js中的函数(方法)的格式(<strong><code>注意：参数类型不需要写在方法中</code></strong>)：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params">参数列表</span>)</span>&#123;函数体；&#125;</code></pre></li><li><p>Js中没有方法重载，如果方法名相同，则后定义的方法会覆盖之前的方法；</p></li><li><p>获取指定标签对象和内容：</p><ul><li><code>var inputElement= document.getElementById()</code>：该方法可以获取一个标签对象，然后通过该对象inputElement.value;获取(表单)元素标签的内容；</li><li><code>getElementsByName()</code>：通过name属性值获得所有元素；</li><li><code>getElementsByClassName()</code>：通过class属性值获得所有元素；</li><li><code>getElementsByTagName()</code>：通过标签名获得所有元素。</li></ul></li><li><p>设置定时器：</p><ul><li><code>window.setInterval(code,millisec)</code>，其中：<ul><li>code：可以是Js代码，也可以是一个函数；</li><li>millisec：时间间隔，单位是毫秒；即，每隔millisec毫秒会执行code一次。</li></ul></li><li><code>window.setTimeout(code,millisec)</code>，其中：<ul><li>code：可以是Js代码，也可以是一个函数；</li><li>millisec：时间间隔，单位是毫秒；即，millisec毫秒后只执行code一次。</li></ul></li></ul></li><li><p>页面加载事件：即window.onload事件，当页面加载完毕之后才会触发后面的函数；基本语法格式：</p><pre><code class="hljs js">#方式一:<span class="hljs-built_in">window</span>.onload = 函数名<span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> 函数名1(<span class="hljs-params"></span>)</span>&#123;函数体；&#125;#方式二：<span class="hljs-built_in">window</span>.load = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;函数体；&#125;</code></pre></li><li><p>修改标签的样式属性值：<code>标签对象.style.属性 = 值</code>；</p></li><li><p>获取HTML中非表单元素标签的内容：</p><ul><li>标签对象.innerHTML：获取标签的所有内容，包括HTML标签，即会解析其中HTML代码；</li><li>标签对象.innerText：获取标签的所有内容，不包括HTML标签，即不会解析其中HTML代码；</li></ul></li><li><p>事件：</p><ul><li><code>onsubmit</code>：提交按钮事件，提交按钮点击后，触发表单提交事件；</li><li><code>onfocus</code>：获取焦点事件，即鼠标选中，就是焦点获取；</li><li><code>onblur</code>：失去焦点时间，即鼠标未选中，就是焦点失去；</li><li><code>onmousevoer</code>：鼠标移入事件，即鼠标移入时的事件；</li><li><code>onmouseout</code>：鼠标移出事件，即鼠标移出的事件；</li></ul></li><li><p>Js中的this关键字：表示的是当前元素，即谁调用，就代表谁；</p></li><li><p>Js中创建数组(这里的Array与Java中的集合类似，长度可变，可存任意类型)：<code>new Array(元素1,元素2,元素3....)</code>；</p></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO-1-4-JQuery"><a href="#NO-1-4-JQuery" class="headerlink" title="NO.1.4 JQuery"></a>NO.1.4 JQuery</h3><p>JQuery的存在极大地简化了JavaScript 编程。</p><ul><li><p>JQuery</p><ul><li><p>定义：是一套跨浏览器的Js库；可以简化HTML和Js之间的操作；</p></li><li><p>导入方式：使用外联式方法导入对应的“.js“后缀文件即可；</p></li><li><p>JQuery语法：</p><ul><li><p>基本语法格式：<code>JQuery()或者$()</code>；</p></li><li><p>获取值：<code>var v = $(&quot;选择器&quot;)</code>，获取JQuery对象;  v.val()，即可获取对应表单标签的值；</p></li><li><p>页面加载事件：<code>$(function(){函数体})</code>；</p></li><li><p>事件绑定：</p><pre><code class="hljs js">获取JQuery对象JQuery对象.事件方法(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;函数体&#125;)</code></pre></li></ul></li><li><p>JQuery效果：</p><ul><li>显示和隐藏：<ul><li><code>show(毫秒值)</code>；</li><li><code>hide(毫秒值)</code>；</li><li><code>taggle(毫秒值)</code>：这个是切换，即显示和隐藏相互切换；毫秒值是指，在指定毫秒值内，显示或隐藏；</li></ul></li><li>滑入和滑出：<ul><li><code>slideDown(毫秒值)</code>；</li><li><code>slideUp(毫秒值)</code>；</li><li><code>slideToggle(毫秒值)</code>：这个是切换，即滑入和滑出相互切换；毫秒值是指，在指定毫秒值内，滑入或滑出；</li></ul></li><li>淡入和淡出：<ul><li><code>fadeIn(毫秒值)</code>；</li><li><code>fadeOut(毫秒值)</code>；</li><li><code>fadeToggle(毫秒值)</code>： 这个是切换，即淡入和淡出相互切换；毫秒值是指，在指定毫秒值内，淡入或淡出；</li></ul></li></ul></li><li><p>JQuery选择器：</p><ul><li>基本选择器：<ul><li><code>#id</code>：选择指定的id的标签；</li><li><code>.class</code>：选择指定的class值的标签；</li><li><code>标签</code>：选择指定的标签名的标签；</li><li><code>*</code>：选择所有的标签；</li><li><code>a,b,c</code>：选择指定a,b,c的标签；</li></ul></li><li>层次选择器：<ul><li><code>a b</code>：父标签a下所有的后代标签b；</li><li><code>a&gt;b</code>：父标签a下所有的子类标签b；</li><li><code>a+b</code>：标签a后第一个b标签；</li><li><code>a~b</code>：标签a后所有的b标签；</li></ul></li><li>过滤选择器：<ul><li><code>a:first</code>：第一个a标签；</li><li><code>a:last</code>：最后一个a标签；</li><li><code>a:even</code>：所有偶数a标签；</li><li><code>a:odd</code>：所有奇数a标签；</li><li><code>a:eq(index)</code>：a标签下第index个标签；</li><li><code>a:gt(index)</code>：a标签下大于index的标签；</li><li><code>a:lt(index)</code>：a标签下小于index的标签；</li></ul></li><li>内容过滤选择器：<ul><li>a:has(内容)：a标签下所有含有”内容”的标签；<ul><li>属性选择器：<ul><li><code>a:[属性=属性值]</code>：a标签下属性=属性值的所有的标签；</li></ul></li><li>表单选择器：<ul><li><code>:input</code>：所有for表单下的子标签；</li></ul></li></ul></li></ul></li></ul></li><li><p>JQuery对CSS样式的操作：</p><ul><li><code>JQuery对象.css(&quot;样式属性名&quot;)</code>；</li><li><code>JQuery对象.css(&quot;样式属性名&quot;,&quot;样式属性值&quot;)</code>。</li></ul></li><li><p>JQuery对属性的操作：</p><ul><li><code>JQuery对象.attr(&quot;属性名&quot;)</code>；</li><li><code>JQuery对象.attr(&quot;属性名&quot;,&quot;属性值&quot;)</code>；</li></ul></li><li><p>JQuery遍历方式：</p><pre><code class="hljs js">JQuery对象.each(function(index,ele)&#123;  #index指的是要遍历的对象的索引值；ele指的是要遍历的每一个对象，也可以使用this指代每一个需要遍历的对象alert($(<span class="hljs-keyword">this</span>).val());&#125;)</code></pre></li><li><p>表单校验：    </p><pre><code class="hljs js">#在页面加载成功后获取表单对象.validate(&#123;rules:&#123;&#125;,  #校验规则messages:&#123;&#125;  #自定义提示信息&#125;)rules写法：要校验的name属性：&#123;校验器<span class="hljs-number">1</span>：取值，校验器<span class="hljs-number">2</span>：取值&#125;注意：多个校验规则之间使用,分割message写法：要校验的name属性：&#123;校验器<span class="hljs-number">1</span>：<span class="hljs-string">"自定义提示信息1"</span>，校验器<span class="hljs-number">2</span>：<span class="hljs-string">"自定义提示信息2"</span>&#125;校验器：required   <span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>   必填校验number     <span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>   数字校验min        数字          最小值max        数字          最大值range      数值区间       [最小值,最大值]minLength|maxLength|rangLength   最小值|最大值|长度区间email:  email           邮箱校验     *@*   <span class="hljs-number">1</span>@xequalTo:  jquery对象    重复性校验</code></pre></li><li><p>栅格系统：把每一行分为十二份   超过十二份自动换行；</p><ul><li>大屏幕：col-lg-n。如，col-lg-1，即1份为一格，大屏幕展示出来的就有12格；</li><li>中等屏幕：col-md-n。如，col-md-3，即3份为一格，中等屏幕展示出来的就只有4格；</li><li>小屏幕：col-sm-6。如，col-sm-6，即6份为一格，小屏幕展示出来的就只有2格；</li><li>超小屏幕：col-xs-12。如，col-xs-12，即12份为一格，中等屏幕展示出来的就只有1格。</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>1.대학교 일 학년</category>
      
      <category>04.前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大一课程</tag>
      
      <tag>前端基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02.JavaEE--学习笔记</title>
    <link href="/2020/07/03/JavaEE--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/03/JavaEE--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaEE–学习笔记-包含JavaEE视频"><a href="#JavaEE–学习笔记-包含JavaEE视频" class="headerlink" title="JavaEE–学习笔记(包含JavaEE视频)"></a>JavaEE–学习笔记(包含JavaEE视频)</h1><h2 id="Lesson1-JavaEE基础"><a href="#Lesson1-JavaEE基础" class="headerlink" title="Lesson1 JavaEE基础"></a>Lesson1 JavaEE基础</h2><h3 id="NO1-1-JDBC与事务"><a href="#NO1-1-JDBC与事务" class="headerlink" title="NO1.1 JDBC与事务"></a>NO1.1 JDBC与事务</h3><p>我们常说的操作数据库，其实指的是操作DBMS，即操作数据库管理系统。</p><ul><li><p>数据库：</p><ul><li><p>MySQL数据库细节部分，请参考另一篇博客，这里不做过多叙述。</p></li><li><p>原生JDBC连接数据库：</p><ul><li><p>定义：JDBC即Java与数据库的连接，建立连接之后，就可以使用Java与数据库进行交互；</p></li><li><p>应用：</p><ul><li><p>首先，熟悉JDBC的核心，即三个接口和一个类；</p><ul><li>DriverManager：驱动管理类，帮助我们加载驱动；</li><li>Connection：数据库连接接口，实现类在驱动中；</li><li>Statement：执行SQL语句的接口，实现类在驱动中；</li><li>Result：结果集接口，实现类在驱动中；</li></ul></li><li><p>然后，编写原生JDBC开发；</p><ul><li><p>导入数据库驱动包或Maven导入相应的依赖；</p></li><li><p>注册驱动：</p><pre><code class="hljs java">Class.forName(com.mysql.jdbc.Driver);</code></pre></li><li><p>获取连接(四大要素：驱动、需要连接的数据库字符串、用户名、密码)，前提是必须注册驱动：</p><pre><code class="hljs java">Connection conn = DriverManager.getConnection(<span class="hljs-string">"jdbc:mysql://IP地址:3306/数据库名称"</span>,<span class="hljs-string">"用户名"</span>,<span class="hljs-string">"密码"</span>);</code></pre></li><li><p>获取sql语句预处理对象：</p><pre><code class="hljs java">PreparedStatement pst = conn.prepareStatement(String sql);pst.setObject(<span class="hljs-string">"占位符序列号"</span>,<span class="hljs-string">"具体的参数值"</span>);注意：这里设置的是上面sql语句中的占位符?的值，例如select * from userwhere uid = ?</code></pre></li><li><p>使用sql语句执行对象执行操作，并获取结果集：</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> rows = pst.executeUpdate();  <span class="hljs-comment">//增删改操作，返回的是影响的行数，可以根据这个值来判断操作是否成功</span>ResultSet rs = pst.executeQuery();  <span class="hljs-comment">//查询操作</span></code></pre></li><li><p>处理结果集(只针对查询操作)，循环遍历操作：</p><pre><code class="hljs java">rs.next();  <span class="hljs-comment">//判断是否有下一条记录</span>结果集对象rs.getObject(<span class="hljs-string">"字段名"</span>)  <span class="hljs-comment">//获取具体的值</span>拓展：结果集的处理方法一、结果集第一种处理方法：ArrayHandler，将结果集的第一行存储到对象数组中Object[]；二、结果集第二种处理方法：ArrayListHandler，将结果集的每一行，封装到对象数组中，出现很多对象数组，对象数组存储到List集合；三、结果集第三种处理方法：BeanHandler，将结果集的第一行数据，封装成JavaBean对象(常用)；注意：被封装成到JavaBean对象，JavaBean类必须有无参构造；四、结果集第四种处理方法：BeanListHandler，结果集每一行数据，封装JavaBean对象，多个JavaBean对象，存储到List集合(常用)；五、结果集第五种处理方法：ColumnListHandler，将指定列的数据，存储到List集合，List&lt;Object&gt; 每个列数据类型不同；六、结果集第六种处理方法：ScalarHandler，对于查询后，只有<span class="hljs-number">1</span>个结果(常用)；七、结果集第七种处理方法：MapHandler，将结果集第一行数据，封装到Map集合中，Map&lt;键,值&gt; 键：列名，值：这列的数据；八、结果集第八种处理方法：MapListHandler，将结果集每一行存储到Map集合，键：列名，值：数据，Map集合过多，存储到List集合；</code></pre></li><li><p>释放资源：</p><pre><code class="hljs java">conn.close();  <span class="hljs-comment">//关闭链接对象</span>                pst.close();  <span class="hljs-comment">//关闭SQL语句预处理对象</span>rs.close();  <span class="hljs-comment">//只针对查询操作</span></code></pre></li></ul></li></ul></li></ul></li></ul></li></ul><pre><code>-   编写JDBCUtils工具类用于加载驱动和获取连接对象：    <pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * JDBC工具类</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 邓燕飞</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCUtils</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String driverName = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String url = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String username = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String password = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 数据库的驱动没有必要每一次调用都加载，放在static代码块中，只加载一次即可</span>    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//加载四大要素配置文件</span>            <span class="hljs-comment">//使用Map集合Properties加载配置文件</span>            Properties pp = <span class="hljs-keyword">new</span> Properties();            pp.load(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"jdbc_config.properties"</span>));            <span class="hljs-comment">//从配置文件对象中获取驱动、需要连接的数据库字符串、数据库账号、数据库密码</span>            driverName = pp.getProperty(<span class="hljs-string">"driverName"</span>);            url = pp.getProperty(<span class="hljs-string">"url"</span>);            username = pp.getProperty(<span class="hljs-string">"username"</span>);            password = pp.getProperty(<span class="hljs-string">"password"</span>);                        <span class="hljs-comment">// 加载驱动</span>            Class.forName(driverName);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-comment">// 驱动出错，则后面的代码没必要继续执行，抛出异常，直接终止程序；</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"数据库驱动加载出错..."</span>);        &#125;    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 这是获取数据库的连接的对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回一个连接对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 获取与数据库的连接</span>        Connection conn = DriverManager.getConnection(url, username, password);        <span class="hljs-comment">// 返回连接对象</span>        <span class="hljs-keyword">return</span> conn;    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 这是关闭连接对象，执行语句对象，结果集对象的方法</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> conn 这是连接对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> st 执行语句对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rs 结果集对象</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeAll</span><span class="hljs-params">(Connection conn, PreparedStatement ps,ResultSet rs)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (conn != <span class="hljs-keyword">null</span>) &#123;                conn.close();            &#125;            <span class="hljs-keyword">if</span> (ps != <span class="hljs-keyword">null</span>) &#123;                ps.close();            &#125;            <span class="hljs-keyword">if</span> (rs != <span class="hljs-keyword">null</span>) &#123;                rs.close();            &#125;        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            System.out.println(<span class="hljs-string">"资源关闭出错啦..."</span>);            e.printStackTrace();        &#125;    &#125;&#125;</code></pre>-   编写C3P0Utils连接池工具类：**`注意：C3P0连接池不需要手动加载配置文件，只需将c3p0-config.xml文件放入src目录下，C3P0连接池会自动去找配置文件并加载里面的配置。`**    <pre><code class="hljs java">c3p0-config.xml文件&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;&lt;c3p0-config&gt;    &lt;<span class="hljs-keyword">default</span>-config&gt;        &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt;        &lt;property name=<span class="hljs-string">"jdbcUrl"</span>&gt;jdbc:mysql:<span class="hljs-comment">//localhost:3306/dbtest&lt;/property&gt;</span>        &lt;property name="user"&gt;root&lt;/property&gt;        &lt;property name="password"&gt;Deng521314&lt;/property&gt;        &lt;property name="initialPoolSize"&gt;10&lt;/property&gt;    &lt;/default-config&gt;&lt;/c3p0-config&gt;<span class="hljs-comment">//--------------------------------------</span><span class="hljs-comment">//C3P0Utils连接池工具类；</span><span class="hljs-comment">/***</span><span class="hljs-comment"> * C3P0也实现了javax.sql.DataSource接口，实现类：ComboPooledDataSource</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C3P0Utils</span> </span>&#123;    <span class="hljs-comment">//创建C3P0连接池</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ComboPooledDataSource C3P0_dataSource =<span class="hljs-keyword">new</span> ComboPooledDataSource();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 0.获取C3P0连接池对象的方法getDataSource()</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回一个C3P0连接池对象</span><span class="hljs-comment">     */</span>    <span class="hljs-comment">//供给DBUtils的连接池对象</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataSource <span class="hljs-title">getDataSource</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> C3P0_dataSource;    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 1.获取数据库的连接对象的方法getConnection()</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回一个连接对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;        Connection conn = C3P0_dataSource.getConnection();        <span class="hljs-keyword">return</span> conn;    &#125;     <span class="hljs-comment">/***</span><span class="hljs-comment">      * 2.这是关闭连接对象，执行语句对象，结果集对象的方法closeAll()</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> conn 这是连接对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> st 执行语句对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rs 结果集对象</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeAll</span><span class="hljs-params">(Connection conn, PreparedStatement ps,ResultSet rs)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (conn != <span class="hljs-keyword">null</span>) &#123;                conn.close();            &#125;            <span class="hljs-keyword">if</span> (ps != <span class="hljs-keyword">null</span>) &#123;                ps.close();            &#125;            <span class="hljs-keyword">if</span> (rs != <span class="hljs-keyword">null</span>) &#123;                rs.close();            &#125;        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            System.out.println(<span class="hljs-string">"资源关闭出错啦..."</span>);            e.printStackTrace();        &#125;    &#125;&#125;注意：C3P0连接池不要加载配置文件，只需将c3p0-config.xml文件放入src目录下，C3P0连接池会自动去找配置文件加载里面的配置</code></pre>-   DBUtils中：    -   只需要创建QueryRunner类对象；    -   处理结果集(将获取到的对象封装到JavaBean中，所以domain类的属性要和数据库表中字段名一致)即可。        <pre><code class="hljs java"><span class="hljs-comment">//不带事务</span><span class="hljs-comment">//获取C3P0工具类的C3P0连接池对象</span>DataSource ds = C3P0Utils.getDataSource();<span class="hljs-comment">//1.创建QueryRunner类对象，因为没有事务，所以需要传入连接池对象；</span><span class="hljs-comment">//2.这样update或query方法内部就调用this.getconnection方法来从这个数据源获得连接对象，操作完后，就关闭conneciton,preparedstatement和resultset对象.</span>QueryRunner qr = <span class="hljs-keyword">new</span> QueryRunner(ds);<span class="hljs-comment">//添加操作</span><span class="hljs-comment">//qr.update("insert into users (uid,uname,uage) values (?,?,?)", 2,"二哈狗子",2);</span><span class="hljs-comment">//查询操作</span>List&lt;Users&gt; query = qr.query(<span class="hljs-string">"select * from users"</span>,<span class="hljs-keyword">new</span> BeanListHandler&lt;Users&gt;(Users<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;<span class="hljs-comment">//遍历集合，打印集合元素</span><span class="hljs-keyword">for</span> (Users users : query) &#123;    System.out.println(users);&#125;    <span class="hljs-comment">//------------------------------------------</span>    <span class="hljs-comment">//带事务</span>Connection conn = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//1.带事务操作，不需要连接池对象，这种情况下，调用update或query方法时，需要传入对应的connection参数</span><span class="hljs-comment">//2.DBUtils调用这种带connection参数的方法时，只会关闭preparedstatement和resultset对象，不会关闭conneciton对象，就是为了允许其他方法来使用这个conneciton；</span>QueryRunner qr = <span class="hljs-keyword">new</span> QueryRunner();<span class="hljs-keyword">try</span>&#123;    conn = C3P0Utils.getConnection();    <span class="hljs-comment">//MySQL是自动提交事务，关闭自动事务提交，即开启手动事务提交</span>    conn.setAutoCommit(<span class="hljs-keyword">false</span>);    <span class="hljs-comment">//给小仙女转账</span>    qr.update(conn, <span class="hljs-string">"update mybank set money=money-? where name=?"</span>,<span class="hljs-number">1000</span>,<span class="hljs-string">"邓先森"</span>);    <span class="hljs-comment">//模拟转账失败</span>    <span class="hljs-comment">//System.out.println(1/0);</span>    <span class="hljs-comment">//小仙女收钱</span>    qr.update(conn, <span class="hljs-string">"update mybank set money=money+? where name=?"</span>,<span class="hljs-number">1000</span>,<span class="hljs-string">"小仙女"</span>);    <span class="hljs-comment">//提交事务</span>    conn.commit();&#125;<span class="hljs-keyword">catch</span> (SQLException e) &#123;    e.printStackTrace();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//事务回滚</span>        conn.rollback();    &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;        e.printStackTrace();    &#125;&#125;<span class="hljs-keyword">finally</span> &#123;    conn.close();&#125;</code></pre>-   `ThreadLocal&lt;T&gt;`：线程局部变量，作用是为每一个线程，提供一个存储数据的空间，`&lt;T&gt;`：泛型是设置值的类型，一般是连接对象类；它有两个方法：    -   `get()`：获取值的方法，它是以当前线程对象作为键，从map中取值，内部原码：map.get(Thread.currentThread())；    -   `set(Object obj)`：设置值的方法，以当前线程对象作为键，将obj存储到map中，内部原码：map.set(Thread.currentThread,obj)。        <pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionManager</span> </span>&#123;            <span class="hljs-comment">//创建一个ThreadLocal集合</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Connection&gt; tl = <span class="hljs-keyword">new</span> ThreadLocal&lt;Connection&gt;();            <span class="hljs-comment">/**</span><span class="hljs-comment">         * 1.获取连接对象的方法</span><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> 连接对象</span><span class="hljs-comment">         * <span class="hljs-doctag">@throws</span> SQLException</span><span class="hljs-comment">         */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;                <span class="hljs-comment">//第一次获取时，肯定是null</span>            Connection conn = tl.get();                <span class="hljs-comment">//判断是Service层(第一次)还是Dao(第二次以上)层获取连接对象</span>            <span class="hljs-keyword">if</span>(conn==<span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-comment">//如果是第一次获取，则从连接池获取一个连接对象</span>                conn = C3P0Utils.getConnection();                                <span class="hljs-comment">//放入ThreadLocal集合中</span>                tl.set(conn);            &#125;                <span class="hljs-comment">//返回连接对象；如果是第二次以上获取连接对象，则直接返回连接对象即可</span>            <span class="hljs-keyword">return</span> conn;        &#125;                <span class="hljs-comment">/**</span><span class="hljs-comment">         * 2.开启事务的方法</span><span class="hljs-comment">         * <span class="hljs-doctag">@throws</span> SQLException</span><span class="hljs-comment">         */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startTransaction</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;            ConnectionManager.getConnection().setAutoCommit(<span class="hljs-keyword">false</span>);        &#125;                <span class="hljs-comment">/**</span><span class="hljs-comment">         * 3.提交事务的方法</span><span class="hljs-comment">         * <span class="hljs-doctag">@throws</span> SQLException</span><span class="hljs-comment">         */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commitTransaction</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;            ConnectionManager.getConnection().commit();        &#125;                <span class="hljs-comment">/**</span><span class="hljs-comment">         * 4.回滚事务的方法</span><span class="hljs-comment">         * <span class="hljs-doctag">@throws</span> SQLException</span><span class="hljs-comment">         */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rollbackTransaction</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;            ConnectionManager.getConnection().rollback();        &#125;                <span class="hljs-comment">/**</span><span class="hljs-comment">         * 5.关闭连接的方法</span><span class="hljs-comment">         * <span class="hljs-doctag">@throws</span> SQLException</span><span class="hljs-comment">         */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cloesConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;            ConnectionManager.getConnection().close();        &#125;    &#125;        <span class="hljs-comment">//---------------------------------------------------------------------</span>        测试代码：        <span class="hljs-comment">//操作事务</span>    Connection conn = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span>&#123;        QueryRunner qr = <span class="hljs-keyword">new</span> QueryRunner();        conn = ConnectionManager.getConnection();            <span class="hljs-comment">//关闭自动事务提交，即开启手动事务提交</span>        ConnectionManager.startTransaction();        qr.update(<span class="hljs-string">"update mybank set money=money-? where name=?"</span>, <span class="hljs-number">1000</span>,<span class="hljs-string">"邓先森"</span>);            <span class="hljs-comment">//模拟转账失败</span>        System.out.println(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>);        qr.update(<span class="hljs-string">"update mybank set money=money+? where name=?"</span>, <span class="hljs-number">1000</span>,<span class="hljs-string">"任仙女"</span>);            <span class="hljs-comment">//提交事务</span>        ConnectionManager.commitTransaction();        &#125;<span class="hljs-keyword">catch</span> (SQLException e) &#123;        e.printStackTrace();            System.out.println(<span class="hljs-string">"出现错误..."</span>);            <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//事务回滚</span>            ConnectionManager.rollbackTransaction();        &#125; <span class="hljs-keyword">catch</span> (SQLException e1) &#123;            e1.printStackTrace();        &#125;            &#125;<span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">try</span> &#123;            ConnectionManager.cloesConnection();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;</code></pre></code></pre><p>&nbsp;</p><ul><li><p>事务的安全性问题和隔离级别；</p><ul><li><p>事务的安全性问题；</p><ul><li>脏读：是指一个事务读到另一个事务还没有提交的数据；<code>如，事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</code>；<ul><li>不可重复读：是指一个事务读到另一个事务已经提交的update数据，导致在当前事务中多次查询的结果不一致；<code>如，事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致</code>；</li><li>虚读/幻读：是指一个事务读到另一个事务已经提交的insert数据，导致在当前事务中多次查询的结果不一致；<code>如，系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读</code>。</li></ul></li></ul></li><li><p>事务的安全性问题的解决办法(Y代表可能发生，N代表不会发生)：</p><p><img src="JavaEE--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Image-jee1.png" srcset="/img/loading.gif" alt="Image"></p><ul><li><p>READ-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读；</p></li><li><p>READ-COMMITTED(读取已提交)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生；</p></li><li><p>REPEATABLE-READ(可重复读)：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生；</p></li><li><p>SERIALIZABLE(可串行化)：最高的隔离级别，完全服从ACID的隔离级别；所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p><pre><code class="hljs java">拓展：MySQL和Oracle数据库隔离级别一、MySQL默认的事务处理级别是<span class="hljs-string">'REPEATABLE-READ'</span>,也就是可重复读；二、Oracle默认系统事务隔离级别是READ COMMITTED,也就是读已提交；Oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别。</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-2-Web"><a href="#NO1-2-Web" class="headerlink" title="NO1.2 Web"></a>NO1.2 Web</h3><p>看完了后端数据库，我们来看看Web层的一些操作。</p><ul><li>HTTP协议：<ul><li>定义：所谓协议，就是指双方遵循的规范；HTTP协议，就是浏览器和服务器之间进行“沟通”的一种规范；市面上两种常见的架构：<ul><li><code>B/S系统</code>：是指Brower/Server，即浏览器/服务器系统；如网站和服务器系统等；</li><li><code>C/S系统</code>：是指Client/Server，即客户端/服务器系统；如电脑软件客户端和服务器系统等；</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>web应用服务器：<ul><li>定义：供向外部发布web资源的服务器软件；常用的web应用服务器如下：<ul><li>weblogic：oracle公司的大型收费web服务器，支持JavaEE规范；</li><li>websphere：IBM公司的的大型收费web服务器，支持JavaEE规范；</li><li>Tomcat：Apache开源组织下的，开源的，免费的小型web服务器，支持JavaEE中的Servlet和JSP规范。</li></ul></li><li>web资源：存在于web应用服务器并可供外界访问的资源就是web资源。</li></ul></li></ul><p>&nbsp;</p><ul><li><p>Servlet：</p><ul><li><p>定义：是运行在服务端的Java小程序，是sun公司提供的一套规范(接口)，用来处理请求和发送响应数据；但Servlet的实质就是Java代码，通过Java的API动态的向客户端输出内容；</p></li><li><p>基本语法格式：</p><ul><li>创建一个Servlet：<ul><li>创建一个Java类并实现Servlet接口；</li><li>实现主要方法：service()方法；</li><li>在web.xml进行servlet的配置；</li></ul></li></ul></li><li><p>Servlet的API：</p><ul><li><code>init()方法</code>：Servlet对象创建的时候执行；</li><li><code>service()方法</code>：每次请求都会执行；</li><li><code>destroy()方法</code>：Servlet对象销毁的时候执行；</li></ul></li><li><p>Servlet的生命周期；</p><ul><li><code>Servlet何时创建</code>：默认第一次访问Servlet时，创建该对象；</li><li><code>Servlet何时销毁</code>：服务器关闭，Servlet就销毁了；</li></ul></li><li><p>Servlet在web.xml的配置；</p><pre><code class="hljs java">&lt;servlet&gt;            <span class="hljs-comment">//3.这里取什么名字无所谓，作用是让下方的&lt;servlet-name&gt;名称找到这里，并指引找到响应资源的Servlet</span>            &lt;servlet-name&gt;servletTest&lt;/servlet-name&gt;                            <span class="hljs-comment">//4.Servlet的全限定类名，也就是Servlet的位置，由上面的&lt;servlet-name&gt;指引而来</span>            &lt;servlet-<span class="hljs-class"><span class="hljs-keyword">class</span>&gt;<span class="hljs-title">com</span>.<span class="hljs-title">action</span>.<span class="hljs-title">ServletTest</span>&lt;/<span class="hljs-title">servlet</span>-<span class="hljs-title">class</span>&gt;</span><span class="hljs-class">        &lt;/<span class="hljs-title">servlet</span>&gt;</span><span class="hljs-class">        &lt;<span class="hljs-title">servlet</span>-<span class="hljs-title">mapping</span>&gt;</span><span class="hljs-class">            //2.这里的名称必须要和上方的&lt;<span class="hljs-title">servlet</span>-<span class="hljs-title">name</span>&gt;名称相同；</span><span class="hljs-class">            &lt;<span class="hljs-title">servlet</span>-<span class="hljs-title">name</span>&gt;<span class="hljs-title">servletTest</span>&lt;/<span class="hljs-title">servlet</span>-<span class="hljs-title">name</span>&gt;</span><span class="hljs-class">        </span><span class="hljs-class">        </span>            //1.通过浏览器地址请求的资源名找到这里，注意："/"一定要写，相当于项目名称            &lt;url-pattern&gt;/servletTest&lt;/url-pattern&gt;        &lt;/servlet-mapping&gt;</code></pre></li><li><p>为什么eclipse创建的Servlet没有service()方法，只有doGet()和doPost()却仍然能够实现接收请求和反馈响应呢？</p><pre><code class="hljs java">要想接收请求和反馈响应，就必须实现Servlet接口，而eclipse创建的Servlet继承自HttpServlet，但是HttpServlet中却没有找到实现Serverlet接口，所以继续找HttpServlet的父类，之后发现其父类GenericServlet，实现了Servlet接口，也就是说HttpServlet间接的实现了Servlet接口；之后因为又发现父类GenericServlet没有实现service()方法，只是继承了该方法，该方法仍然是抽象方法，所以去找子类HttpServlet，而在HttpServlet中，找到了被重写的service()方法，但参数却是ServletRequest和ServletResponse，也就是说，这就是普通的一个类间接实现了Servlet接口，重写service()方法，然后HttpServlet中将原生的Servlet参数ServletRequest和ServletResponse强制转成了带Http协议的HttpServletRequest和HttpServletResponse，之后又调用了HttpServlet本类中重载的方法(即方法名相同，参数不同的)service()方法，根据请求中发送数据的方法get和post，分别调用我们看到doGet()和doPost()方法。</code></pre></li><li><p>ServletContext：</p><ul><li>定义：是指web应用项目上下文对象，一个web应用项目只有一个ServletContext，但可以有多个Servlet对象；</li></ul></li><li><p>ServletContext生命周期；</p><pre><code>-   创建：该web应用项目被加载(即服务器启动或发布web应用)；-   销毁：web应用被卸载(服务器关闭或移除该web应用)。</code></pre><ul><li>基本语法格式：通过getServletContext()直接获得ServletContext对象；</li><li>ServletContext的三个主要的作用：<ul><li>获得初始化参数(一般写框架的时候才会用到，平常不用)；</li><li>获得web应用中任何资源的绝对路径(重要)：String getRealPath(path); path是某个文件，返回该文件所在的绝对路径；<ul><li>Tomcat服务器中的项目名称，对应的是eclipse中的WebContent目录；即在Tomcat中的daydayup0011项目，对应在eclipse中的目录为：daydayup0011下的WebContent，WebContent才是真实目录；</li></ul></li><li>ServletContext是一个域对象：<ul><li>域对象就是存储数据的区域；</li><li>作用范围：整个web应用，即该web应用所有的web资源都可以随意向ServletContext域中存取数据，意思就是数据共享；</li><li>域对象通用的方法：<ul><li><code>setAtrribute(String name,Object obj)</code>：向ServletContext域中存数据；</li><li><code>getAtrribute(String name)</code>：根据名称向ServletContext域中取数据；</li><li><code>removeAtrribute(String name)</code>：根据名称删除ServletContext域中的数据。</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>Request：</p><ul><li><p>定义：就是用户指定访问某个资源，会发送一个访问许可的请求，这个请求就是request；</p></li><li><p>Request中包含的表单，其提交方式：</p><ul><li>表单以”get”方式提交，请求参数会在url后面，以?隔开，以&amp;方式连接不同的参数，且长度有限，安全性低；</li><li>表单以”post”方式提交，则请求参数会封装在request中的请求体中，长度较大，安全性高。</li></ul></li><li><p>Request的常用API：</p><ul><li><code>String getContextPath()</code>：获得web应用的名称；</li><li><code>String getHeader(String name)</code>：获得请求头中某个指定的键所对应的值；</li><li><code>String getParameter(String name)</code>：根据指定的单个参数名获得对应的值；</li><li><code>String[] getParameterValues(String name)</code>：根据指定的单个参数名获得对应的多个值(用于获取表单中复选框的值)；</li><li><code>Map&lt;String,String[]&gt; getParameterMap()</code>：该方法的返回值只能读，不能改；</li></ul></li><li><p>Request也是一个域对象；</p><ul><li>作用范围：Request域对象的作用范围只能是在同一次请求当中；</li><li><code>setAtrribute(String name,Object obj)</code>：向request域中存数据；</li><li><code>getAtrribute(String name)</code>：根据名称向request域中取数据；</li><li><code>removeAtrribute(String name)</code>：根据名称删除request域中的数据；</li></ul></li><li><p>Request解决获取的参数乱码问题；</p><ul><li><p>Post提交方式：<code>request.setCharacterEncoding(&quot;UTF-8&quot;)</code>，设置request中接收的参数用UTF-8编码；</p></li><li><p>Get提交方式：<code>new String(target.getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;)</code>；</p><pre><code class="hljs java">拓展：乱码形成一、乱码形成：中文---&gt;自动用UTF-<span class="hljs-number">8</span>编码转成程序能看的字节---&gt;开发工具(这里是eclipse)用ISO-<span class="hljs-number">8859</span>-<span class="hljs-number">1</span>解码---&gt;我们看到的乱码二、解决乱码：乱码---&gt;先用ISO-<span class="hljs-number">8859</span>-<span class="hljs-number">1</span>编码转成程序看的字节---&gt;再用UTF-<span class="hljs-number">8</span>解码---&gt;解成我们想要看的中文</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>Response：</p><ul><li><p>定义：就是用户请求指定的资源后，服务端给予客户端的一种反馈形式就被成为响应；</p></li><li><p>Response的常用API：</p><ul><li><p><code>setStatus(int sc)</code>：该方法用于设置响应行中的状态码；</p><pre><code class="hljs java"><span class="hljs-number">2</span>XX：成功<span class="hljs-number">3</span>XX：重定向<span class="hljs-number">4</span>XX：请求资源错误<span class="hljs-number">5</span>XX：服务器错误</code></pre></li><li><p><code>addHeader(String name,String value)</code>：以键值对的形式，添加一个响应头信息；如果键相同，则值会添加到上一个值的后面，用,隔开；</p><pre><code class="hljs java">response.addHeader(<span class="hljs-string">"name"</span>,<span class="hljs-string">"zhangsan"</span>);  <span class="hljs-comment">//以键值对的形式添加一个响应头的信息</span>                        response.addHeader(<span class="hljs-string">"name"</span>,<span class="hljs-string">"lisi"</span>);  <span class="hljs-comment">//再次以键值对的形式添加一个响应头的信息，但是键相同结果在浏览器抓包响应时显示：name="zhangsan,lisi"</span></code></pre></li><li><p><code>setHeader(String name,String value)</code>：以键值对的形式，设置一个响应头信息；如果有键相同，则值会覆盖；</p><pre><code class="hljs java">response.addHeader(<span class="hljs-string">"name"</span>,<span class="hljs-string">"zhangsan"</span>);  <span class="hljs-comment">//以键值对的形式添加一个响应头的信息</span>                        response.addHeader(<span class="hljs-string">"name"</span>,<span class="hljs-string">"lisi"</span>);  <span class="hljs-comment">//再次以键值对的形式添加一个响应头的信息，但是键相同结果在浏览器抓包响应时显示：name="lisi";</span></code></pre></li><li><p><code>getOutputStream()</code>：获得一个字节输出流，实际就是一个IO流，用于传输字节数据，如下载图片，视频等，浏览器能够直接解析并获取；下载图片等文件：</p><ul><li><code>response.setContentType(getServletCOntext().getMimeType(文件名的字符串))</code>：获取文件的MIME类型，即程序区分文件类型是使用MIME类型去区分的，是为了下载传输数据做准备；</li><li><code>response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+文件名的字符串)</code>：这个时候程序已经拿到某个文件的MIME类型，该方法是告知浏览器这个文件用附件形式打开，即不会直接解析，因为直接解析会在浏览器端直接打开文件，不是我们想要的方式，也就不是文件下载了；<ul><li><code>filename = new String(filename.getBytes(&quot;本地字符集&quot;),&quot;UTF-8&quot;)</code>：解决文件名是中文乱码</li></ul></li></ul></li><li><p>Response解决中文乱码；</p><ul><li>response.setContentType(“text/html;charset=字符集”)：即告知浏览器，让浏览器用指定字符集去解析信息；(该方法也隐含了让response用指定的字符集编码)。</li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>重定向和请求转发的区别：</p><ul><li><p>重定向是在客户端发生的，速度慢；请求转发是在服务端发生的，速度快；</p></li><li><p>重定向是两次请求，地址栏有变化；请求转发是一次请求，地址栏没有变化；</p></li><li><p>重定向的方法为：<code>response.sendRedirect(String location)</code>；</p><p>请求转发的方法为：<code>request.getRequestDispatcher(String path).forward(request, response)</code>。</p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>Cookie和Session：</p><ul><li><p>定义：即会话技术，是指从打开一个浏览器访问某个站点，到关闭这个浏览器的整个过程，称为一次会话；而会话技术就是记录这次会话中客户端的状态与数据的；</p></li><li><p>会话技术分为：</p><ul><li><p>Cookie；</p><ul><li><p>定义：数据存储在客户端本地，减少了服务器端的数据存储压力，但安全性不好，客户端可以清除Cookie；</p></li><li><p>Cookie的发送和接收：</p><ul><li><p>创建Cookie：</p><pre><code class="hljs java"><span class="hljs-comment">//以键值对的形式创建一个Cookie</span>Cookie cookie = <span class="hljs-keyword">new</span> Cookie(String key,String value);<span class="hljs-comment">//将cookie发送给客户端即可</span>response.addCookie(cookie);注意：Cookie不能存储中文</code></pre></li><li><p>设置Cookie的持久化时间(即存在时间)：</p><pre><code class="hljs java"><span class="hljs-comment">//参数是秒，一般的默认都是会话级别的Cookie，在会话结束后就消失；持久化Cookie需要使用该方法设置持久化时间，但时间过了也会消失</span>cookie.setMaxAge(<span class="hljs-keyword">int</span> seconds);</code></pre></li><li><p>设置Cookie的携带路径(即访问哪一些资源需要携带Cookie，哪一些不需要)；</p><pre><code class="hljs java"><span class="hljs-comment">//参数是路径名，即访问path资源需要携带Cookie，除此之外，不携带cookie</span>cookie.setPath(String path);如：web01/aaa/bbb/testservlet：该路径下产生了Cookie；则，web01/aaa/bbb路径下的所有资源都会携带Cookie注意：如果不设置该方法，则只默认访问，在产生该Cookie的路径下都会携带Cookie，即除开路径<span class="hljs-string">"/"</span>最后一部分，前面的路径下的资源都会携带Cookie</code></pre></li><li><p><code>Cookie[] request.getCookies()</code>：该方法返回的是一个Cookie数组，通过遍历数组和想要找的键的比对，找到想要的Cookie值；</p></li><li><p>删除Cookie，只需创建一个同名同路径Cookie，且该Cookie的持久化时间为0的即可。</p></li></ul></li></ul></li><li><p>Session；</p><ul><li><p>定义：Session会话技术是将数据存储在服务器端的技术，会为每个客户端都创建一块内存空间存储客户的数据，但是客户端需要每次都携带一个标识ID去服务器中寻找自己的内存空间；所以说Session的实现是基于Cookie，Session需要借助于Cookie存储客户的唯一性标识JSESSIONID；另外数据存储在服务器端，增加了服务器端的数据存储压力，但安全性好；</p></li><li><p>Session的发送和接收：</p><ul><li><p>创建Session；</p><pre><code class="hljs java"><span class="hljs-comment">//该方法会自动判断访问的客户端是否已经在服务端有Session区域，没有则创建，否则就返回原先拥有的Session区域；</span>HttpSession session = request.getSession();</code></pre></li></ul></li><li><p>Session也是一个域对象：</p><ul><li>范围：Session域对象的作用范围只能是在同一次会话当中，即浏览器只要不关闭或重新开启，都是一次会话；</li><li>setAtrribute(String name,Object obj)：向Session域中存数据；</li><li>getAtrribute(String name)：根据名称向Session域中取数据；</li><li>removeAtrribute(String name)：根据名称删除Session域中的数据。</li></ul></li><li><p>Session的生命周期；</p><ul><li><p>创建：第一次执行request.getSession();时创建Session；</p></li><li><p>销毁：服务器(非正常)关闭时，Session销毁。</p><pre><code class="hljs java">拓展：Session过期时间一、Session过期，一般Session有效时间<span class="hljs-number">30</span>分钟，从最后一次不操作服务器端资源开始计算；手动销毁Session.invalidate();</code></pre></li></ul></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>JSP：</p><ul><li><p>定义：JPS是一种动态网页开发技术，它使用JSP标签在HTML网页中插入Java代码；标签通常以&lt;% %&gt;开头和结束；JSP是简化的Servlet；</p></li><li><p>JSP脚本：</p><ul><li>&lt;%这里写Java代码%&gt;，内部的Java代码会被翻译到service内部；</li><li>&lt;%=Java变量或表达式%&gt;，内部的Java代码会被翻译到service内部；</li><li>&lt;%!这里写Java代码%&gt;，内部的Java代码会被翻译到service成员位置。</li></ul></li><li><p>JSP指令：</p><ul><li>taglib指令：在JSP页面中引入标签库；格式：&lt;%@ taglib uri=”标签库地址” prefix=”前缀”%&gt;。</li></ul></li><li><p>JSP内置对象(9个)：即这些对象不需要我们生产，直接使用即可；</p><ul><li>out：用于页面输出；</li><li>request：用于得到用户请求；</li><li>response：用于服务端向客户端的响应；</li><li>config：服务器配置，可以取得初始化参数；</li><li>session：用来保存用户信息；</li><li>application：所有用户的共享信息(即ServletContext)；</li><li>page：指当前页面转换后的Servlet类的实例对象，就是this；</li><li>pageContext：JSP的页面容器；</li><li>exception：表示JSP页面所引发的异常，在错误页面中才起作用。</li></ul></li><li><p>pageContext也是一个域对象；</p><ul><li><p>范围：pageContext域对象的作用范围只能是当前JSP页面当中；</p></li><li><p>setAtrribute(String name,Object obj)：向pageContext域中存数据；</p></li><li><p>getAtrribute(String name)：根据名称向pageContext域中取数据；</p></li><li><p>removeAtrribute(String name)：根据名称删除pageContext域中的数据；</p></li><li><p>findAttribute(String name)：依次(从小到大)从pageContext域、request域、Session域、Application域中查找指定名称的数据。</p></li><li><p>pageContext可以获得其他八个内置对象，通过get对象名()方法；</p><pre><code class="hljs java">拓展：对域对象进行操作一、setAtrribute(String name,Object obj,<span class="hljs-keyword">int</span> scope)：向指定scope域中存数据；二、getAtrribute(String name,<span class="hljs-keyword">int</span> scope)：根据名称向指定scope域中取数据；三、removeAtrribute(String name,<span class="hljs-keyword">int</span> scope)：根据名称删除指定scope域中的数据；</code></pre></li></ul></li><li><p>静态包含与动态包含的区别？</p><ul><li>静态包含会将被包含的JSP页面合并到一起，即两个页面合成一个页面；也就只有一个.class文件；</li><li>动态包含则是编译运行主页面后，在主页面引入被包含的页面，之后再去编译运行被包含的页面；有两个.class文件；</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>EL表达式</p><ul><li><p>定义：是指可以嵌入在JSP页面的内部，减少JSP脚本(即Java代码)编写的表达式；EL的出现就是为了替代JSP页面中脚本的编写；</p></li><li><p>基本语法格式：</p><ul><li><p>EL从域中取出数据：格式为<code>${EL表达式}</code>；用的最多的是：<code>${key}</code>，即传入一个key，让其自动到四个域对象中去找(范围从小到大)；</p></li><li><p>EL的内置对象有11个，常用的有(1个)：pageContext，作用是获取其他8个内置对象，常用于获取web应用名称，即<code>${pageContext.request.ContextPath}</code>；</p></li><li><p>EL还可以执行表达式运算；</p><pre><code class="hljs html">$&#123;1+1&#125;            $&#123;xxx==null?true:false&#125;            $&#123;empty xxx&#125;                        说明：上面的empty用于判断后面的xxx是否为空</code></pre></li><li><p>EL表达式中，若需要和字符串作拼接，则需要使用<code>concat(&quot;需要拼接的字符串&quot;)</code>方法。<code>如，${user.uname.concat(&quot;是小可爱&quot;)}，结果为：XXX是小可爱</code>；</p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>JSTL</p><ul><li><p>定义：是指JSP的标准标签库，可以嵌入JSP页面中使用标签的形式完成业务逻辑等功能；也是为了替代JSP中的脚本而出现的；</p></li><li><p>JSTL有5个子库，但只有1个常用：Core库，即核心库，前缀为”c”；核心库的常用标签有：</p><ul><li><p><code>&lt;c:if test=&quot;&quot;&gt;</code>：test是返回boolean的条件；</p></li><li><p><code>&lt;c:forEach&gt;</code>：就是循环；</p><ul><li><p>基本遍历；</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">c:forEach</span> <span class="hljs-attr">begin</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">end</span>=<span class="hljs-string">"5"</span> <span class="hljs-attr">var</span>=<span class="hljs-string">"i"</span>&gt;</span>$&#123;i&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">c:forEach</span>&gt;</span>说明：从0开始，到5(包括5)为止，将值赋给变量i，用EL输出</code></pre></li><li><p>数组或集合遍历</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">c:forEach</span> <span class="hljs-attr">items</span>=<span class="hljs-string">"这里放集合或数组"</span> <span class="hljs-attr">var</span>=<span class="hljs-string">"j"</span>&gt;</span>$&#123;j&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">c:forEach</span>&gt;</span>说明：从集合中，取出元素，赋给变量j，并输出(推荐此方法，因为是增强for遍历的方)</code></pre></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>MVC模式：<ul><li>M：Model—模型，即JavaBean，封装数据；</li><li>V：View—视图，即JSP等，仅页面显示；</li><li>C：Controller—控制体，即Servlet等，处理请求(获取数据)和响应(传递数据)。</li></ul></li></ul><p>&nbsp;</p><ul><li><p>AJax：</p><ul><li><p>定义：是指异步的JavaScript和XML或者HTML；</p></li><li><p>同步和异步：</p><ul><li><code>同步现象</code>：是指客户端发送请求到服务端，在服务端返回响应之前，客户端都处于等待卡死状态；通俗的说，同步就是同一段时间内，只能做一件事情，跟单线程类似；</li><li><code>异步现象</code>：是指客户端发送请求到服务端，无论服务端是否返回响应，客户端都可以做其他事情，不会被卡死；通俗的说，异步就是同一段时间内，能做多件事情，跟多线程类似；</li></ul></li><li><p>Js的原生Ajax步骤；</p><pre><code class="hljs js">#创建Ajax引擎对象(所有操作都是通过Ajax引擎对象实现的)；<span class="hljs-keyword">var</span> xmlHttp = <span class="hljs-keyword">new</span> XMLHttpRequest();#绑定监听(即监听服务器是否已经返回相应的数据)；xmlHttp.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    #未返回数据则不走这里；    #返回数据后机就会走这里：    <span class="hljs-keyword">var</span> result = xmlHttp.responseText;&#125;#绑定地址(boolean参数表示，是否异步，true为异步，否则为同步)；xmlHttp.open(<span class="hljs-string">"提交方式"</span>,<span class="hljs-string">"资源访问路径"</span>,<span class="hljs-literal">true</span>);#发送请求：xmlHttp.send();</code></pre></li><li><p>Json：</p><ul><li>定义：是一种数据交互的格式，用于Ajax进行前后台的数据交互；</li><li>Json有两种格式：<ul><li><code>对象格式</code>：<code>{&quot;key1&quot;:obj, &quot;key2&quot;:obj, &quot;key3&quot;:obj}</code>，key是字符串，value是Object；</li><li><code>数组格式</code>：<code>[obj,obj,obj...]</code>。</li></ul></li></ul></li><li><p>JQuery的Ajax步骤；</p><ul><li><p>Get方式；</p><pre><code class="hljs js">$.get&#123;  #该方法乱码问题解决：参考get方式提交参数，解决乱码的方法    "xxx/xxx",  #这是请求的资源地址，即uri    &#123;"key1":obj, "key2":obj&#125;,  #这是请求所携带的参数    function(data)&#123;  #执行成功后回调的函数，即响应后走这里,data是响应回来的数据        执行操作...  #操作时，data响应信息已经被解析成了jason格式的字符串对象，可以用该对象获取属性值等    &#125;,    "json"   #指定返回的响应里面信息的格式，一般用json和text&#125;</code></pre></li><li><p>Post方式；</p><pre><code class="hljs js">$.post&#123;  #该方法乱码问题解决：不用管，或参考post提交参数，解决乱码的方法    "xxx/xxx",  #这是请求的资源地址，即uri    &#123;"key1":obj, "key2":obj&#125;,  #这是请求所携带的参数    function(data)&#123;  #执行成功后回调的函数，即响应后走这里,data是响应回来的数据        执行操作...  #操作时，data响应信息已经被解析成了jason格式的字符串对象，可以用该对象获取属性值等    &#125;,    "json"   #指定返回的响应里面信息的格式，一般用json和text&#125;</code></pre></li><li><p>常用形式；</p><pre><code class="hljs js">$.ajax(&#123;    url:"xxx/xxx",  #请求的资源地址    async:true,  #是否异步，默认为true，即默认异步    type:"POST",  #数据提交方式POST和GET    data:&#123;"xx":xx,"xx":xx&#125;,  #请求参数    success:function(data)&#123;  #请求成功后回调的函数，data是响应的数据        执行操作...    &#125;,    dataType:"json"  #返回的响应信息的格式，一般用json和text&#125;);</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>监听器</p><ul><li><p>定义：即Listener，就是监听Web服务器的运行，当发生特定事件时，采取预先设定的处理措施的组件；</p></li><li><p>监听服务：</p><ul><li>监听器一般是监听这三个域对象：即Request、Session、servletContext；</li><li>监听的内容：一般是监听上面提到的三个域对象的创建与销毁、属性的变化这两种内容；<ul><li>监听ServletContext域对象：<ul><li>ServletContextListener(主要用于监听ServletContext即Servlet容器的创建与销毁)；</li><li>ServletContextAttributeListener(主要用于监听ServletContext作用域中属性的变化，即增删改属性的变化)。</li></ul></li><li>监听Session域对象：<ul><li>HttpSessionListener(用于监听session对象的创建与销毁)；</li><li>HttpSessionAttributeListener(用户监听session作用域中属性的变化)。</li></ul></li><li>监听Request域对象：<ul><li>ServletRequestListener(主要用于监听request对象的创建与销毁)；</li><li>ServletRequestAttributeListener(主要用于监听request作用域中属性的变化)。</li></ul></li></ul></li></ul></li><li><p>监听器的编写步骤：</p><ul><li><p>编写一个监听器类(普通定义的一个类)去实现监听器Listener接口；</p></li><li><p>重写监听器的方法(可以根据方法中的参数获得所监听的对象)；</p></li><li><p>需要在web.xml中进行配置，即注册监听器；</p><pre><code class="hljs java">&lt;listener&gt;监听器类的全包名路径&lt;/listener&gt;</code></pre></li></ul></li><li><p>绑定与解绑监听器：</p><ul><li>HttpSessionBindingListenner，作用：该接口用于实体类，让其对象知道绑定与解绑的状态，绑定与解绑，决定于该类对象是否被存入或删除于Session域中；</li></ul></li><li><p>钝化与活化监听器：</p><ul><li>HttpSessionActivationListenner，作用：该接口用于实体类，让其对象知道钝化与活化的状态，如果存入Session域中的该类对象被保存到了磁盘中就是钝化，相反，从磁盘上再次恢复到Session内存中，则是活化；</li></ul></li><li><p>要想将数据序列化(保存到)磁盘上，必须实现<code>Serializable</code>接口，该接口下没有任何需要实现的方法，只需实现该接口即可；</p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>过滤器：</p><ul><li><p>定义：即Filter，JavaWeb中的过滤器可以拦截所有访问web资源的请求或响应操作；</p></li><li><p>过滤器的编写步骤；</p><ul><li><p>编写一个过滤器类实现Filter接口；</p></li><li><p>实现接口中未实现的方法(主要是doFilter方法)；</p><ul><li><p>doFilter()方法中，当过滤了请求后，一定要记得放行，即让请求通过，调用chain对象的doFilter()方法；</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> class MyFilter implements <span class="hljs-title">Filter</span><span class="hljs-params">()</span></span>&#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException</span>&#123;                    &#125;                                    <span class="hljs-comment">//这是主要的过滤的方法</span>                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletReponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException,ServletException</span>&#123;                        <span class="hljs-comment">//请求放行的方法</span>                        chain.doFilter(request,response);                    &#125;                                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span></span>&#123;                    &#125;                &#125;</code></pre></li></ul></li><li><p>在web.xml中进行配置(主要配置过滤的条件)；</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>过滤器名称<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>过滤器类的全包名路径<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>过滤器名称(要和上面的一致)<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>//这里设置过滤的条件        <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre></li></ul></li><li><p>Filter的主要作用：</p><ul><li>对公共代码的提取；</li></ul></li><li><p>可以对request和response中的方法进行增强(装饰者模式)；</p><ul><li>进行权限的控制；</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>1.대학교 일 학년</category>
      
      <category>03.Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大一课程</tag>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01.JavaSE--学习笔记</title>
    <link href="/2020/06/29/JavaSE--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/06/29/JavaSE--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaSE–学习笔记-包含JavaSE视频，Java核心技术书籍"><a href="#JavaSE–学习笔记-包含JavaSE视频，Java核心技术书籍" class="headerlink" title="JavaSE–学习笔记(包含JavaSE视频，Java核心技术书籍)"></a>JavaSE–学习笔记(包含JavaSE视频，Java核心技术书籍)</h1><h2 id="Lesson1-Java概述"><a href="#Lesson1-Java概述" class="headerlink" title="Lesson1 Java概述"></a>Lesson1 Java概述</h2><h3 id="NO1-1-Java简介"><a href="#NO1-1-Java简介" class="headerlink" title="NO1.1 Java简介"></a>NO1.1 Java简介</h3><p>Java是一门高级语言，高级语言下面还有汇编语言、机器语言。</p><ul><li>Java：<ul><li>定义：简单地说，Java 是由Sun Microsystems公司于1995年推出的一门面向对象程序设计语言。2010 年Oracle公司收购Sun Microsystems，之后由 Oracle 公司负责 Java 的维护和版本升级；</li><li>构成：Java平台由 Java 虚拟机(Java Virtual Machine，JVM)和 Java 应用编程接口(Application Programming Interface，API)构成；</li><li>Java 可分为 3 个体系，即 Java SE、Java EE 和 Java ME：<ul><li>Java SE(Java Platform Standard Edition，Java 平台标准版)以前称为 J2SE，它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为 Java EE 提供基础，如 Java 语言基础、JDBC 操作、I/O 操作、网络通信以及多线程等技术；</li><li>Java EE(Java Platform Enterprise Edition，Java 平台企业版)以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在 Java SE 基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构(Service Oriented Architecture，SOA)和 Web 2.0 应用程序；</li><li>Java ME(Java Platform Micro Edition，Java 平台微型版)以前称为 J2ME，也叫 K-JAVA。 Java ME 为在移动设备和嵌入式设备(比如手机、PDA、电视机顶盒和打印机)上运行的应用程序提供一个健壮且灵活的环境，现在使用很少。</li></ul></li><li>优点：<ul><li>面向对象：Java是一种面向对象的语言，它对对象中的类、对象、继承、封装、多态、接口、包等均有很好的支持；</li><li>跨平台性。但是JVM不是跨平台的，因为JVM要根据不同的平台提供不同版本的JVM；</li><li>多线程：Java语言是多线程的，这也是 Java 语言的一大特性，它必须由Thread类和它的子类来创建；</li><li>….等等。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-2-JVM、JRE、JDK"><a href="#NO1-2-JVM、JRE、JDK" class="headerlink" title="NO1.2 JVM、JRE、JDK"></a>NO1.2 JVM、JRE、JDK</h3><p>这三者的关系是什么呢？</p><ul><li>定义：<ul><li><code>JVM</code>：Java虚拟机。即Java文件编译完成后得到的字节码文件，需要传给JVM解释并执行；</li><li><code>JRE</code>：Java运行环境。包含Java虚拟机(即JVM)、库函数、运行Java应用程序所必需的文件；</li><li><code>JDK</code>：Java开发环境。包含JRE、以及一些用于程序开发的文件；另外我们所说的安装Java，就是安装JDK的意思。</li></ul></li></ul><p>&nbsp;</p><ul><li>三者的关系：JDK包含JRE，而JRE包含JVM。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-3-安装与配置Java"><a href="#NO1-3-安装与配置Java" class="headerlink" title="NO1.3 安装与配置Java"></a>NO1.3 安装与配置Java</h3><p>安装Java比较简单，但是不要安装错了版本。</p><ul><li>安装Java：<ul><li>下载：直接去Java官网下载对应的版本即可；</li><li>安装：这里没有什么特别需要注意的，只要自定义一个安装Java的目录即可。</li></ul></li></ul><p>&nbsp;</p><ul><li>配置JAVA(以WINDOWS为例)：<ul><li>在环境变量里新建一个变量，名为<code>JAVA_HOME</code>，值为JDK的安装目录即可；</li><li>然后再在Path变量的值的最前面，配置<code>%JAVA_HOME\bin%;</code>；<strong><code>注意：分号一定要写进去，字符全部英文小写。</code></strong></li></ul></li></ul><p>&nbsp;</p><ul><li>配置JAVA_HOME的作用是：使得我们可以在任意目录下执行javac/java等工具命令。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-4-命令行命令：javac和java"><a href="#NO1-4-命令行命令：javac和java" class="headerlink" title="NO1.4 命令行命令：javac和java"></a>NO1.4 命令行命令：javac和java</h3><p>在我们使用编码工具之前，都是使用记事本直接写Java代码的。</p><ul><li>命令行执行Java文件：<ul><li><code>javac xxxx.java</code>：当我们用记事本写完Java代码后，保存起来了，那么怎么运行呢？这就需要用到该命令了，即告诉JAVA编译这个文件。<strong><code>注意：编译xxxx.java时，xxxx文件名要与该文件中的类名保持一致，原因是：如果有一个public class类，就应该让文件名和此类名相同；那如果没有呢，即所有的class都没有修饰符，那么可以给该文件随便起名字。</code></strong></li><li><code>java xxxx</code>：当编译完Java代码后，就可以使用该命令告诉JAVA执行这个文件。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-5-IDEA的安装"><a href="#NO1-5-IDEA的安装" class="headerlink" title="NO1.5 IDEA的安装"></a>NO1.5 IDEA的安装</h3><p>为了提高我们编写代码的效率，我们使用IDEA集成工具来编写代码。</p><ul><li>IDEA：<ul><li>定义：是一款用于Java语言开发的集成环境软件；</li><li>安装：去官网选择自己喜欢的版本安装即可。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson2-JavaSE基础"><a href="#Lesson2-JavaSE基础" class="headerlink" title="Lesson2 JavaSE基础"></a>Lesson2 JavaSE基础</h2><h3 id="NO2-1-注释"><a href="#NO2-1-注释" class="headerlink" title="NO2.1 注释"></a>NO2.1 注释</h3><p>注释不会被执行，只是起到一个说明代码的辅助作用。</p><ul><li>注释：<ul><li>定义：用于解释和说明程序的文字；</li><li>特点：注释不会被JVM所执行，即不会出现在.class(字节码文件)当中。</li></ul></li></ul><p>&nbsp;</p><ul><li>注释的种类：<ul><li><code>//</code>：这是单行注释；</li><li><code>/* */</code>：这是多行注释；</li><li><code>/** */</code>：文档注释(Java特有)。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-2-关键字与标识符"><a href="#NO2-2-关键字与标识符" class="headerlink" title="NO2.2 关键字与标识符"></a>NO2.2 关键字与标识符</h3><p>关键字，顾名思义，用户不能乱使用，是被Java语言中被赋予了特殊意义的单词。</p><ul><li><p>关键字：</p><ul><li><p>定义：被Java语言赋予特定含义的单词；</p></li><li><p>特点：组成关键字单词的字母全部小写。</p><p><img src="./Image-jse1.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><ul><li>标识符：<ul><li>定义：就是给类、接口、方法、变量等起名字；</li><li>组成规则如下；<strong><code>注意：标识符不能以数字开头，不能是Java中的关键字，且区分大小写。</code></strong><ul><li>英文大小写字母；</li><li>数字字符；</li><li>可以用$和_开头；</li><li>变量名、方法名尽量遵循“驼峰规则”。<code>如，studentName、studentAge、eatFoot()、watchDoor()等等</code>；</li><li>常量的名称尽量都大写，多个单词用_隔开，这样方便区分变量和常量；</li><li>类、接口等标识符，单个单词首字母大写，或者多个单词，每个首字母都大写；</li><li>可以使用汉字，但是不建议。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-3-变量、常量以及Java数据类型"><a href="#NO2-3-变量、常量以及Java数据类型" class="headerlink" title="NO2.3 变量、常量以及Java数据类型"></a>NO2.3 变量、常量以及Java数据类型</h3><p>常量和变量是Java程序中最基础的两个元素。</p><ul><li><p>变量：</p><ul><li><p>定义：值在程序运行期间可以被修改；</p></li><li><p>本质：是一个“可操作的存储空间”，空间位置是确定的，但是里面放置什么值，却是不确定的，我们可通过变量名来访问“对应的存储空间”，从而操作这个“存储空间”存储的值；</p></li><li><p>基本语法格式：<code>数据类型 变量名 = 初始化值</code>。<strong><code>注意：变量必须先初始化以后才能使用。</code></strong></p><pre><code class="hljs java">拓展：局部变量、成员变量、静态变量的位置一、局部变量在方法或语句块内(即&#123; <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;&#125;)；成员变量在类的内部成员位置；静态变量用<span class="hljs-keyword">static</span>修饰，从属于类。</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li>常量：<ul><li>定义：值在程序运行期间无法被改变。是数据的直接表示，所以常量又称为字面常量；<code>如，final int a = 1，在整个程序运行期间，常量a的值都为1，无法再次被赋值</code>；</li><li>基本语法格式：<code>final 数据类型 变量名 = 初始化值</code>。其实就是在变量的前面，添加一个关键字final，变量就会变成常量，常量一旦被赋值过一次之后就不能够再被赋予其他值。<code>如，int i= 10，final int i = 10</code>；</li></ul></li></ul><p>&nbsp;</p><ul><li><p>Java数据类型的种类，如下图所示；<strong><code>注意：整数默认int类型，小数默认double类型，long在数字后边加个L或l特别表示，float在数字后面加个F或f特别表示。如，long c = 10000000000L，不加L会报错。</code></strong></p><p><img src="./Image-jse2.png" srcset="/img/loading.gif" alt="Image"></p><p><strong><code>注意：Java中有专门存放字符串的数据类型，即String类型，它属于引用类型；使用&quot;&quot;表示，即用两个双引号表示。</code></strong></p><pre><code class="hljs java">拓展：ASCII码表中常用值：一、<span class="hljs-string">'A'</span>十进制的值为<span class="hljs-number">65</span>，B是<span class="hljs-number">66</span>，后面字母依次加<span class="hljs-number">1</span>类推，Z为<span class="hljs-number">90</span>；二、<span class="hljs-string">'a'</span>十进制的值为<span class="hljs-number">97</span>，b是<span class="hljs-number">98</span>，后面字母依次加<span class="hljs-number">1</span>类推，z为<span class="hljs-number">122</span>；三、<span class="hljs-string">'0'</span>是<span class="hljs-number">48</span>，后面字符依次加<span class="hljs-number">1</span>类推，<span class="hljs-string">'9'</span>是<span class="hljs-number">57</span>。</code></pre></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-4-自动类型转换和强制类型转换"><a href="#NO2-4-自动类型转换和强制类型转换" class="headerlink" title="NO2.4 自动类型转换和强制类型转换"></a>NO2.4 自动类型转换和强制类型转换</h3><p>数据类型之间的转换有两种。</p><ul><li><p>数据类型转换：</p><ul><li><p>自动类型转换(也叫隐式类型转换)：数值范围小的会自动向数值范围大的数据类型转换；</p><p><img src="./Image-jse3.png" srcset="/img/loading.gif" alt="Image"></p><pre><code class="hljs java">拓展：整数运算和浮点运算注意事项一、整数运算：    <span class="hljs-number">1</span>.如果两个操作数有一个为<span class="hljs-keyword">long</span>，则结果也为<span class="hljs-keyword">long</span>；    <span class="hljs-number">2</span>.没有<span class="hljs-keyword">long</span>时，结果为<span class="hljs-keyword">int</span>；即使操作数全是<span class="hljs-keyword">byte</span>、<span class="hljs-keyword">short</span>、<span class="hljs-keyword">char</span>(这三个先转为<span class="hljs-keyword">int</span>再参与运算)，结果也是<span class="hljs-keyword">int</span>。二、浮点运算：    <span class="hljs-number">1</span>.如果两个操作数有一个为<span class="hljs-keyword">double</span>(默认的小数都是<span class="hljs-keyword">double</span>类型)，则结果为<span class="hljs-keyword">double</span>；    <span class="hljs-number">2</span>.只有两个操作数都为<span class="hljs-keyword">float</span>，则结果才为<span class="hljs-keyword">float</span>；注意：变量运算，会首先看数据类型，最终赋值时也会考虑数据类型问题；但是，常量运算，首先做运算后，看结果是否在该数据类型的范围内，如果不在范围内，才会报错；如：<span class="hljs-keyword">byte</span> b1 =<span class="hljs-number">3</span>;<span class="hljs-keyword">byte</span> b2 =<span class="hljs-number">4</span>;<span class="hljs-keyword">byte</span> b;b = b1+b2;  <span class="hljs-comment">//这里会报错，因为变量相加，byte首先转成int然后再相加，结果为int，再赋值强制转换成byte，有可能损失精度，所以报错</span>b = <span class="hljs-number">3</span>+<span class="hljs-number">4</span>;  <span class="hljs-comment">//这里的3和4是常量，在编译的时候就已经运算完毕，结果7在byte范围内，所以能够赋值给b，且没有报错</span><span class="hljs-comment">//==========================================================</span>拓展：值溢出问题一、当两个操作数都为某一数据类型，相互运算后，得到的值超出了这个默认数据类型的范围，值就会变为负数。如：<span class="hljs-keyword">int</span> a = <span class="hljs-number">1000000000</span>;  <span class="hljs-comment">//a=10亿</span><span class="hljs-keyword">int</span> years = <span class="hljs-number">20</span>;<span class="hljs-keyword">int</span> total = a*years;  <span class="hljs-comment">//值为200亿，就超出了int类型的最大范围21亿，这时候得到的total就为一个负数</span>注意：解决如上问题，只需要将数据间的某个数据强制转换为值更大的数据类型即可，即：<span class="hljs-keyword">int</span> total = a*(<span class="hljs-keyword">long</span>)years；就能够解决值溢出的问题</code></pre></li></ul></li><li><p>强制类型转换(也叫显示类型转换)：从表示范围大的类型转换为表示范围小的类型，需要强制转换；</p><pre><code><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">324</span>;<span class="hljs-comment">//因为int类型数值范围比long小，所以可以将值赋给b</span><span class="hljs-keyword">long</span> b = a;<span class="hljs-comment">//因为long类型的数值范围比double小，所以自动转换为double类型，但有可能损失精度</span><span class="hljs-keyword">double</span> c = b;</code></pre></code></pre></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-5-二进制、八进制、十进制、十六进制"><a href="#NO2-5-二进制、八进制、十进制、十六进制" class="headerlink" title="NO2.5 二进制、八进制、十进制、十六进制"></a>NO2.5 二进制、八进制、十进制、十六进制</h3><p>进制，其实就是一个数据的不同形式表示。</p><ul><li>进制：<ul><li>定义：一个数据的不同形式表示；</li><li>常用进制：二进制、八进制、十进制、十六进制；<ul><li>二进制：以<code>0b</code>或者<code>0B</code>开头，由0和1构成；</li><li>八进制：以<code>0</code>开头，由0到7构成；</li><li>十六进制：以<code>0x</code>或者<code>0X</code>开头，由0到9、a(10)、b(11)、c(12)、d(13)、e(14)、f(15)构成。</li></ul></li><li>规则：二进制就是逢二进一….，以此类推，十六进制就是逢十六进一等等；</li></ul></li></ul><p>&nbsp;</p><ul><li><p>进制间的转换：</p><ul><li><p>任何进制转十进制：<code>每一位上的数据值*进制(二进制乘以二，八进制乘以八，十六进制乘以十六)^从右往左且幂从0开始</code>；</p><pre><code class="hljs java">二进制的<span class="hljs-number">0b100</span>，转为十进制：        <span class="hljs-number">1</span>*<span class="hljs-number">2</span>^<span class="hljs-number">2</span>+<span class="hljs-number">0</span>*<span class="hljs-number">2</span>^<span class="hljs-number">1</span>+<span class="hljs-number">0</span>*<span class="hljs-number">2</span>^<span class="hljs-number">0</span> = <span class="hljs-number">4</span>                八进制的<span class="hljs-number">0125</span>，转为十进制：        <span class="hljs-number">1</span>*<span class="hljs-number">8</span>^<span class="hljs-number">2</span>+<span class="hljs-number">2</span>*<span class="hljs-number">8</span>^<span class="hljs-number">1</span>+<span class="hljs-number">5</span>*<span class="hljs-number">8</span>^<span class="hljs-number">0</span> = <span class="hljs-number">85</span>                十六进制的<span class="hljs-number">0x544</span>，转为十进制：        <span class="hljs-number">5</span>*<span class="hljs-number">16</span>^<span class="hljs-number">2</span>+<span class="hljs-number">4</span>*<span class="hljs-number">16</span>^<span class="hljs-number">1</span>+<span class="hljs-number">4</span>*<span class="hljs-number">16</span>^<span class="hljs-number">0</span> = <span class="hljs-number">1348</span></code></pre></li><li><p>十进制转任意进制：<code>直接用这个数除以进制数(二进制除以二，八进制除以八，十六进制除以十六)，直到商为0，余数反转即可</code>；</p><pre><code class="hljs java">十进制的<span class="hljs-number">125</span>，转为二进制：<span class="hljs-number">0b1111101</span>；            <span class="hljs-number">125</span> / <span class="hljs-number">2</span> = <span class="hljs-number">62</span>   余<span class="hljs-number">1</span>        <span class="hljs-number">62</span> / <span class="hljs-number">2</span> = <span class="hljs-number">31</span>    余<span class="hljs-number">0</span>            <span class="hljs-number">31</span> / <span class="hljs-number">2</span> = <span class="hljs-number">15</span>    余<span class="hljs-number">1</span>            <span class="hljs-number">15</span> / <span class="hljs-number">2</span> = <span class="hljs-number">7</span>     余<span class="hljs-number">1</span>            <span class="hljs-number">7</span> / <span class="hljs-number">2</span> = <span class="hljs-number">3</span>      余<span class="hljs-number">1</span>            <span class="hljs-number">3</span> / <span class="hljs-number">2</span> = <span class="hljs-number">1</span>      余<span class="hljs-number">1</span>            <span class="hljs-number">1</span> / <span class="hljs-number">2</span> = <span class="hljs-number">0</span>      余<span class="hljs-number">1</span>            结果反转为<span class="hljs-number">1111101</span></code></pre></li><li><p>二进制和十进制的相互快速转换；</p><ul><li><p>二进制转十进制：只需要将二进制上每个1位上的十进制数相加即可；</p></li><li><p>十进制转二进制：看十进制的值是否够二进制每一位的值，够的话则相应的二进制位为1，并减去该值，得到的差再继续比较，如果不够则为0；也就是我们常说的8421码：</p><p><code>二进制  1  1  1  1  1  1  1  1</code></p><p><code>十进制 128 64 32 16 8  4  2  1</code></p><pre><code class="hljs java">二进制转十进制            <span class="hljs-number">0b1010100</span> = <span class="hljs-number">64</span> + <span class="hljs-number">0</span> + <span class="hljs-number">16</span> + <span class="hljs-number">0</span> + <span class="hljs-number">4</span> + <span class="hljs-number">0</span> + <span class="hljs-number">0</span> = <span class="hljs-number">84</span>                    十进制转二进制        <span class="hljs-number">100</span> = <span class="hljs-number">0b1100100</span></code></pre></li></ul></li><li><p>任意进制到任意进制的转换：</p><ul><li><p>先转成十进制再转成目标进制即可；</p></li><li><p>三位归并法(主要用于二进制转成八进制，而八进制转成二进制称为1位分三位)：每三位一组，不够位数的左边添0，求出每个三位的二进制值，最后结果拼接即可；</p><pre><code class="hljs java">二进制<span class="hljs-number">0b1100110</span>转八进制：            <span class="hljs-number">001</span> <span class="hljs-number">100</span> <span class="hljs-number">110</span>        <span class="hljs-number">1</span>   <span class="hljs-number">4</span>   <span class="hljs-number">6</span> = <span class="hljs-number">0146</span></code></pre></li><li><p>四位归并法(主要用于二进制转成十六进制，而十六进制转成二进制称为1位分四位)：每四位一组，不够位数的左边添0，求出每个四位的二进制值，最后结果拼接即可；</p><pre><code class="hljs java">二进制<span class="hljs-number">0b1100110</span>转十六进制：        <span class="hljs-number">0110</span> <span class="hljs-number">0110</span>    <span class="hljs-number">6</span>    <span class="hljs-number">6</span> = <span class="hljs-number">0x66</span></code></pre></li></ul></li></ul></li></ul><h3 id="NO2-6-原码、反码、补码"><a href="#NO2-6-原码、反码、补码" class="headerlink" title="NO2.6 原码、反码、补码"></a>NO2.6 原码、反码、补码</h3><p>计算机内部的运算都是采用一个数的补码进行运算的。</p><ul><li>在计算机内，有符号数(即正负数)有3种表示法(都是二进制)：原码、反码、补码；所有数据的运算都采用补码进行的；</li></ul><p>&nbsp;</p><ul><li><p>原码：<strong><code>注意：原码就是二进制定点表示法(你可以理解为其实就是二进制)，即最高位为符号位，0表示正数，1表示负数，其余位表示数值大小。</code></strong></p><ul><li><p>正数：符号位为0的二进制；</p></li><li><p>负数：符号位为1的二进制。</p><pre><code class="hljs java">+<span class="hljs-number">7</span> 和 -<span class="hljs-number">7</span>        二进制为：<span class="hljs-number">111</span>        +<span class="hljs-number">7</span> 的原码为<span class="hljs-number">00000111</span>        -<span class="hljs-number">7</span> 的原码则为<span class="hljs-number">10000111</span></code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>反码：</p><ul><li><p>正数：正数的反码与其原码相同；</p></li><li><p>负数：负数的反码是对其原码逐位取反(即0变1，1变0)，但符号位不变；</p><pre><code class="hljs java">+<span class="hljs-number">7</span> 的原码为<span class="hljs-number">00000111</span>，反码也是<span class="hljs-number">00000111</span>        -<span class="hljs-number">7</span> 的原码为<span class="hljs-number">10000111</span>，反码则是<span class="hljs-number">11111000</span></code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>补码：</p><ul><li><p>正数：正数的补码和原码相同；</p></li><li><p>负数：负数的补码是在其反码的末位(即数值位的最右边的一位)加1；</p><pre><code class="hljs java">+<span class="hljs-number">7</span> 的原码为<span class="hljs-number">00000111</span>，反码也是<span class="hljs-number">00000111</span>，补码仍然为<span class="hljs-number">00000111</span>        -<span class="hljs-number">7</span> 的原码为<span class="hljs-number">10000111</span>，反码则是<span class="hljs-number">11111000</span>，补码变成<span class="hljs-number">11111001</span></code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-7-运算符"><a href="#NO2-7-运算符" class="headerlink" title="NO2.7 运算符"></a>NO2.7 运算符</h3><p>运算符有许多种，常用在变量、表达式、方法中等等。</p><ul><li><p>算数运算符：</p><ul><li><p><code>+、-、*、/、%</code>：即加、减、乘、除、和取余；<strong><code>注意：这里的减号，除了用作减号外，还可以用作负号；加号除了用作加号，还能当作正号和字符串连接符。</code></strong></p><pre><code class="hljs java">    拓展：取模运算、整数相除的注意事项    一、取模运算(即取余运算)中，获得的余数的符号和%号前面的数(被除数)符号相同；    如：    <span class="hljs-number">9</span>%(-<span class="hljs-number">5</span>)=<span class="hljs-number">4</span>;    -<span class="hljs-number">9</span>%<span class="hljs-number">5</span>=-<span class="hljs-number">4</span>;        二、整数相除只能获得整数，想要获得小数，将其中一个操作数转换为<span class="hljs-keyword">double</span>类型即可；    如：    <span class="hljs-number">3</span>/<span class="hljs-number">4</span> =<span class="hljs-number">0</span>;<span class="hljs-number">3</span>*<span class="hljs-number">1.0</span>/<span class="hljs-number">4</span>=<span class="hljs-number">0.75</span>;</code></pre></li><li><p><code>++、--</code>：即自增和自减。</p><ul><li><p>单独使用时：自身的值只是单纯的加一或者减一；</p></li><li><p>和其他操作数一起使用时：</p><ul><li><p><code>++/--操作数</code>：先加一或者减一，再进行操作；</p></li><li><p><code>操作数++/--</code>：先操作，然后再加一或者减一。</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> a =<span class="hljs-number">1</span>;                        a++;            或            ++a;                        <span class="hljs-comment">//结果都一样，为2</span>            a=<span class="hljs-number">2</span>                                    <span class="hljs-comment">//===================================</span>                        <span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>;                        <span class="hljs-comment">//先自增然后再操作，即先a+1，再赋值给b</span>            <span class="hljs-keyword">int</span> b = ++a;                        <span class="hljs-comment">//所以，结果为</span>            a=<span class="hljs-number">4</span>,b=<span class="hljs-number">4</span>                        <span class="hljs-comment">//--------------------------------------</span>                        <span class="hljs-comment">//先赋值给b，然后a再自增</span>            <span class="hljs-keyword">int</span> b = a++;                        <span class="hljs-comment">//所以，结果为</span>            a=<span class="hljs-number">4</span>,b=<span class="hljs-number">3</span></code></pre></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>赋值运算符：</p><ul><li><p><code>=</code>：为变量或常量指定数值的符号；<strong><code>注意：不要将赋值运算符与相等运算符“==”混淆。</code></strong></p></li><li><p><code>+=、-=、*=、/=、%=</code>：将该运算符左边的数值与右边的数值进行加减乘除取余操作(只有一种生效)， 得到的结果赋值给左边变量本身。</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> a=<span class="hljs-number">5</span>;        a+=<span class="hljs-number">2</span>;        a=<span class="hljs-number">7</span>                    拓展：a = a+<span class="hljs-number">1</span> 和 a+= <span class="hljs-number">1</span>的区别        一、a+=b，即a=(a的数据类型)(a+b)，隐含了强制类型转换；                二、a=a+<span class="hljs-number">1</span>则不含强制转换。                    如：        <span class="hljs-keyword">short</span> s = <span class="hljs-number">1</span>;                <span class="hljs-comment">//这里的s+1结果为int类型，转为short时，会报错，因为有可能损失精度</span>        s = s + <span class="hljs-number">1</span>;                  <span class="hljs-comment">//等价于s = (s的数据类型)(s+1)，因为隐含了强制类型转换，所以赋值给s不会报错；</span>        s += <span class="hljs-number">1</span>;                  <span class="hljs-comment">//===========================================</span>                拓展：乘除扩展运算        一、如下所示：        如：        a*=b+<span class="hljs-number">3</span>;                a=a*(b+<span class="hljs-number">3</span>);</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>关系运算符：</p><ul><li><p><code>&gt;、&gt;=、&lt;、&lt;=、==、!=</code>：也称为“比较运算符”，用来比较判断两个变量或常量或表达式的大小。运算结果是boolean型。当运算符对应的关系成立时，运算结果是true，否则是false。</p><pre><code class="hljs java"><span class="hljs-number">4</span>==<span class="hljs-number">4</span>  <span class="hljs-comment">//结果为true</span>        <span class="hljs-number">97</span>==<span class="hljs-string">'a'</span>  <span class="hljs-comment">//结果为true</span>        <span class="hljs-number">5.0</span>==<span class="hljs-number">5</span>  <span class="hljs-comment">//结果为true</span>        <span class="hljs-keyword">true</span>==<span class="hljs-keyword">false</span> <span class="hljs-comment">//结果为false</span>        <span class="hljs-number">4</span>!=<span class="hljs-number">2</span>  <span class="hljs-comment">//结果为true</span></code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li>逻辑运算符：<strong><code>注意：逻辑运算符是对布尔型变量进行运算，其结果也是布尔型。</code></strong><ul><li><code>&amp;</code>：逻辑与。<code>如，a&amp;b，a和b 全为true时，计算结果为true，否则为false</code>；</li><li><code>|</code>：逻辑或。<code>如，a|b，a和b 全为false时，计算结果为false，否则为true</code>；</li><li><code>!</code>：逻辑非。<code>如，!a，a 为true时，值为false，a 为false时，值为true</code>；</li><li><code>&amp;&amp;</code>：短路与。<code>如，a&amp;&amp;b，a和b 全为true时，计算结果为true，否则为false</code>；<ul><li>&amp;&amp;与&amp;区别：如果a为false，则不计算 b(因为不论 b 为何值，结果都为 false)。</li></ul></li><li><code>||</code>：短路或。<code>如，a||b，a和b 全为false时，计算结果为false，否则为true</code>；<ul><li>||与|区别：如果a为true，则不计算 b(因为不论 b 为何值，结果都为 true)。</li></ul></li><li><code>^</code>：逻辑异或。<code>如，a^b，a和b都相同，则返回false，不同则返回true</code>。</li></ul></li></ul><p>&nbsp;</p><ul><li><p>位运算符：</p><ul><li><p><code>&amp;</code>：与。对两个操作数的补码进行操作，简记：<code>有0则0，两1为1</code>；</p></li><li><p><code>|</code>：或。对两个操作数的补码进行操作，简记：<code>有1则1，两0为0</code>；</p></li><li><p><code>~</code>：非。对一个操作数的补码进行操作，简记：<code>0变1，1变0</code>；</p></li><li><p><code>^</code>：异或。对两个操作数的补码进行操作，简记：<code>相同则0，不同则1</code></p></li><li><p><code>&lt;&lt;</code>：左移运算符。简单的说就是将操作数的补码进行左移操作，左移1位，相当于乘以一个2，左移2位，乘以两个2；即该数的补码，向左移动指定位数，不论正负数，左边最高位丢弃，右边用0补齐；<code>如，3&lt;&lt;2= 3*2*2 = 12</code>。</p></li><li><p><code>&gt;&gt;</code>：右移运算符。简单的说就是将操作数的补码进行右移操作，右移1位，相当于除以一个2取商，右移2位，除以两个2取商；该数的补码，向右移动指定位数，最高位是0，左边用0补齐；最高位是1，左边补齐1；<code>如，12&gt;&gt;2= 12/2/2 = 3</code>。</p></li><li><p><code>&gt;&gt;&gt;</code>：无符号右移。即该数的补码，向右移动指定位数，然后符号位不论0还是1，都用0补齐；</p><pre><code class="hljs angelscript"><span class="hljs-number">3</span>的二进制：<span class="hljs-number">0x11</span>        <span class="hljs-number">4</span>的二进制：<span class="hljs-number">0x100</span>                    <span class="hljs-number">3</span> &amp; <span class="hljs-number">4</span> (&amp;位与运算：有<span class="hljs-number">0</span>则<span class="hljs-number">0</span>)：           <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000011</span> --<span class="hljs-number">-3</span>的二进制补码        &amp;  <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000100</span> --<span class="hljs-number">-4</span>的二进制补码        -----------------------------------------           <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> 结果为<span class="hljs-number">0</span>                    <span class="hljs-number">3</span> | <span class="hljs-number">4</span> (|位或运算：有<span class="hljs-number">1</span>则<span class="hljs-number">1</span>)：           <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000011</span> --<span class="hljs-number">-3</span>的二进制补码        |  <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000100</span> --<span class="hljs-number">-4</span>的二进制补码        -----------------------------------------           <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000111</span> 结果为<span class="hljs-number">7</span>                    <span class="hljs-number">3</span> ^ <span class="hljs-number">4</span> (^位异或运算：相同则<span class="hljs-number">0</span>，不同则<span class="hljs-number">1</span>)：           <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000011</span> --<span class="hljs-number">-3</span>的二进制补码        ^  <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000100</span> --<span class="hljs-number">-4</span>的二进制补码        -----------------------------------------           <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000111</span> 结果为<span class="hljs-number">7</span>                    ~ <span class="hljs-number">3</span> (~按位取反运算：<span class="hljs-number">0</span>变<span class="hljs-number">1</span>，<span class="hljs-number">1</span>变<span class="hljs-number">0</span>)：                ~  <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000011</span> --<span class="hljs-number">-3</span>的二进制补码        -----------------------------------------           <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111100</span>                    补码：<span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111100</span>            反码：<span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111011</span>            原码：<span class="hljs-number">10000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000100</span> ---结果为<span class="hljs-number">-4</span>                    注意：^(位异或运算)的特点：一个数对另一个数位异或两次，最后的结果仍然为第一个数。如：        <span class="hljs-built_in">int</span> a =<span class="hljs-number">10</span>;        <span class="hljs-built_in">int</span> b =<span class="hljs-number">20</span>;                a^b^b = <span class="hljs-number">10</span>;        a^b^a = <span class="hljs-number">20</span>;</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li>三元运算符：<ul><li>基本语法格式：<code>x?a:b</code>。即，当x(该x为boolean表达式)为true时，输出a，反之则输出b，三元运算符一定返回一个结果，所以必须有变量去接收这个结果。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-8-获取用户输入"><a href="#NO2-8-获取用户输入" class="headerlink" title="NO2.8 获取用户输入"></a>NO2.8 获取用户输入</h3><p>我们常常会想要获取用户的输入。</p><ul><li><p>获取用户输入：</p><ul><li><p>基本语法格式：</p><pre><code class="hljs java">Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);  <span class="hljs-comment">//获取键盘录入的对象</span>System.out.println(<span class="hljs-string">"请输入您的名字"</span>);  <span class="hljs-comment">//为了提升用户体验，添加了这句代码</span>String inputName = sc.nextLine();  <span class="hljs-comment">//接收数据</span></code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-9-流程控制语句"><a href="#NO2-9-流程控制语句" class="headerlink" title="NO2.9 流程控制语句"></a>NO2.9 流程控制语句</h3><p>我们使用流程控制语句来控制程序的走向。</p><ul><li><p>基本流程控制语句：</p><ul><li><p><code>if</code>：符合条件就进入，否则就不进入。最简单的流程控制语句；</p><ul><li><p>基本语法格式：</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(条件表达式)&#123;要执行的代码&#125;</code></pre></li></ul></li><li><p><code>if-else</code>：二选一，即要么进入if代码块中，要么进入else代码块中；</p><ul><li><p>基本语法格式：</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(条件表达式)&#123;要执行的代码&#125;<span class="hljs-keyword">else</span>&#123;要执行的代码&#125;</code></pre></li></ul></li><li><p><code>if-elseif-else</code>：可以有多重选择(也就是可以有多个elseif)，但只会选择进入一个；</p><ul><li><p>基本语法格式：</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(条件表达式)&#123;要执行的代码&#125;elseif&#123;要执行的代码&#125;....&#123;要执行的代码&#125;<span class="hljs-keyword">else</span>&#123;要执行的代码&#125;</code></pre></li></ul></li><li><p><code>switch-case</code>：也是在多个选择中选择一个进入。</p><ul><li><p>基本语法格式：</p><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(条件表达式)&#123;    <span class="hljs-keyword">case</span> 常量<span class="hljs-number">1</span>:    要执行的语句<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> 常量<span class="hljs-number">2</span>:    要执行的语句<span class="hljs-keyword">break</span>;        ....        <span class="hljs-keyword">default</span>:  <span class="hljs-comment">//前面都没有匹配上的话，就会走这里，和if-else中的else差不多</span>    要执行的语句<span class="hljs-keyword">break</span>;&#125;拓展：<span class="hljs-keyword">case</span>穿透一、<span class="hljs-keyword">switch</span>选择结构语句中，<span class="hljs-keyword">case</span>后面放的是常量；    二、一定要在语句体中写<span class="hljs-keyword">break</span>，否则会产生<span class="hljs-keyword">case</span>穿透，即语句一直往下走，直到有<span class="hljs-keyword">break</span>的语句体中。如：    <span class="hljs-keyword">switch</span>(<span class="hljs-number">1</span>)&#123;    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:&#123;    <span class="hljs-comment">//如果这里没有break，则程序会继续执行下面语句的内容，产生case穿透</span>    System.out.println(<span class="hljs-string">"这是1"</span>);    <span class="hljs-comment">//break;</span>    &#125;    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:&#123;    System.out.println(<span class="hljs-string">"这是2"</span>);    <span class="hljs-keyword">break</span>;    &#125;&#125;注意：上面的输出结果为：这是<span class="hljs-number">1</span>，这是<span class="hljs-number">2</span>，两条语句输出，这是因为<span class="hljs-keyword">case</span> <span class="hljs-number">1</span> 的语句体中没有<span class="hljs-keyword">break</span>，产生<span class="hljs-keyword">case</span>穿透</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>循环控制语句：</p><ul><li><p><code>for循环</code>：是有限次数的循环；</p><ul><li><p>基本语法格式：</p><pre><code class="hljs java"><span class="hljs-keyword">for</span>(初始化条件;循环判断条件;迭代条件)&#123;循环体代码&#125;拓展：foreach循环，该方式用的频率很高，牢记<span class="hljs-keyword">for</span>(类型 变量名:集合) &#123;    语句块;&#125;<span class="hljs-comment">//===========================</span>拓展：死循环的写法一、<span class="hljs-keyword">for</span>(;;)，要避免死循环。    <span class="hljs-comment">//===========================</span>    拓展：九九乘法表一、代码如下：<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> h =<span class="hljs-number">1</span>;h&lt;=<span class="hljs-number">9</span>;h++) &#123;<span class="hljs-comment">//外循环控制行</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=h;i++) &#123;<span class="hljs-comment">//里循环控制列</span>        System.out.print(i+<span class="hljs-string">"*"</span>+h+<span class="hljs-string">"="</span>+h*i+<span class="hljs-string">"\t"</span>);    &#125;    <span class="hljs-comment">//这是每输出一行后，进行换行</span>    System.out.println();&#125;</code></pre></li></ul></li><li><p><code>while循环</code>：无限次数的循环；</p><ul><li><p>基本语法格式：</p><pre><code class="hljs java"><span class="hljs-keyword">while</span>(循环判断条件)&#123;循环体代码&#125;拓展：死循环的写法一、<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)，要避免死循环。另外，循环之间可以嵌套使用，即多重循环。</code></pre></li></ul></li><li><p><code>do-while循环</code>(Java中用的不多)：也是无限次数的循环，只不过和while不同的是，该循环会先进行循环再查看是否符合循环条件。</p><ul><li><p>基本语法格式：</p><pre><code class="hljs java"><span class="hljs-keyword">do</span>&#123;循环体代码&#125;<span class="hljs-keyword">while</span>(循环判断条件)</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>continue、break、return关键字。</p><ul><li><p>continue：是指当符合条件时，continue会跳出当前循环(也就是continue后面的语句不会执行)，并进行下一次循环；</p></li><li><p>break：是指当符合条件时，break会跳出循环，即停止循环；</p></li><li><p>return：是指结束方法，后面的语句不会再执行；</p><pre><code class="hljs java"><span class="hljs-comment">//输出100至150之间的所有不能被3整除的数，并且每行输出5个</span>                <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n = <span class="hljs-number">100</span>; n &lt;= <span class="hljs-number">150</span>; n++)&#123;                    <span class="hljs-comment">//当n为被3整除的数时，就进入这里，并跳出当前循环，进入下一次循环</span>            <span class="hljs-keyword">if</span>(n%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>)&#123;                        <span class="hljs-comment">//遇到continue，跳出当前循环(continue后面的代码不再执行)，进入下一次循环</span>                <span class="hljs-comment">//continue;</span>                        System.out.println(<span class="hljs-string">"我是continue后面的代码，我是永远不会执行的，因为已经进入下一次循环了"</span>);                        <span class="hljs-comment">//遇到break关键字，直接停止循环</span>                <span class="hljs-comment">//break;</span>            &#125;                    <span class="hljs-comment">//打印输出不能被3整除的数字</span>            System.out.print(n+<span class="hljs-string">"\t"</span>);                    <span class="hljs-comment">//定义一个统计变量，判断是否需要进行换行操作，也就是输出5个数字后进行换行操作</span>            count++;            <span class="hljs-keyword">if</span>(count==<span class="hljs-number">5</span>)&#123;                        <span class="hljs-comment">//换行</span>                System.out.println();                        <span class="hljs-comment">//初始化count变量值</span>                count=<span class="hljs-number">0</span>;            &#125;        &#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO-2-10-数组"><a href="#NO-2-10-数组" class="headerlink" title="NO 2.10 数组"></a>NO 2.10 数组</h3><p>数组是同一类型数据的集合。</p><ul><li><p>数组：</p><ul><li><p>定义：即同一类型数据的集合，就称为数组。<code>如，一个公司，都是为公司工作的人，那么这个公司其实就可以看成是一个数组，因为都存放了为公司工作的人这种同一类型的数据</code>。</p></li><li><p>数组的三个基本特点；</p><ul><li>长度是确定的。数组一旦被创建，它的大小就是不可以改变的；</li><li>其元素必须是相同类型，不允许出现混合类型；</li><li>数组类型可以是任何数据类型，包括基本类型和引用类型，但数组的所有元素必须是同一数据类型。</li></ul></li><li><p>基本语法格式：<strong><code>注意：根据数据类型初始化默认值，基本类型是0，引用类型是null，布尔类型是false，char类型是&#39;\u0000&#39;(即空字符，什么都没有)。</code></strong></p><ul><li>动态初始化数方式(默认是该方式初始化数组)：<code>数据类型[] 变量名 = new 数据类型[长度]</code>。<code>如，int[] arr1 = new int[10]，该数组长度是10，下标为0到9，即0到arr.length-1</code>。</li><li>静态初始化数组方式(推荐这个方式)：<code>数据类型[] 变量名 = {元素1,元素2..}</code>。<code>如，int[] arr2 = {1,2,3,4,5}，该数组长度是5</code>。</li></ul></li><li><p>数组长度：<code>数组名.length</code>；</p></li><li><p>数组元素赋值：<code>数组名[索引值]=值</code>；<strong><code>注意：索引是从0开始的。</code></strong></p></li><li><p>数组调用：<code>数组名[索引值]</code>。</p><pre><code class="hljs java">拓展：数组反转(推荐用这个)如：<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myArrayReverse2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> start =<span class="hljs-number">0</span>,end = array.length-<span class="hljs-number">1</span>;start &lt;= end;start++,end--)&#123;        <span class="hljs-keyword">int</span> temp = array[start];        array[start] = array[end];        array[end] = temp;    &#125;&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>二维数组：</p><ul><li><p>定义：就是元素为一维数组的一个数组；</p></li><li><p>基本语法格式：</p><ul><li><p>动态初始化：<code>数据类型[][] 数组名 = new 数据类型[m][n]</code>。 m：这个二维数组中有m个一维数组；n表示，每一个一维数组的元素有n个，但是n一般不直接定义，都是动态定义的，即n可以不用定义：<code>数据类型[][] 数组名 = new 数据类型[m][]</code>。</p></li><li><p>静态初始化：<code>数据类型[][] 数组名=new 数据类型[][]{ {x},{x},{x} }</code>。(推荐)简化版：<code>数据类型[][] 数组名={ {x},{x},{x} }</code>。</p><pre><code class="hljs java">拓展：二维数组的遍历如：<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traversingElements</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] arr)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x =<span class="hljs-number">0</span>;x&lt;arr.length;x++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;y&lt;arr[x].length;y++)&#123;            System.out.println(arr[x][y]);        &#125;    &#125;&#125;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-11-Arrays工具类"><a href="#NO2-11-Arrays工具类" class="headerlink" title="NO2.11 Arrays工具类"></a>NO2.11 Arrays工具类</h3><p>我们可以使用Arrays工具类来对数组进行一些方便的操作。</p><ul><li>Arrays类常见的方法：<ul><li>String toString(int[] arr)：把数组转成字符串；</li><li>void sort(int[] arr)：对数组进行排序；</li><li>int binarySearch(int[] arr,int key)：二分查找，返回要查找的元素的索引值；</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-12-冒泡排序、选择排序、二分查找法"><a href="#NO2-12-冒泡排序、选择排序、二分查找法" class="headerlink" title="NO2.12 冒泡排序、选择排序、二分查找法"></a>NO2.12 冒泡排序、选择排序、二分查找法</h3><p>常见的算法是我们必须要会的。</p><ul><li><p>冒泡排序(重要)：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">arrayReverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;            <span class="hljs-comment">//外循环控制比较的次数，最大次数为数组长度-1</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>; count&lt;arr.length-<span class="hljs-number">1</span>; count++) &#123;                <span class="hljs-comment">//内循环两两比较，-1是为了不超出最大索引，-count是为了去除已经参与比较过的元素个数</span>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>; x&lt;arr.length-<span class="hljs-number">1</span>-count; x++) &#123;                    <span class="hljs-keyword">if</span>(arr[x] &gt; arr[x+<span class="hljs-number">1</span>]) &#123;                        <span class="hljs-keyword">int</span> temp = arr[x];                    arr[x] = arr[x+<span class="hljs-number">1</span>];                    arr[x+<span class="hljs-number">1</span>] = temp;                &#125;            &#125;        &#125;    &#125;</code></pre></li></ul><p>&nbsp;</p><ul><li><p>选择排序；</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">arrayReverse2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;            <span class="hljs-comment">//假设一个最小值的索引，依次+1，最多能到最大索引-1</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> min = <span class="hljs-number">0</span>; min &lt; arr.length - <span class="hljs-number">1</span>; min++) &#123;                <span class="hljs-comment">//与数组的第min+1位索引开始比较</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = min+<span class="hljs-number">1</span>; x &lt; arr.length; x++) &#123;                    <span class="hljs-keyword">if</span> (arr[x] &lt; arr[min]) &#123;                        <span class="hljs-keyword">int</span> temp = arr[min];                    arr[min] = arr[x];                    arr[x] = temp;                &#125;            &#125;        &#125;    &#125;</code></pre></li></ul><p>&nbsp;</p><ul><li><p>二分查找法(注意：该查找法必须要求数组是有序的)：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> value)</span> </span>&#123;            <span class="hljs-keyword">int</span> minIndex = <span class="hljs-number">0</span>; <span class="hljs-comment">//最小索引</span>            <span class="hljs-keyword">int</span> maxIndex = arr.length-<span class="hljs-number">1</span>; <span class="hljs-comment">//最大索引</span>            <span class="hljs-keyword">int</span> midIndex = (minIndex + maxIndex)/<span class="hljs-number">2</span>; <span class="hljs-comment">//中间索引</span>            <span class="hljs-comment">//先判断是否比数组中最大的还大，比最小的还小，则不存在该元素，直接返回-1</span>        <span class="hljs-keyword">if</span>(value &gt; arr[maxIndex] || value &lt; arr[minIndex])&#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;            <span class="hljs-keyword">while</span>(value != arr[midIndex]) &#123;                <span class="hljs-keyword">if</span>(value &lt; arr[midIndex]) &#123; <span class="hljs-comment">//假设要查找的值，比中间的值小</span>                    maxIndex = midIndex-<span class="hljs-number">1</span>; <span class="hljs-comment">//最大索引变为中间索引-1</span>                &#125;<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//假设要查找的值，比中间的值大</span>                    minIndex = midIndex+<span class="hljs-number">1</span>; <span class="hljs-comment">//最小索引值变为中间索引+1</span>                &#125;                midIndex = (minIndex + maxIndex)/<span class="hljs-number">2</span>; <span class="hljs-comment">//继续求中间索引</span>        &#125;        <span class="hljs-keyword">return</span> midIndex;    &#125;</code></pre></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson3-面向对象基础"><a href="#Lesson3-面向对象基础" class="headerlink" title="Lesson3 面向对象基础"></a>Lesson3 面向对象基础</h2><h3 id="NO3-1-类和对象"><a href="#NO3-1-类和对象" class="headerlink" title="NO3.1 类和对象"></a>NO3.1 类和对象</h3><p>对Java来说，一切皆是对象。面向对象的三大核心特性：继承、封装和多态。</p><ul><li><p>类和对象：</p><ul><li><p>解释：</p><ul><li>类：实际上表示的是一个客观世界某类群体的一些基本特征抽象；你可以理解为就像设计图一样，用这个来创造东西；</li><li>对象：表示的是一个个具体的东西。所以说类是对象的抽象，对象是类的具体。用设计图创造出来的东西就叫做对象。</li></ul></li><li><p>定义：</p><ul><li>类：是概念模型，定义对象的所有特性和所需的操作。</li><li>对象：是真实模型，是一个具体的实体。<code>如，“人类”只是一个抽象的概念，它仅仅是一个概念，是不存在的实体！但是所有具备“人类”这个群体的属性(一些参数、数值)与方法(一些行为，他能干什么)的对象都叫人！这个对象“人” 是实际存在的实体！每个人都是“人类”这个群体的一个对象</code>。</li></ul></li><li><p>地位：在面向对象中，类和对象是最基本、最重要的组成单元。</p></li><li><p>属性：对象或实体所拥有的特征在类中表示时称为类的属性。<code>如，每个人都具有姓名、年龄和体重，这是所有人共有的特征。但是每一个对象的属性值又各不相同，就像小明和小红都具有体重这个属性，但是他们的体重值是不同的</code>。</p></li><li><p>方法：对象执行的操作称为类的方法。<code>如，“人”这个对象都具有的行为是“吃饭”，因此，吃饭就是“人”类的一个方法</code>。</p></li><li><p>基本语法格式：</p><ul><li><p>类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 类名</span>&#123;    <span class="hljs-comment">// 定义属性部分(也叫成员变量)</span>    属性数据类型 属性名<span class="hljs-number">1</span>;    属性数据类型 属性名<span class="hljs-number">2</span>;    <span class="hljs-comment">//定义方法部分(也叫成员方法)</span>    function1();    function2();    function3();&#125;如：<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;String name;<span class="hljs-keyword">int</span> age;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"正在学习"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"正在吃饭"</span>);&#125;&#125;</code></pre></li><li><p>对象：</p><pre><code class="hljs java">类名 对象名 = <span class="hljs-keyword">new</span> 类名();  <span class="hljs-comment">//创建了一个对象</span>对象名.属性  <span class="hljs-comment">//对象调用它内部的属性</span>对象名.方法  <span class="hljs-comment">//对象调用它内部的方法</span>如：Student s1 = <span class="hljs-keyword">new</span> Student();s1.name;s1.age;s1.study();s1.eat();</code></pre></li><li><p>方法声明：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> 返回值类型 方法名(参数列表)&#123;    方法体&#125;注意：<span class="hljs-keyword">void</span>：表示该方法没有返回值。如：<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;    <span class="hljs-keyword">int</span> res = a + b;    <span class="hljs-keyword">return</span> res;&#125;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-2-JVM中的堆、栈、方法区"><a href="#NO3-2-JVM中的堆、栈、方法区" class="headerlink" title="NO3.2 JVM中的堆、栈、方法区"></a>NO3.2 JVM中的堆、栈、方法区</h3><p>Java内存是一个比较有趣的地方。</p><ul><li><p>Java虚拟机的内存可以分为三个区域：<code>栈(stack)</code>、<code>堆(heap)</code>、<code>方法区(method area)</code>；</p><ul><li><p><code>栈(stack)</code>：</p><ul><li>特点：<ul><li>先进后出，后进先出，类似于子弹夹的结构；</li><li>由系统自动分配，速度快，是一个连续的内存空间；</li><li>栈内存的数据使用完毕后，就消失了，即被回收；</li><li>栈属于线程私有，线程间不能实现栈的共享。</li></ul></li><li>作用：<ul><li>方法的调用，是在栈(stack)中进行的；</li><li>JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等)；</li></ul></li></ul></li><li><p><code>堆(heap)</code>：</p><ul><li>特点：<ul><li>堆是一个不连续的内存空间，分配灵活，但速度慢；</li><li>JVM只有一个堆，被所有线程共享。</li></ul></li><li>作用：<ul><li>堆(heap)用于存储创建好的对象和数组(数组也是对象)，即new出来的都在这里，并且有地址值和默认值。</li></ul></li></ul></li><li><p><code>方法区(method area)</code>：</p><ul><li><p>特点：</p><ul><li>JVM只有一个方法区，被所有线程共享。</li></ul></li><li><p>作用：</p><ul><li><p>用来存放程序中永远不变或唯一的内容(类的信息、静态信息、字符串常量等)；</p></li><li><p>方法区实际也是堆，只是用于存储类、常量相关的信息。</p><p><img src="./Image-jse4.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-3-静态变量、成员变量、局部变量"><a href="#NO3-3-静态变量、成员变量、局部变量" class="headerlink" title="NO3.3 静态变量、成员变量、局部变量"></a>NO3.3 静态变量、成员变量、局部变量</h3><p>除了成员变量，还有静态变量和局部变量。</p><ul><li>静态变量：<ul><li>定义：在类中，用<code>static</code>关键字声明的成员变量为静态成员变量，也称为类变量；</li><li>生命周期：类变量的生命周期和类相同，在整个应用程序执行期间都有效，即被所有对象所共享；static修饰的变量被修改后，所有对象的该属性都会被修改；</li><li>区别：<ul><li>static修饰的成员变量和成员方法，从属于类；</li><li>普通变量和方法从属于对象。</li></ul></li><li>权限：<ul><li>static修饰的部分，只能访问static修饰的其他部分，无法访问非static的部分，即static只能访问static修饰的部分；</li><li>相反，非static部分，可以访问所有static修饰的部分和非static的部分，即，非static可以访问所有；因为static修饰部分从属于类，非static修饰的部分从属于对象。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>成员变量和局部变量的区别：</p><ul><li><p>在类中的位置不同：</p><ul><li>即成员变量在类中方法外；</li><li>局部变量在方法中(即方法内部)或方法声明上(即形式参数)。</li></ul></li><li><p>在内存中的位置不同：</p><ul><li>即成员变量在堆内存；</li><li>局部变量在栈内存。</li></ul></li><li><p>生命周期不同：</p><ul><li>即成员变量随对象创建而存在，随对象消失而消失；</li><li>局部变量随着方法的调用而存在，随着方法调用完毕而消失。</li></ul></li><li><p>初始化值不同：</p><ul><li><p>即成员变量有默认初始化值；</p><pre><code class="hljs java">拓展：如果声明成员变量时没有对其初始化，则系统会使用默认值初始化成员变量。初始化的默认值如下一、整数型(<span class="hljs-keyword">byte</span>、<span class="hljs-keyword">short</span>、<span class="hljs-keyword">int</span>和<span class="hljs-keyword">long</span>)的基本类型变量的默认值为<span class="hljs-number">0</span>；    二、单精度浮点型(<span class="hljs-keyword">float</span>)的基本类型变量的默认值为<span class="hljs-number">0.0f</span>；    三、双精度浮点型(<span class="hljs-keyword">double</span>)的基本类型变量的默认值为<span class="hljs-number">0.0</span>d；    四、字符型(<span class="hljs-keyword">char</span>)的基本类型变量的默认值为 “\u0000”；    五、布尔型的基本类型变量的默认值为 <span class="hljs-keyword">false</span>；    六、数组引用类型的变量的默认值为<span class="hljs-keyword">null</span>，如果是数组元素是基本数据类型，那么根据数据类型取值。如，<span class="hljs-keyword">int</span>[] arr，那么该数组中的元素默认初始组都是<span class="hljs-number">0</span>。</code></pre></li></ul></li></ul></li></ul><pre><code>-   局部变量没有默认初始化值，必须先定义，然后赋值，最后才可以使用；</code></pre><p>&nbsp;</p><ul><li>成员变量和静态变量的区别：<ul><li>所属不同：<ul><li>即成员变量属于对象；</li><li>静态变量属于类。</li></ul></li><li>内存中位置不同：<ul><li>即成员变量存储于堆内存；</li><li>静态变量存储于静态区。</li></ul></li><li>内存出现时间不同：<ul><li>即成员变量随着对象的创建而存在，随着对象消失而消失；</li><li>静态变量随着类加载而存在，随着类消失而消失。</li></ul></li><li>调用不同：<ul><li>即成员变量只能通过对象调用；</li><li>静态变量可以通过类名调用，也可以通过对象调用。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-4-匿名对象"><a href="#NO3-4-匿名对象" class="headerlink" title="NO3.4 匿名对象"></a>NO3.4 匿名对象</h3><p>匿名对象，就是没有名字的对象，即没有对象名。</p><ul><li><p>匿名对象：</p><ul><li><p>定义：没有对象名的对象；</p></li><li><p>使用场景：只使用一次，但又不想创建一个对象的时候，就可以使用匿名对象；</p></li><li><p>基本语法格式：</p><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类名()&#123;需要实现的方法&#125;<span class="hljs-keyword">new</span> 类名()&#123;需要实现的方法&#125;.属性<span class="hljs-keyword">new</span> 类名()&#123;需要实现的方法&#125;.方法如：<span class="hljs-keyword">new</span> Student().name;<span class="hljs-keyword">new</span> Student().age;<span class="hljs-keyword">new</span> Student().eat();</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-5-方法重载"><a href="#NO3-5-方法重载" class="headerlink" title="NO3.5 方法重载"></a>NO3.5 方法重载</h3><p>两个方法的声明，除了参数列表不一样，其他完全一样的，就称为方法重载。</p><ul><li><p><code>Overload</code>：</p><ul><li><p>定义：即方法名相同，参数列表不同；与返回值类型无关。也就是说我们可以定义一些声明大部分相同的方法，通过定义不同的输入参数来区分这些方法，然后在调用时，虚拟机就会根据不同的参数，来选择合适的方法执行；</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;        ...        &#125;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;        ...        &#125;                <span class="hljs-comment">//上面这两个方法就是方法重载方法名相同，但参数列表不同</span>                拓展：可变参数列表        一、JDK5<span class="hljs-number">.0</span>新增内容。可变参数就是指可以用一个参数代替多个参数，但必须都是同一类型的参数。        如：        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ... a)</span>  <span class="hljs-comment">//这里的int参数可以放许多个，但必须都是int类型</span></span></code></pre></li></ul></li><li><p><code>Override</code>：</p><ul><li>定义：是方法覆盖的意思，也就是重写(后面讲接口的时候会讲)；它是覆盖了一个方法并且对其重写，以求达到不同的作用；</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-6-参数传递"><a href="#NO3-6-参数传递" class="headerlink" title="NO3.6 参数传递"></a>NO3.6 参数传递</h3><p>方法中的参数可以是基本数据类型，也可以是引用数据类型。</p><ul><li><p>参数传类型：</p><ul><li><p>基本数据类型：该类型作为参数传递时，形式参数的改变对实际参数没有影响。即基本类型只是值传递(就是把值拷贝给了方法使用而已)，无论做什么操作，原本的基本数据类型的值不会改变；<strong><code>注意：String作为形式参数，和基本数据类型是一样的，只是值传递，不改变实际参数。</code></strong></p><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;  <span class="hljs-comment">//只是值的一个复制，不会影响原先a的值</span>        <span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> res = a + b;        &#125;</code></pre></li><li><p>引用数据类型：该类型作为参数传递时，形式参数的改变直接影响实际参数；即引用类型传递的是地址值，对该地址进行操作后，原先的地址里的内容，也会发生改变；</p><pre><code class="hljs ebnf"><span class="hljs-attribute">Student s</span> = new Studeng();</code></pre></li></ul><p>public void getSum(Studeng stu){  //把对象的地址值传递给了方法去操作，</p><pre><code>    stu.age = 5;  //这里设置了stu对象的age属性为5，因为传递的是地址值，所以stu中的age属性就被改成了5}<pre><code class="hljs routeros">&amp;nbsp;&amp;nbsp;<span class="hljs-comment">### NO3.7 封装和权限修饰符</span>我们自己创造的类，它的属性、方法一般不会给让用户自己随意更改和调用，这就需要给属性和方法设置一个权限。-   封装：    -   定义：封装是将代码及其处理的数据绑定在一起的一种编程机制，该机制保证了程序和数据都不受外部干扰且不被误用；    -   目的：封装的目的在于保护信息。&amp;nbsp;-   权限修饰符：    -   定义：用于给属性、方法设置访问权限的关键字；    -   基本语法格式：        ```java        修饰符      同一个类    同一个包中   不同包下子类   所有类        private      √               <span class="hljs-built_in"> default </span>     √           √                protected    √           √          √                public       √           √          √            √                    说明：权限修饰符        一、private表示私有，只有本类能访问；                二、default表示没有修饰符修饰，只有同一个包下的类能访问；                三、protected表示受保护，可以被同一个包下的类以及其他包中的子类访问；                四、public表示可以被该项目的所有包中的所有类访问。</code></pre></code></pre></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-8-构造方法"><a href="#NO3-8-构造方法" class="headerlink" title="NO3.8 构造方法"></a>NO3.8 构造方法</h3><p>构造方法，其实就是我们根据类来创建对象时，所用的方法。</p><ul><li><p>构造方法：</p><ul><li><p>定义：顾名思义，就是用来构造对象的方法；</p></li><li><p>作用：创建对象时使用；</p></li><li><p>种类：</p><ul><li>无参构造方法；</li><li>带参构造方法。</li></ul></li><li><p>基本语法格式：</p><pre><code class="hljs java"><span class="hljs-comment">//无参构造方法</span><span class="hljs-keyword">public</span> 类名称() &#123;    方法体&#125;<span class="hljs-comment">//----------------------------</span><span class="hljs-comment">//带参构造方法</span><span class="hljs-keyword">public</span> 类名称(参数类型 参数名称) &#123;    方法体&#125;如:<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<span class="hljs-comment">//成员变量</span>String name;<span class="hljs-keyword">int</span> age;<span class="hljs-comment">//无参构造方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//带参构造方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name)</span></span>&#123;<span class="hljs-keyword">this</span>.name = name&#125;<span class="hljs-comment">//成员方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"学习学习"</span>);&#125;&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-9-this关键字"><a href="#NO3-9-this关键字" class="headerlink" title="NO3.9 this关键字"></a>NO3.9 this关键字</h3><p>this关键字指向的是当前对象的引用。</p><ul><li><p><code>this</code>：</p><ul><li><p>定义：指向当前对象的引用，即你可以理解为当前类创建的一个对象。</p></li><li><p>应用：</p><ul><li><p><code>this.属性名</code>：调用本类中的属性，也就是类中的成员变量；</p></li><li><p><code>this.方法名</code>：调用本类中的其他方法，也就是类中成员方法；</p></li><li><p><code>this(参数列表)</code>：调用本类中的其他构造方法，调用时要放在方法内部的首行。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;                        <span class="hljs-comment">//成员变量</span>            String name;            <span class="hljs-keyword">int</span> age;                        <span class="hljs-comment">//无参构造方法</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;&#125;                        <span class="hljs-comment">//带参构造方法</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name)</span></span>&#123;            <span class="hljs-keyword">this</span>.name = name            &#125;                        <span class="hljs-comment">//成员方法</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;            System.out.println(<span class="hljs-string">"吃饭吃饭"</span>);            &#125;                        <span class="hljs-comment">//成员方法</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;            <span class="hljs-keyword">this</span>(<span class="hljs-string">"this调用带参构造方法"</span>)  <span class="hljs-comment">//this调用构造方法</span>            <span class="hljs-keyword">this</span>.age = <span class="hljs-number">10</span>;  <span class="hljs-comment">//this调用属性</span>            <span class="hljs-keyword">this</span>.eat();  <span class="hljs-comment">//this调用方法</span>            System.out.println(<span class="hljs-string">"学习学习"</span>);            &#125;            &#125;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-10-继承"><a href="#NO3-10-继承" class="headerlink" title="NO3.10 继承"></a>NO3.10 继承</h3><p>继承，顾名思义，就是父类的东西，能够被子类所获取。这和现实生活中的父子概念有点相似。</p><ul><li><p>继承：</p><ul><li><p>定义：Java中的继承就是在已经存在的类的基础上进行扩展，从而产生新的类。已经存在的类称为父类、基类或超类，而新产生的类称为子类或派生类。在子类中，不仅包含父类的属性和方法(不包括构造方法)，还可以增加新的属性和方法，以及重写父类的一些方法。</p></li><li><p>基本语法格式：</p><pre><code class="hljs java">权限修饰符 <span class="hljs-class"><span class="hljs-keyword">class</span> 子类名 <span class="hljs-keyword">extends</span> 父类名 </span>&#123;    类的主体&#125;<span class="hljs-comment">//==========================================================</span>拓展：继承的一些知识一、Java中的所有类，都继承自一个类，这个类就是Object类。    二、在Java继承中，子类不能够访问父类的私有属性和私有方法，即用<span class="hljs-keyword">private</span>修饰的属性和方法；三、在Java继承中，子类变量名和父类变量名相同，根据就近原则，先找子类方法中有没有，然后找子类成员位置有没有，最后找父类成员位置有没有；四、子类中的任何构造方法，都会默认先调用父类的无参构造方法。原因是，子类继承了父类，有可能需要访问父类的数据，所以必须要先初始化父类数据才能让子类访问，即子类的构造方法的第一句永远是<span class="hljs-keyword">super</span>()，也就是父类的无参构造方法，我们看不到是因为该方法是隐含的；    五、Java中的继承只有单继承，没有多继承，但是可以多层继承。    六、子类继承父类后，在子类中，可以重写父类所拥有的方法；但是在创建子类对象后，调用重写的方法时，调用的是子类本身中那个方法，而不是父类的同名方法，要想调用父类的方法，就使用关键字Super；    七、在方法覆盖中，子类要重写的方法，其方法声明(即除开方法体的部分)必须和父类方法保持一致。        如：<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;    ....&#125;<span class="hljs-comment">//----------------------</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;    ....&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-11-Super关键字"><a href="#NO3-11-Super关键字" class="headerlink" title="NO3.11 Super关键字"></a>NO3.11 Super关键字</h3><p>子类继承父类后，如果我们想调用父类某些属性、方法，就需要使用Super关键字。</p><ul><li>super：<ul><li>定义：你可以理解为是当前类的父类创建的一个对象，是Java中用来调用父类属性或方法的关键字；</li><li>应用：<strong><code>注意：Super只在子类中出现，是父类存储空间的标识。</code></strong><ul><li><code>super.属性名</code>：获取父类中的某个属性值；</li><li><code>super.方法名()</code>：直接调用父类中的某个方法；</li><li><code>super(参数列表)</code>：调用父类的某个构造方法。你所调用的父类构造方法根据括号里的内容的变化而改变(即有参数就调用有参构造，没有参数就调用无参构造)；</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-12-多态"><a href="#NO3-12-多态" class="headerlink" title="NO3.12 多态"></a>NO3.12 多态</h3><p>多态是Java中特性又一个特点。</p><ul><li>多态：<ul><li>定义：是指在父类中定义的属性和方法被子类继承之后，不同的子类可以具有不同的数据类型或表现出不同的行为；</li><li>特点：<ul><li>多态是方法的多态，不是属性的多态(多态与属性无关);</li><li>多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象(即<code>父类名 对象名 = new 子类名()</code>)；</li><li>父类引用指向子类对象后，用父类引用调用子类重写的方法，此时多态就出现了；</li></ul></li><li>多态中的成员访问特点：<ul><li>成员变量：编译看左边，运行看左边；</li><li>构造方法：创建子类对象的时候，会访问父类的构造方法，对父类的数据进行初始化；</li><li>成员方法：编译看左边，运行看右边；</li><li>静态方法：编译看左边，运行看左边(静态和类相关，算不上重写，所以，访问还是左边的)；</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-13-多态中的向上转型和向下转型"><a href="#NO3-13-多态中的向上转型和向下转型" class="headerlink" title="NO3.13 多态中的向上转型和向下转型"></a>NO3.13 多态中的向上转型和向下转型</h3><p>多态的必要条件之一就是向上转型。</p><ul><li><p>多态的自动向上转型和强制向下转型：</p><ul><li><p>自动向上转型：当父类引用指向子类对象后，就被称为自动向上转型，但是当子类中拥有自己特有的方法时，父类引用就无法访问子类中的这些特有的方法；</p><pre><code class="hljs java">Animal a = <span class="hljs-keyword">new</span> Dog()  <span class="hljs-comment">//对象a就是父类引用，等号右边的new Dog()就是子类对象</span></code></pre></li><li><p>强制向下转型：父类引用想要访问子类中特有的方法时，就需要将父类引用强制向下转换成子类对象，转换后，该子类引用可以访问父类和子类本身拥有的方法。</p><pre><code class="hljs java"><span class="hljs-comment">//这是父类Animal，拥有eat()和sleep两个方法</span>        <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;                System.out.println(<span class="hljs-string">"动物吃吃吃..."</span>);            &#125;                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>&#123;                System.out.println(<span class="hljs-string">"动物睡觉觉..."</span>);            &#125;        &#125;                <span class="hljs-comment">//---------------------------------------------</span>                <span class="hljs-comment">//这是子类Dog，继承了Animal,拥有重写后的eat()方法和子类特有seeDoor()方法</span>        <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;                System.out.println(<span class="hljs-string">"狗子吃吃吃..."</span>);            &#125;                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">seeDoor</span><span class="hljs-params">()</span> </span>&#123;                System.out.println(<span class="hljs-string">"狗子看门门..."</span>);            &#125;        &#125;                <span class="hljs-comment">//-----------------------------------------------</span>                <span class="hljs-comment">//测试</span>        <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;                        <span class="hljs-comment">//这是自动向上转型，父类引用a，指向子类对象new Dog()</span>                Animal a = <span class="hljs-keyword">new</span> Dog();                        <span class="hljs-comment">//输出：狗子吃吃吃...，因为子类复写了eat()方法，所以调用的是子类中的eat()方法</span>                a.eat();                        <span class="hljs-comment">//输出：动物睡觉觉...，调用父类中的sleep()方法，因为是父类引用，所以失去了子类中特有的seeDoor()方法</span>                a.sleep();                        System.out.println(<span class="hljs-string">"------------分隔符"</span>);                        Dog d = (Dog)a;  <span class="hljs-comment">//这是强制向下转型</span>                        d.eat();  <span class="hljs-comment">//狗子吃吃吃...，调用的是子类复写后的eat()方法</span>                        d.sleep();  <span class="hljs-comment">//动物睡觉觉...，调用的是父类中的sleep()方法</span>                        d.seeDoor();  <span class="hljs-comment">//狗子看门门...，调用的是子类中特有的seeDoor()方法</span>            &#125;        &#125;                拓展：<span class="hljs-keyword">instanceof</span>关键字        一、该关键字用于判断某个对象是否是某个类生成的对象。对象名 <span class="hljs-keyword">instanceof</span> 类名。</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-14-Object类中常见的方法"><a href="#NO3-14-Object类中常见的方法" class="headerlink" title="NO3.14 Object类中常见的方法"></a>NO3.14 Object类中常见的方法</h3><p>Object是Java中所有类的父类。</p><ul><li>Object类的常见方法：<ul><li><code>hashCode()</code>：是指根据哈希算法，将对象的内存地址转换成一个整数值；</li><li><code>toString()</code>：一般子类会重写该方法，即把该类的成员变量用字符串显示输出就行；</li><li><code>equals()</code>：用于比较引用类型中的某些值是否相等。“==”和equals()方法的区别：<ul><li>如果比较基本数据类型；<ul><li><code>==</code> ：比较的是基本数据类型的值；</li><li><code>equals()</code>：是不存在的，因为int、float等是基本数据类型，不是对象，就没有equals()方法，不存在int.equals()。</li></ul></li><li>如果比较的是引用数据类型；<ul><li><code>==</code> ：比较的是两个引用是否指向同一个对象实例，即比较的是在内存中的地址值；</li><li><code>equals()</code>：首先看调用equals()方法的对象，其equals方法是否被重写，如果有被重写则按照重写的规则比较；没有重写则与<code>==</code>比较规则一样，一般来说，重写equals()方法后，比较的是对象的成员变量是否相同即可。</li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-15-包装类"><a href="#NO3-15-包装类" class="headerlink" title="NO3.15 包装类"></a>NO3.15 包装类</h3><p>基础数据类型是无法调用equals()方法的，所以包装类出现了。</p><ul><li><p>包装类</p><ul><li><p>定义：用于将基本数据类型封装成对象的类。常用的操作之一：用于基本数据类型与字符串之间的转换；</p></li><li><p>基本数据类型的包装类(按照字节大小排列，其中boolean除外)：</p><pre><code class="hljs java">基本数据类型       包装类型<span class="hljs-keyword">byte</span>       ---&gt;    Byte<span class="hljs-keyword">short</span>      ---&gt;    Short<span class="hljs-keyword">int</span>        ---&gt;    Integer<span class="hljs-keyword">long</span>       ---&gt;    Long<span class="hljs-keyword">boolean</span>    ---&gt;    Boolean<span class="hljs-keyword">char</span>       ---&gt;    Character<span class="hljs-keyword">float</span>      ---&gt;    Float<span class="hljs-keyword">double</span>     ---&gt;    Double    拓展：自动装箱和自动拆箱(JDK5<span class="hljs-number">.0</span>以后)一、自动装箱：就是将基本数据类型自动封装成对应的包装类型；如：Integer a = <span class="hljs-number">100</span>;  <span class="hljs-comment">//等价于 Integer a = Integer.valueOf(100)，这是自动装箱；</span>二、自动拆箱：就是将包装类型转成对应的基本数据类型；如：<span class="hljs-keyword">int</span> b = a;  <span class="hljs-comment">//等价于int b = a.intValue()，这是自动拆箱；</span><span class="hljs-comment">//=======================================================</span>拓展：Integer包装类缓存了一个数组，这个数组的范围是-<span class="hljs-number">128</span>到<span class="hljs-number">127</span>之间；如：Integer a = -<span class="hljs-number">128</span>;Integer b = -<span class="hljs-number">128</span>;System.out.println(a==b);  <span class="hljs-comment">//true，因为integer会缓存一个数组，当调用valueOf()方法时，会匹配对比这个范围内的值，是否可以直接从这个数组获取，如果有目标值，就不会开辟空间创造新的包装类对象，所以这里是true,否则就创建新的包装类对象</span>System.out.println(a.equals(b));  <span class="hljs-comment">//true，这里比较的是值，所以是true</span></code></pre></li><li><p>JDK5以后新增的特性：</p><ul><li><p>泛型：即“宽泛的数据类型”，放入的是引用数据类型或者自定义类。一般用”<code>&lt;T&gt;</code>“表示泛型；泛型通配符包括：</p><ul><li><code>&lt;? extends E&gt;</code>：上限通配符，表示 ?必须是E的子类或者就是E类本身；</li><li><code>&lt;? super E&gt;</code>：下限通配符，表示 ?必须是E的父类或者就是E类本身。</li></ul></li><li><p>枚举：即enum，主要用于定义一组可以使用的类对象。详细的细节后面章节会讲；</p></li><li><p>自动装箱与拆箱：简单一点说，装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型；</p></li><li><p>增强for：for循环的增强版本，也叫foreach循环；</p><pre><code class="hljs java"><span class="hljs-keyword">for</span>(集合或数组中元素的数据类型 变量名 : 被遍历的集合或数组)&#123;      遍历操作&#125; 注意：被遍历的集合或数组不可以为<span class="hljs-keyword">null</span>。</code></pre></li><li><p>可变参数：不确定要传递的参数的个数时，就可以使用可变参数，其实可变参数是一个数组；格式：数据类型… 参数名</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>... a)</span></span>&#123;...&#125;;注意：可变参数 <span class="hljs-keyword">int</span>... a，其实是一个数组，想要获取其中的参数参照遍历数组即可。</code></pre></li><li><p>静态导入：对import语句的增强，格式：import static 包名….类名.方法名。</p></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-16-static关键字"><a href="#NO3-16-static关键字" class="headerlink" title="NO3.16 static关键字"></a>NO3.16 static关键字</h3><p>static是一个修饰符，能够修饰许多东西。</p><ul><li>static：<ul><li>定义：用于修饰的修饰符；</li><li>应用：<ul><li>static 变量：用static修饰的变量，称为静态变量，也叫做类变量，因为从属于类。使用<code>类名.静态变量</code>调用静态变量；<strong><code>注意：静态变量是该类所有对象所共享的。</code></strong></li><li>static 方法：用static修饰的方法，称为静态方法，也就叫做类方法，也是从属于类。使用<code>类名.静态方法</code>调用静态方法；</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-17-静态代码块、构造代码块、构造方法"><a href="#NO3-17-静态代码块、构造代码块、构造方法" class="headerlink" title="NO3.17 静态代码块、构造代码块、构造方法"></a>NO3.17 静态代码块、构造代码块、构造方法</h3><p>静态代码块、构造代码块、构造方法的执行顺序是….</p><ul><li><p>代码块根据位置不同分为：</p><ul><li>局部代码块：在方法内部位置，用于限定变量生命周期，提高内存利用率；</li><li>构造代码块：在类中成员位置，用于存放构造方法中相同的代码，每次调用构造方法之前都会执行；</li><li>静态代码块：在类中方法外位置，随着类的加载而加载，用于类进行初始化。</li></ul></li><li><p>执行顺序：静态代码块(只加载一次)&gt;构造代码块&gt;构造方法。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;            <span class="hljs-comment">//静态代码块</span>        <span class="hljs-keyword">static</span> &#123;            System.out.println(<span class="hljs-string">"Student的静态代码块"</span>);        &#125;            <span class="hljs-comment">//构造代码块</span>        &#123;            System.out.println(<span class="hljs-string">"Student的构造代码块"</span>);        &#125;            <span class="hljs-comment">//构造方法</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;            System.out.println(<span class="hljs-string">"Student的构造方法"</span>);        &#125;    &#125;        <span class="hljs-comment">//----------------------------------------</span>        <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;            <span class="hljs-comment">//静态代码块</span>        <span class="hljs-keyword">static</span> &#123;            System.out.println(<span class="hljs-string">"拥有main方法的类的静态代码块"</span>);        &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;                System.out.println(<span class="hljs-string">"我是main方法"</span>);                Student s1 = <span class="hljs-keyword">new</span> Student();                Student s2 = <span class="hljs-keyword">new</span> Student();        &#125;    &#125;        输出结果：        <span class="hljs-string">"拥有main方法的类的static代码块"</span>    <span class="hljs-string">"我是main方法"</span>        <span class="hljs-string">"Student的静态代码块"</span>  <span class="hljs-comment">//从这开始是s1</span>    <span class="hljs-string">"Student的构造代码块"</span>    <span class="hljs-string">"Student的构造方法"</span>        <span class="hljs-string">"Student的构造代码块"</span>  <span class="hljs-comment">//从这开始是s2</span>    <span class="hljs-string">"Student的构造方法"</span>        说明：Student类中的三个代码块，前提是有对象才能输出，所以优先进入main方法去<span class="hljs-keyword">new</span> Student()，在此之前，main方法之前还有一个代码块，所以该<span class="hljs-keyword">static</span>代码块最先执行，其次main方法，最后是Student对象的三个代码块(<span class="hljs-keyword">static</span>代码块优先、构造代码块其次，最后构造方法)。</code></pre></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-18-final关键字"><a href="#NO3-18-final关键字" class="headerlink" title="NO3.18 final关键字"></a>NO3.18 final关键字</h3><p>final可以修饰变量、方法、类等等</p><ul><li><p>final：</p><ul><li><p>定义：也是一个修饰符，表示最终的意思；</p></li><li><p>应用：</p><ul><li><p>修饰变量：被修饰的变量不可改变。一旦赋了初值，就不能被重新赋值。</p><pre><code class="hljs java"><span class="hljs-comment">//final固定的不是成员变量的默认值，而是第一次赋值后的值；如果final固定的是默认值，则成员变量永远是默认值，这不符合语法规则；</span>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> age = <span class="hljs-number">120</span>;                        <span class="hljs-comment">//如果定义成员变量时没有赋值，则必须在构造方法中或静态代码块中赋值完成</span>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> id;                        <span class="hljs-comment">//修饰引用类型，其地址值不能变，但是该对象的堆内存(即对象内容)的其他值(即对象属性)是可以改变的；</span>            <span class="hljs-keyword">final</span> Student s = <span class="hljs-keyword">new</span> Student();</code></pre></li><li><p>修饰方法：该方法不能被子类重写；但是可以被重载；</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;&#125;            <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">(String name)</span></span>&#123;&#125;</code></pre><pre><code class="hljs arduino">            -   修饰类：修饰的类不能被继承；如，Math、<span class="hljs-keyword">String</span>类都是<span class="hljs-keyword">static</span>修饰的等等。        ```java<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span>&#125;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-19-抽象类和抽象方法"><a href="#NO3-19-抽象类和抽象方法" class="headerlink" title="NO3.19 抽象类和抽象方法"></a>NO3.19 抽象类和抽象方法</h3><p>abstract修饰符，分别用来修饰类和方法时，就成了抽象类和抽象方法。</p><ul><li>抽象类：<ul><li>定义：从多个普通类上抽取出共有的部分而形成的模板，且加上abstract修饰符，就变成了抽象类；</li><li>特点：<ul><li>抽象类不能被实例化，即不能new对象；</li><li>用abstract修饰的类，即抽象类；</li><li>抽象类中不一定要包含abstrace方法。也就是说，抽象类中可以没有abstract方法；</li><li>一旦类中包含了abstract方法，那该类必须声明为abstract类；</li><li>抽象类被继承后，其子类若是想访问本身特有的方法，必须经过向下转型才能访问；</li><li>抽象类有构造方法，但不能用于创建实例，只是为了让抽象类的子类调用，并初始化父类数据；</li><li>抽象类存在的意义就在于：为子类提供统一的、规范的继承模板；</li></ul></li><li>基本语法格式：<code>权限修饰符 abstract class 类名{}</code>；</li></ul></li></ul><p>&nbsp;</p><ul><li><p>抽象方法：  </p><ul><li><p>定义：没有方法体，且用abstract修饰的方法，就是抽象方法；</p></li><li><p>特点：</p><ul><li>抽象方法不能有方法主体，即没有<code>{}</code>的部分，普通方法带有方法体。<code>如，public void eat(){...}</code>；</li><li>用abstract修饰的方法，即抽象方法；</li><li>拥有抽象方法的抽象类被继承后，其子类必须重写抽象方法；</li></ul></li><li><p>基本语法格式：<code>权限修饰符 abstract 返回值类型 方法名()</code>；</p><pre><code class="hljs java">拓展：<span class="hljs-keyword">abstract</span>不能与下列关键字共存一、<span class="hljs-keyword">private</span> 冲突；原因是：抽象方法被私有后，子类不允许被访问，更不能重写；如：<span class="hljs-comment">//private修饰方法，即被类私有，而子类继承后无法复写该方法</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;二、<span class="hljs-keyword">final</span> 冲突；原因是：抽象方法被<span class="hljs-keyword">final</span>修饰后，无法被重写；如：<span class="hljs-comment">//final修饰方法，子类无法复写该方法</span><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;三、<span class="hljs-keyword">static</span> 无意义；原因是：类名可以调用<span class="hljs-keyword">static</span>修饰的方法，但是该抽象方法没有&#123;&#125;方法体，所以无意义；如：<span class="hljs-comment">//static修饰方法，即可以使用类名调用该方法，但是该方法为抽象方法，没有方法体，调用无意义</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-20-接口"><a href="#NO3-20-接口" class="headerlink" title="NO3.20 接口"></a>NO3.20 接口</h3><p>接口是对抽象类的更加抽象化提取。</p><ul><li>接口：对抽象类的更加抽象化的提取，是一种特殊的抽象类。</li><li>特点：<ul><li>接口是特殊的抽象类，没有构造方法，也不能创建实例；</li><li>接口可以实现多继承，即一个类可以同时实现多个接口，一个接口可以同时继承多个接口；</li><li>接口中的常量，总是：public static final 修饰，不写也是；</li><li>接口中的方法，只能是：public abstract 修饰，省略的话也是；</li><li>接口被实现后，其实现类必须重写其含有抽象方法；若是想访问实现类本身特有的方法，必须经过向下转型才能访问。</li></ul></li><li>基本语法格式：<ul><li>接口：<code>public interface 接口名{....}</code>；</li><li>实现类实现接口：<code>public class 类名 implements {重写抽象方法}接口名</code>。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-21-内部类"><a href="#NO3-21-内部类" class="headerlink" title="NO3.21 内部类"></a>NO3.21 内部类</h3><p>内部类可以很好隐藏一些代码的细节实现。</p><ul><li><p>内部类：</p><ul><li><p>定义：在类内部也可以定义另一个类，此时这另一个类就称为内部类</p></li><li><p>种类：</p><ul><li><p>成员内部类(又分为非静态内部类、静态内部类)：即成员位置的内部类；</p><ul><li><p>非静态内部类：</p><ul><li><p>定义：即没有用static修饰的内部类；</p></li><li><p>特点：</p><ul><li>非静态内部类必须寄存在一个外部类对象里；因此，如果有一个非静态内部类对象那么一定存在对应的外部类对象；非静态内部类对象单独属于外部类的某个对象；</li><li>非静态内部类可以直接访问外部类的所有成员，但是外部类不能直接访问非静态内部类成员，需要new内部类对象才能够访问；</li><li>非静态内部类不能有静态方法、静态属性和静态初始化块；除非同时用final和static修饰。</li></ul></li><li><p>内部类方法中访问外部类成员变量：</p><ul><li><p>外部类属性：<code>外部类名.this.变量名</code>；</p></li><li><p>内部类属性：<code>this.变量名</code>；</p></li><li><p>内部类里方法中的局部变量：<code>变量名</code>。</p><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">Outer</span> &#123;                                                    <span class="hljs-built_in">public</span> String <span class="hljs-type">name</span> = "outer";                                                        //内部类                            <span class="hljs-keyword">class</span> <span class="hljs-keyword">Inner</span> &#123;                            //内部类成员变量                                String <span class="hljs-type">name</span> = "inner";                                                                <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> <span class="hljs-keyword">show</span>() &#123;                                    String <span class="hljs-type">name</span> = "show";                                    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">name</span>);                                    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(this.name);                                    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">Outer</span>.this.name);                                &#125;                              &#125;                        &#125;                                                //<span class="hljs-comment">---------------------------------------</span>                                                <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;                        <span class="hljs-keyword">Inner</span> <span class="hljs-keyword">inner</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Outer</span>().<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>();                        <span class="hljs-keyword">inner</span>.<span class="hljs-keyword">show</span>();                        &#125;</code></pre></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><pre><code>            -   基本语法格式：`Outter.Inner oi = new Outter().new Inner()`。        -   静态内部类：            -   定义：即用static修饰的内部类；-   特点：                -   当一个静态内部类对象存在，并不一定存在对应的外部类对象。                -   静态内部类可以直接访问外部类的静态成员，如果要访问外部类的非静态成员，则需要通过外部类的实例去访问；                -   静态内部类可以有静态方法、静态属性和静态初始化块；            -   基本语法格式：`Outter.Inner oi = new Outter.Inner()`；    -   匿名内部类：        -   定义：本质是new了一个继承了某个类的子类匿名对象或实现了某个接口的实现类匿名对象；        -   特点：是一个特殊的内部类；        -   基本语法格式：            <pre><code class="hljs java"><span class="hljs-keyword">new</span> 类名或接口名()&#123;            重写方法即可        &#125;                如：        <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">eat</span></span>&#123;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eatFoot</span><span class="hljs-params">()</span></span>;        &#125;                <span class="hljs-comment">//创建的匿名内部类就是</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;                <span class="hljs-comment">//这就是匿名内部类；eat接口并没有实现</span>        <span class="hljs-keyword">new</span> eat()&#123;                <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eatFoot</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"吃饭饭"</span>);        &#125;        &#125;        &#125;</code></pre>    -   局部内部类(该类几乎不用);        -   定义：定义在方法中的内部类称为局部内部类；        -   特点：            -   局部内部类访问局部变量，必须加上final修饰。因为当局部内部类对象创建后，不会马上消失，而这个时候，当方法调用完毕后，局部变量已经被回收了，究其原因：因为局部内部类对象的生命周期比局部变量的生命周期长，所以想要访问该局部变量需要加上final修饰它；                <pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outter</span></span>&#123;</code></pre>            //成员变量                    private Object obj;                    //成员方法                    public void method(){                        //局部变量，需要加上final修饰，使其变为常量，不加就会报错                        final int num2 = 20;                        //局部内部类                        class Inner{                            public void show(){                            System.out.println(num2); //报错，因为局部变量需要加final修饰                            }                        }                        //创建局部内部类Inner对象                        Inner i = new Inner();                        //调用局部内部类Inner的show方法                        i.show();                        //赋值给外部的成员变量                        obj = i;                    }                }                //-----------------------------------------------------                public class Test{                    public static void main(String[] args) {                        Outter o = new Outter();                        o.method();                        //此时调用局部内部类的方法show时，局部变量已经消失，所以报错，无法访问到                        o.obj.show();                    }                }                <pre><code class="hljs markdown">&amp;nbsp;&amp;nbsp;<span class="hljs-section">### NO3.22 异常及其处理机制</span>Java将异常封装到一个类中，出现错误时就会拋出异常。<span class="hljs-bullet">-   </span>异常：<span class="hljs-bullet">    -   </span>定义：异常(exception)是在运行程序时产生的一种例外情况；<span class="hljs-code">`如，你计划周末郊游，计划从家里出发→到达目的→游泳→烧烤→回家。但天有不测风云，当你准备烧烤时候突然天降大雨，只能终止郊游提前回家。“天降大雨”就是一种异常情况`</span>。<span class="hljs-bullet">    -   </span>所属类：Java中的异常都被封装到了<span class="hljs-code">`Throwable`</span>类的子类中。<span class="hljs-bullet">    -   </span>种类：<span class="hljs-bullet">        -   </span><span class="hljs-code">`Error(错误)`</span>：即任何处理技术都无法恢复的情况，肯定会导致程序非正常终止。并且 Error 错误属于未检查类型，大多数发生在运行时。也就是说出现这种错误的时候，我们是暂时解决不了的；<span class="hljs-bullet">        -   </span><span class="hljs-code">`Exception(异常)`</span>：程序正常运行过程中可以预料到的意外情况，并且应该被开发者捕获，进行相应的处理。可分为：<span class="hljs-bullet">            -   </span><span class="hljs-code">`RuntimeException(运行时异常)`</span>：即运行过程中，程序产生的异常；常见的异常有：<span class="hljs-bullet">                -   </span>NullPointerException：空指针异常；<span class="hljs-code">                    ```java</span>String str = null;<span class="hljs-code">                    </span><span class="hljs-code">                    str.length();</span></code></pre>            -   ClassCastException：类型转换异常；                <pre><code class="hljs java">Animal a =<span class="hljs-keyword">new</span> Dog();</code></pre>Cat c = (Cat)a;                <pre><code class="hljs angelscript">                            -   ArrayIndexOutOfBoundsException：数组索引越界异常；                        ```java<span class="hljs-built_in">int</span>[] a=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;                System.<span class="hljs-keyword">out</span>.println(a[<span class="hljs-number">3</span>]);</code></pre>            -   ClassNotFoundException，未找到该类；            -   ArithmeticException，除数为0的算数异常；            -   UnknowTypeException，未知类型异常。        -   `CheckedException(编译时异常)`：即代码编译时，被检查到的异常。处理机制有：            -   使用 `try-catch-finally `捕获异常；                <pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;                可能出现异常的代码(这里的代码越少越好)            &#125;<span class="hljs-keyword">catch</span>(异常名 变量名)&#123;                            针对异常的处理                        &#125;<span class="hljs-keyword">finally</span>&#123;                            释放资源(无论异常触发与否，这里的代码一定会执行)                        &#125;                        说明：<span class="hljs-keyword">finally</span>关键字里面的内容不论什么情况都会执行，除非在<span class="hljs-keyword">finally</span>之前遇到System.exit(<span class="hljs-number">0</span>)，即退出虚拟机；一般<span class="hljs-keyword">finally</span>代码块里面，放的都是释放资源的方法。                            <span class="hljs-comment">//-------------------------------------------------------</span>            拓展：<span class="hljs-keyword">final</span>、<span class="hljs-keyword">finally</span>、finalize的区别            一、<span class="hljs-keyword">final</span>：是最终的意思，可以修饰类，成员变量，成员方法；修饰类，类不能被继承；修饰成员变量，变量变为常量；修饰成员方法，方法不能被重写；                        二、<span class="hljs-keyword">finally</span>：是异常处理的一部分，一般用于释放资源；                        三、finalize：是Object类的一个方法，用于垃圾回收。</code></pre>            -   使用`throws`声明异常，即抛出异常到方法声明上；                -   throws 和 throw 的区别；                    -   throws：                        -   用在方法声明后面，后跟异常类名；            -   可以跟多个异常类名；                        -   表示抛出异常，由方法的调用者来处理；            -   throws 表示出现异常的一种可能性，并不一定会发生这种异常。                    -   throw：                        -   用在方法体内，后跟异常对象名；                        -   只能抛出一个异常对象名；                        -   表示抛出异常，由方法体内语句处理；                        -   throw 则是抛出异常，执行throw则一定抛出某种异常。</code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-23-多线程"><a href="#NO3-23-多线程" class="headerlink" title="NO3.23 多线程"></a>NO3.23 多线程</h3><p>你有没有想过，我们看视频的时候，还能看到弹幕在浮动，这一个个浮动的弹幕，其实就是一个个线程在运行。</p><ul><li><p>多线程：</p><ul><li><p>定义：是指一个进程内有多条执行路径在执行不同的任务，而这些执行路径其实就是线程。一个程序就是一个进程，而一个程序中的多个任务则被称为线程。进程是表示资源分配的基本单位，线程是进程中执行运算的最小单位，亦是调度运行的基本单位；</p></li><li><p>三种创建线程的方式：</p><ul><li><p><code>继承Thread类</code>： 即继承Thread类，重写run()方法，并new子类对象之后调用start()方法来启动线程；</p><pre><code class="hljs java"><span class="hljs-comment">//第一种方式：继承Thread类</span>                        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;                            <span class="hljs-keyword">private</span> String name;                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadA</span><span class="hljs-params">(String name)</span> </span>&#123;                            <span class="hljs-keyword">this</span>.name = name;                            &#125;                            <span class="hljs-comment">//重写Run()方法</span>                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;                                    System.out.println(name+<span class="hljs-string">"正在跑："</span>+i);                    &#125;                &#125;            &#125;            <span class="hljs-comment">//----------------------------------------------------</span>                        <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;                            <span class="hljs-comment">//创建线程</span>                ThreadA ta1 = <span class="hljs-keyword">new</span> ThreadA(<span class="hljs-string">"皮卡丘线程"</span>);                ThreadA ta2 = <span class="hljs-keyword">new</span> ThreadA(<span class="hljs-string">"杰尼龟线程"</span>);                            <span class="hljs-comment">//调用start()方法，告知系统你随时可以调用这两个线程了</span>                ta1.start();                ta2.start();                &#125;            &#125;</code></pre></li><li><p><code>实现Runnable接口(推荐使用)</code>：即实现Runnable接口，重写run()方法，并new Thread(Runnable实现类对象)，调用start()方法启动线程；</p><pre><code class="hljs java"><span class="hljs-comment">//第二种方式：实现Runnable接口</span></code></pre></li></ul></li></ul><p>class ThreadB implements Runnable {</p><pre><code>        private String name;        public ThreadB(String name) {            this.name = name;    }        //重写Run()方法        @Override        public void run() {            for(int i =1;i&lt;10;i++) {                System.out.println(name+&quot;线程，正在努力奔跑中...&quot;);            }        }    }    //--------------------------------------------------------------    public class Test {        public static void main(String[] args) {        //创建实现类对象        ThreadB tb1 = new ThreadB(&quot;金毛&quot;);        ThreadB tb2 = new ThreadB(&quot;二哈&quot;);        //创建线程，并将实现类对象放入        Thread t1 = new Thread(tb1);        Thread t2 = new Thread(tb2);        //调用start()方法，告知系统你随时可以调用这两个线程了        t1.start();        t2.start();        }    }    <pre><code class="hljs arduino">            -   `实现Callable&lt;V&gt;接口`：即实现Callable&lt;V&gt;接口，泛型是重写call()方法后的返回值类型，即如果线程结束后想要有一个返回值，就使用该方法创建线程即可；  **`注意：该方法依赖线程池才能使用，并且该方法可以抛出异常，即可以不用<span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span>捕获异常。`**-   线程的周期(即线程的<span class="hljs-number">5</span>种状态)：    ​      ![Image](./Image-jse5.png)    -   `新建(New)`：新创建了一个线程对象；-   `就绪(Runnable)`：线程对象创建后，其它线程调用了该对象的start()方法；该状态的线程位于可执行线程池中，等待获取CPU的使用权；        -   `运行(Running)`：就绪状态的线程获取了CPU，执行程序代码；运行时，线程中的<span class="hljs-built_in">run</span>()方法定义了线程需要进行的操作或功能；-   `阻塞(Blocked)`：堵塞状态是线程由于某种原因放弃CPU使用权，临时停止执行。直到线程进入就绪状态，才有机会转到执行状态；堵塞的情况分三种：        -   等待堵塞：正在执行中的线程执行了wait()方法，JVM会把该线程放入等待池中，需要使用notify()方法或者notifyAll()方法唤醒等待池里的线程；        -   同步堵塞：正在执行中的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中(锁池就是线程竞争锁对象的地方，拿到锁，线程进入就绪，进而执行，执行完后释放锁，锁池里的线程再次竞争)；        -   其它堵塞：正在执行中的线程遇到sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为堵塞状态；当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完成时，线程又一次转入就绪状态。    -   `死亡(Dead)`：线程运行完了或者因异常退出了<span class="hljs-built_in">run</span>()方法，该线程结束生命周期。-   线程的管理；    -   `wait()`：让线程等待，并释放锁，即让出执行权；    -   `sleep()`：静态方法，让线程睡一下，静态方法，不释放锁，最好不要用Thread的实例对象调用它，因为它睡眠的始终是当前正在运行的线程，而不是调用它的线程对象，它只对正在运行状态的线程对象有效；        ```java<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-title">implements</span> <span class="hljs-title">Runnable</span>&#123;</span>                @Override             <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;                    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"66"</span>);                &#125;            &#125;        &#125;                <span class="hljs-comment">//--------------------------</span>                <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> throws InterruptedException </span>&#123;  <span class="hljs-comment">//当前正在执行的是main线程</span>                                A a = <span class="hljs-keyword">new</span> A();  <span class="hljs-comment">//创建Runnable实现类对象</span>                                Thread t = <span class="hljs-keyword">new</span> Thread(a);  <span class="hljs-comment">//创建一个线程</span>                                t.start();  <span class="hljs-comment">//t线程进入就绪状态</span>                                t.sleep(<span class="hljs-number">2000</span>);  <span class="hljs-comment">//让t线程睡2秒</span>                                <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;                    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"bb"</span>);                &#125;            &#125;        &#125;                说明：当前正在执行的线程是main线程，然后在该线程里调用了其他线程t，而sleep方法的作用是让当前正在执行的线程进入阻塞，所以进入阻塞状态的是main线程，而不是t线程。</code></pre>-   `yield()`：静态方法，不释放锁，让出当前线程的cpu执行权(即从运行状态回到就绪状态，并等待获取执行权)，让同等优先权的线程先运行。如果没有同等优先权的线程，那么yield()方法将不会起作用；-   `join()`：线程对象调用该方法，不释放锁，调用join()方法的线程先执行，执行完成后才会去执行其他线程；-   `setDaemon(boolean on)`：线程对象调用该方法，将线程设置为守护线程，用户线程执行完成后，守护线程也会退出；-   `currentThread()`：静态方法，获取当前线程的对象；-   `interrupt()`：线程对象调用该方法，将线程的状态终止，并抛出一个异常，但是run()方法剩余的代码还会继续执行，直到执行完毕；</code></pre><ul><li><p>线程同步：</p><ul><li><p>定义：Java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时(如，数据的增删改查)，将会导致数据不准确，相互之间产生冲突；因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性；</p></li><li><p>解决线程不安全的有以下几种方式：</p><ul><li><p><code>同步方法(锁对象是隐含的this对象)</code>：即有synchronized关键字修饰的方法。原因：由于Java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法，在调用该方法前，需要获得内置锁，否则就处于阻塞状态；<strong><code>注意：静态同步方法的锁对象是类的字节码文件对象。</code></strong></p><pre><code class="hljs java"><span class="hljs-comment">//并发问题，使用synchronized方法</span></code></pre></li></ul><p>class W12306 implements Runnable {</p><pre><code>static int ticket = 100;boolean flag = true;    public W12306() {}    @Override    public void run() {        while (flag) {            try {                Thread.sleep(200);            } catch (InterruptedException e) {                e.printStackTrace();            }            qiangpiao();        }    }    //在这个方法上添加synchronized关键字，即使用同步锁    public synchronized void qiangpiao() {        if (ticket &lt;= 0) {            flag = false;            return;        } else {            try {                Thread.sleep(200);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + &quot;抢到票啦！！&quot; + &quot;剩余：&quot; + ticket--);        }    }}<pre><code class="hljs autohotkey">    -   `同步块(任意非匿名对象，也可以使用this对象)`：即有synchronized关键字修饰的语句块；被该关键字修饰的语句块会自动被加上内置锁，从而实现同步；        ```java//并发问题,使用synchronized同步块</code></pre></code></pre></li></ul><p>class W12306 implements Runnable{</p><pre><code>static int ticket = 10;boolean flag = true;public W12306() {}    @Override    public void run() {        while(flag) {            try {                Thread.sleep(200);            } catch (InterruptedException e) {                e.printStackTrace();            }            qiangpiao();        }    }    public void qiangpiao() {        //双重判断机制，即票的剩余数量如果小于等于0就没必要进行同步操作了        if(ticket&lt;=0) {            flag = false;            return;        }        //这里就是synchronized同步块        synchronized(this) {            if(ticket&lt;=0) {                flag = false;                return;            }else {                try {                    Thread.sleep(200);                } catch (InterruptedException e) {                    e.printStackTrace();                } System.out.println(Thread.currentThread().getName()+&quot;抢到票啦！！&quot; +&quot;剩余：&quot;+ticket--);            }        }    }}<pre><code class="hljs cs">        -   Lock锁(JDK1<span class="hljs-number">.5</span>以后新增)：即实现了`java.util.concurrent.locks`接口的实现类，也就是`ReentrantLock(可重入锁)`。            -   构造方法：                -   `ReentrantLock()`：默认是非公平锁。意思就是说，线程总会有个先来后到，非公平锁就会使得线程之间是一个竞争CPU执行权的关系；    -   `ReentrantLock(boolean fair)`：可选公平锁，即参数是<span class="hljs-literal">true</span>，就是公平锁；参数是<span class="hljs-literal">false</span>，就是非公平锁；如果是公平锁，CPU的执行权会按照线程申请锁的时间顺序获得锁进行分配，也就是像栈一样，先进先出，先申请的线程自然就先获得CPU执行权，执行完成后，会将CPU执行权给第二个申请锁的线程，以此类推，就几乎不会出现同一个线程连续执行多次的情况。    -   常用方法：        -   `<span class="hljs-keyword">lock</span>()`：上锁；                -   `unlock()`：释放锁。                    ```java<span class="hljs-keyword">class</span> <span class="hljs-title">W12306</span> <span class="hljs-title">implements</span> <span class="hljs-title">Runnable</span>&#123;                        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">10</span>;                        boolean flag = <span class="hljs-literal">true</span>;                                    <span class="hljs-comment">//创建一个ReentrantLock锁对象</span>                    <span class="hljs-keyword">private</span> ReentrantLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();                                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">W12306</span>(<span class="hljs-params"></span>)</span> &#123;&#125;                                @Override                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;                                        <span class="hljs-keyword">while</span>(flag) &#123;                            <span class="hljs-keyword">try</span> &#123;                                Thread.sleep(<span class="hljs-number">200</span>);                            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                                e.printStackTrace();                            &#125;                            qiangpiao();                        &#125;                    &#125;                                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">qiangpiao</span>(<span class="hljs-params"></span>)</span> &#123;                                        <span class="hljs-keyword">if</span>(ticket&lt;=<span class="hljs-number">0</span>) &#123;                            flag = <span class="hljs-literal">false</span>;                                            <span class="hljs-keyword">return</span>;                        &#125;                                        <span class="hljs-comment">//这里使用ReentrantLock锁</span>                        <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-comment">//上锁</span>                <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();                                            <span class="hljs-keyword">if</span>(ticket&lt;=<span class="hljs-number">0</span>) &#123;                                                flag = <span class="hljs-literal">false</span>;                                                <span class="hljs-keyword">return</span>;                                            &#125;<span class="hljs-keyword">else</span> &#123;                                <span class="hljs-keyword">try</span> &#123;                                    Thread.sleep(<span class="hljs-number">200</span>);                                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                                    e.printStackTrace();                                &#125;                                                 System.<span class="hljs-keyword">out</span>.println(Thread.currentThread().getName()+<span class="hljs-string">"抢到票啦！！"</span> +<span class="hljs-string">"剩余："</span>+ticket--);                                            &#125;                        &#125;<span class="hljs-keyword">finally</span>&#123;                        <span class="hljs-comment">//释放锁</span>                        <span class="hljs-keyword">lock</span>.unlock();                        &#125;                    &#125;                &#125;</code></pre></code></pre></li><li><p><code>ReentrantLock</code>和<code>synchronized</code>的区别：</p><ul><li>相同点：<ul><li>两者都是可重入锁。如，当一个线程执行到某个上锁的方法时，比如说method1，而在method1中会调用另外一个上锁的方法method2，此时线程不必重新去申请method2的锁，而是可以直接执行方法method2。</li></ul></li><li>不同点：<ul><li>底层实现不一样：<ul><li>synchronized是Java语言的关键字，是原生语法层面的互斥，需要JVM实现；</li><li>ReentrantLock是JDK1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try-finally语句块来使用。</li></ul></li><li>释放锁的机制不一样：<ul><li>synchronized隐式(自动)释放锁。不会造成死锁现象的发生；</li><li>ReentrantLock则是显示的释放锁。如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，需要搭配finally块使用。</li></ul></li><li>并发策略不一样：</li><li>synchronized是同步阻塞，使用的是悲观并发策略；<ul><li>lock是同步非阻塞，采用的是乐观并发策略。</li></ul></li><li>等待机制不同：<ul><li>使用synchronized时，等待的线程会一直等待下去，不能够中断等待；</li><li>ReentrantLock则可以让线程放弃等待。</li></ul></li><li>锁种类不一样：<ul><li>synchronized只有非公平锁；</li><li>ReentrantLock可以选择非公平锁和公平锁。</li></ul></li><li>唤醒线程的方式不一样：<ul><li>synchronized要么随机唤醒一个线程要么唤醒全部线程；</li><li>ReentrantLock对象可以同时绑定对个对象。ReenTrantLock提供了一个Condition(条件)类，用来实现分组唤醒需要唤醒的线程们。</li></ul></li></ul></li></ul></li><li><p>多线程安全问题产生的原因：</p><ul><li>是否有多线程环境；</li><li>是否有共享数据；</li><li>是否有多条语句操作共享数据。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-24-线程池"><a href="#NO3-24-线程池" class="headerlink" title="NO3.24 线程池"></a>NO3.24 线程池</h3><p>我们可以使用一个线程池来放置那些需要用到的线程。</p><ul><li>线程池：<ul><li>定义：用来放置那些要使用的线程的集合；</li><li>出现原因：由于创建和关闭线程的资源消耗比较多，为了提高性能，我们经常使用线程池来放置我们要使用的线程；</li><li>工作机制：任务是提交给整个线程池，而不是直接提交给某个线程，线程池在拿到任务后，就在内部寻找是否有空闲的线程，如果有，则将任务交给某个空闲的线程；</li><li>两个对象：<ul><li><code>Executors</code>：线程池的工厂类，是一个用于创建不同类型的线程池的工具类；</li><li><code>ExecutorService</code>：这是一个接口，但作为返回值返回给我们的时候，返回的应该是其实现类的对象，也就是说，Executors工厂类创建线程池后返回的ExecutorService接口，其实返回的是这个接口的实现类的对象。主要方法有：<ul><li><code>void execute(Runnable command)</code>：执行一个任务，没有返回值，一般用于实现类Runnable接口的线程；</li><li><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>：也是执行一个任务，有返回值，即用于实现了Callable接口的线程；</li><li>shutdown()：关闭线程池。当线程池调用该方法时，线程池的状态则立刻变成SHUTDOWN状态，也就不能再往线程池中添加任何任务，否则将会抛出RejectedExecutionException异常。此时线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出。</li></ul></li></ul></li><li>常见的线程池创建方式：<ul><li>``ExecutorService Executors.newCacheThreadPool()`：创建一个可缓存的线程池；<ul><li>特点：<ul><li>先查看池中有没有以前建立的线程，如果有，就直接使用；如果没有，就建一个新的线程加入池中；</li><li>如果处理需要的线程数超过了线程池最大容纳度，可灵活回收空闲线程，若无可回收，则新建线程；</li><li>如果长时间没有往该线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程；</li><li>缓存型池子通常用于执行一些生存期很短的异步型任务。</li></ul></li></ul></li><li><code>ExecutorService Executors.newFixedThreadPool(int n)(推荐使用这个)</code>：创建一个可复用的固定线程个数的线程池；<ul><li>特点：<ul><li>每当提交一个任务就创建一个工作线程；</li><li>如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。</li></ul></li></ul></li><li><code>ExecutorService Executors.newScheduledThreadPool(int n)</code>：创建一个定长线程池；<ul><li>特点：<ul><li>支持定时及周期性任务的执行。</li></ul></li></ul></li><li><code>ExecutorService Executors.newSingleThreadExecutor()</code>：创建一个单线程化的线程池。<ul><li>特点：<ul><li>该程池中最多执行1个线程，之后提交的线程任务，将会排在队列中并以此队列顺序执行；</li><li>可定时或者延迟执行线程任务。</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="NO3-25-String类的使用"><a href="#NO3-25-String类的使用" class="headerlink" title="NO3.25 String类的使用"></a>NO3.25 String类的使用</h3><p>String类是Java中常用的一个类。</p><ul><li><p>String：</p><ul><li><p>定义：用来创建和操作字符串的类型，就是String类型。</p></li><li><p>特点：</p><ul><li><p>String可以看成是一个字符数组；</p></li><li><p>字面值字符串也可以看成是一个字符串对象；</p></li><li><p>字符串是常量，一旦被赋值，值就不能改变，但可以使用其他变量重新赋值的方式进行更改；</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;String s = <span class="hljs-string">"aaa"</span>;s = <span class="hljs-string">"bbb"</span>;System.out.println(s);  <span class="hljs-comment">//这里会输出bbb</span>&#125; 说明：首先创建了一个字符串常量aaa，把aaa这个字符串的地址值赋值给了另一个字符串变量s，此时s指向的地址值中存放的内容为aaa；后面又创建了bbb这个字符串，且将这个字符串的地址值也赋值给了s，所以这个时候s中存放的地址值，是bbb字符串的地址值，然后s根据这个地址值找到在内存中所存放的值，这个值为bbb。</code></pre></li></ul></li><li><p>String类常用方法：</p><ul><li><p>判断方法：</p><ul><li>boolean equals(Object obj)：比较字符串的内容是否相同，区分大小写；</li><li>boolean equalsIgnoreCase(String str)：比较字符串的内容是否相同，忽略大小写；</li><li>boolean contains(String str)：判断字符串是否包含子字符串(连续的字符串)；</li><li>boolean startsWith(String str)：判断字符串是否以某个指定字符串开头；</li><li>boolean endsWith(String str)：判断字符串是否以某个指定字符串结尾；</li><li>boolean isEmpty()：判断字符串是否为空；</li></ul></li><li><p>获取方法：</p><ul><li>int length()：获取字符串的长度；</li><li>char charAt(int index)：获取指定索引位置的字符；</li><li>String substring(int start)：从指定位置开始截取字符串，默认到末尾；</li><li>String substring(int start,int end)：从指定位置开始到指定位置结束截取字符串；</li><li>int indexOf(String str)：返回指定字符串在此字符串中第一次出现的索引；</li><li>int indexOf(int ch)：返回指定字符在此字符串中第一次出现的索引(字符可以转成int类型)；</li></ul></li><li><p>转换方法：</p><ul><li>byte[] getBytes()：把字符串转换为字节数组；</li><li>char[] toCharArray()：把字符串转换为字符数组；</li><li>static String valueOf(Object obj)：将任意类型的数据转成字符串；</li><li>String toLowerCase()：把字符串转成小写；</li><li>String toUpperCase()：把字符串转成大写；</li><li>String concat(String str)：拼接字符串；</li></ul></li><li><p>其他方法：</p><ul><li><p>String replace(char old,char new)：用字符new替换所有的字符old；</p></li><li><p>String replace(String old,String new)：用字符串new替换所有的字符串old；</p></li><li><p>String trim()：去除字符串两端的空格；</p></li><li><p>int compareTo(String str)：</p><ul><li><p>当两个比较的字符串是英文且长度不等时：</p><ul><li><p>长度短的与长度长的字符内容完全一致，则返回的结果是两个长度相减的值；</p></li><li><p>长度不一样且字符内容也不一致，从第一位开始找，当找到不一样的字符时，则返回的值是这两个字符的ASCII码表的差值;</p><pre><code class="hljs java">String s1 = <span class="hljs-string">"hello"</span>;                                                String s2 = <span class="hljs-string">"hello"</span>;                                                String s3 = <span class="hljs-string">"hel"</span>;                                                String s4 = <span class="hljs-string">"abc"</span>;                                                String s5 = <span class="hljs-string">"xyz"</span>;                                                s1.compareTo(s2);  <span class="hljs-comment">//结果为0</span>                                                s1.compareTo(s3);  <span class="hljs-comment">//结果为2，两者字符一样，结果为s1的长度，减去s2的长度，等于2</span>                                                s1.compareTo(s4);  <span class="hljs-comment">//结果为7，两者字符第一位就不一样，则h的ASCII值为104，a的ASCII值为97，所以差值为7</span>                                                s1.compareTo(s5);  <span class="hljs-comment">//结果为-16，两者字符第一位就不一样，则h的ASCII值为104，x的ASCII值为120，所以差值为-16</span></code></pre></li></ul></li></ul></li></ul></li></ul></li><li><p>一个面试题。</p><pre><code class="hljs java">字符串比较        String a = <span class="hljs-string">"1"</span>;        String b = <span class="hljs-string">"2"</span>;        String c = <span class="hljs-string">"1"</span>+<span class="hljs-string">"2"</span>;        String d = a+b;        System.out.println(c==d);  <span class="hljs-comment">//false</span>        System.out.println(c.equals(d));  <span class="hljs-comment">//true，equals()比较的是值，c="12"，d="12"，所以为true</span>        说明：    一、字符串如果是变量相加，先开空间，再拼接        二、字符串如果是常量相加，先拼接，然后再去字符串常量池里找，如果有就直接返回地址，没有就创建一个，并返回地址；编译时，c=<span class="hljs-string">"12"</span>，常量池没有，创建并返回了地址值；而d=a+b，先开辟空间，然后拼接得到<span class="hljs-string">"12"</span>，再去常量池找，得到地址值，返回给d在堆内存开辟的空间，然后再将空间地址值赋给d</code></pre></li><li><p>一个面试题：</p><pre><code class="hljs java">String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"hello"</span>) 和 String s1 = <span class="hljs-string">"hello"</span> 的区别        前者会在堆内存开辟一个空间<span class="hljs-keyword">new</span>对象，然后将值<span class="hljs-string">"hello"</span>与方法区里面的字符串常量池进行对比，如果有，就直接返回字符串常量池里这个值的地址值，然后<span class="hljs-keyword">new</span>对象开辟的空间也有一个地址值，s就指向<span class="hljs-keyword">new</span>对象开辟的空间地址值，而该空间内部存放的是<span class="hljs-string">"hello"</span>在字符串常量池中的地址值；如果没有，则创建值<span class="hljs-string">"hello"</span>放入字符串常量池中，并返回地址值给堆内存，然后s指向堆内存开辟的空间；        后者直接将值<span class="hljs-string">"hello"</span>与方法区里面的字符串常量池进行对比，有就返回地址值，没有就创建并返回地址值；        差异：前者一般会创建<span class="hljs-number">2</span>(或<span class="hljs-number">1</span>)个对象，后者一般只创建<span class="hljs-number">1</span>(或<span class="hljs-number">0</span>)个对象；        注意：当字符串常量池中有该数据时，则不需要创建，直接返回地址值</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-26-可变字符序列"><a href="#NO3-26-可变字符序列" class="headerlink" title="NO3.26 可变字符序列"></a>NO3.26 可变字符序列</h3><p>在Java中，除了通过String类创建和处理字符串之外，还可以使用可变字符序列来处理字符串。</p><ul><li>可变字符序列：<ul><li>定义：即内容可以随意变换的可变字符串类；</li><li>种类：<ul><li>StringBuffer：线程安全的可变字符串类。因为线程安全，所以效率低；</li><li>StringBuilder：线程不安全的可变字符串类。因为线程不安全，所以效率高一些。</li></ul></li><li>两种可变字符序列的区别：<ul><li>不同点：<ul><li>StringBuffer：线程安全，效率低；</li><li>StringBuilder：线程不安全，效率高。</li></ul></li><li>相同点：<ul><li>可变字符串序列内容的增删改都不会改变其本身的地址值，这是可变字符序列的最大特点；</li><li>可变字符串序列可以添加任意数据类型的数据，但最终结果都是字符串。</li></ul></li></ul></li><li>常用方法：<ul><li>构造方法：<ul><li>StringBuffer()：构造一个空的字符串缓冲区，并且初始化为16个字符的容量；</li><li>StringBuffer(int length)：创建一个空的字符串缓冲区，并且初始化为指定长度 length的容量；</li><li>StringBuffer(String str)：创建一个字符串缓冲区，并将其内容初始化为指定的字符串内容str，字符串缓冲区的初始容量为 16 加上字符串 str 的长度。</li></ul></li><li>成员方法：<ul><li>添加：<ul><li>append(Object obj)：在尾部添加任意数据；</li><li>insert(int start,Object obj)：在指定位置添加任意数据；</li></ul></li><li>删除：<ul><li>deleteCharAt(int index)：删除指定索引位置上的字符；</li><li>delete(int start,int end)：删除从start开始到end(不包括end)位置结束的内容；</li></ul></li><li>替换：<ul><li>replace(int start,int end,String str)：从start开始到end(不包括end)用str替换；</li></ul></li><li>反转：<ul><li>reverse()：反转字符串；</li></ul></li><li>截取：<ul><li>String substring(int start)：截取从start开始，默认到末尾的字符串；</li><li>String substring(int start,int end)：截取从start开始到end(不包括end)，获取截取到的字符串；</li></ul></li></ul></li></ul></li><li>可变字符序列和字符串的互相转换：<ul><li>字符串转换成可变字符序列：<ul><li>使用new可变字符序列对象 方式：<code>StringBuilder 变量名 = new StringBuilder(&quot;字符串&quot;);</code>；</li></ul></li><li>可变字符序列转换成字符串：<ul><li>使用对象本身拥有的toString方法：<code>可变字符序列变量名.toString();</code>；</li><li>使用String类的方法：<code>String.valueOf(s2);</code>。</li></ul></li></ul></li><li>参数传递：<ul><li>可变字符序列作为形式参数传递时，作简单的赋值操作，不改变实际参数；</li><li>使用可变字符序列对象调用方法(即调用append等方法时)，则会改变实际参数。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-27-日期类的使用"><a href="#NO3-27-日期类的使用" class="headerlink" title="NO3.27 日期类的使用"></a>NO3.27 日期类的使用</h3><p>Java中的日期类也有几个，但现在常用的是Calendar类。</p><ul><li><p>日期类：</p><ul><li><p>定义：拥有获取当前时间的类；</p></li><li><p>种类：</p><ul><li><p>Date类：</p><ul><li><p>构造方法：</p><ul><li>Date()：初始化一个简单的Date对象；</li><li>Date(long date)：初始化一个带毫秒的Date对象，即表示从1970 年1月1日0时0分0秒开始经过参数date指定的毫秒数。</li></ul></li><li><p>常用成员方法：</p><ul><li>long getTime()：返回从1970 年1月1日0时0分0秒开始到现在经过的毫秒数；</li><li>String toString()：把Date对象转换为以下形式的字符串: dow mon dd hh:mm:ss zzz yyyy；其中dow是一周中的某一天(Sun、Mon、Tue、Wed、Thu、Fri 及 Sat)。</li></ul></li><li><p>SimpleDateFormat类：日期格式化类，即把日期格式化成自己想要的格式；通常配合Date类一起使用</p><ul><li><p>常用成员方法：</p><ul><li><p>String format(Date date)：将Date对象格式化成自己想要的日期/时间字符串；</p></li><li><p>Date parse(String source)：将给定的字符串解析成日期/时间。</p><pre><code class="hljs java"><span class="hljs-comment">//将Date转成指定格式的日期字符串</span>                        SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);                                                <span class="hljs-comment">//调用转换的方法，并加入参数：当前时间</span>                        String time = sdf.format(<span class="hljs-keyword">new</span> Date());                                                <span class="hljs-comment">//输出结果为：2019-09-29 17:43:00</span>                        System.out.println(time);                                                <span class="hljs-comment">//--------------------------------------------------</span>                                                <span class="hljs-comment">//将日期字符串转成Date对象</span>                        String time = <span class="hljs-string">"2019年08月14 22点52分30秒"</span>;                                                SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy年MM月dd HH点mm分ss秒"</span>);                                                <span class="hljs-comment">//解析字符串式的日期时间</span>                        Date date = sdf.parse(time);                                                System.out.println(date);</code></pre></li></ul></li></ul></li></ul></li><li><p>Calendar类：</p><ul><li><p>构造方法：没有构造方法，使用<code>Calendar 变量名 = Calendar.getInstance();</code> 获取Calendar对象；</p></li><li><p>常用成员方法：</p><ul><li><p>int get(int field)：返回指定日历字段的值；其中field可以为：</p><ul><li>Calendar.YEAR：年份；</li></ul></li></ul></li><li><p>Calendar.MONTH：月份；这里的月份是从0开始的；</p><pre><code>-   Calendar.DAY_OF_MONTH：日期，和上面的字段意义完全相同；-   Calendar.HOUR：12小时制的小时；-   Calendar.HOUR_OF_DAY：24 小时制的小时；-   Calendar.MINUTE：分钟；-   Calendar.SECOND：秒；-   Calendar.DAY_OF_WEEK：星期几。</code></pre><ul><li><p>Date getTime()：返回一个从格林威治时间1970年01月01日00时<br>00 分00秒至现在经过的毫秒转成的Date 对象；</p><pre><code class="hljs java"><span class="hljs-comment">//用getInstance()方法来获取Calendar类的一个通用对象</span>                    Calendar c = Calendar.getInstance();                                <span class="hljs-comment">//可以通过get()方法获取年月日、时分秒等信息，然后作字符串拼接</span>                    System.out.println(c.get(Calendar.YEAR));                                        <span class="hljs-comment">//注意：月份是从0开始的，所以要获得真正月份需要加1</span>                    System.out.println(c.get(Calendar.MONTH)+<span class="hljs-number">1</span>);                                        System.out.println(c.get(Calendar.DAY));</code></pre></li><li><p>.set(int year,int month,int date)：直接设置年月日；</p></li><li><p>add(int field,int amount)：根据给定的日历字段和对应的时间，来对当前日历进行操作；</p><pre><code class="hljs java">Calendar c = Calendar.getInstance();</code></pre></li></ul></li></ul></li></ul></li></ul><p>//表示设置一个日期</p><pre><code>            c.set(2019,8,14);            //表示当前年份的前五年            c.add(c.get(Calendar.YEAR),-5);            <pre><code class="hljs arduino">                    -   JDK8后，新增获取日期/时间的方式：                    -   `LocalDate time = LocalDate.now()`，输出time获取当前年月日；            -   `LocalTime time = LocalTime.now()`，输出time获取当前时分秒；            -   `LocalDateTime time = LocalDateTime.now()`，输出time获取当前年月日时分秒。&amp;nbsp;&amp;nbsp;### NO3<span class="hljs-number">.28</span> 比较器比较器一般用于对象之间的比较，常常用来解决排序问题。-   比较器：    -   定义：是Java为了统一比较规则而产生的，一般用于对象之间的排序问题；    -   种类：        -   `Comparable&lt;T&gt;`：自然排序比较器。这是一个接口，需要重写接口中的CompareTo(Obj obj)方法，这种情况下，在使用java.util.Arrays.sort()方法时不用指定具体的比较器，sort()方法会使用对象自己的比较函数(也就是你写的CompareTo方法)对对象进行排序。该方法有一个<span class="hljs-keyword">int</span>类型的返回值：            -   返回正数：即当前对象的<span class="hljs-keyword">this</span>大于形参对象obj；            -   返回负数：即当前对象的<span class="hljs-keyword">this</span>小于形参对象obj；            -   返回<span class="hljs-number">0</span>：即当前对象的<span class="hljs-keyword">this</span>等于形参对象obj。                ```java<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-title">implements</span> <span class="hljs-title">Comparable</span>&lt;Student&gt; &#123;</span>                                    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name;                    <span class="hljs-keyword">private</span> Integer age;                                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student1</span><span class="hljs-params">(<span class="hljs-keyword">String</span> name, Integer age)</span> </span>&#123;                        <span class="hljs-keyword">this</span>.name = name;                        <span class="hljs-keyword">this</span>.age = age;                    &#125;                                        <span class="hljs-comment">//....get和set方法....</span>                                        @Override                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Student s)</span> </span>&#123;                                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAge()-s.getAge();                    &#125;                &#125;                                <span class="hljs-comment">//-------------------------------------------</span>                                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;                                 Student[] arr = <span class="hljs-keyword">new</span> Student[];                                        Student s1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"a"</span>,<span class="hljs-number">19</span>);                Student s2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"b"</span>,<span class="hljs-number">17</span>);                                        <span class="hljs-comment">//我们设定，数组中按照年龄进行排序，即年龄大的放前面</span>                Arrays.sort(arr);                &#125;</code></pre>-   `Comparator&lt;T&gt;`：定制排序比较器。这也是一个接口，JDK1.8之后出现；需要重写compare(Obj obj1,Obj obj2)方法；一般用于没有实现Comparable接口，或在不想修改代码的基础上进行实现比较排序时使用，又或者实现了Comparable，但不想按照该接口中的方法进行排序。该方法也有一个int类型返回值，和Comparable接口的中重写的方法的返回值一致：即返回正数，obj1大于obj2，返回负数就小于，返回0就相等；    <pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;</code></pre>private String name;        private Integer age;        public Student1(String name, Integer age) {            this.name = name;            this.age = age;        }        //....get和set方法....    }    //-------------------------------------------    class StudentComparator implements Comparator&lt;Student&gt;{        @Override        public int compareTo(Student s1,Student s2) {            return s1.getAge()-s2.getAge();        }    }</code></pre></li></ul><pre><code>​    ​    //-------------------------------------------​    ​    public static void main(String[] args) {​     ​        Student[] arr = new Student[];​            ​        Student s1 = new Student(&quot;a&quot;,19);​        Student s2 = new Student(&quot;b&quot;,17);​            ​        //我们设定，数组中按照年龄进行排序，即年龄大的放前面​        Arrays.sort(arr,new StudentComparator());​    }        ​    ```</code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-29-System类和Math类的使用"><a href="#NO3-29-System类和Math类的使用" class="headerlink" title="NO3.29 System类和Math类的使用"></a>NO3.29 System类和Math类的使用</h3><p>这两个类，用的不是很多，但是也是需要了解一下。</p><ul><li><p>System类：</p><ul><li><p>定义：代表系统类，系统级的很多属性和方法都放置在该类中。</p></li><li><p>常用方法：</p><ul><li><p>arraycopy(Object src,int srcStart,Object dest,int desStart,int length)：从指定源数组，指定位置开始复制指定个数的元素，到从指定位置开始的目标数组(<strong><code>注意：会替代被复制的元素</code></strong>)；</p><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>,<span class="hljs-number">55</span>&#125;;                        <span class="hljs-keyword">int</span>[] arr2 = &#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;                        System.arraycopy(arr,<span class="hljs-number">1</span>,arr2,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);                        System.out.println(Arrays.toString(arr));  <span class="hljs-comment">//结果为：[11,22,33,44,55]</span>            System.out.println(Arrays.toString(arr2));  <span class="hljs-comment">//结果为：[6,7,22,33,10]</span></code></pre></li><li><p>void exit(int status)：退出虚拟机(也就是退出程序的意思)。参数status如果是0，表示正常退出；如果是非0，表示异常退出；</p></li></ul></li></ul></li><li><p>void gc()：用于请求系统进行垃圾回收。根据系统自身情况(回收机制算法及系统当时的情况)，系统自己会去执行。</p></li></ul><p>&nbsp;</p><ul><li><p>Math类：</p><ul><li><p>定义：用于数学计算的一个类。</p></li><li><p>常用方法：</p><ul><li><p>static int abs(double/float/int/long a)：获取a的绝对值；</p></li><li><p>static double ceil(double a)：向上取整(比a大的最小整数)；</p></li><li><p>static double floor(double a)：向下取整(比a小的最大整数)；</p></li><li><p>static int max(int a,int b)：获取最大值；</p></li><li><p>static int min(int a,int b)：获取最小值；</p></li><li><p>static double pow(double a,double b)：a的b次幂；</p></li><li><p>static double random()：获取随机数，范围是[0.0,1.0)，包括0，但不包括1；</p></li><li><p>static int round(float a)：四舍五入；</p></li><li><p>static double sqrt(double a)：获取正平方根，即开平方；</p><pre><code class="hljs java">System.out.println(Math.ceil(<span class="hljs-number">12.34</span>));<span class="hljs-comment">//比12.34大的最小整数，结果为13.0</span>            System.out.println(Math.ceil(<span class="hljs-number">12.56</span>));<span class="hljs-comment">//比12.56大的最小整数，结果为13.0</span>                        System.out.println(Math.floor(<span class="hljs-number">12.34</span>));<span class="hljs-comment">//比12.34小的最大整数，结果为12.0</span>            System.out.println(Math.floor(<span class="hljs-number">12.56</span>));<span class="hljs-comment">//比12.56小的最大整数，结果为12.0</span>                        拓展：BigInteger和BigDecimal            一、BigInteger是比<span class="hljs-keyword">long</span>类型更大的整数类型                            二、BigDecimal用于商业计算中，因为商业计算的精度要求很高。也就是说该类型比<span class="hljs-keyword">double</span>精度更高。</code></pre></li></ul></li></ul></li></ul><p>&nbsp;<br>&nbsp;</p><h3 id="NO3-30-枚举类"><a href="#NO3-30-枚举类" class="headerlink" title="NO3.30 枚举类"></a>NO3.30 枚举类</h3><p>一周的星期只能是7天中的一个，类似这种当一个变量有几种固定可能的取值时，就可以将它定义为枚举类型。</p><ul><li><p>枚举：</p><ul><li><p>定义：枚举是一个的整型常数的集合，而这个集合中，每一个常数都有对应的名称去标识；</p></li><li><p>关键字：<code>enum</code>；</p></li><li><p>特点：</p><ul><li>JDK1.5之后出现，之前都是使用接口；</li><li>任意两个枚举成员不能具有相同的名称；</li><li>枚举中的元素，其常数值必须在该枚举的基础类型的范围之内；</li><li>多个枚举成员之间使用逗号分隔；</li><li>枚举类型隐性地继承自java.lang.Enum；</li><li>枚举元素默认都是public static final修饰的。</li></ul></li><li><p>基本语法格式：</p><pre><code class="hljs java"><span class="hljs-keyword">enum</span> 枚举类名&#123;枚举元素<span class="hljs-number">1</span>，枚举元素<span class="hljs-number">2</span>,....;&#125;如：<span class="hljs-keyword">enum</span> Sesson&#123;SPRING,SUMMER,FALL,WINTER;&#125;System.out.println(Sesson.FALL);  <span class="hljs-comment">//因为没有在Sesson枚举类中重写toString()方法，所以这里输出FALL的字符串形式，即结果为FALL</span></code></pre></li><li><p>枚举类的常用的方法：</p><ul><li>values()：以数组形式返回枚举类型的所有成员；</li><li>valueOf(Obj name)：根据name参数去枚举中找同名的枚举实例；如果没找到，就抛出异常；</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-31-集合"><a href="#NO3-31-集合" class="headerlink" title="NO3.31 集合"></a>NO3.31 集合</h3><p>集合是开发者常用到的。</p><ul><li><p>集合：</p><ul><li><p>定义：为了保存数量不确定的对象数据，Java提供了集合类，集合是一个容器；</p></li><li><p>种类：</p><ul><li><code>Collection</code>：单列容器的顶层接口。主要有三个子接口：<ul><li><code>List</code>：<ul><li>定义：列表接口；</li><li>特点：<ul><li>元素是有序的：即元素有下标(即存储和取出的顺序是一致的)；</li><li>元素可重复：即元素可以相同。</li></ul></li><li>实现类的特点：<ul><li><code>ArrayList</code>：查询快，增删慢，线程不安全，底层数据结构是数组；</li><li><code>LinkedList</code>：查询慢，增删快，线程不安全，底层数据结构是链表；</li><li><code>Vector(不常用)</code>：查询快，增删慢，线程安全，底层数据结构是数组。</li></ul></li></ul></li><li><code>Set</code>：<ul><li>定义：集合接口；</li><li>特点：<ul><li>无序：即元素没有下标(即存储和取出顺序是不一致的)；</li><li>元素不可重复的：即元素唯一，也就是说每一个元素不可以相同。</li></ul></li><li>实现类的特点：<ul><li><code>HashSet</code>：无序的(即存储和取出顺序不一致)；底层数据结构是哈希表(即元素为链表的数组)；<ul><li>HashSet元素的唯一性依赖于：hashCode()和equals()；</li><li>HashSet的子类<code>LinkedHashSet</code>：有序的(即存储和取出顺序一致)，底层数据结构是哈希表和链接列表(即链表)；哈希表保证元素唯一性，链表保证元素有序；</li></ul></li><li><code>TreeSet</code>：能够排序，底层数据结构是红黑树。<ul><li>一种排序方法是：使用无参构造；<ul><li>基本数据类型：使用无参构造即可(即按照自然排序规则，给元素进行排序，该排序不适用对象类型排序；以第一个元素为根节点，小的放左边，大的放右边，相等的元素不放入；取出时，按左中右顺序依次取出(也就是中序遍历)；</li><li>引用数据类型：实体类要实现Comparable接口，重写compareTo(Object obj)方法，一般排序条件写两到三个，是为了防止比较的条件相同，最后根据返回值进行排序即可；</li></ul></li><li>另一种排序方法是：比较器排序；<ul><li>使用TreeSet的带参构造方法即可，参数是比较器Comparator的子类对象(可使用匿名内部类的方式，即new Comparator())，重写compare()方法即可，最后根据返回值进行排序。</li></ul></li></ul></li></ul></li></ul></li><li>Queue：LinkedList实现类该接口，所以参照LinkedList即可。</li></ul></li><li>Map：双列容器的顶层接口。<ul><li>特点：以一个键值对的形式存入数据。即一个键，对应一个值；键值对的键不能重复，即键唯一，如果添加的键值对中，键相同，则键不存储，而值覆盖；保证一个键对应一个值；</li><li>常用的实现类特点：<ul><li><code>HashMap</code>：无序的(即存储和取出顺序不一致)，底层数据结构是哈希表(元素是链表的数组)，所以在查询和增删上，效率都比较高；<ul><li><code>LinkedHashMap</code>：是HashMap的子类。有序的(即存储和取出顺序一致)，底层数据结构是哈希表和链表；</li></ul></li><li><code>TreeMap</code>：按Key排序的，是典型的红黑二叉树结构，排序方法参照TreeSet即可；</li><li><code>Hashtable(被HsahMap替代)</code>：HashMap和HashTable的区别。<ul><li><code>HashMap</code>：线程不安全，效率高；允许null键和null值；</li><li><code>Hashtable</code>：线程安全，效率低；不允许null键和null值。</li></ul></li></ul></li></ul></li></ul></li><li><p>基本语法格式：<code>集合类名&lt;T&gt; 变量名 = new 集合类名()&lt;T&gt;</code>；如，<code>ArrayList&lt;Student&gt; s = new ArrayList()&lt;Student&gt;</code>；泛型优点如下：</p><ul><li>在编译的时候检查类安全；</li><li>所有强制转换都是自动和隐式的，提高代码的重用率。</li></ul></li><li><p>应用场景：</p><ul><li>如果你知道是List，但是不知道是哪个List，就用ArrayList；</li><li>如果你知道是Set，但是不知道是哪个Set，就用HashSet；</li></ul></li><li><p>集合常用方法：</p><ul><li>Collection：<ul><li><code>boolean add(E e)</code>：向集合中添加一个元素，添加成功，则返回true。E 是元素的数据类型；</li><li><code>boolean addAll(Collection c)</code>：向集合中添加集合c中的所有元素，添加成功，则返回true；</li><li><code>boolean contains(Object o)</code>：判断集合中是否存在指定元素，存在则返回true；</li><li><code>boolean isEmpty()</code>：判断集合是否为空；</li><li><code>Iterator&lt;E&gt; iterator()</code>：返回一个Iterator对象，Iterator对象用于遍历集合中的元素；</li><li><code>boolean remove(Object o)</code>：从集合中删除一个指定元素，当集合中包含了一个或多个元素o时，该方法只删除第一个符合条件的元素，该方法将返回true；</li><li><code>int size()</code>：返回集合中元素的个数；</li><li><code>Object[] toArray()</code>：把集合转换为一个数组，所有的集合元素变成对应的数组元素。</li></ul></li><li>Map：<ul><li>V put(K key, V value)：向Map集合中添加键值对，如果当前Map中已有一个与该key 相同的key-value对，则新的key-value对会覆盖原来的key-value对；</li><li>V get(Object key)：返回Map集合中指定键所对应的值。V表示值的数据类型；</li><li>boolean containsKey(Object key)：查询Map中是否包含指定的key，如果包含则返回true；</li><li>Set entrySet()：返回Map集合中所有键值对的Set集合，此Set集合中元素的数据类型为Map.Entry；</li><li>Set keySet()：返回 Map 集合中所有键对象的Set集合；</li><li>int size()：返回该 Map 里 key-value 对的个数。</li></ul></li></ul></li><li><p>迭代：</p><ul><li><p>遍历list、Set、Map集合时，尽量使用增强for循环(即foreach)或迭代器Iterator进行遍历操作。尤其是在边查询边删除时，一定要用迭代器去删除，而不是用集合本身去删除。</p><ul><li><p>迭代器中的方法：</p><ul><li><p>hasNext()：检查集合中是否还有元素；</p></li><li><p>next()：获得集合中的下一个元素；</p></li><li><p>remove()：将迭代器新返回的元素删除。</p><pre><code class="hljs java"><span class="hljs-comment">//迭代器遍历</span>                    HashSet&lt;String&gt; hs = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();                                        hs.add(<span class="hljs-string">"金毛"</span>);                                        hs.add(<span class="hljs-string">"二哈"</span>);                                        hs.add(<span class="hljs-string">"泰迪"</span>);                                        hs.add(<span class="hljs-string">"雪纳瑞"</span>);                                        hs.add(<span class="hljs-string">"雪纳瑞"</span>);                                        Iterator&lt;String&gt; it = hs.iterator();                                        <span class="hljs-keyword">while</span>(it.hasNext()) &#123;  <span class="hljs-comment">//用迭代器查看集合是否还有下一个元素</span>                                            String target = it.next();  <span class="hljs-comment">//获取迭代器所在的集合中的下一个元素</span>                                            <span class="hljs-keyword">if</span>(<span class="hljs-string">"泰迪"</span>.equals(target)) &#123;                                                <span class="hljs-comment">//hs.remove();  //这个是错误的，会产生并发异常，不要用集合本身去删除</span>                                                it.remove();  <span class="hljs-comment">//一定要使用迭代器查询元素、迭代器删除元素，不要用集合本身去删除元素</span>                        &#125;                    &#125;                                                            <span class="hljs-comment">//===================================================</span>                                        <span class="hljs-comment">//Map两种遍历方式</span>                                        HashMap&lt;String,String&gt; hs = <span class="hljs-keyword">new</span> HashMap&lt;String,String&gt;();                                        hs.put(<span class="hljs-string">"dengyanfei"</span>, <span class="hljs-string">"邓先森"</span>);                                        hs.put(<span class="hljs-string">"renjia"</span>, <span class="hljs-string">"小仙女"</span>);                                        hs.put(<span class="hljs-string">"jinmao"</span>, <span class="hljs-string">"最可爱的狗子"</span>);                                        <span class="hljs-comment">//第一种遍历方式，获取所有的键值对对象的集合</span>                    Set&lt;Map.Entry&lt;String,String&gt;&gt; set = hs.entrySet();                                        <span class="hljs-keyword">for</span>(Map.Entry&lt;String,String&gt; temp :set) &#123;                                            System.out.println(temp.getKey()+<span class="hljs-string">"---"</span>+temp.getValue());                    &#125;                                                            <span class="hljs-comment">//第二种遍历方式，获取所有的键集合</span>                    Set&lt;String&gt; keySet = hs.keySet();                                        <span class="hljs-keyword">for</span>(String temp:keySet) &#123;                                            String value = hs.get(temp);                                            System.out.println(temp+<span class="hljs-string">"---"</span>+value);                    &#125;                                        <span class="hljs-comment">//===================================================</span>                                        <span class="hljs-comment">//TreeMap的比较器排序</span>                                        TreeMap&lt;Student,String&gt; tm = <span class="hljs-keyword">new</span> TreeMap&lt;Student,String&gt;(<span class="hljs-keyword">new</span> Comparator&lt;Student&gt;() &#123;                                            <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student st1, Student st2)</span> </span>&#123;                                                <span class="hljs-comment">//按照年龄排序，st1-st2是从小到大排序；st2-st1则是从大到小排序</span>                            <span class="hljs-keyword">int</span> num = st1.getAge()-st2.getAge();                                                <span class="hljs-comment">//如果年龄相同，按照姓名排序</span>                            <span class="hljs-keyword">int</span> num2 = num ==<span class="hljs-number">0</span>?st1.getName().compareTo(st2.getName()):num;                                                <span class="hljs-keyword">return</span> num2;                        &#125;                    &#125;);                                        Student s1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"邓燕飞"</span>,<span class="hljs-number">25</span>);                    Student s2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"小仙女"</span>,<span class="hljs-number">22</span>);                    Student s3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"金毛"</span>,<span class="hljs-number">3</span>);                    Student s4 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"二哈"</span>,<span class="hljs-number">3</span>);                                        tm.put(s1, <span class="hljs-string">"邓先森"</span>);                    tm.put(s2, <span class="hljs-string">"小仙女"</span>);                    tm.put(s3, <span class="hljs-string">"最可爱的狗子"</span>);                    tm.put(s4, <span class="hljs-string">"最活泼的狗子"</span>);                                        <span class="hljs-comment">//第一种遍历方式，获取所有的键值对对象的集合</span>                    Set&lt;Entry&lt;Student, String&gt;&gt; set = tm.entrySet();                                        <span class="hljs-keyword">for</span>(Entry&lt;Student, String&gt; temp :set) &#123;                                            System.out.println(temp.getKey().getName()+<span class="hljs-string">"---"</span>+                                            temp.getKey().getAge()+<span class="hljs-string">"---"</span>+temp.getValue());                    &#125;                                        <span class="hljs-comment">//第二种遍历方式，获取所有的键集合</span>                                        Set&lt;Student&gt; keySet = tm.keySet();                                        <span class="hljs-keyword">for</span>(Student temp:keySet) &#123;                                            String value = tm.get(temp);                                            System.out.println(temp.getName()+<span class="hljs-string">"---"</span>+temp.getAge()+<span class="hljs-string">"---"</span>+value);                    &#125;</code></pre></li></ul></li></ul></li></ul></li><li><p>数组和集合的区别：</p><ul><li>长度：</li><li>数组长度固定；<ul><li>集合长度是可变的。</li></ul></li><li>存储的数据类型：<ul><li>数组既可以存储基本数据类型，也可以存储引用数据类型；</li><li>集合只能存储引用类型。</li></ul></li></ul></li><li><p>Collection和Collections的区别：</p><ul><li>Collection是单列集合的顶层接口，有子接口List、Set、Queue；</li></ul></li><li><p>Collections是针对集合操作的工具类。<code>如，对集合进行排序、二分查找等</code>；常用方法有：</p><pre><code>-   void sort(List list)：根据元素的自然顺序对指定List集合的元素按升序进行排序，也就是自然排序，即实现了Comparable接口；-   void sort(List&lt;T&gt; list,Comparator  c)：根据指定Comparator产生的顺序对List集合元素进行排序，也就是比较器排序，即实现了Comparator 接口；-   int binarySearch(List&lt;?&gt; list,T key)：二分查找；-   void reverse(List&lt;?&gt; list)：集合元素顺序反转；-   void shuffle(List&lt;?&gt; list)：随机置换；-   &lt;T&gt; T max(Collection&lt;?&gt; coll)：最大值。</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-32-File类和I-O流"><a href="#NO3-32-File类和I-O流" class="headerlink" title="NO3.32 File类和I/O流"></a>NO3.32 File类和I/O流</h3><p>在变量、数组、对象和集合中存储的数据是暂时存在的，一旦程序结束它们就会丢失。为了能够永久地保存程序创建的数据，需要将其保存到磁盘文件中，这样就可以在其他程序中使用它们。</p><ul><li><p>File：</p><ul><li><p>定义：如果希望在程序中操作文件和目录，则都可以通过File类来完成；</p></li><li><p>作用：File类定义了一些方法来操作文件，如新建、删除、重命名文件和目录等；</p></li><li><p>应用：</p><ul><li><p>构造方法：</p><ul><li>File(String path)：如果path是实际存在的路径，则该File对象表示的是目录；如果 path是带路径文件名，则该File对象表示的是文件；</li><li>File(String path, String name)：path是路径名，name是文件名；</li><li>File(File dir, String name)：dir是路径对象，name是文件名；</li></ul></li><li><p>成员方法：</p><ul><li>createNewFile()：在File对象指定的路径下创建一个文件；</li><li>mkdir()：根据File对象的路径，在路径下创造新文件夹；</li><li>mkdirs()：根据File对象的路径，创造多级文件夹；</li><li>exists()：根据File对象的路径，判断指定的文件或者文件夹是否存在；</li><li>isFile()：根据File对象的路径，判断当前的FIle对象是否是文件；</li><li>isDirectory()：根据File对象的路径，判断当前的FIle对象是否是文件夹；</li><li>getName()：根据File对象的路径，获取文件或文件夹的名称；</li><li>getPath()：根据当前File对象，获取文件或文件夹的相对路径，如果该抽象路径已经是绝对路径名，则和getAbsolutePath()方法返回值相同；</li><li>getAbsolutePath()：根据当前File对象，获取该文件或文件夹的绝对路径，即带盘符的路径；</li></ul></li><li><p>使用文件名过滤器；</p><pre><code class="hljs java">File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"d:/"</span>);String[] fileNameArray = f.list(<span class="hljs-keyword">new</span> FilenameFilter()&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">accept</span><span class="hljs-params">(File dir,String name)</span></span>&#123;  <span class="hljs-comment">//括号内的参数就是上面f中的所有文件的拆分，前者是文件路径，后者是文件名称</span>                <span class="hljs-comment">//File file = new File(dir,name);</span>        <span class="hljs-comment">//接下来就是对放入数组的文件进行过滤条件的设置即可</span>        <span class="hljs-comment">//如：放入文件数组中的是文件，且以".jpg"结尾，这是过滤条件</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> File(dir,name).isFile() &amp;&amp; name.endsWith(<span class="hljs-string">".jpg"</span>);    &#125;&#125;);</code></pre></li><li><p>递归打印目录树；</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printFileName</span><span class="hljs-params">(File srcFolder)</span> </span>&#123;    <span class="hljs-comment">//获取该文件夹下的所有文件对象</span>    File[] fileArray = srcFolder.listFiles();    <span class="hljs-comment">//遍历这些文件对象</span>    <span class="hljs-keyword">for</span>(File file : fileArray)&#123;        <span class="hljs-comment">//判断是否是文件夹</span>        <span class="hljs-keyword">if</span>(file.isDirectory())&#123;            <span class="hljs-comment">//递归调用(即自己调用自己)</span>            printFileName(file);        &#125;<span class="hljs-keyword">else</span>&#123;            System.out.println(file.getPath());        &#125;    &#125;&#125;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>IO流：</p><ul><li><p>定义：简单地讲，就是文件的读取和输出，也就是读和写；</p></li><li><p>种类：</p><ul><li><p>按流向分：输入流和输出流；</p></li><li><p>按类别分：字节流和字符流；</p><ul><li><p>字节流分为：</p><ul><li><p><code>InputStream</code>：字节输入流；其子类主要有：</p><ul><li><code>FileInputStream</code>：文件字节输入流；</li><li><code>BufferedInputStream</code>：缓冲字节输入流；</li></ul></li><li><p><code>OutputStream</code>：字节输出流；其子类主要有：</p><ul><li><p><code>FileOutputStream</code>：文件字节输出流；</p></li><li><p><code>BufferedOutputStream</code>：缓冲字节输出流；</p><pre><code class="hljs java">如：文件字节输入、输出流；<span class="hljs-comment">//获取需要复制的文件的路径</span>File srcFile = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"d:/java.jpg"</span>);<span class="hljs-comment">//加载输入流</span>FileInputStream fis = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//加载输出流</span>FileOutputStream fos = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">try</span> &#123;    fis = <span class="hljs-keyword">new</span> FileInputStream(srcFile);    <span class="hljs-comment">//如果这里还有第二个参数",true"，则表示在文件内容末尾追加输入</span>    fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"e:/java.jpg"</span>,<span class="hljs-keyword">true</span>));&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;    e.printStackTrace();&#125;<span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">//定义一个读取数组，即一次性读取1024个字节</span>    <span class="hljs-keyword">byte</span>[] bys = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];    <span class="hljs-comment">//定义文件内容的有效长度，即读取的真实有效的字节数</span>    <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;    <span class="hljs-comment">//如果等于-1，则文件内容已经读取完成</span>    <span class="hljs-keyword">while</span>((length = fis.read(bys))!=-<span class="hljs-number">1</span>) &#123;        <span class="hljs-comment">//调用方法，进行写入操作</span>        fos.write(bys, <span class="hljs-number">0</span>, length);        <span class="hljs-comment">//刷新输出流，防止异常出现时，输出流中还缓存有数据</span>        fos.flush();    &#125;&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    e.printStackTrace();&#125;<span class="hljs-keyword">finally</span> &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//关闭流对象</span>        fos.close();        fis.close();    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;&#125;<span class="hljs-comment">//==================================================</span>如：缓冲字节输入、输出流；<span class="hljs-comment">//获取需要复制的文件路径</span>File srcFile = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"d:/java.jpg"</span>);<span class="hljs-comment">//加载输入流</span>BufferedInputStream fis = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//加载输出流</span>BufferedOutputStream fos = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">try</span> &#123;    fis = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(srcFile));    fos = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"e:/java.jpg"</span>)));&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;    e.printStackTrace();&#125;<span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">//定义一个读取数组(即，一次性读取1024个字节)</span>    <span class="hljs-keyword">byte</span>[] bys = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];    <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>((length = fis.read(bys))!=-<span class="hljs-number">1</span>) &#123;        fos.write(bys, <span class="hljs-number">0</span>, length);        fos.flush();    &#125;&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    e.printStackTrace();&#125;<span class="hljs-keyword">finally</span> &#123;    <span class="hljs-keyword">try</span> &#123;        fos.close();        fis.close();    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre></li></ul></li></ul></li><li><p>字符流分为：</p><ul><li><p><code>Reader</code>：字符输入流；其子类主要有：</p><ul><li><code>InputStreamReader</code>：字节转字符转换输入流，默认GBK编码；</li><li><code>FileReader</code>：文件字符输入流；</li><li><code>BufferedReader</code>：缓冲字符输入流；</li></ul></li><li><p><code>Writer</code>：字符输出流；其子类主要有：</p><ul><li><p><code>OutputStreamWriter</code>：字节转字符转换输出流，默认GBK编码；</p></li><li><p><code>FileWriter</code>：文件字符输出流；</p></li><li><p><code>BufferedWriter</code>：缓冲字符输出流；</p><pre><code class="hljs java">拓展：Properties类能够将文件里的数据读取到集合中一、Properties中的常用方法；注意：文件里的数据必须以键值对的形式存储，因为要读取到properties集合中，也能够将集合中的数据保存到文件中去；<span class="hljs-number">1</span>.setProperties(String key,String value)：添加方法；    <span class="hljs-number">2</span>.load(Reader reader)：从文件中读取数据；    <span class="hljs-number">3</span>.store(Writer writer,String target)：将键值对添加到配置文件中，第二个参数为属性列表的注释，也可以写<span class="hljs-keyword">null</span>；<span class="hljs-comment">//====================================================</span>如：文件字符输入、输出流；FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">"d:/aaa.txt"</span>);FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">"f:/b.txt"</span>);<span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1024</span>];<span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>((len = fr.read(chars))!=-<span class="hljs-number">1</span>) &#123;    fw.write(chars, <span class="hljs-number">0</span>, len);    fw.flush();&#125;fw.close();fr.close();<span class="hljs-comment">//====================================================</span>如：缓冲字符输入、输出流；<span class="hljs-comment">//获取需要复制的文件路径</span>File srcFile = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"d:/aaa.txt"</span>);<span class="hljs-comment">//加载文件输入流</span>BufferedReader br = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//加载文件输出流</span>BufferedWriter bw = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">//这里要注意，使用字节流转换字符流桥梁：InputStreamReader，并且注意编码问题</span>    br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(srcFile),<span class="hljs-string">"GBK"</span>));    <span class="hljs-comment">//同上</span>    bw = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"e:/bbb.txt"</span>),<span class="hljs-string">"GBK"</span>));&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    e.printStackTrace();&#125;<span class="hljs-keyword">try</span> &#123;    String length = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">while</span>((length = br.readLine())!=<span class="hljs-keyword">null</span>) &#123;        bw.write(length);        <span class="hljs-comment">//这是换行符</span>        bw.newLine();        <span class="hljs-comment">//刷新内存中的流，就是将还存在于通道中的流信息写入到目标文件中，避免流对象关闭的时候，还有数据存在于通道，造成数据丢失</span>        bw.flush();    &#125;&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    e.printStackTrace();&#125;<span class="hljs-keyword">finally</span> &#123;    <span class="hljs-keyword">try</span> &#123;        bw.close();        br.close();    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-33-网络编程"><a href="#NO3-33-网络编程" class="headerlink" title="NO3.33 网络编程"></a>NO3.33 网络编程</h3><p>网络中有许多的节点，而这些节点其实就是我们能够上网的设备，例如手机，电脑等，都是节点。</p><ul><li><p>ip、port、url：</p><ul><li><p><code>ip(网络地址)</code>：我们用IP地址来区分不同的节点；</p><ul><li><p>InetAddress：</p><ul><li><p>作用：该类用于获取本机(就是你上网用的电脑)的实例对象；</p></li><li><p>常用方法：</p><ul><li><p>getLocalHost()：获取本机的对象；</p></li><li><p>getHostAddress()：获取本机的IP地址；</p></li><li><p>getHostName()：获取本机的主机名；</p><pre><code class="hljs java"><span class="hljs-comment">//获得本机的对象</span>                    InetAddress addr = InetAddress.getLocalHost();                                        <span class="hljs-comment">//根据本机的对象获取本机的IP地址</span>                    System.out.println(addr.getHostAddress());                                        <span class="hljs-comment">//获取本机的主机名</span>                    System.out.println(addr.getHostName());</code></pre></li></ul></li></ul></li></ul></li><li><p><code>port(端口号)</code>：用端口号来区分上网设备上的软件；</p><ul><li><p>端口号有2个字节，端口号的范围是0到65535；</p></li><li><p>同一个协议端口不能冲突；</p></li><li><p>获得端口，可以通过InetSocketAddress类的方法封装；</p><pre><code class="hljs java">InetSocketAddress isa = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"127.0.0.1"</span>,<span class="hljs-number">8080</span>);</code></pre></li></ul><p>//获得封装的端口号：8080</p><pre><code>System.out.println(isa.getPort());<pre><code class="hljs autohotkey">    -   `url(统一资源定位符)`：URL区分软件上不同的资源；    -   一般的，url由四部分组成：协议、存放资源的主机域名、端口号、资源文件名；        ```java<span class="hljs-string">"http://google.com:80/index.html"</span></code></pre></code></pre><p>其中：</p><pre><code>http是协议</code></pre><p>google.com是主机域名</p><pre><code>80是端口号index.html是资源文件名<pre><code class="hljs autohotkey">-   获取URL的各部分数据：        ```javaURL url =<span class="hljs-keyword">new</span> URL(<span class="hljs-string">"http://www.baidu.com:80/index.html?username=dyf&amp;age=26#a"</span>)<span class="hljs-comment">;</span></code></pre></code></pre></li></ul><p>System.out.println(url.getProtocol());  //获得协议</p><pre><code>    System.out.println(url.getHost());  //获得域名，即IP地址System.out.println(url.getPort());  //获得端口号    System.out.println(url.getFile());  //获得需要请求的资源，带参数System.out.println(url.getPath());  //获得需要请求的资源，不带参数    System.out.println(url.getQuery());  //获得参数    <pre><code class="hljs arduino">&amp;nbsp;-   网络传输协议主要分为两大类：    -   `TCP协议`：        -   定义：是一种面向连接的、可靠地、基于字节流的传输层协议；        -   特点：            -   面向连接；            -   点到点的通信；            -   高可靠性；            -   占用系统资源多、低效率；            -   没有数据大小限制。        -   TCP发送数据和接收数据基本流程：            ```java            <span class="hljs-comment">//服务端</span>            <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> &#123;</span>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> throws IOException </span>&#123;                                <span class="hljs-comment">//1.使用ServerSocket创建服务器，并指定端口号</span>                    ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">9999</span>);                                <span class="hljs-comment">//2.阻塞式等待连接accept()</span>                    Socket socket = server.accept();                                <span class="hljs-comment">//连接成功后打印此提示</span>                    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"有连接接入"</span>);                                <span class="hljs-comment">//3.操作输入或输出流</span>                    InputStream is = socket.getInputStream();                                <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];                                <span class="hljs-keyword">int</span> length = is.<span class="hljs-built_in">read</span>(bytes);                                System.out.<span class="hljs-built_in">println</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(bytes,<span class="hljs-number">0</span>,length));                                <span class="hljs-comment">//4.释放资源</span>                    <span class="hljs-comment">//一般来说服务器不会关闭，因为需要时时刻刻接收客户端的请求</span>                &#125;            &#125;                        <span class="hljs-comment">//------------------------------------------------------------------</span>                        <span class="hljs-comment">//客户端</span>            <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> &#123;</span>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> throws IOException </span>&#123;                                <span class="hljs-comment">//1.使用Socket创建客户端建立连接(必须知道服务器的IP地址和端口)</span>                    Socket client = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"localhost"</span>,<span class="hljs-number">9999</span>);                                <span class="hljs-comment">//2.操作输入或输出流</span>                    OutputStream os = client.getOutputStream();                                <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-string">"你好，JAVA服务端"</span>.getBytes();                                os.<span class="hljs-built_in">write</span>(bytes, <span class="hljs-number">0</span>, bytes.length);                                System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"发送成功"</span>);                                <span class="hljs-comment">//3.释放资源</span>                    client.<span class="hljs-built_in">close</span>();                &#125;            &#125;</code></pre></code></pre><ul><li><p><code>UDP协议</code>：</p><ul><li><p>定义：是一种无连接、提供面向事务的简单、不可靠信息传送服务的传输层协议；</p></li><li><p>特点：</p><ul><li>非面向连接、传输不可靠，可能丢失；</li><li>发送时，不管对方是否准备好；发送后，接收方收到也不确认；</li><li>可以广播发送；</li><li>非常简单的协议，开销小；</li><li>传输数据有大小限制，60K。</li></ul></li><li><p>UDP发送数据和接收数据基本流程：</p><pre><code class="hljs java"><span class="hljs-comment">//发送端</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UDPClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        System.out.println(<span class="hljs-string">"发送端口正在启动中...."</span>);        <span class="hljs-comment">//1.使用DategramSocket 指定端口，创建发送端</span>        DatagramSocket ds = <span class="hljs-keyword">new</span> DatagramSocket(<span class="hljs-number">6666</span>);        <span class="hljs-comment">//2.准备数据，一定要转成字节数组</span>        <span class="hljs-keyword">byte</span>[] bye = <span class="hljs-string">"越努力，越幸运"</span>.getBytes();        <span class="hljs-comment">//3.封装成DatagramPacket包裹，需要指定目的地，即目的地的IP和端口</span>        InetSocketAddress isa = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">7777</span>);        <span class="hljs-comment">//3.1.封装要发送的数据到包裹中，然后指定目的地</span>        DatagramPacket dp = <span class="hljs-keyword">new</span> DatagramPacket(bye,<span class="hljs-number">0</span>,bye.length,isa);        <span class="hljs-comment">//4.发送包裹send(DatagramPacket)</span>        ds.send(dp);        <span class="hljs-comment">//5.释放资源</span>        ds.close();    &#125;&#125;<span class="hljs-comment">//--------------------------------------------------------------------------</span><span class="hljs-comment">//接收端</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UDPServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        System.out.println(<span class="hljs-string">"接收端启动中......"</span>);        <span class="hljs-comment">//1.使用DategramSocket 指定端口，创建接收端</span>        DatagramSocket ds = <span class="hljs-keyword">new</span> DatagramSocket(<span class="hljs-number">7777</span>);        <span class="hljs-comment">//2.准备容器，封装成DatagramPacket包裹</span>        <span class="hljs-keyword">byte</span>[] bye = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">60</span>];        DatagramPacket dp = <span class="hljs-keyword">new</span> DatagramPacket(bye, <span class="hljs-number">0</span>, bye.length);        <span class="hljs-comment">//3.阻塞式接收包裹receive(DatagramPaket)</span>        ds.receive(dp);        <span class="hljs-comment">//4.分析数据</span>        <span class="hljs-keyword">byte</span>[] datas = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">60</span>];        datas = dp.getData();        System.out.println(<span class="hljs-keyword">new</span> String(datas, <span class="hljs-number">0</span>, datas.length));        <span class="hljs-comment">//5.释放资源</span>        ds.close();    &#125;&#125;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-34-注解"><a href="#NO3-34-注解" class="headerlink" title="NO3.34 注解"></a>NO3.34 注解</h3><p>Java实际开发中，是很常用注解的。</p><ul><li>注解：<ul><li>定义：注解就是Annontation，Annontation是Java5开始引入的新特征，中文名称叫做注解，它提供了一种安全的类似注释的机制，可以起到减少配置的成果，给程序起到辅助性的作用；</li><li>基本语法格式：<code>@xxx</code>；</li><li>注解的优缺点：<ul><li>优点是：开发效率高，成本低；</li><li>缺点是：耦合性大，且不利于后期维护。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-35-反射"><a href="#NO3-35-反射" class="headerlink" title="NO3.35 反射"></a>NO3.35 反射</h3><p>反射机制是Java语言的一个重要特性。</p><ul><li><p>反射：</p><ul><li><p>定义：Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性，这种动态获取信息和动态，以及调用对象的方法的功能称为Java语言的反射机制；</p></li><li><p>基本语法格式：</p><ul><li><p>获取Class文件对象，也就是字节码文件对象：</p><ul><li>方式一：通过<code>类名.class</code>获取Class对象；<code>如，Student.class</code>；</li><li>方式二：通过<code>对象.getClass()</code>获取Class对象；<code>如，Student s = new Student()，s.getClass()</code>；</li><li>方式三：通过<code>Class.forName(类的全包名路径)</code>获取Class对象，该方式需要抛出异常；<code>如，Class.forName(&quot;cn.dyf.Student&quot;)</code>；</li><li>方式四：通过<code>当前类的类加载器：当前类.class.getClassLoader().loadClass(指定类的全包名路径)</code>获取Class对象；<code>如，当前类为StudentTest，需要Student的Class对象，则StudentTest.class.getClassLoader().loadClass(&quot;cn.dyf.Student&quot;)</code>；</li></ul></li><li><p>调用Class文件对象方法来获取成员变量、构造方法、成员方法；</p><p><img src="./image-jse6.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java">Class c = Class.forName(<span class="hljs-string">"gotostudy001.User"</span>);  <span class="hljs-comment">//获取.class文件对象,以这种方式获取class文件对象，必须带包名的全路径</span>                        c.getName();  <span class="hljs-comment">//获取的是：包名+类名</span>                        c.getSimpleName();  <span class="hljs-comment">//获取的是：类名</span>                        c.getDeclaredFields();  <span class="hljs-comment">//获得的是该类下的所有字段(不论是public还是private修饰)</span>                        c.getDeclaredMethods();  <span class="hljs-comment">//获得的是该类下的所有方法(不论是public还是private修饰)</span>                        c.getDeclaredConstructors();  <span class="hljs-comment">//获得的是该类下的所有构造方法(不论是public还是private修饰)</span>                        拓展：哪些类型有Class对象            一、类、接口、数组、枚举、注解、基本数据类型、<span class="hljs-keyword">void</span>。</code></pre></li><li><p>通过反射获取类的实例；</p><pre><code class="hljs java"><span class="hljs-comment">//获取.class文件对象；</span>            Class c = Class.forName(<span class="hljs-string">"gotostudy001.User"</span>);                <span class="hljs-comment">//使用这两个方法直接获取类的实例：getDeclaredConstructor()和newInstance();</span>            User user= c.getDeclaredConstructor().newInstance();</code></pre></li><li><p>通过反射调用方法：<code>Class对象.getDeclaredMethod(方法名字符串，需要传入的参数的数据类型的class).invoke(调用方法的对象,需要传入到方法里的参数);</code></p><pre><code class="hljs java"><span class="hljs-comment">//这里通过反射获取方法后，调用invoke方法</span>            c.getDeclaredMethod("setName", String.class).invoke(user,"邓先森");</code></pre><pre><code class="hljs plain"> </code></pre></li></ul></li></ul></li><li><p>通过反射操作(私有)属性或方法：以属性为例：</p><pre><code>-   `Field nameFiled = c.getDeclaredField(&quot;需要操作的属性名称&quot;);`；-   因为类中的属性一般都是private修饰，所以要操作属性时，需要获得访问权限。即：`nameFiled.setAccessible(true);` 该方法可以明显提高反射的运行效率；-   获取操作权限之后再操作即可，`nameFiled.set(需要操作的属性所在的那个对象,操作的属性的值)；`    <pre><code class="hljs java"><span class="hljs-comment">//获取.class文件对象</span>                Class c = Class.forName(<span class="hljs-string">"gotostudy001.User"</span>);                        <span class="hljs-comment">//获取构造方法对象</span>        Constructor con2 = clazz.getDeclaredConstructor();                        <span class="hljs-comment">//通过构造方法对象创建实例对象</span>                Object user = con2.newInstance();                                <span class="hljs-comment">//操作属性</span>                <span class="hljs-comment">//通过反射获取需要操作的属性</span>                Field nameFiled = c.getDeclaredField(<span class="hljs-string">"name"</span>);                                <span class="hljs-comment">//因为属性是private修饰的，所以需要获得访问权限</span>                nameFiled.setAccessible(<span class="hljs-keyword">true</span>);                                <span class="hljs-comment">//需要操作的属性去调用set()方法，然后进行操作；</span>                nameFiled.set(user, <span class="hljs-string">"邓先森"</span>);                                <span class="hljs-comment">//调用方法</span>                <span class="hljs-comment">//获取需要调用的方法的对象</span>                Method showMethod = c.getDeclaredMethod(<span class="hljs-string">"show"</span>);                                <span class="hljs-comment">//如果方法是私有的，需要获取访问权限</span>                <span class="hljs-comment">//showMethodsetAccessible(true);</span>                                <span class="hljs-comment">//传入调用方法时需要使用的对象即可</span>                showMethod.invoke(user);</code></pre></code></pre></li></ul><p>&nbsp;<br>&nbsp;</p><h3 id="NO3-36-代理"><a href="#NO3-36-代理" class="headerlink" title="NO3.36 代理"></a>NO3.36 代理</h3><p>代理，顾名思义，就是能够帮我们做更多事情的人。</p><ul><li><p>代理：</p><ul><li><p>定义：代理是一种模式，提供了对目标对象的间接访问方式，即通过代理访问目标对象；</p></li><li><p>种类：</p><ul><li><p>静态代理：</p><ul><li><p>静态代理的实现比较简单，代理类通过实现与目标对象相同的接口，并在类中维护一个代理对象；</p></li><li><p>通过构造器传入目标对象，赋值给代理对象，进而执行代理对象实现的接口方法，并实现前拦截，后拦截等所需的业务功能。</p><pre><code class="hljs java"><span class="hljs-comment">//结婚的接口</span>                <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Marry</span></span>&#123;                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">happyMarry</span><span class="hljs-params">()</span></span>;                &#125;                                <span class="hljs-comment">//我结婚</span>                <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">I</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Marry</span></span>&#123;                                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">happyMarry</span><span class="hljs-params">()</span> </span>&#123;                        System.out.println(<span class="hljs-string">"终于买房，并找到自己爱的人和爱自己的人，一起结婚了，开心！"</span>);                    &#125;                &#125;                                <span class="hljs-comment">//婚庆公司</span>                <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeddingCompany</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Marry</span></span>&#123;                                    <span class="hljs-keyword">private</span> I husband;                                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeddingCompany</span><span class="hljs-params">(I husband)</span></span>&#123;                        <span class="hljs-keyword">this</span>.husband = husband;                    &#125;                                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">happyMarry</span><span class="hljs-params">()</span> </span>&#123;                        ready();                        husband.happyMarry();                        after();                    &#125;                                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ready</span><span class="hljs-params">()</span> </span>&#123;                        System.out.println(<span class="hljs-string">"正在布置婚礼会场，以及邀请司仪，您先去迎接可爱的新娘"</span>);                    &#125;                                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;                        System.out.println(<span class="hljs-string">"婚礼举办完成啦，新婚快乐！！！！！"</span>);                    &#125;                &#125;</code></pre></li></ul></li><li><p>动态代理：随着静态代理的业务逐渐增多，那么往静态代理中添加的方法是不是就越多，那么这样的代理类会变得很庞大和繁杂，所以有了动态代理；</p><ul><li>原理：JDK提供了java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy类，这两个类相互配合来实现动态代理，入口是Proxy，所以我们先聊它。Proxy有个静态方法：getProxyClass(ClassLoader, interfaces)，只要你给它传入类加载器和一组接口，它就给你返回代理Class对象。所以，一旦我们明确接口，完全可以通过接口的Class对象，创建一个代理Class，通过代理Class即可创建代理对象。所以，Proxy.getProxyClass()这个方法的本质就是：以Class造Class。</li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-37-JDK8、9新特性"><a href="#NO3-37-JDK8、9新特性" class="headerlink" title="NO3.37 JDK8、9新特性"></a>NO3.37 JDK8、9新特性</h3><p>JDK的更新，伴随而来的是更多要学习的东西。</p><ul><li><p>JDK8新特性：</p><ul><li><p>Lambda表达式：</p><ul><li><p>定义：Lambda表达式在Java语言中引入了一个新的语法元素和操作符。这个操作符为 “-&gt;” ，该操作符被称 为Lambda 操作符或箭头操作符。它将 Lambda分为两个部分：</p><ul><li>左侧：指定了Lambda表达式需要的所有参数；</li></ul></li></ul></li><li><p>右侧：指定了Lambda 体，即Lambda表达式要执行 的功能。</p></li><li><p>本质：作为函数式接口的实例；</p></li><li><p>任何Lambda表达式的基本语法是：</p><pre><code>-   (参数)，即将参数用括号括起来；**`注意：当只有一个参数，可以不需要括号()，然而，这是一个特例；正常情况使用括号()包裹参数，为了保持一致性，也可以使用括号()包裹单个参数，虽然这种情况并不常见；如果没有参数，则必须使用括号()表示空参数列表；对于多个参数，将参数列表放在括号()中。`**-   接着 -&gt;，可视为“产出”；-   -&gt; 之后的内容都是方法体；    例如：    <pre><code class="hljs java"><span class="hljs-comment">//使用匿名内部类创建一个线程</span><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;     <span class="hljs-meta">@Override</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;         System.out.println(<span class="hljs-string">"Hello World!"</span>);     &#125; &#125;);  <span class="hljs-comment">//使用Lambda表达式</span> <span class="hljs-keyword">new</span> Thread(() -&gt; System.out.println(<span class="hljs-string">"Hello World!"</span>)))</code></pre></code></pre></li><li><p>函数式接口：</p><ul><li><p>定义：只包含一个抽象方法的接口，称为函数式接口；</p></li><li><p>标识：可以在任意函数式接口上使用@FunctionalInterface注解，这样做可以检查它是否是一个函数式接口；</p></li><li><p>实现：可以通过Lambda表达式来创建该接口的对象；之所以Lambda必须和函数式接口配合是因为，接口中如果有多个函数，则Lambda表达式无法确定实现的是哪个；</p><p><img src="./image-jse7.png" srcset="/img/loading.gif" alt="image-20200703094458584"></p></li></ul></li><li><p>方法引用：</p><ul><li>定义：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用；</li><li>基本语法格式：<ul><li><code>对象::实例方法</code>；</li><li><code>类::静态方法</code>；</li><li><code>类::实例方法</code>。</li></ul></li></ul></li><li><p>Stream流：</p><ul><li><p>定义：是数据渠道，用于操作数据源(集合、数组等)所生成的元素序列；<strong><code>注意：Stream 自己不会存储元素；Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream；Stream操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</code></strong></p></li><li><p>Stream的操作三个步骤：</p><ul><li><p>创建Stream：一个数据源(如，集合、数组)，获取一个流；创建流的方式包括：</p><ul><li>Java8中的Collection接口被扩展，提供了 两个获取流的方法：<ul><li><code>default Stream&lt;E&gt; stream()</code>：返回一个顺序流；</li><li><code>default Stream&lt;E&gt; parallelStream()</code>： 返回一个并行流。</li></ul></li><li>Java8中的Arrays的静态方法stream()可以获取数组流：<ul><li><code>static &lt;T&gt; Stream&lt;T&gt; stream(T[] array)</code>：返回一个流。</li></ul></li><li>可以使用静态方法 Stream.of(), 通过显示值 创建一个流。它可以接收任意数量的参数：<ul><li><code>public static&lt;T&gt; Stream&lt;T&gt; of(T... values)</code>：返回一个流。</li></ul></li><li>可以使用静态方法：<ul><li>Stream.iterate() 和 Stream.generate()：创建无限流。</li></ul></li></ul></li><li><p>中间操作：一个中间操作链，对数据源的数据进行处理；</p></li><li><p>终止操作(终端操作)：一个终止操作，执行中间操作链，并产生结果。</p><p><img src="./image-jse8.png" srcset="/img/loading.gif" alt="image-20200703100636743"></p></li></ul></li></ul></li><li><p>optional类：</p><ul><li><p>定义：<code>Optional&lt;T&gt;</code>类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</p></li><li><p>常用方法：</p><p><img src="./image-jse9.png" srcset="/img/loading.gif" alt="image-20200703101926473"></p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>JDK9新特性：</p><ul><li><p>模块化系统：</p><ul><li><p>定义：个人理解，是对包的一个更深层次的管理，也就是为包指定了一个模块，即将这个包划分给模块来管理。通常情况下一个模块包含着一个模块描述符文件(module-info.java)用来指定模块的名字、依赖(需要注意的是每个模块必须显式得声明其依赖)、对外可使用的包(其余的包则对外不可见)、模块提供的服务、模块使用的服务以及允许哪些模块可以对其进行反射等配置信息；</p></li><li><p>基本语法格式：</p><ul><li><p>首先，需要为指定包划分一个模块，右键属性，找到module-info.java，即可创建一个module-info.java，然后在该文件里，写入：</p><pre><code class="hljs java"><span class="hljs-keyword">module</span> 模块名 &#123;    <span class="hljs-keyword">exports</span> 你想要暴露的包的路径;   &#125;注意：模块名，默认一般都会以你的项目名填进去。</code></pre></li><li><p>其次，在你想要引用别的模块的项目中，也创建一个module-info.java，然后写入：</p><pre><code class="hljs java"><span class="hljs-keyword">module</span> 模块名 &#123;    <span class="hljs-keyword">requires</span> 你想要引入的包的路径;   &#125;</code></pre></li></ul></li></ul></li><li><p>JShell：</p><ul><li>定义：是一种快速运行语句的基于命令行的工具；简单讲，你不用开IDEA，然后写main方法，然后再做一些简单的测试了，直接使用JShell做简单的测试即可；</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>1.대학교 일 학년</category>
      
      <category>03.Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大一课程</tag>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01.数据库系统概念--学习笔记</title>
    <link href="/2020/06/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/06/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库系统概念–学习笔记-包含数据库系统概念书籍"><a href="#数据库系统概念–学习笔记-包含数据库系统概念书籍" class="headerlink" title="数据库系统概念–学习笔记(包含数据库系统概念书籍)"></a>数据库系统概念–学习笔记(包含数据库系统概念书籍)</h1><h2 id="Lesson1-数据库基本概述"><a href="#Lesson1-数据库基本概述" class="headerlink" title="Lesson1 数据库基本概述"></a>Lesson1 数据库基本概述</h2><h3 id="NO1-1-数据库管理系统"><a href="#NO1-1-数据库管理系统" class="headerlink" title="NO1.1 数据库管理系统"></a>NO1.1 数据库管理系统</h3><p>数据库和管理这个数据库的程序，我们把这两者统称为数据库管理系统。</p><ul><li>数据库管理系统由一个数据库和一个管理该数据库的程序组成。<ul><li>数据库，顾名思义，就是存放了大量数据的仓库。<code>如，我们常见的银行系统(用来存储客户信息等)、大学的学生系统(用来存储学生信息等)、机票系统(用来存储订票和航班信息等)，都有数据库的身影</code>；</li><li>管理数据库的程序，称为数据库管理系统，即我们常说的DBMS。常见的DBMS有：MySQL、SQL Server、ORacle、PostgreSQL、DB2等等。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-2-数据模型"><a href="#NO1-2-数据模型" class="headerlink" title="NO1.2 数据模型"></a>NO1.2 数据模型</h3><p>数据模型是数据库的基础。这句话怎么理解呢？简单的说，就是一个存放数据的仓库，你要存放的数据不能是凭空捏造的吧？(因为凭空捏造的数据没什么意义，用不到现实世界中去呀)，既然不能凭空捏造而来，那么我们就只能从现实世界里获取了呀，即数据模型就是将我们现实世界客观的事物抽象成一个能放到数据库中的模型，而这个模型拥有一些属性。如，客观世界存在的人，我们把他抽象成一个人的模型，那么它可能拥有名字、年龄、性别等等这些数据，为什么会有这些数据呢？是因为客观世界存在的人就有这些属性。</p><ul><li><p>数据模型被分为了以下几种：</p><ul><li><p>关系模型：该模型是使用最广泛的数据模型，当今大量的数据库都采用了这种关系模型；</p></li><li><p>实体-联系模型：该模型被广泛用于数据库的设计；</p></li><li><p>基于对象的数据模型：该模型结合了面向对象的数据模型和关系模型的特征；</p></li><li><p>半结构化数据模型；</p></li><li><p>层次数据模型；</p></li><li><p>网状数据模型。</p><p>  <img src="./Image-s1.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-3-数据抽象"><a href="#NO1-3-数据抽象" class="headerlink" title="NO1.3 数据抽象"></a>NO1.3 数据抽象</h3><p>所谓的数据抽象，其实就是把数据库更加的形象化，相当于把数据库当成现实世界中一个真正存在的大型仓库，只不过这个仓库放的不是别的东西，而是我们要查找的数据。</p><ul><li><p>为了简化用户与数据库的交互，数据库被分成了三个层次的抽象：</p><ul><li><p>物理层：这是最低层次的抽象，讲的是数据在底层是怎么存储的。就如同你要修建一座仓库，该用什么材料，做成什么样子；</p></li><li><p>逻辑层：比物理层稍微高一点的抽象，讲的是数据库里存储的是什么数据以及数据间都有什么样的关系。相当于仓库修建好了，你要往里面放什么样的东西，以及该怎么放。</p></li><li><p>视图层：这是最高层次的抽象，其实就是我们用户所看到的数据库的一部分。仓库修建好了，里面也放东西了，我们用户根据需求去找我们要的东西，当然要给我们用户一个能看到的“货架”。</p><p>  <img src="./Image-s2.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-4-数据库的三级模式"><a href="#NO1-4-数据库的三级模式" class="headerlink" title="NO1.4 数据库的三级模式"></a>NO1.4 数据库的三级模式</h3><ul><li>根据三个层次的抽象，数据库又被分为三个模式：<ul><li>物理模式(即内模式)：简单理解为，数据库的二进制信息最终还是要存储到存储设备上，内模式就是考虑用什么算法储存这些数据，储存的数据是否要压缩或者加密等等。数据库只能有一个内模式；</li><li>逻辑模式(即模式)：其实，模式就是数据库把所有的数据设计成我们用户能看 明白的样式。如，MySQL的模式，就是表；数据库只能有一个模式；</li><li>子模式(即外模式或用户模式)：通俗的讲，外模式就是数据库实际给我们用户看到的样式，是数据库查询产生的产物。外模式是模式的子集，数据库可以有多个外模式。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-5-数据库语言"><a href="#NO1-5-数据库语言" class="headerlink" title="NO1.5 数据库语言"></a>NO1.5 数据库语言</h3><p>数据库提供了用于定义模式(即数据该怎么放)的DDL语言，以及查询和更新数据库所使用的DML语言。</p><ul><li>数据定义语言(DDL)：用于定义数据库模式的语言。DDL的主要语句有：<ul><li>CREATE语句：可以创建数据库和数据库的一些对象；</li><li>DROP语句：可以删除数据模式、索引、触发程序、条件约束以及数据表的权限等；</li><li>ALTER语句：修改数据模式的定义及属性。</li></ul></li></ul><p>&nbsp;</p><ul><li>数据操纵语言(DML)，即能够对数据库中的数据进行增删改查的语言。DML通常分为过程化DML和非过程化DML：过程化DML要求用户不仅要知道自己想要什么数据，且还要知道怎么获得这些数据；而非过程化DML只要求用户知道自己想要什么数据就可以了，所以这比过程化DML要易学易用。DML的主要语句有：<ul><li>insert语句：向数据表张插入记录；</li><li>delete语句：删除数据表中的记录；</li><li>UPDATE语句：修改表中的记录。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-6-关系型数据库"><a href="#NO1-6-关系型数据库" class="headerlink" title="NO1.6 关系型数据库"></a>NO1.6 关系型数据库</h3><p>我们常说的关系型数据库，就是用表作为模式的数据库。</p><ul><li>关系数据库基于关系模型，使用一系列表来表示数据之间的关系。每个表有多个列，每个列有唯一的名称。关系数据库也包括DDL和DML。关系数据库的SQL查询语言是非过程化的，即只要知道需要什么样的数据，而不用考虑怎么获得这些数据。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-7-数据库设计"><a href="#NO1-7-数据库设计" class="headerlink" title="NO1.7 数据库设计"></a>NO1.7 数据库设计</h3><p>数据库的创建流程需要经历多个步骤。其中我们常用E-R模型来辅助设计数据库。</p><ul><li><p>数据库设计流程图：</p><p>  <img src="./Image-s3.png" srcset="/img/loading.gif" alt="Image"></p></li></ul><p>&nbsp;</p><ul><li>E-R模型的基本元素是：实体、联系和属性。<ul><li>实体：现实生活中任何可以被认知，区分的事物；</li><li>联系：实体之间的关系，可以一对一、一对多、多对多；</li><li>属性：实体的某一特性称为属性。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-8-数据库系统功能部件"><a href="#NO1-8-数据库系统功能部件" class="headerlink" title="NO1.8 数据库系统功能部件"></a>NO1.8 数据库系统功能部件</h3><p>数据库系统划分为不同的模块，每个模块完成整个系统的一个功能。</p><ul><li>数据库系统的功能部件大致可分为两大部分：<ul><li>存储管理器：负责数据库中数据的存储、检索和更新。</li><li>查询处理部件：该部件还分为了DDL解释器(用于解释DDL语句并记录到数据字典中)、DML解释器(用于将DML语句翻译成一个执行方案、以及查询引擎能够理解的低级指令)、查询执行引擎(用于执行由DML解释器产生的低级指令)。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-9-事务的特性"><a href="#NO1-9-事务的特性" class="headerlink" title="NO1.9 事务的特性"></a>NO1.9 事务的特性</h3><p>所谓的事务，就是指一个逻辑单元执行的一系列操作。如，我去超市买东西，付钱这个操作就是一个逻辑单元所要执行的一个系列操作：即我这里扣钱，商家那里得到钱，必须同时满足；只满足一方，都不叫事务。</p><ul><li>事务四大特性：<ul><li>原子性(ATOmicity)，是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</li><li>一致性(Consistency)，是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态；拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</li><li>隔离性(Isolation)，是指一个事务的执行不能被其他事务干扰，比如操作同一张表时，数据库会为每一个用户开启事务，而每个事务不能被其他事务的操作所干扰，即多个并发事务之间要相互隔离；即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</li><li>持久性(Durability)，是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson2-关系模型介绍"><a href="#Lesson2-关系模型介绍" class="headerlink" title="Lesson2 关系模型介绍"></a>Lesson2 关系模型介绍</h2><h3 id="NO2-1-关系数据库的结构"><a href="#NO2-1-关系数据库的结构" class="headerlink" title="NO2.1 关系数据库的结构"></a>NO2.1 关系数据库的结构</h3><p>关系数据库由许多个表构成。</p><ul><li>关系数据库的一些概念：<ul><li>关系型数据库中都是表，且每个表都有唯一的名字；</li><li>表又称为关系，表的行称为元组，表的列称为属性，每个属性都有一个取值范围，我们称为域；</li><li>NULL值出现在域中，表示值未知或不存在，但是我们要尽量避免NULL，因为这会给数据库的访问和更新带来很多困难。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-2-码"><a href="#NO2-2-码" class="headerlink" title="NO2.2 码"></a>NO2.2 码</h3><p>我们用表的某个属性来区分不同的记录。</p><ul><li>超码(就是主键的意思)：是指一个或多个属性的组合，其实就是一个或多个列的值的组合，而形成的复合列的意思。超码用来标识关系中唯一的一个元组。</li></ul><p>&nbsp;</p><ul><li>候选码：是指最小的超码。超码可以唯一标识一条记录，那么只要包含了超码的集合，也是超码，但如果这样的话，超码的范围就太广了(就是你搞那么多的超码，没什么用处)，所以我们就拿最小的那个超码就行了，而这个最小的超码就是候选码。<code>如，student表中，有id、name、age三个属性，其中id属性可以作为超码来标识唯一的元组，那么id+name可以是超码，id+age可以是超码，id+name+age也可以是超码，但是这三种超码，你不觉得没什么用吗，其实只要用一个id当做超码就可以了，因为一个id就可以区分每一个元组了，就没必要用其他另外的三种</code>。</li></ul><p>&nbsp;</p><ul><li>主码：就是用来标识被我们选中的候选码(因为有时候表中可能不止一个属性可以用来唯一标识一个元组。<code>如，people表有id，name，age,id_card属性，其中id和ic_card都可以作为候选码，这时我们随意选择一个作为主码即可)。主码一般放在表的最前面，且必须是从不或极少变化的属性</code>。</li></ul><p>&nbsp;</p><ul><li>外码：指的是如果一个表中，包括了另一个表中的主码，那么，这个外来的主码就称为外码。<code>如，A表中除了自身的主码外，还包含了B表中主码，那么A表中包含的另一个主码，就称为外码</code>；</li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson3-SQL"><a href="#Lesson3-SQL" class="headerlink" title="Lesson3 SQL"></a>Lesson3 SQL</h2><h3 id="NO3-1-SQL查询语言概览"><a href="#NO3-1-SQL查询语言概览" class="headerlink" title="NO3.1 SQL查询语言概览"></a>NO3.1 SQL查询语言概览</h3><p>SQL最早的版本是由IBM开发的，它最初被叫做Sequel，后来变成了SQL(即结构化查询语言)。1986年发布了SQL标准：SQL-86，最新的版本是SQL:2008。</p><ul><li>SQL语言主要有以下几个部分：<ul><li>数据定义语言(DDL)：DDL使我们有能力创建或删除关系，也可以定义索引，规定关系之间的链接，以及设置关系的约束等等；</li><li>数据操作语言(DML)：DML供用户实现对数据的新增、删除、更新、查询等操作；</li><li>完整性：就是指对表设置约束，DDL中包括了这个功能。<code>如，表的某些字段不能为NULL、是否唯一等等</code>；</li><li>视图定义：即根据表的查询结果创建视图，DDL中包括了这个功能；常使用的语句为CREATE view….；</li><li>事务控制：即定义事务的开始和结束的命令，SQL中包括了这个功能；</li><li>嵌入式SQL和动态SQL：即定义嵌入式SQL和动态SQL如何嵌入到通用编程语言中；</li><li>授权：定义对表的和视图的访问权限的命令，DDL中包括了这个功能；</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-2-SQL数据定义"><a href="#NO3-2-SQL数据定义" class="headerlink" title="NO3.2 SQL数据定义"></a>NO3.2 SQL数据定义</h3><p>数据库中的数据该用什么样的形式存放，必须由数据定义语言(DDL)指定给系统。</p><ul><li>SQL标准支持多种固有的基本数据类型，常见的有：<ul><li><code>char(size)</code>：固定长度的字符串(可包含字母、数字以及特殊字符)，不足长度的字符会用空格来填满。size指定字符串的长度，最多255个字符；</li><li><code>varchar(size)</code>：可变长度的字符串(可包含字母、数字以及特殊字符)。size指定字符串的最大长度，最多255个字符；<strong><code>注意：如果值的长度大于255，则被转换为TEXT类型；推荐使用varchar</code></strong>；</li><li><code>int(size)</code>：数值类型，占用4个字节，范围是-2147483648到2147483647。size指定最大位数；</li><li><code>smallint(size)</code>：数值类型，占用2个字节，范围是-32768到32767。size指定最大位数；</li><li><code>numeric(m,n)</code>：数值类型，占用m个字节，表示的是一个长度为m的数，小数位有n个(即m表示数字总长度，n表示小数位)；</li><li><code>double(size,d)</code>：双精度浮点数，d参数表示小数点后有多少位；</li><li><code>float(size,d)</code>：单精度浮点数，d参数表示小数点后有多少位。</li></ul></li></ul><p>&nbsp;</p><ul><li><p>基本表的定义和部分完整性约束；</p><ul><li><p>创建表；</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名称(    字段名<span class="hljs-number">1</span> 数据类型(长度),    字段名<span class="hljs-number">2</span> 数据类型(长度),    .......，)如：<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person(    LAStName <span class="hljs-built_in">varchar</span>(<span class="hljs-number">30</span>),    Age <span class="hljs-built_in">int</span>(<span class="hljs-number">3</span>))</code></pre></li></ul></li><li><p>删除表；</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> 表名称;如：<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> person;</code></pre></li></ul></li><li><p>修改表；</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql">向表中添加字段：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> 新字段名称 新字段类型 <span class="hljs-keyword">COMMENT</span> [解释] [插入字段的位置];如：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">ADD</span> age <span class="hljs-built_in">int</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'年龄'</span> <span class="hljs-keyword">after</span> birthday;修改字段的类型：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">MODIFY</span> 字段 新字段类型;如：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">MODIFY</span> <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>);删除字段：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> 新字段名称;如：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">pASswORd</span>;修改表名称：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">TO</span> 新名称;如：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">TO</span> student;修改字段名称：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">CHANGE</span> 字段名 新字段名 新字段类型;如：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">CHANGE</span> <span class="hljs-keyword">name</span> username <span class="hljs-built_in">varchar</span>(<span class="hljs-number">15</span>);</code></pre></li></ul></li><li><p>部分完整性约束。</p><ul><li><p>主键约束：将指定的字段设置为主键，可以直接写在某个字段后面，也可以在所有字段都写完之后再声明主键也行；</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql">字段名 数据类型 PRIMARY KEY 或PRIMARY KEY(字段名)如：<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person(    <span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>) PRIMARY <span class="hljs-keyword">KEY</span>,  //直接写在某个字段后面    <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">25</span>),    ADDress <span class="hljs-built_in">varchar</span>(<span class="hljs-number">25</span>),    //PRIMARY <span class="hljs-keyword">KEY</span>(<span class="hljs-keyword">id</span>)  //或者在所有字段都写完之后再声明主键)</code></pre></li></ul></li><li><p>外键约束：将指定的字段设置为外键，这个外键的值是另一个表中的主键的值；可以直接写在创建表时的的末尾，也可以在表创建完成后再添加。</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql">FOREIGN KEY(字段名) references 另一张表的名称 (另一张表的主键) 或 <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> 外键约束起个名称 (指定的字段名) <span class="hljs-keyword">references</span> 另一张表的名称 (另一张表的主键);如：<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person(    <span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> (<span class="hljs-number">10</span>) PRIMARY <span class="hljs-keyword">KEY</span>,    <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span> (<span class="hljs-number">25</span>),    ADDress <span class="hljs-built_in">varchar</span> (<span class="hljs-number">25</span>),    role_id <span class="hljs-built_in">int</span> (<span class="hljs-number">10</span>),    PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-keyword">id</span>),    <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (role_id) <span class="hljs-keyword">references</span> <span class="hljs-keyword">Role</span> (role_id)  //在所有字段都写完之后再声明外键)或<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> person <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> p_r_fk (role_id) <span class="hljs-keyword">references</span> <span class="hljs-keyword">role</span> (role_id);</code></pre></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-3-SQL查询的基本结构"><a href="#NO3-3-SQL查询的基本结构" class="headerlink" title="NO3.3 SQL查询的基本结构"></a>NO3.3 SQL查询的基本结构</h3><p>SQL的查询基本结构由：SELECT、FROM和WHERE组成。</p><ul><li><p>单表查询</p><ul><li><p>定义：即只对一个表进行查询；</p></li><li><p>基本语法格式：</p>  <pre><code class="hljs sql">基本查询：<span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">from</span> 表名;如：<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;使用DISTINCT去重：<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> 字段名 <span class="hljs-keyword">fORm</span> 表名;如：<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;WHERE条件查询，后面可跟逻辑连词AND、OR、NOT多个条件关系：<span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">AND</span> 条件;如：<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> adress = <span class="hljs-string">'地球村'</span>;使用AS为表取表别名，也可以省略不写，直接在表名后面空格，跟上表的别名也可以：<span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">AS</span> 表别名 <span class="hljs-keyword">WHERE</span> 条件;如：<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">AS</span> u <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span>;使用模糊匹配查询“%”和“_”，前者匹配任意个字符，后者匹配任意一个字符：<span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 字段名 <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'模糊查询'</span>;如：<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> adress <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%村'</span>;拓展：使用escape来定义转义字符：<span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'\%字段名%'</span> escape <span class="hljs-string">'\'</span> ，这里使用escape对<span class="hljs-string">"%"</span>进行了转义，表示模糊查询以“%字段名”开头的属性。使用*号获取所有的列：<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> 表名;如：<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;使用ORDER BY来按照某一列进行排序，后面可以跟DESC(降序)、ASC(升序)，不指定的话，默认是ASC升序：<span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 列名 <span class="hljs-keyword">DESC</span>;如：<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> adress = <span class="hljs-string">'地球村'</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">DESC</span>;使用BETWEEN...AND...范围限定条件：<span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">BETWEEN</span> ... <span class="hljs-keyword">AND</span> ...;如：<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> age <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">18</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">30</span>;</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>多表查询：</p><ul><li><p>使用的是natural join，我们称为自然连接。这种多表查询没有太多的意义，只是把相同的列合并成一个，所以这里了解一下就可以。</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段名 fram 表名 <span class="hljs-keyword">natural</span> <span class="hljs-keyword">join</span> 另一张表名;</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-4-集合运算"><a href="#NO3-4-集合运算" class="headerlink" title="NO3.4 集合运算"></a>NO3.4 集合运算</h3><p>数据库里的集合运算，一般指的是两张表的并集、交集和差集。</p><ul><li><p>分别使用<code>union/union all、intersect、except</code>关键字取两张表的并集、交集、差集。</p>  <pre><code class="hljs sql">使用union将多个表进行拼接，会自动去掉完全相同的两行或多行，只保留一行；union all和union作用一样，只是不会去除重复行：(<span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">FROM</span> 表名) <span class="hljs-keyword">union</span> (<span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">FROM</span> 表名)使用<span class="hljs-keyword">intersect</span>，取两张表的公共部分，但是MySQL中不支持该功能：(<span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">FROM</span> 表名) <span class="hljs-keyword">intersect</span> (<span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">FROM</span> 表名)使用<span class="hljs-keyword">except</span>，会自动去重，并取两张表的差集，<span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> 且还可以在最后添加<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>进行分组，但MySQL中不支持该功能：(<span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">FROM</span> A表) <span class="hljs-keyword">union</span> (<span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">FROM</span> B表)  //A表在前，则取属于A但不属于B表的记录(<span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">FROM</span> B表) <span class="hljs-keyword">union</span> (<span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">FROM</span> A表)  //B表在前，则取属于B表但不属于A表的记录</code></pre><p>  例如：</p><p>  <img src="./Image-s4.png" srcset="/img/loading.gif" alt="Image"></p><p>  <img src="./Image-s5.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>结果为：</code></p><p>  <img src="./Image-s6.png" srcset="/img/loading.gif" alt="Image"></p><p>  <strong><code>注意：union合并了id为c的记录，因为出现了两次，所以就只取了一次。</code></strong></p><p>  <img src="./Image-s7.png" srcset="/img/loading.gif" alt="Image"></p><p>  <img src="./Image-s8.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>结果为：</code></p><p>  <img src="./Image-s9.png" srcset="/img/loading.gif" alt="Image"></p><p>  <strong><code>注意：union all则没有去除重复的行记录。</code></strong></p></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-5-聚集函数"><a href="#NO3-5-聚集函数" class="headerlink" title="NO3.5 聚集函数"></a>NO3.5 聚集函数</h3><p>聚集函数返回的都是单个值。</p><ul><li>SQL提供了五个基本的聚集函数，聚集函数除了count()以外，其他函数都会忽略NULL(空值)。<ul><li>平均值：<code>avg(列名)</code>，只能用于数值类型；</li><li>最小值：<code>min(列名)</code>；</li><li>最大值：<code>max(列名)</code>；</li><li>总和：<code>sum(列名)</code>，只能用于数值类型；</li><li>计数：<code>count(列名)</code>。</li></ul></li></ul><p>&nbsp;</p><ul><li><p>分组聚集。</p>  <pre><code class="hljs sql">使用GROUP BY进行分组：<span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 字段名;注意：还可以在分组后，再次进行筛选，使用having即可：<span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 字段名 <span class="hljs-keyword">having</span> 条件。</code></pre></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-6-嵌套子查询"><a href="#NO3-6-嵌套子查询" class="headerlink" title="NO3.6 嵌套子查询"></a>NO3.6 嵌套子查询</h3><p>SQL还提供了嵌套子查询机制，简单讲就是将WHERE条件换成了一个SELECT句子。</p><ul><li><p>子查询。</p><ul><li><p>定义：其实就是将另一条SELECT-FROM-WHERE语句的结果当做查询的条件；</p></li><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 (<span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件)如：<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">max</span>(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">FROM</span> scORe);</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>集合的比较：all和some/any的使用。</p><ul><li><p><code>All</code>(比较条件包括：&gt;、&gt;=、&lt;、&lt;=、=、&lt;&gt;) ：对于外查询的每一条记录，与子查询所有的记录进行比较，如果满足指定的比较条件，那么就取出外查询的这条记录，否则就不取出；<strong><code>注意：&lt;&gt;为不等于。</code></strong></p></li><li><p><code>some/any</code>(比较条件包括：&gt;、&gt;=、&lt;、&lt;=、=、&lt;&gt;) ：对于外查询的每一条记录，与子查询部分的记录进行比较，如果满足指定的比较条件，那么就取出外查询的这条记录，否则就不取出。</p><p>  例如：</p><p>  <img src="./Image-s10.png" srcset="/img/loading.gif" alt="Image"></p><p>  <img src="./Image-s11.png" srcset="/img/loading.gif" alt="Image"></p><p>  <img src="./Image-s12.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p><code>exists</code>的使用：对于外查询中的每一条记录，都与子查询中所有记录进行比对，如果子查询中有与外查询的这条记录相符合的，就将外查询这条记录取出来。</p><p>  例如：</p><p>  <img src="./Image-s13.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>SQL：SELECT * FROM article WHERE EXISTS (SELECT * FROM user WHERE article.uid = user.uid)</code></p><p>  <code>查询结果为：</code></p><p>  <img src="./Image-s14.png" srcset="/img/loading.gif" alt="Image"></p><p>  <strong><code>说明：首先根据外查询的语句SELECT * FROM article，可以知道，查询article表的所有内容，说白了也就是每一条记录嘛；再来看看子查询的语句SELECT * FROM user WHERE article.uid = user.uid，可以知道，要查询的是user表中uid=?的记录，那么这个?是什么呢，其实就是外查询的每一条记录中uid的值而已，也就是说，可以将外查询的每一条记录都当做是article表，而article.uid属性不就是这条记录的uid属性吗？那么我们把这条记录uid值取出来，给子查询当做查询条件就行了；最后，从外查询的每一条记录中获得的这个uid值，当做查询条件放到子查询中，就只有两种结果，要么在子查询中找到了符合条件的记录，要么没找到，找到了就将外查询的这条记录当做输出结果保存，否则就不保存。</code></strong></p>  <pre><code class="hljs sql">拓展：相关子查询与不相关子查询一、相关子查询：子查询的执行依赖外部的查询，也就是说外部查询后，要将查询条件传给子查询使用，多数情况下是子查询的WHERE子句中引用了外部查询的表；二、不相关子查询：简单讲就是，子查询的执行不依赖外部的查询，一般子查询的结果会作为查询条件给外部条件使用。</code></pre></li></ul><p>&nbsp;</p><ul><li><code>UNIQUE/no UNIQUE</code>函数：该函数用于将外查询中的记录与子查询中记录进行比对，如果外查询唯一/不唯一，则保存这条外查询记录，否则就不保存为输出结果；MySQL中不支持该函数；</li></ul><p>&nbsp;</p><ul><li><p><code>WITH....AS</code>函数：其实就是把一大堆重复用到的SQL语句放在WITH….AS….里面，取一个别名，后面的查询就可以用它，相当于SQL片段；MySQL中不支持该函数；</p><p>  例如：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">WITH</span> a <span class="hljs-keyword">AS</span> (<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">test</span>);<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> a;</code></pre></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-7-表数据的删除、插入、修改操作"><a href="#NO3-7-表数据的删除、插入、修改操作" class="headerlink" title="NO3.7 表数据的删除、插入、修改操作"></a>NO3.7 表数据的删除、插入、修改操作</h3><ul><li><p>删除操作；</p><ul><li>基本语法格式：</li><li><code>DELETE FROM 表名</code>：删除表中所有数据；<ul><li><code>DELETE FROM 表名 WHERE 条件</code>：删除表中指定数据。</li></ul></li></ul></li><li><p>插入操作；</p><ul><li>基本语法格式：</li><li><code>INSERT INTO表名 (字段名1,字段名2....) VALUES (值1,值2....)</code>：添加单条数据；<ul><li><code>INSERT INTO表名 (字段名1,字段名2....) VALUES (值1,值2....),(值1,值2....)....</code>：添加多条数据。</li></ul></li></ul></li><li><p>修改；</p><ul><li><p>基本语法格式：</p><ul><li><p><code>UPDATE 表名 SET 字段名=新值, 字段名2=新值2</code>：修改指定数据；</p></li><li><p><code>UPDATE 表名 SET 字段名 = CASE WHEN 条件 THEN 处理 ELSE 其他处理 end</code>：针对不同的条件，修改为不同属性值。</p><p>  例如：</p><p>  <code>未执行sql之前，a表为：</code></p><p>  <img src="./Image-s15.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>执行完sql之后，a表为：</code></p><p>  <img src="./Image-s16.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>其中sql语句如下：</code></p><p>  `UPDATE a SET id =<br>  CASE</p><pre><code>WHEN id &lt;= 6  THEN id * 2  //当符合id小于6的，id都乘以2WHEN id &gt;= 8  THEN id / 2  //当符合id大于8的，id都除以2ELSE id+1  //其他，既不小于6，也不大于8的，id加1</code></pre><p>  END`</p></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson4-中级SQL"><a href="#Lesson4-中级SQL" class="headerlink" title="Lesson4 中级SQL"></a>Lesson4 中级SQL</h2><h3 id="NO4-1-外链接"><a href="#NO4-1-外链接" class="headerlink" title="NO4.1 外链接"></a>NO4.1 外链接</h3><p>SQL有三种形式的外链接。</p><ul><li><p>这三种外链接分别是：</p><ul><li><p>左外链接(left join/left outer join)：简单理解就是，以左表为主，左表所有内容都会出现，右表中只取与左表相连接的部分；</p></li><li><p>右外链接(right join/right outer join)：以右表为主，右表所有内容都会出现，左表中只取与右表相连接的部分；</p></li><li><p>全外链接(full outer join)：其实是取两个表的并集，能匹配上的就匹配，不能匹配上的记录也会放入查询结果中，MySQL不支持该功能。</p><p>  例如：</p><p>  <img src="./Image-s17.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：左表的记录将会全部表示出来，而右表只会显示符合搜索条件的记录，右表记录不足的地方均为NULL。</code></p><p>  <img src="./Image-s18.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：右外连接就是右表全部展示，左表取符合条件的部分，不足的地方用NULL表示。</code></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>内连接(inner join)的作用是取两个表的交集，即只取两张表能匹配上的记录放入查询结果中。</p><p>  例如：</p><p>  <img src="./Image-s19.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：组合两个表中的记录，返回两个表的交集(阴影)部分。</code></p></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO4-2-视图"><a href="#NO4-2-视图" class="headerlink" title="NO4.2 视图"></a>NO4.2 视图</h3><p>其实视图就是根据SQL语句查询出来的结果集，我们把它变成了一张表而已。</p><ul><li><p>使用CREATE view创建视图。</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">view</span> 视图名(列名<span class="hljs-number">1</span>,列名<span class="hljs-number">2.</span>...) <span class="hljs-keyword">AS</span> (<span class="hljs-keyword">SELECT</span> 列名 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件)注意：根据<span class="hljs-keyword">SQL</span>语句查询的结果而创建的视图，如果定义视图的那些记录发生了改变，如增删改，在符合定义视图时的条件下(<span class="hljs-keyword">FROM</span>后面只有一张表，且<span class="hljs-keyword">SELECT</span>中包含了视图的属性名，不能使用任何表达式、聚集函数、<span class="hljs-keyword">DISTINCT</span>、没有<span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>约束，也不构成主键的一部分，没有<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>或<span class="hljs-keyword">having</span>。简单的说，就是视图的创建语句，越简单越好)，那么视图中的相关记录信息也会跟着增删改，我们称为物化视图，同样的视图中的数据增删改也会影响原表中的记录，当然前提是符合定义视图时创建的条件；</code></pre><p>  例如：</p><p>  <code>表a：</code></p><p>  <img src="./Image-s20.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>创建视图的SQL语句：CREATE VIEW myview(id) AS SELECT id FROM a WHERE id &gt; 5；</code></p><p>  <code>创建后的视图为：</code></p><p>  <img src="./Image-s21.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>然后往表a中分别添加记录：3、11；添加两条记录后的表a为：</code></p><p>  <img src="./Image-s22.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>再来看看视图是否有变化：</code></p><p>  <img src="./Image-s23.png" srcset="/img/loading.gif" alt="Image"></p><p>  <strong><code>说明：只添加了11，3没有添加进去，因为3不符合创建视图时的定义，即id &gt; 5这个条件；同理往视图中添加记录也是一样，必须符合定义视图的条件才可以影响原表。</code></strong></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO4-3-事务"><a href="#NO4-3-事务" class="headerlink" title="NO4.3 事务"></a>NO4.3 事务</h3><p>SQL标准规定，当一条SQL语句被执行的时候，就隐式的开始了一个事务。结束事务只有两个状态：提交当前事务和回滚事务。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO4-4-完整性约束"><a href="#NO4-4-完整性约束" class="headerlink" title="NO4.4 完整性约束"></a>NO4.4 完整性约束</h3><p>完整性约束可以在创建表的时候添加，或表创建后再添加约束也可以，一般在创建表的时候添加。</p><ul><li><p>除了之前讲过的主键约束、外键约束，还包括以下几种：</p><ul><li><p><code>NOT NULL约束</code>：即被约束的列不允许空值，也就是必须要有值，一般在创建表时，直接写在字段名称后面就行了；</p></li><li><p><code>UNIQUE约束</code>：即要求被约束的列的值必须唯一，就是不相同的意思，但可以为NULL，也允许有多个NULL；</p></li><li><p><code>CHECK约束</code>：用于限制列中的值的范围；如果对单个列定义了CHECK约束，那么该列只允许特定的值，如gender列，只允许“男”和“女”。<strong><code>注意：MySQL中没有实现该功能，虽然有这个关键字，但是无效哦。</code></strong></p>  <pre><code class="hljs sql">拓展：约束的延迟检查：即事务中有可能出现：如两条语句，第一条插入的时候违反了约束，第二条符合了约束，这样的情况，有的数据库提供了延迟检查，在事务提交的时候进行检查；目前比较少数据库支持这个功能一、INITIALLY IMMEDIATE：意味着，当事务开始时，每个SQL语句执行后都必须检查是否违反了约束规则；二、INITIALLY DEFERRED：意味着，当事务开始后，对约束的检查可以推迟到晚些时候，但不晚于当前事务的结束。</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO4-5-SQL中的日期和时间类型，以及一些数据类型"><a href="#NO4-5-SQL中的日期和时间类型，以及一些数据类型" class="headerlink" title="NO4.5 SQL中的日期和时间类型，以及一些数据类型"></a>NO4.5 SQL中的日期和时间类型，以及一些数据类型</h3><p>时间和日期方面的数据类型、函数，都是数据库用的比较多的。</p><ul><li>SQL中日期和时间的数据类型；<ul><li>date：日期，包括年月日；如，2019-04-06；</li><li>time：时间，包括时分秒，还可以使用time(n)，其中n表示精确到秒的小数点后面的数字位数；如，09:30:50；</li><li>timestamp：date和time的组合。如，2019-04-03 09:15:29。</li></ul></li></ul><p>&nbsp;</p><ul><li>SQL中时间函数；<ul><li>current_date：返回当前日期；</li><li>current_time：返回当前时间(带有时区)；</li><li>localtime：返回当前的本地时间(不带时区)。</li></ul></li></ul><p>&nbsp;</p><ul><li>创建表的时候，可以给字段设置默认值，使用格式：default 数据默认值。如果在添加新纪录时，没有给某些列赋值，那么这个默认值就会生效，前提是必须设置了默认值。</li></ul><p>&nbsp;</p><ul><li>SQL还提供了大对象数据类型(clob)和二进制数据的大对象数据类型(blob)。</li></ul><p>&nbsp;</p><ul><li>SQL还支持自定义数据类型，一种是独特类型，另一种是结构化数据类型。这里讨论的独特类型：<ul><li>CREATE type 自定义数据类型名称 AS 数据类型 final。如，CREATE type Dollars AS numeric(12,2) final，定义了一个Dollars类型，总共有12位数，其中2位用于小数部分；</li><li>DROP type 类型名称；</li><li>ALTER type 类型名称。</li></ul></li></ul><p>&nbsp;</p><ul><li>CREATE TABLE的扩展。<ul><li>使用<code>CREATE TABLE .... LIKE ....</code>，可以创建一个与某个表结构相同的新表，但是，表中是没有数据的。如CREATE TABLE a LIKE b，根据b表创建了一个新表a，两者结构相同(列名、约束等等)，但就是没有数据；</li><li>使用<code>CREATE TABLE .... AS ....</code> (查询语句) WITH data，就可以创建与某个表相同结构的新表，且还拥有了表数据。MySQL好像不支持这个操作，我自己试了一下。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO4-6-权限"><a href="#NO4-6-权限" class="headerlink" title="NO4.6 权限"></a>NO4.6 权限</h3><p>我们有时会给别的用户授予一些权限。</p><ul><li>一个创建了新表的用户将自动被授予该表的所有权限。<ul><li><code>grant &lt;权限列表&gt; on &lt;表名或视图名&gt; TO &lt;用户/角色列表&gt;</code>：授予权限的命令。<code>如，grant SELECT on user(id) TO xiaoming，表示给了xiaoming在user表的id属性上的查询权限</code>；</li><li><code>revoke &lt;权限列表&gt; on &lt;表名或视图名&gt; FROM &lt;用户/角色列表&gt;</code>：收回权限的命令。</li></ul></li></ul><p>&nbsp;</p><ul><li><code>CREATE ROLE 角色名</code>：创建角色使用该命令，表示给数据库创建一个新的角色。这些角色和用户一样，用户拥有的权限，角色也可以被授予。</li></ul><p>&nbsp;</p><ul><li><code>grant references on 表名 TO 用户名</code>：给予操作外键的权限。<code>如，grant references (tea_id) on clASs TO xiaoming，表示给予了xiaoming操作clASs表的外键tea_id的权限</code>。</li></ul><p>&nbsp;</p><ul><li><code>grant 权限名 on 表 TO 用户名 WITH grant option</code>：给予被授权的用户将权限授予其它的用户。</li></ul><p>&nbsp;</p><ul><li><code>revoke 权限名 on 表名 FROM 用户名 restrict</code>：在大多数数据库系统中，级联是默认的行为，为了防止在收回权限时，产生级联收回，所以使用该命令。</li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson5-高级SQL"><a href="#Lesson5-高级SQL" class="headerlink" title="Lesson5 高级SQL"></a>Lesson5 高级SQL</h2><h3 id="NO5-1-使用程序设计语言访问数据库"><a href="#NO5-1-使用程序设计语言访问数据库" class="headerlink" title="NO5.1 使用程序设计语言访问数据库"></a>NO5.1 使用程序设计语言访问数据库</h3><p>JDBC标准定义了一套API(应用程序接口)，这套API是干嘛的呢，就是用于Java程序连接数据库服务器使用的。</p><ul><li><p>创建一个用JDBC连接数据库的程序，包含7个步骤：</p><ul><li><p>加载JDBC驱动程序：在连接数据库之前，首先明白自己想要连接到哪个数据库，然后将想要连接的数据库的驱动，加载到JVM(Java虚拟机)，这通过java.lang.ClASs类的静态方法fORName(String clASsName)实现；成功加载后，会将Driver类的实例注册到DriverManager类中；相当于，先告诉一声某个数据库，让它知道有我们这个人存在；</p>  <pre><code class="hljs java">ClASs.fORName(<span class="hljs-string">"各个数据库注册驱动的方式不一样，调用的驱动类就不一样"</span>);<span class="hljs-comment">//加载MySql的驱动类</span>ClASs.fORName(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>);</code></pre></li><li><p>创建数据库的连接：要连接数据库，需要向java.sql.DriverManager请求并获得Connection对象，Connection对象就代表一个数据库的连接；使用DriverManager的getConnectin(String url, String username, String pASswORd)方法获得连接对象，该方法需要传入三个参数：即想要连接的数据库的路径、数据库的用户名、密码；相当于，来到了指定数据库的门前，要进行身份的验证，然后递上用户名和密码进行检验；</p>  <pre><code class="hljs java"><span class="hljs-comment">//获取连接对象，该方法需要三个参数url、username、pASswORd</span>Connection con = DriverManager.getConnection(url , username , pASswORd );<span class="hljs-comment">//URL：简单理解就是，数据库问你：你要访问哪个数据库，回答是：我想访问URL中的(数据库)</span>jdbc:数据库:<span class="hljs-comment">//ip地址:数据库端口/要连接的数据库名称?useUnicode=true&amp;characterEncoding=utf-8;</span><span class="hljs-comment">//MySql的连接URL；其中useUnicode=true表示使用Unicode字符集，characterEncoding=xxx表示字符编码的方式</span>String url = <span class="hljs-string">"jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8"</span> ;<span class="hljs-comment">//账户名和密码，可以理解为，你想进这个数据库大门，就需要账户名和密码来验证你</span>String username = <span class="hljs-string">"root"</span> ;String pASswORd = <span class="hljs-string">"root"</span> ;</code></pre></li><li><p>进入数据库之后，是不是要搞事情了呢，那么就需要一个能够操作数据库的对象，这就是Statement对象，用于预处理SQL，什么叫预处理呢，简单理解就是你想要做什么，先告诉这个对象，然后由这个对象带着你的要求(就是你写的SQL语句)去操作数据库；创建一个Statement，要执行SQL语句，必须获得java.sql.Statement实例，Statement实例分为三种类型：执行静态SQL语句，通常通过Statement实例实现、执行动态SQL语句，通常通过PreparedStatement实例实现、执行数据库存储过程，通常通过CallableStatement实例实现；获取预处理对象的方式如下：</p>  <pre><code class="hljs java">Statement stmt = con.CREATEStatement();CallableStatement cstmt = con.prepareCall(<span class="hljs-string">"&#123;CALL demoSp(? , ?)&#125;"</span>);String sql=<span class="hljs-string">"INSERT INTOuser VALUES(0,?,?)"</span>;  <span class="hljs-comment">//SQL语句</span>PreparedStatement pstmt = con.prepareStatement(sql);  <span class="hljs-comment">//推荐用这个，安全性高，可以防止SQL注入，参数sql表示传入你要执行的SQL语句</span>pstmt.SETXxx(index,value);  <span class="hljs-comment">//设置SQL语句中?的值</span></code></pre></li><li><p>当prepareStatement准备好SQL语句后，就可以执行了；prepareStatement接口提供了三种执行SQL语句的方法：executeQuery(即ResultSET executeQuery(String sqlString)：执行查询数据库的SQL语句，返回一个结果集ResultSET对象)、executeUPDATE(int executeUPDATE(String sqlString)：用于执行INSERT、UPDATE或DELETE语句以及SQL DDL语句，如：CREATE TABLE和DROP TABLE等)、execute(execute(sqlString)：用于执行返回多个结果集、多个更新计数或二者组合的语句)；具体实现的代码如下：</p>  <pre><code class="hljs java">ResultSET rs = pstmt.executeQuery(<span class="hljs-string">"SELECT * FROM ..."</span>);<span class="hljs-keyword">int</span> rows = pstmt.executeUPDATE(<span class="hljs-string">"INSERT INTO..."</span>);<span class="hljs-keyword">boolean</span> flag = pstmt.execute(String sql);</code></pre></li><li><p>处理结果，两种情况：执行更新、删除、添加，返回的是本次操作影响到的记录数；执行查询返回的结果是一个ResultSET对象；</p>  <pre><code class="hljs java">ResultSET包含了，符合SQL语句中条件的所有行，并且它通过一套get方法提供了对这些行中数据的访问，使用结果集ResultSET对象的访问方法获取数据：<span class="hljs-keyword">while</span>(rs.next())&#123;    String name = rs.getString(<span class="hljs-string">"name"</span>);   <span class="hljs-comment">//通过列名获取值</span>    String pASs = rs.getString(<span class="hljs-number">1</span>);  <span class="hljs-comment">//此方法比较高效，列是从左到右编号的，并且从列1开始</span>&#125;</code></pre></li><li><p>关闭JDBC对象；数据库操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源，关闭顺序和声明顺序相反：</p>  <pre><code class="hljs java"><span class="hljs-keyword">if</span>(rs != NULL)&#123;   <span class="hljs-comment">//关闭结果集</span>    rs.close();&#125;<span class="hljs-keyword">if</span>(stmt != NULL)&#123;   <span class="hljs-comment">//关闭SQL预处理对象</span>    stmt.close();&#125;<span class="hljs-keyword">if</span>(conn != NULL)&#123;  <span class="hljs-comment">//关闭连接对象</span>    conn.close();&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li>ODBC，即Open DatabASe Connectivity，指的是开放数据库连接，是一组对数据库访问的标准API，也就是说，一个基于ODBC的应用程序，对数据库的操作不依赖任何DBMS，不直接与DBMS打交道，所有的数据库操作由对应的DBMS的ODBC驱动程序完成；不论是SQL Server、Access还是ORacle数据库，均可用ODBC API进行访问；由此可见，ODBC的最大优点是能以统一的方式处理所有的数据库；对于ODBC，这里暂时不做深入研究；</li></ul><p>&nbsp;</p><ul><li>嵌入式SQL，其实就是指的是将SQL嵌入到高级语言中去使用。平常我们所使用的SQL称为交互式SQL，即一般在DBMS中写入SQL语句，然后点击执行，DBMS根据你的SQL语句，返回给你想要的数据，就是立马能给你响应的，我们就称为交互式SQL。但是用的最多的，却是嵌入式SQL，像开头介绍的JDBC就属于嵌入式SQL，即把SQL语句嵌入到高级语言中，就是这么个意思了。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO5-2-函数和过程"><a href="#NO5-2-函数和过程" class="headerlink" title="NO5.2 函数和过程"></a>NO5.2 函数和过程</h3><p>不同的DBMS对于自定义函数也做了不同程度修改。</p><ul><li><p>自定义函数，简单理解就是我们自己定义一个函数，传入指定类型的参数，并返回指定类型的返回值；函数强调的是返回值，所以一般只返回一个值，不返回多个值。</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql">//基本格式<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> 函数名称(参数列表)<span class="hljs-keyword">RETURNS</span> 返回值类型<span class="hljs-keyword">RETURN</span> 函数体//如果有复合语句，如，<span class="hljs-keyword">SELECT</span>语句、<span class="hljs-keyword">insert</span>语句，就需要使用begin....end<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> 函数名称(参数列表)<span class="hljs-keyword">RETURNS</span> 返回值类型<span class="hljs-keyword">begin</span><span class="hljs-keyword">RETURN</span> (语句体)<span class="hljs-keyword">end</span>如：(这里以MySQL为例)//创建函数<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> stuNameById(stuId <span class="hljs-built_in">INTEGER</span>)<span class="hljs-keyword">RETURNS</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">45</span>)<span class="hljs-keyword">RETURN</span>(<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">FROM</span> tb_student <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span>=stuId);//调用函数<span class="hljs-keyword">SELECT</span> stuNameById(<span class="hljs-number">1</span>)</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li>过程其实和函数差不太多，只是一些方面限制要小一些。<code>如，函数返回一个值，过程可以返回多个值等等，且过程中使用IN和OUT分别来表示待赋值的参数和返回结果</code>。创建过程使用<code>CREATE procedure....</code>其他和创建函数大同小异；</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO5-3-触发器"><a href="#NO5-3-触发器" class="headerlink" title="NO5.3 触发器"></a>NO5.3 触发器</h3><p>触发器是一条语句。</p><ul><li><p>当对数据库作修改时，触发器会自动被系统执行；</p><ul><li><p>基本语法格式：</p>  <pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> 触发器名 <span class="hljs-keyword">BEFORE</span>|<span class="hljs-keyword">AFTER</span> 触发事件 <span class="hljs-keyword">ON</span> 表名 [<span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span>] [<span class="hljs-keyword">begin</span>] 执行语句 [<span class="hljs-keyword">end</span>]   //方括号表示可选说明：<span class="hljs-keyword">BEFORE</span>和<span class="hljs-keyword">AFTER</span>表示触发器是在触发事件之前触发还是之后触发；触发事件包括：<span class="hljs-keyword">UPDATE</span>、<span class="hljs-keyword">insert</span>、<span class="hljs-keyword">delete</span>；<span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span>表示对每一行；<span class="hljs-keyword">new</span>：当触发插入和更新事件时可用，指向的是被操作的记录；<span class="hljs-keyword">old</span>：当触发删除和更新事件时可用，指向的是被操作的记录。</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson6-形式化关系查询语言"><a href="#Lesson6-形式化关系查询语言" class="headerlink" title="Lesson6 形式化关系查询语言"></a>Lesson6 形式化关系查询语言</h2><h3 id="NO6-1-关系代数"><a href="#NO6-1-关系代数" class="headerlink" title="NO6.1 关系代数"></a>NO6.1 关系代数</h3><p>关系代数是一种过程化查询语言。</p><ul><li>关系代数包括一个运算的集合，这些运算以一个或两个表为输入，产生一个新的表作为结果。关系代数包括：<ul><li>传统的集合运算包括并、交、差、笛卡尔积；</li><li>专门的关系运算包括选择、投影、连接、除。</li></ul></li></ul><p>&nbsp;</p><ul><li>传统的集合运算包括并、交、差、笛卡尔积。<ul><li>并运算：简单理解就是把两张表的所有记录都集合成一个表，完全相同的记录只出现一条。<code>如，SELECT name FROM student WHERE chinese_scORe &gt; 60 union SELECT name FROM student WHERE math_scORe &gt; 70，表示将student表中语文趁机大于60分的学生或者数学成绩大于70分的学生的名字全都找出来，这就是并运算</code>；</li><li>交运算：其实就是取两张表都有的记录，取出来组成一张新的表；</li><li>差运算：通俗的讲，A和B两张表，A-B就是将属于表A但不属于表B的元素取出来，反之B-A，就是将属于表B但不属于表A的元素取出来，这就是差运算；</li><li>笛卡尔积：就是把表A的每一条记录与表B的每一条记录作匹配，即表A的记录乘以表B的记录=笛卡尔积。</li></ul></li></ul><p>&nbsp;</p><ul><li><p>专门的关系运算包括选择、投影、连接、除。</p><ul><li><p>选择运算：简单的理解，选择是对表中的记录，也就是表的一行进行操作。<code>如，SELECT * FROM student WHERE scORe &gt; 60，表示将student表中scORe大于60分的学生记录全部找出来，即一个学生的全部信息，这就是选择操作</code>；</p></li><li><p>投影运算：这个也比较简单，投影是对表中的列进行操作。<code>如，SELECT name FROM student WHERE scORe &gt; 60，表示将student表中scORe大于60分的学生的姓名全部找出来，这里我只要求姓名，并没有要求一个学生的所有信息，这就是投影操作</code>；</p></li><li><p>连接运算：即在笛卡尔积的基础上，取出满足条件的记录组成一张新表。<code>如，SELECT * FROM student,teacher WHERE student.id = teacher.id，表示取出学生id和老师id相等的记录</code>；</p></li><li><p>除运算：简单理解，A和B两张表，A/B就是，在A中找出符合B所有属性的记录。</p><p>  <img src="./Image-s24.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>那么学生/s1，结果为</code></p><p>  <img src="./Image-s25.png" srcset="/img/loading.gif" alt="Image"></p><p>  <img src="./Image-s26.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>那么学生/s2，结果为</code></p><p>  <img src="./Image-s27.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><ul><li>更名运算：其实就是为表或者列，创建一个别名，和数据库的AS功能一样；如，SELECT s.name FROM student AS s中将表student取了一个别名为s。</li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson7-数据库设计和E-R模型"><a href="#Lesson7-数据库设计和E-R模型" class="headerlink" title="Lesson7 数据库设计和E-R模型"></a>Lesson7 数据库设计和E-R模型</h2><h3 id="NO7-1-实体-联系模型"><a href="#NO7-1-实体-联系模型" class="headerlink" title="NO7.1 实体-联系模型"></a>NO7.1 实体-联系模型</h3><p>实体-联系模型的提出旨在方便数据库的设计。</p><ul><li>实体-联系(E-R)数据模型：该数据模型基于对现实世界的这样一种认识，即世界由一组称为实体的基本对象以及这些对象间的联系组成。简单理解就是将现实世界映射到数据库，数据库的一条记录就是一个基本对象。E-R数据模型采用了三个基本概念：<ul><li>实体：实体是客观存在并且可以互相区分的事物，可以是人或物，也可以是抽象的概念。在现实世界，实体并不是孤立存在的，实体与实体之间也存在联系，<code>如，课程与学生之间存在学生学习课程的联系，课程与老师之间存在老师教授课程的联系等等</code>；</li><li>联系：实体不是孤立存在的，实体之间是有联系的。实体之间的联系可以分为三类：一对一(1:1)、一对多(1:n)和多对多(m:n)。<code>如，一个老师可以教授多个课程，老师与课程的联系就是一对多的关系等等</code>；</li><li>属性：每个实体具有的特征称为属性，一个实体可以由若干个属性来描述。<code>如，课程实体可以由课程编号、课程名称、授课老师等属性组成</code>。属性都有其取值范围，称为值集或值域。唯一地标识实体的属性或属性组称为实体的关键字。<code>如，属性值“20180603、Java编程基础、郎老师”，其中20180603是课程编号的属性值，该编号在在所有的课程实体中是唯一的，该属性就是课程实体的关键字</code>。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO7-2-E-R图"><a href="#NO7-2-E-R图" class="headerlink" title="NO7.2 E-R图"></a>NO7.2 E-R图</h3><p>E-R图其实就是E-R模型的图形化表示。</p><ul><li><p>E-R图主要有以下几种表示：</p><p>  <img src="./Image-s28.png" srcset="/img/loading.gif" alt="Image"></p><p>  例如：</p><p>  <img src="./Image-s29.png" srcset="/img/loading.gif" alt="Image"></p></li></ul><p>&nbsp;</p><ul><li><p>E-R图给出了实体联系模型的图形化描述，增强了开发人员与客户的沟通能力。到了设计阶段，就需要在概念模型的基础上建立关系模型，关系模型是用二维表来表示实体集、属性以及联系的一种形式化模型。如下所示：</p><p>  <img src="./Image-s30.png" srcset="/img/loading.gif" alt="Image"></p></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO7-3-统一建模语言UML"><a href="#NO7-3-统一建模语言UML" class="headerlink" title="NO7.3 统一建模语言UML"></a>NO7.3 统一建模语言UML</h3><ul><li>UML作为一种模型语言，它使开发人员专注于建立产品的模型和结构，而不是选用什么程序语言和算法实现。主要是用来做软件蓝图。UML的核心是图表。大致可以将这些图归类为两种：<ul><li>静态视图，其下分为：用例图，类图，对象图，构件图，部署图；</li><li>动态视图，其下又分为：状态图，活动图，协作图，序列图。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson8-关系数据库的设计"><a href="#Lesson8-关系数据库的设计" class="headerlink" title="Lesson8 关系数据库的设计"></a>Lesson8 关系数据库的设计</h2><h3 id="NO8-1-数据库的三范式"><a href="#NO8-1-数据库的三范式" class="headerlink" title="NO8.1 数据库的三范式"></a>NO8.1 数据库的三范式</h3><p>在关系型数据库中，我们把设计数据库的规范称为范式。</p><ul><li>常用的三范式：<ul><li>第一范式(1NF)：强调的是列的原子性，即列不能够再分成其他几列；</li><li>第二范式(2NF)：首先要符合1NF，其次需要包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分；</li><li>第三范式(3NF)：首先要符合2NF，其次非主键列必须直接依赖于主键，不能存在传递依赖，即不能存在：非主键列A依赖于非主键列B，非主键列B依赖于主键的情况。<code>如，表中有id、name、course_id、course_name四个列，id为主键，其他列都依赖这个主键来区分不同的记录，符合2NF，但是course_name却直接依赖的是course_id，而不是id，所以不符合3NF</code>。</li></ul></li></ul><p>&nbsp;</p><ul><li>第二范式和第三范式的概念很容易混淆，区分它们的关键点在于，2NF：非主键列是否完全依赖于主键，还是依赖于主键的一部分；3NF：非主键列是直接依赖于主键，还是直接依赖于非主键列。</li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson9-应用设计和开发"><a href="#Lesson9-应用设计和开发" class="headerlink" title="Lesson9 应用设计和开发"></a>Lesson9 应用设计和开发</h2><p>关于Servlet和JSP、以及连接数据库，Java中已学习过，不再费时间学习</p><h2 id="Lesson10-存储和文件结构"><a href="#Lesson10-存储和文件结构" class="headerlink" title="Lesson10 存储和文件结构"></a>Lesson10 存储和文件结构</h2><p>这一章在这里不做学习，学习的性价比暂时不高</p><h2 id="Lesson11-索引与散列"><a href="#Lesson11-索引与散列" class="headerlink" title="Lesson11 索引与散列"></a>Lesson11 索引与散列</h2><p>这一章在这里不做学习，接触不同数据库时再进行学习</p><h2 id="Lesson12-查询处理"><a href="#Lesson12-查询处理" class="headerlink" title="Lesson12 查询处理"></a>Lesson12 查询处理</h2><p>这一章在这里不做学习，接触不同数据库时再进行学习</p><h2 id="Lesson13-查询优化"><a href="#Lesson13-查询优化" class="headerlink" title="Lesson13 查询优化"></a>Lesson13 查询优化</h2><p>这一章在这里不做学习，接触不同数据库时再进行学习</p><h2 id="Lesson14-事务"><a href="#Lesson14-事务" class="headerlink" title="Lesson14 事务"></a>Lesson14 事务</h2><p>Java中已学习过，不再费时间学习</p><h2 id="Lesson15-并发控制"><a href="#Lesson15-并发控制" class="headerlink" title="Lesson15 并发控制"></a>Lesson15 并发控制</h2><p>这一章在这里不做学习，接触不同数据库时再进行学习</p><h2 id="Lesson16-恢复系统"><a href="#Lesson16-恢复系统" class="headerlink" title="Lesson16 恢复系统"></a>Lesson16 恢复系统</h2><p>这一章在这里不做学习，学习的性价比暂时不高</p><h2 id="Lesson17-数据库系统体系结构"><a href="#Lesson17-数据库系统体系结构" class="headerlink" title="Lesson17 数据库系统体系结构"></a>Lesson17 数据库系统体系结构</h2><p>这一章在这里不做学习，学习的性价比暂时不高</p><h2 id="Lesson18-并行数据库"><a href="#Lesson18-并行数据库" class="headerlink" title="Lesson18 并行数据库"></a>Lesson18 并行数据库</h2><p>这一章在这里不做学习，学习的性价比暂时不高</p><h2 id="Lesson19-分布式数据库"><a href="#Lesson19-分布式数据库" class="headerlink" title="Lesson19 分布式数据库"></a>Lesson19 分布式数据库</h2><p>这一章在这里不做学习，学习的性价比暂时不高</p><h2 id="Lesson20-数据仓库与数据挖掘"><a href="#Lesson20-数据仓库与数据挖掘" class="headerlink" title="Lesson20 数据仓库与数据挖掘"></a>Lesson20 数据仓库与数据挖掘</h2><p>这一章在这里不做学习，学习的性价比暂时不高</p><h2 id="Lesson21-信息检索"><a href="#Lesson21-信息检索" class="headerlink" title="Lesson21 信息检索"></a>Lesson21 信息检索</h2><p>这一章在这里不做学习，学习的性价比暂时不高</p><h2 id="Lesson22-基于对象的数据库"><a href="#Lesson22-基于对象的数据库" class="headerlink" title="Lesson22 基于对象的数据库"></a>Lesson22 基于对象的数据库</h2><p>这一章在这里不做学习，学习的性价比暂时不高</p><h2 id="Lesson23-XML"><a href="#Lesson23-XML" class="headerlink" title="Lesson23 XML"></a>Lesson23 XML</h2><p>这一章在这里不做学习，学习的性价比暂时不高</p><h2 id="Lesson24-高级应用开发"><a href="#Lesson24-高级应用开发" class="headerlink" title="Lesson24 高级应用开发"></a>Lesson24 高级应用开发</h2><p>这一章在这里不做学习，学习的性价比暂时不高</p><h2 id="Lesson25-时空数据和移动性"><a href="#Lesson25-时空数据和移动性" class="headerlink" title="Lesson25 时空数据和移动性"></a>Lesson25 时空数据和移动性</h2><p>这一章在这里不做学习，学习的性价比暂时不高</p><h2 id="Lesson26-高级事务处理"><a href="#Lesson26-高级事务处理" class="headerlink" title="Lesson26 高级事务处理"></a>Lesson26 高级事务处理</h2><p>这一章在这里不做学习，学习的性价比暂时不高</p><h2 id="Lesson27-PostgreSQL"><a href="#Lesson27-PostgreSQL" class="headerlink" title="Lesson27 PostgreSQL"></a>Lesson27 PostgreSQL</h2><p>这一章在这里不做学习，会单独作为一门课程学习</p><h2 id="Lesson28-ORacle"><a href="#Lesson28-ORacle" class="headerlink" title="Lesson28 ORacle"></a>Lesson28 ORacle</h2><p>这一章在这里不做学习，会单独作为一门课程学习</p><h2 id="Lesson29-DB2"><a href="#Lesson29-DB2" class="headerlink" title="Lesson29 DB2"></a>Lesson29 DB2</h2><p>这一章在这里不做学习，会单独作为一门课程学习</p><h2 id="Lesson30-SQL-Server"><a href="#Lesson30-SQL-Server" class="headerlink" title="Lesson30 SQL Server"></a>Lesson30 SQL Server</h2><p>这一章在这里不做学习，会单独作为一门课程学习</p>]]></content>
    
    
    <categories>
      
      <category>3.대학교 삼 학년</category>
      
      <category>05.数据库系统原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大三课程</tag>
      
      <tag>数据库原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01.Docker--学习笔记</title>
    <link href="/2020/06/28/Docker--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/06/28/Docker--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker–学习笔记-包含Docker视频"><a href="#Docker–学习笔记-包含Docker视频" class="headerlink" title="Docker–学习笔记(包含Docker视频)"></a>Docker–学习笔记(包含Docker视频)</h1><h2 id="Lesson1-Docker概述"><a href="#Lesson1-Docker概述" class="headerlink" title="Lesson1 Docker概述"></a>Lesson1 Docker概述</h2><h3 id="NO1-1-Docker简介"><a href="#NO1-1-Docker简介" class="headerlink" title="NO1.1 Docker简介"></a>NO1.1 Docker简介</h3><p>Docker是一个开源的应用容器平台，通俗的讲Docker就如同它的那个鲸鱼Logo一样，只要下载了Docker这个容器平台，那么那些打包好了的“集装箱”就能在安装了Docker的电脑上使用。</p><ul><li>Docker：<ul><li>出现原因：软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在哪些机器上跑起来？用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。所以说，环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。由此，虚拟技术应运而生，先是LXC容器技术，然后再是Docker；</li><li>背景介绍：Docker是一个开源项目，诞生于2013年初，最初是dotCloud公司内部的一个业余项目，基于Google公司的Go语言实现，项目后来加入Linux基金会，遵从Apache2.0协议，项目代码在Github上维护；</li><li>定义：Docker是一个开源的应用容器引擎，通俗的讲Docker就如同它的那个鲸鱼Logo一样，只要下载了Docker这个容器引擎，那么那些打包好了的“集装箱”就能在安装了Docker的电脑上使用；</li><li>目标：实现轻量级的操作系统虚拟化解决方案。Docker的基础是Linux容器(Linux Containers，缩写为LXC)等技术，在LXC基础上Docker做了进一步的封装，让用户不需要关心容器的管理，使得操作更为简便。用户操作Docker容器就像操作一个快速轻量级的虚拟机一样简单；</li><li>作用：<ul><li>提供一次性的环境。<code>如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境</code>；</li><li>提供弹性的云服务。因为Docker容器可以随开随关，很适合动态扩容和缩容；</li><li>组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>Docker和虚拟机的区别：<ul><li>表面区别：<ul><li>内存占用：容器占用体积小，虚拟机占用体积大；</li><li>隔离性：容器提供了基于进程的隔离，而虚拟机提供了资源的完全隔离；</li><li>启动速度：虚拟机可能需要一分钟来启动，而容器只需要一秒钟或更短；</li><li>容器使用宿主操作系统的内核，而虚拟机使用独立的内核。Docker的局限性之一是，它只能用在64位的操作系统上。</li></ul></li><li>本质区别：<ul><li>容器是被隔离的进程。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-2-Docker三大核心组件"><a href="#NO1-2-Docker三大核心组件" class="headerlink" title="NO1.2 Docker三大核心组件"></a>NO1.2 Docker三大核心组件</h3><p>Docker的核心组件有三个。</p><ul><li>Docker核心组件：<ul><li>Docker仓库(registeries)：用来保存镜像的仓库。Docker仓库分为公开仓库和私有仓库；最大的公开仓库是Docker Hub，但是这个太慢，所以一般用的都是阿里云或网易云的镜像公开仓库；</li><li>Docker镜像(images)：就是一个只读的模板。镜像可以用来创建Docker容器，一个镜像可以创建多个容器；就跟Java的类一样，一个类可以创建出许多个对象一样；</li><li>Docker容器(containers)：就是Docker镜像运行的一个或多个实例。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-3-Docker架构"><a href="#NO1-3-Docker架构" class="headerlink" title="NO1.3 Docker架构"></a>NO1.3 Docker架构</h3><p>Docker使用C/S架构，Client通过接口与Server进程通信实现容器的构建，运行和发布。</p><p><img src="./Image-do1.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><ul><li><p>Docker架构包括三个部分：</p><ul><li><p>Host(Docker 宿主机)：即安装了Docker程序，并运行了Docker daemon的主机。包括：</p><ul><li>Docker daemon(Docker 守护进程)：运行在宿主机上，Docker守护进程，用户通过Docker client(Docker命令)与Docker daemon进行交互；</li><li>Images(镜像)：将软件和软件运行所需要的环境打包好的模板，用来创建容器的，一个镜像可以创建多个容器；</li><li>Containers(容器)：Docker的运行组件，启动一个镜像就是一个容器，容器与容器之间相互隔离，并且互不影响；简单讲容器其实就相当于一个超迷你型的CentOS，里面安装了你想要使用的软件和运行软件的环境，只不过这个CentOS没有那么多东西，所以轻量便捷。</li></ul></li><li><p>Docker Client(Docker 客户端)：Docker命令行工具，用户使用Docker Clients与Docker daemon进行通信并返回结果给用户。也可以使用其他工具通过Docker Api与Docker daemon通信。</p></li><li><p>Registry(仓库服务注册器)：经常会和仓库(Repository)混为一谈，实际上Registry上可以有多个仓库，每个仓库可以看成是一个用户， 一个用户的仓库放了多个镜像。仓库分为了公开仓库(Public Repository)和私有仓库(Private Repository)，最大的公开仓库是官方的Docker Hub，国内也有如阿里云、时速云等，可以给国内用户提供稳定快速的服务。用户也可以在本地网络内创建一个私有仓库。当用户创建了自己的镜像之后就可以使用push命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上pull下来就可以了。</p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-4-Docker安装"><a href="#NO1-4-Docker安装" class="headerlink" title="NO1.4 Docker安装"></a>NO1.4 Docker安装</h3><p>要想使用Docker，必须先安装Docker，但是Docker只支持CentOS6.5以上的版本，因为我这里安装的是CentOS7.x，所以只以这个版本为例。</p><ul><li><p>CentOS7.x的安装：</p><ul><li><p>首先，要安装Docker的一些依赖包(如果已经安装了的，会自动更新到最新)：</p><ul><li>安装命令：<ul><li><code>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code>，其中sudo是指允许已验证的用户以其他用户的身份来运行命令，简单讲就是提升权限的意思。然而，大部分时候我们用它来以提升的权限来运行命令。如果已经在root用户下就可以不用加sudo；</li><li><code>yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code>，设置阿里云镜像，意思就是从阿里云的服务器下载docker等一些需要的安装包。</li></ul></li></ul></li><li><p>依赖包安装完毕后，就可以安装Docker了：</p><ul><li><p>安装命令：</p><ul><li><p><code>sudo yum install docker-ce</code>，这是安装docker的命令；</p></li><li><p><code>docker version</code>，出现如图1.4.1docker版本信息，说明就安装成功了。</p><p>  <img src="./Image-do2.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>图1.4.1</code></p></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-5-Docker启动"><a href="#NO1-5-Docker启动" class="headerlink" title="NO1.5 Docker启动"></a>NO1.5 Docker启动</h3><p>安装完成了Docker，现在就可以启动Dicker服务了。</p><ul><li>安装完Docker之后，启动Docker：<ul><li>启动命令：<ul><li><code>sudo systemctl enable docker</code>，这是开机自启的命令；</li><li><code>sudo systemctl start docker</code>，这是启动docker服务。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>安装好Docker以后，我们就可以从Docker Hub上下载镜像到本地，然后运行镜像，生成容器了，但是连接到国外的网址会很慢很慢，所以就需要配置连接到阿里云或网易云的镜像仓库(阿里云或网易云的的镜像仓库都是从国外整个搬运的)；找到Linux中的/etc/docker，如果没有docker目录，创建即可，然后再在该目录下创建daemon.json文件并进行配置，镜像加速配置如下：</p><p>例如：</p><pre><code class="hljs java"><span class="hljs-comment">//加速器地址：阿里云控制台搜索容器镜像服务，进入容器镜像服务，左侧最下方容器镜像服务中复制加速器地址</span>&#123;  <span class="hljs-string">"registry-mirrors"</span>: [<span class="hljs-string">"你的加速器地址"</span>]&#125;<span class="hljs-comment">//然后使用命令，并在文件中输入上面的加速器地址即可</span>vim /etc/docker/daemon.json  <span class="hljs-comment">//创建并编辑darmon.json文件</span><span class="hljs-comment">//重新加载darmon进程，然后重启docker</span>sudo systemctl daemon-reloadsudo systemctl restart docker<span class="hljs-comment">//查看重启后的docker服务是否成功配置了镜像加速配置</span>如：vim /etc/docker/daemon.json&#123;  <span class="hljs-string">"registry-mirrors"</span>: [<span class="hljs-string">"https://mcokls22.mirror.aliyuncs.com"</span>]&#125;sudo systemctl daemon-reloadsudo systemctl restart docker</code></pre></li></ul><p>&nbsp;</p><ul><li><p>检查自己配置的镜像加速配置是否生效。</p><ul><li><p>输入命令：</p><ul><li><p><code>docker info</code>，找到如图1.4.2，与你之前配置的镜像加速代码是否一致，一致说明镜像加速配置是生效的。</p><p><img src="./Image-do3.png" srcset="/img/loading.gif" alt="Image"></p><p><code>图1.4.2</code></p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>使用拉取命令测试docker是否能够使用：</p><ul><li><p>输入命令：</p><ul><li><p><code>docker run hello-world</code>，出现如图1.4.3就表示docker能够成功拉取镜像，并生成容器使用了。</p><p><img src="./Image-do4.png" srcset="/img/loading.gif" alt="Image"></p><p><code>图1.4.3</code></p></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson2-Docker基础"><a href="#Lesson2-Docker基础" class="headerlink" title="Lesson2 Docker基础"></a>Lesson2 Docker基础</h2><h3 id="NO2-1-Docker常用命令"><a href="#NO2-1-Docker常用命令" class="headerlink" title="NO2.1 Docker常用命令"></a>NO2.1 Docker常用命令</h3><p>我们使用Docker Client来与安装了Docker的主机进行交互。</p><ul><li>帮助命令：<ul><li><code>docker version</code>：查看docker容器平台的版本；</li><li><code>docker info</code>：查看docker容器平台信息：；</li><li><code>docker --help</code>：查看docker容器帮助。</li></ul></li></ul><p>&nbsp;</p><ul><li><p>镜像命令：</p><ul><li><p>镜像构建：</p><ul><li><code>docker build [选项] .</code>：构建一个镜像。选项如下；<strong><code>注意：构建镜像的格式最后面有个“ .”，即一个空格和一个点。</code></strong><ul><li><code>-f</code>：指定要使用的Dockerfile文件的路径；</li><li><code>-t</code>：镜像的名称；</li><li><code>-tag</code>：镜像的版本号。</li></ul></li></ul></li><li><p>镜像查看：</p><ul><li><p><code>docker images [选项]</code>：列出本地的所有镜像。选项如下：</p><ul><li><p><code>-a</code>：列出本地所以镜像，包含中间映像层；</p></li><li><p><code>-q</code>：只显示本地所有镜像的ID；</p></li><li><p><code>-qa</code>：显示本地所有的包含中间映像层的镜像的ID；</p></li><li><p><code>-digests</code>：显示本地所有镜像的摘要信息(包含DIGEST列，只是多了这一个列，和-a功能差不多)；</p></li><li><p><code>-no-trunc</code>：显示本地所有镜像的完整信息(其实就是镜像ID列的完整展示)；</p><p>  <img src="./Image-do5.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul></li><li><p>镜像搜索：</p><ul><li><p><code>docker search [选项] 镜像名</code>：在仓库中查找指定名称的镜像。选项如下：</p><ul><li><p><code>--filter=stars=数值</code>：查找并列出“stars数 &gt;= 数值”的镜像；</p></li><li><p><code>--no-trunc</code>：显示要查找的镜像中其完整描述，就是DESCRIPTION列的完整显示；</p></li><li><p><code>--automated</code>：只列出AUTOMATED=OK的镜像。</p><p>  <img src="./Image-do6.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul></li><li><p>镜像下载：</p><ul><li><code>docker pull 镜像名</code>：下载指定名称的镜像。如果不指定镜像的版本，则默认下载latest版本。即最新版本；</li></ul></li><li><p>镜像删除：</p><ul><li><code>docker rmi [选项] 镜像名/镜像ID</code>：删除指定名称或镜像ID的镜像。如果不指定镜像的版本，则默认删除latest版本。选项如下：<ul><li>-f：表示强制删除(因为删除时，该镜像可能有正在运行的容器)；</li><li>镜像名 空格 镜像名：表示删除多个指定的镜像。如，docker rmi aaa bbb ccc，就表示删除了aaa、bbb、ccc三个镜像，且都是latest版本；</li><li>&amp;(docker images -qa)：删除本地所有的镜像，因为docker images -qa命令就是获得所有的镜像的ID，再加上前面的删除命令，就是删除所有镜像的命令了。</li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>容器命令：</p><ul><li><p>容器启动：</p><ul><li><p><code>docker run [选项] 镜像名</code>：根据指定名称的镜像创建一个容器并运行该容器，该方式也是进入容器的方式。选项如下：</p><ul><li><p><code>-i</code>：以交互模式运行容器，通常与-t一起使用；如，我新建并运行了一个MySQL容器，那么我要肯定要进入这个MySQL容器去进行操作，而-i和-t则分别提供了可以交互的功能和我能够给这个MySQL下命令的终端功能；</p></li><li><p><code>-d</code>：以守护方式启动容器，就是以后台方式运行；</p></li><li><p><code>-t</code>：为容器重新分配一个伪输入终端，通常与-i一起使用；</p></li><li><p><code>--name</code>：为容器指定一个名称，相当于取个别名，方便辨认；如果没有添加该选项，则系统会为容器随机取一个名称；</p></li><li><p><code>-p 外部主机端口:docker容器端口</code>：将外部主机端口映射到docker容器的端口，这样外部就可以访问docker中的容器了；</p></li><li><p><code>-P 随机分配端口</code>：此时Docker会随机映射一个49000~49900的端口到内部容器开放的网络端口。</p><p>  <img src="./Image-do7.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul></li><li><p>容器查看：</p><ul><li><p><code>docker ps [选项]</code>：查看当前正在运行的容器。选项如下：</p><ul><li><p><code>-q</code>：查看正在运行的容器的ID；</p></li><li><p><code>-a</code>：查看当前正在运行的、以及历史运行过的容器；</p></li><li><p><code>-s</code>：显示运行容器总文件大小；</p></li><li><p><code>--no-trunc</code>：表示显示完整的信息；</p></li><li><p><code>-l</code>：显示最近创建的一个容器，无论是否运行；</p></li><li><p><code>-n 数值</code>：显示最近创建的“数值”个容器，无论是否运行。如，-n 3，表示显示最近创建的3个容器。</p><p>  <img src="./Image-do8.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul></li><li><p>容器的进入与退出：</p><ul><li>进入容器：<ul><li><code>docker run [选项] 镜像名</code>：创建容器，并首次进入容器；</li><li><code>docker attach 容器ID/容器别名</code>：进入容器后，退出来，不关闭容器，后面再进入容器进行其他操作。但如果当多个窗口同时使用该命令进入该容器时，所有的窗口都会同步显示。如果有一个窗口阻塞了，那么其他窗口也无法再进行操作，该命令不太适合于生产环境，平时自己开发应用时可以使用该命令；</li><li><code>docker exec -it 容器ID/容器别名 /bin/bash</code>：不进入容器，但是希望执行某些操作，且结果返回当前终端。选项如下：<ul><li><code>-i</code>：即使没有附加也保持STDIN打开，一般-it一起使用，相当于进入该容器的shell环境进行操作；</li><li><code>-t</code>：分配一个伪终端；</li><li><code>-d</code>：以分离模式在容器中执行命令，程序后台运行，结果不会反馈到当前终端。</li></ul></li></ul></li><li>退出容器：<ul><li><code>exit</code>：在容器中，直接输入该命令，不仅退出容器，还关闭了容器；</li><li><code>Ctrl + P + Q</code>：在容器中，按该快捷键，只退出容器，不关闭容器。</li></ul></li></ul></li><li><p><code>docker start/restart 容器ID/容器别名....</code>：启动/重启一个或多个容器；</p></li><li><p>容器的停止与删除：</p><ul><li>停止容器：<ul><li><code>docker stop 容器ID或别名</code>：停止一个运行中的容器(正常关闭)；</li><li><code>docker kill 容器ID或别名</code>：停止一个运行中的容器(强制关闭)。</li></ul></li><li>删除容器：<ul><li><code>docker rm 容器ID或别名</code>：删除一个已停止的容器；</li><li><code>docker rm -f 容器ID或别名</code>：删除一个运行中的容器；</li><li><code>docker rm -f $(docker ps -a -q)或者docker ps -a -q | xargs docker rm</code>：删除多个容器。</li></ul></li></ul></li><li><p>容器日志：</p><ul><li><code>docker logs [选项] 容器ID/容器别名</code>：查看容器日志；选项如下：<ul><li><code>-f</code>：实时跟踪日志输出；</li><li><code>-t</code>：显示时间戳，就是什么时间做了什么操作；</li><li><code>--tail=n</code>：仅列出最新n条容器日志；</li><li><code>--since</code>：从某段时间之后开始的日志。</li></ul></li></ul></li><li><p>容器进程：</p><ul><li><code>docker top 容器ID/容器别名</code>：查看容器进程信息。</li></ul></li><li><p>容器内部细节：</p><ul><li><code>docker inspect 容器ID/容器别名</code>：以JSOM串的形式查看容器内部细节。</li></ul></li><li><p>容器数据拷贝：</p><ul><li><code>docker cp 容器ID/容器别名:容器中的文件路径 宿主机的存放路径</code>：从容器中拷贝数据到宿主机。</li></ul></li><li><p>从容器创建一个新的镜像：</p><ul><li><code>docker commit [选项] 容器ID/容器名 命名空间:版本号</code>：将当前正在运行的容器，经过修改后，可以得到一个根据你要求修改的容器，然后可以把该容器作为一个镜像进行提交。选项如下：<ul><li><code>-a</code>：提交的镜像的作者；</li><li><code>-c</code>：使用Dockerfile指令来创建镜像；</li><li><code>-m</code>：提交镜像时的说明文字；</li><li><code>-p</code>：在commit时，将容器暂停。</li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-2-Docker镜像原理"><a href="#NO2-2-Docker镜像原理" class="headerlink" title="NO2.2 Docker镜像原理"></a>NO2.2 Docker镜像原理</h3><p>有想过镜像到底是一个什么东西吗？</p><ul><li>镜像是什么？我们说镜像其实是将软件和软件运行所需的各种环境都打包了的独立软件包，但在底层，镜像是一个UnionFS(联合文件系统)，也就是说，根据一个基础镜像，然后每一次对基础镜像的修改都会叠加。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-3-Docker容器数据卷"><a href="#NO2-3-Docker容器数据卷" class="headerlink" title="NO2.3  Docker容器数据卷"></a>NO2.3  Docker容器数据卷</h3><p>容器数据卷，说白了，就是用来持久化保存容器产生的数据而使用的这么个东西。</p><ul><li><p>容器数据卷：</p><ul><li><p>定义：用来保存容器所产生的的数据，但又独立于容器之外的这么一个文件或目录；</p></li><li><p>作用：</p><ul><li>保存容器中的数据；</li><li>容器间的数据共享。</li></ul></li><li><p>特点：</p><ul><li>数据卷可以在容器之间共享和重用数据；</li><li>卷的更改可以直接生效；</li><li>数据卷的更改不会包含在镜像的更新中；</li><li>数据卷的生命周期一直持续到没有容器使用它为止。</li></ul></li><li><p>基本语法格式：</p><ul><li><p>方式一：直接通过命令挂载。</p><ul><li><p><code>docker run -it -v 宿主机绝对路径目录:容器内目录:[权限选项] --privileged=true 镜像名</code>：将指定的宿主机路径和容器内的路径进行相关联的意思；privileged=true则表示给予权限。选项如下；</p><ul><li><code>ro</code>：表示read only。如果加了该选项，那么容器和宿主机之间相互共享的目录，容器是只可读不可以写入，而宿主机可读可写；如果没有权限选项，那么容器和宿主机之间都两边可以读写操作；</li></ul></li><li><p>可以使用docker inspect 容器ID/容器别名命令，查看是否挂载成功。<strong><code>注意：如果指定的目录不存在，那么系统会自动创建并挂载上；容器停止后，主机修改挂载目录中的数据，容器再次开启后，数据会同步。</code></strong></p><p>  <img src="./Image-do9.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li><li><p>方式二：使用DockerFile添加。</p><ul><li><p>即在自定义的目录下创建一个文件，并在文件中写入Volume指令(如下所示)：指令内容主要是在容器内部的自定义路径中创建一个或多个容器卷来与宿主机进行共享。DockerFile内容如下：</p>  <pre><code class="hljs java">FROM  镜像名  <span class="hljs-comment">//表示该镜像基于哪个镜像</span>VOLUME [<span class="hljs-string">"/容器卷1路径"</span>,<span class="hljs-string">"/容器卷2的路径"</span>....] --privileged=<span class="hljs-keyword">true</span>    <span class="hljs-comment">//定义匿名数据卷，后面的privileged=true，表示权限通过的意思</span>CMD echo <span class="hljs-string">"success build"</span>  <span class="hljs-comment">//用于运行某些指令，这里是打印success build这句话</span>CMD /bin/bash  <span class="hljs-comment">//生成一个伪终端给用户</span>注意*：--privileged=<span class="hljs-keyword">true</span>选项，一般出现cannot open directory:Permission denied异常时(即权限不够)才使用，一般不会遇到。*</code></pre></li><li><p>构建DockerFile文件，即通过该文件生成一个镜像的意思；使用命令：<code>docker build -t 命名空间/镜像名 -f 指定的DockerFile文件的路径</code>；</p><p>  <img src="./Image-do10.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>镜像生成后，只要运行该镜像并生成容器，这样容器内部指定的目录下就会生成容器卷；那么生成的容器卷和宿主机的哪个文件建立共享关联呢，可以使用<code>docker inspect 容器ID/容器别名</code>命令查看。</p><p>  <img src="./Image-do11.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>数据卷容器</p><ul><li><p>定义：其实就是在生成容器的时候，添加一个父容器，表示我当前生成的容器，是继承自某个容器的(其实主要是类似共享同一个数据空间)，这样就能够形成一个数据共享的空间；</p></li><li><p>基本语法格式：</p>  <pre><code class="hljs java">docker run -it - -name 父容器名 镜像名  <span class="hljs-comment">//根据镜像生成一个容器，该镜像必须是包含了创建容器卷操作的镜像，就如同上面使用DockerFile构建容器卷一样</span>docker run -it - -name 子容器<span class="hljs-number">1</span> --volumes -from 父容器名 镜像名docker run -it - -name 子容器<span class="hljs-number">2</span> --volumes -from 父容器名 镜像名....注意：此时，已经根据同一个镜像生成了<span class="hljs-number">3</span>个容器，父容器、子容器<span class="hljs-number">1</span>、子容器<span class="hljs-number">2</span>；此时删掉父容器，子容器<span class="hljs-number">1</span>和<span class="hljs-number">2</span>，任意一个往容器卷里面修改数据，<span class="hljs-number">2</span>和<span class="hljs-number">3</span>都各自还能共享数据，同理，只要继承了任意一个该数据空间中的容器，那么都能加入到该数据空间中来，哪个容器删除，都不影响其他容器之间的数据共享，因为它们都还在同一个数据空间中，只要不是所有的容器都删除了，那么该数据空间(也就是容器卷空间)就会消失，也就是说只要还有一个容器在该数据空间中，那么该数据空间就不会消失。</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-4-DockerFile"><a href="#NO2-4-DockerFile" class="headerlink" title="NO2.4 DockerFile"></a>NO2.4 DockerFile</h3><p>DockerFile就是一个文件，只不过该文件的作用是用来构建镜像的。</p><ul><li><p>DockerFile：</p><ul><li><p>定义：就是用来构建镜像的文件；</p></li><li><p>作用：构建镜像；</p></li><li><p>基础知识：</p><ul><li>每条保留字指令都必须为大写字母，且后面要跟至少一个参数；</li><li>指令按照从上到下的顺序执行；</li><li>#表示注释；</li><li>每条指令都会创建一个新的镜像层，并对镜像进行提交。</li></ul></li><li><p>基本语法格式：</p><ul><li><p>编写DockerFile；DockerFile中的保留字指令及其功能如下；<strong><code>注意：Docker Hub中99%的镜像都是通过base镜像(即scratch)的基础上构建出来的</code></strong>。</p><ul><li><p><code>FROM</code>：表示基础镜像，即当前要构建的镜像是基于哪个镜像；</p></li><li><p><code>MAINTRAINER</code>：镜像维护者和其邮箱地址；</p></li><li><p><code>RUN</code>：表示后面跟着的命令行命令是需要执行的；</p></li><li><p><code>EXPOSE</code>：声明一个端口号，即对外暴露的访问端口号；</p></li><li><p><code>WORKDIR</code>：指定工作目录，即该镜像生成容器后，进入容器内部时所在的初始目录；</p></li><li><p><code>ENV</code>：设置一个环境变量，即设置该变量之后，后面的指令就可以使用这个环境变量；如果想引用环境变量，使用“$环境变量名”格式即可；</p></li><li><p><code>ADD</code>：除了有复制功能之外，如果被复制的文件是gzip、bzip2以及xz的情况下，会自动复制并解压到目标路径；</p></li><li><p><code>COPY</code>：作用和ADD一致，是复制指令，就是从上下文目录中复制文件或者目录到容器里的指定路径，但仅仅只做复制操作；有两种写法：</p><ul><li>COPY src dest；</li><li>COPY [“src”,”dest”]。</li></ul></li><li><p><code>VOLUME</code>：定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到这里指的的匿名卷；</p></li><li><p><code>CMD</code>：指定容器启动时要运行的命令。可以有多个CMD命令，但是只有最后一个生效。另外CMD命令会被docker run命令中的参数所覆盖。我们常常会看到echo “xxx….”，表示输出一段话，和Java的println()功能一致；</p></li><li><p><code>ENTRYPOINT</code>：和CMD的作用相同，即执行该保留字之后命令，但是不会被docker run命令中的参数所覆盖；即该命令后面的参数会被追加到docker run命令后面去；</p></li><li><p><code>ONBUILD</code>：用于延迟构建指令。意思就是说本次构建并不执行这里的命令，只有当别的镜像继承了该镜像后，并在子镜像构建的时候，才会执行这里的命令。</p><p>  例如：</p>  <pre><code class="hljs java"><span class="hljs-comment">//必须要指定基础镜像</span>FROM xxx<span class="hljs-comment">//维护者和维护者的邮箱信息</span>MAINTAINER docker_user docker_user<span class="hljs-meta">@email</span>.com<span class="hljs-comment">//镜像操作指令</span>RUN echo <span class="hljs-string">"check success!!!"</span><span class="hljs-comment">//容器启动时要执行的指令</span>CMD /usr/sbin/nginx</code></pre></li></ul></li><li><p><code>docker build -f 指定的DockerFile文件路径 -t 新镜像的名称:版本号</code>：根据DockerFile构建镜像；</p></li><li><p>运行镜像，并生成容器。</p></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>5.다른 과정</category>
      
      <category>09.应用容器平台</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>应用容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01.C语言--学习笔记</title>
    <link href="/2020/06/26/C%E8%AF%AD%E8%A8%80--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/06/26/C%E8%AF%AD%E8%A8%80--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言–学习笔记-包含C语言视频、C-Primer-Plus书籍"><a href="#C语言–学习笔记-包含C语言视频、C-Primer-Plus书籍" class="headerlink" title="C语言–学习笔记(包含C语言视频、C Primer Plus书籍)"></a>C语言–学习笔记(包含C语言视频、C Primer Plus书籍)</h1><h2 id="Lesson1-C语言概述"><a href="#Lesson1-C语言概述" class="headerlink" title="Lesson1 C语言概述"></a>Lesson1 C语言概述</h2><h3 id="NO1-1-C语言简介"><a href="#NO1-1-C语言简介" class="headerlink" title="NO1.1 C语言简介"></a>NO1.1 C语言简介</h3><p>1972年，贝尔实验室的丹尼斯·里奇(Dennis Ritch)和肯·汤普逊(Ken Thompson)在开发UNIX操作系统时设计了C语言，而C语言是在B语言的基础上进行设计的。</p><ul><li>C语言的特点：运行的高效性(C语言程序紧凑、运行速度很快)、可移植性(移植到别的平台时，几乎不用改什么代码)、强大而灵活(如，UNIX大部分是用C写的)等等。</li></ul><p>&nbsp;</p><ul><li>C语言的应用范围很广：游戏开发、嵌入式软件开发、操作系统等等。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-2-语言标准"><a href="#NO1-2-语言标准" class="headerlink" title="NO1.2 语言标准"></a>NO1.2 语言标准</h3><p>美国国家标准协会(ANSI)于1983年组建了一个委员会，开发了一套新标准，并于1989年正式公布。</p><ul><li>ANSI C标准定义了C语言和C标准库。国际标准化组织于1990年采用了这套C标准(ISO C)。ISO C和ANSI C是完全相同的标准。ANSI/ISO标准的最终版本通常叫作C89或C90。1994年，发布了C99标准。而在2011年12月8日，发布了C11标准。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-3-C语言的编程机制"><a href="#NO1-3-C语言的编程机制" class="headerlink" title="NO1.3 C语言的编程机制"></a>NO1.3 C语言的编程机制</h3><p>C编程的基本策略是：用程序把源代码文件转换为可执行文件(其中包含可直接运行的机器语言代码)。</p><ul><li><p>编程机制：</p><ul><li><p>用C语言编写程序时，编写的内容被储存在文本文件中，该文件被称为源代码文件；</p></li><li><p>编译器把源代码转换成中间代码，可因为中间文件有多种形式，我们在这里描述的是最普遍的一种形式，即把源代码转换为机器语言代码，虽然此时目标代码文件里包含了机器语言代码，但仍然不是一个完整的程序，所以还不能直接运行；</p></li><li><p>目标代码文件缺失启动代码，启动代码充当着程序和操作系统之间的接口，系统不一样，需要的启动代码也是不一样的；</p></li><li><p>目标代码还缺少库函数，几乎所有的C程序都要使用C标准库中的函数；</p></li><li><p>最后，链接器把你编写的目标代码、系统的标准启动代码和库代码这三部分合并成一个文件，即可执行文件。对于库代码，链接器只会把程序中要用到的库函数代码提取出来。</p><p>  <img src="./Image-c1.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-4-VS2019的安装和第一个C程序"><a href="#NO1-4-VS2019的安装和第一个C程序" class="headerlink" title="NO1.4 VS2019的安装和第一个C程序"></a>NO1.4 VS2019的安装和第一个C程序</h3><p>目前主流的C语言集成开发环境，有Visual Studio 2019等等，这里是从VS2019。</p><ul><li><p>我们到VS2019官网去下载最新版本的即可。<strong><code>注意：常用的注释快捷键为ctrl+k+c，取消注释的快捷键为ctrl+k+u。</code></strong></p><p>  <img src="./Image-c2.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：一般，Community版本就够我们个人使用了，其他两个版本需要购买并激活才能使用。</code></p><p>  <img src="./Image-c3.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：下载后，选择自己要安装的版本即可。</code></p><p>  <img src="./Image-c4.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：一般选择图中的Windows平台开发和C++的桌面开发就可以了，其他的默认即可，不需要改动什么。</code></p><p>  <img src="./Image-c5.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：中间的下载缓存里，那个“安装完成后保留下载缓存”选项一定要打勾，否则会出BUG。</code></p><p>  <img src="./Image-c6.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：下载完成后，打开VS2019，选择创建新项目。</code></p><p>  <img src="./Image-c7.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：选择Windows桌面向导。</code></p><p>  <img src="./Image-c8.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：添加项目名称，以及项目的工作空间，最后点击创建。</code></p><p>  <img src="./Image-c9.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：选择控制台应用程序，并勾选功空项目即可。</code></p><p>  <img src="./Image-c10.png" srcset="/img/loading.gif" alt="Image"></p><p>  <img src="./Image-c11.png" srcset="/img/loading.gif" alt="Image"></p><p>  <img src="./Image-c12.png" srcset="/img/loading.gif" alt="Image"></p><p>  <img src="./Image-c13.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：点击工具，选择选项，分别在文本编辑器、命令窗口、输出窗口中将字体根据自己的偏好设置一下就可以了。</code></p><p>  <img src="./Image-c14.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：在右侧窗口，找到源文件，右键添加，选择新建项。</code></p><p>  <img src="./Image-c15.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：在弹出的对话框中，选择C++文件，在起名的时候，使用.c后缀名即可，就可以成功创建C文件了。注意：使用快捷键Ctrl+s保存文件内容，使用Ctrl+F5运行文件。</code></p><p>  <img src="./Image-c16.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：如果出现错误，勾选“不再显示次对话框”，并点击否。</code></p></li></ul><p>&nbsp;</p><ul><li><p>第一个简单的C程序。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;   //#include这是预处理指令，该行告诉编译器把stdio.h中的内容都输入到该行所在的位置，相当于粘贴复制操作；所有C编译器软件都提供了stdio.h文件，该文件提供键盘输入和屏幕输出的函数(如，printf_s()函数等)，所以这个文件是标准的输入/输出头文件</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;   <span class="hljs-comment">//main函数总是第一个被调用的函数，函数是C程序的基本模块；void表示main()函数不带任何参数</span>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;   <span class="hljs-comment">//声明一个变量，但是要注意变量名称不能太长，C99的标准允许使用更长的变量名，但编译器只能识别前63个字符，超出就识别不了了；变量名不能以数字开头，但可以用小写字母、大写字母、数字和下划线来命名</span>    printf_s(<span class="hljs-string">"这是我使用VS2019创建的第一个C文件，hello world!!!!\n"</span>);   <span class="hljs-comment">//printf_s()是一个函数；“\n”表示换行的意思</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//返回值，就是将0返回给系统</span>&#125;<span class="hljs-comment">//----------------------------------</span>一个简单的C语言程序基本语法格式：<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    语句    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson2-C语言基础"><a href="#Lesson2-C语言基础" class="headerlink" title="Lesson2 C语言基础"></a>Lesson2 C语言基础</h2><h3 id="NO2-1-转义字符"><a href="#NO2-1-转义字符" class="headerlink" title="NO2.1 转义字符"></a>NO2.1 转义字符</h3><p>转义字符一般以“\”开头，目的是为了转义“\”后面跟的符号。</p><ul><li>常用转义字符：<ul><li><code>\t</code>：表示水平制表，说白了就是让输出的代码有个间隔的意思。<code>如，printf_s(&quot;你\t好\t啊&quot;)，原本输出结果：你好啊；现在输出：你    好    啊，中间多了空格</code>；</li><li><code>\n</code>：表示换行的意思。<code>如，printf_s(&quot;你好\n啊&quot;)，原本输出：你好啊；现在输出：“你好”两个字占一行，“啊”字又占了一行</code>；</li><li><code>\\</code>：表示输出一个“\”。<code>如，printf_s(&quot;你好\\\啊&quot;)，原本输出：你好啊；现在输出：你好\啊</code>；</li><li><code>\&quot;</code>：表示输出一个“””。<code>如，printf_s(&quot;你好\&quot;啊&quot;)，原本输出：你好啊；现在输出：你好&quot;啊</code>；</li><li><code>\&#39;</code>：表示输出一个“’”。<code>如，printf_s(&quot;你好\\&#39;啊&quot;)，原本输出：你好啊；现在输出：你好&#39;啊</code>；</li><li><code>\r</code>：表示将光标移动到本行的开头。<code>如，printf_s(&quot;你好\r啊&quot;)，原本输出：你好啊；现在输出：啊好，也就是原本输出到你好，然后又回到本行开头打印”啊“，所以”啊“把”你“字覆盖了</code>。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-2-注释、语句、表达式"><a href="#NO2-2-注释、语句、表达式" class="headerlink" title="NO2.2 注释、语句、表达式"></a>NO2.2 注释、语句、表达式</h3><p>用于解释说明代码的文字就叫做注释。注释也可以用于代码，但是注释的代码不会被编译器执行。</p><ul><li><p>注释分两种：</p><ul><li><p>单行注释：</p><ul><li>基本语法格式：<code>//需要注释的文字</code>。<code>如，//这是单行注释</code>；</li></ul></li><li><p>多行注释：</p><ul><li>基本语法格式：<code>/* 需要注释的文字 */</code>。<code>如，/*这里是多行注释*/</code>。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>表达式和语句：</p><ul><li><p>表达式：由运算符和运算对象组成。运算对象可以是常量、也可以是变量；每个表达式都有一个值；最简单的表达式是一个单独的运算对象。<code>如，6、-4等等</code>；</p></li><li><p>语句：是C程序的基本构建块。一条语句相当于一条完整的指令。语句一般以分号结尾。最简单的语句是空语句：<code>;</code>，也就是一个分号。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-number">8</span>;<span class="hljs-number">3</span>+<span class="hljs-number">4</span>;<span class="hljs-comment">//以上这些都是语句，但不算真正有效的语句，因为什么也没做</span></code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-3-标准库"><a href="#NO2-3-标准库" class="headerlink" title="NO2.3 标准库"></a>NO2.3 标准库</h3><p>标准库其实就是一些写好了的函数所组成的文件。</p><ul><li>C语言中常用的标准库有：<ul><li>&lt;asset.h&gt;：设定插入点；</li><li>&lt;ctype.h&gt;：字符处理；</li><li>&lt;errno.h&gt;：定义错误码；</li><li>&lt;float.h&gt;：浮点数处理；</li><li>&lt;limits.h&gt;：定义各种数据类型最值常量；</li><li>&lt;locale.h&gt;：定义本地化函数；</li><li>&lt;math.h&gt;：定义数学函数；</li><li>&lt;stdlib.h&gt;：定义杂项函数及内存分配函数；</li><li>&lt;stdio.h&gt;：定义输入／输出函数；</li><li>&lt;string.h&gt;：字符串处理；</li><li>&lt;time.h&gt;：定义关于时间的函数；</li><li>….等等。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-4-变量和常量"><a href="#NO2-4-变量和常量" class="headerlink" title="NO2.4 变量和常量"></a>NO2.4 变量和常量</h3><p>C语言中需要用东西来承载数据。</p><ul><li><p>变量和常量：</p><ul><li><p>变量(variable)：</p><ul><li><p>定义：就是在程序运行过程中，内部存储的值，随时可以被改变的一段内存地址空间；</p></li><li><p>基本语法基本语法格式：<code>数据类型 变量名 = 数据值</code>。<strong><code>注意：变量必须先声明，再使用；在同一个程序中，变量名不允许相同，不能使用C语言的的关键字；变量名只能用字母或下划线开头，其它字母可以是字母、数组和下划线(除了下划线，不允许有其他特殊字符)。</code></strong></p><p>  例如：</p>  <pre><code class="hljs c">include&lt;stdio.h&gt;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    ...    <span class="hljs-keyword">int</span> num = <span class="hljs-number">8</span>;  <span class="hljs-comment">//声明一个int类型的变量num</span>    <span class="hljs-keyword">char</span> c = <span class="hljs-string">'a'</span>;  <span class="hljs-comment">//声明一个char类型的变量c</span>    ...&#125;</code></pre></li></ul></li><li><p>常量(constant)：</p><ul><li><p>定义：就是在程序运行过程中，所表示的值，无法被改变的量；</p></li><li><p>基本语法基本语法格式，有两种：</p><ul><li><p>使用C预处理器声明常量(即程序在进行预编译处理时就生效)：只要在程序的顶部，添加代码：<code>#define 大写常量名 值</code>，推荐使用该方式声明常量；如果想要取消定义的常量，并重新定义常量，使用：<code>undef 大写的常量名</code>，就可以重新定义常量的值了；<strong><code>注意：定义字符常量用单引号，定义字符串常量用双引号；该方式定义常量只是简单的替换。</code></strong></p></li><li><p>使用const修饰变量(即在程序编译、运行时才生效)：<code>const 变量名 = 值</code>，一旦被第一次赋值之后，那么该变量就变为只读，不能再更改值，也就变成常量了。</p><p>  例如：</p>  <pre><code class="hljs c">include&lt;stdio.h&gt;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AGE 8  <span class="hljs-comment">//定义了一个常量AGE，值为8，这样程序中所用的同名常量都会被替换成指定的值</span></span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> AGE  <span class="hljs-comment">//取消定义AGE常量</span></span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AGE 10  <span class="hljs-comment">//重新定义AGE常量</span></span>#define NAME 'JOHN'   //定义了一个字符常量<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  ADDRESS <span class="hljs-meta-string">"CHINA"</span>   <span class="hljs-comment">//定义了一个字符串常量</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    ...<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;  <span class="hljs-comment">//使用关键字const声明int类型的常量</span>    ...&#125;</code></pre></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>limits.h头文件中和float.h头文件中，提供了一些整数类型和浮点数类型使用的常量；(了解即可)</p><p>  <img src="./Image-c17.png" srcset="/img/loading.gif" alt="Image"> </p><p>  <img src="./Image-c18.png" srcset="/img/loading.gif" alt="Image"> </p></li></ul><p>&nbsp;</p><ul><li>位、字节和字的关系。<ul><li>位(bit)：最小的存储单元，可以储存0或1；</li><li>字节(byte)：是常用的计算机存储单位。对于几乎所有的机器，1个字节 = 8位，即1 byte = 8 bit，这是字节的标准定义；</li><li>字(word)：是设计计算机时给定的自然存储单位。不同位系统中，字所占的位数也不同：<ul><li>在16位的系统中(比如8086微机)，1字(word) = 2字节(byte) = 16(bit)；</li><li>在32位的系统中(比如win32)，1字(word) = 4字节(byte) = 32(bit)；</li><li>在64位的系统中(比如win64)，1字(word) = 8字节(byte) = 64(bit)。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-5-数据类型"><a href="#NO2-5-数据类型" class="headerlink" title="NO2.5 数据类型"></a>NO2.5 数据类型</h3><p>C语言让程序员针对不同情况选择不同的数据类型。</p><ul><li>C语言中的数据类型主要分为以下几种：<ul><li>基本类型：它们是算数类型，包括整数类型和浮点类型；</li><li>枚举类型：它们是算数类型，被用来定义在程序中只能赋予其一定的离散整数值的变量；</li><li>void类型：void表明没有可用的值；</li><li>派生类型：包括：指针类型、数组类型、结构类型、共用体类型和函数类型。</li></ul></li></ul><p>&nbsp;</p><ul><li>整型(以32位或64位系统为标准，不含小数点和指数的数称为整数)。<strong><code>注意：signed表示有符号的类型，unsigned表示无符号类型，优先考虑使用无符号类型的数据类型；当超出了数据类型的最大值，那么重新从最小值开始计算。如，int num = 2147483647 + 1，num的结果为-2147483648，而不是2147483648，因为结果已经超出了int的最大范围，就重新回到int最小值开始算，其他数据类型也是同理。</code></strong><ul><li>char：1个字节，范围是0~255，很奇怪为什么char是整型的一种是吗？那是因为在ASCII码表中，所有的字符都可以转为整型，且char也可以是字符；ASCII表中，字符0对应的十进制为48，’A’为65，’a’为97；</li><li>unsigned char：1个字节，范围是0~255；</li><li>signed char：1个字节，范围是-128~127；</li><li>short(也叫short int、signed short、signed short int)：2个字节，范围是-32768~32767；</li><li>unsigned short(也叫unsigned short int)：2个字节，范围是0~65535；</li><li>int(也叫signed、signed int)：4个字节，范围是-2147483648~2147483647；推荐使用int；</li><li>unsigned int(也叫unsigned)：4个字节，范围是0~4294967295，只能用于非负值；</li><li>long(也叫long int、signed long、signed long int)：4个字节，范围是-2147483648~2147483647；使用后缀l或L表名是long类型，推荐使用L；</li><li>unsigned long(也叫unsigned long int)：4个字节，范围是0~4294967295；</li><li>long long(也叫long long int、signed long long、signed long long int)：8个字节，范围为-9223372036854775808~9223372036854775807；</li><li>unsigned long long：8个字节，范围是0~18446744073709551615。</li></ul></li></ul><p>&nbsp;</p><ul><li>浮点类型。<strong><code>注意：浮点型常量，可以没有小数点或指数部分，但是不能同时省略两者，如2e5、19.88等等；也可以没有小数部分或整数部分，但是不能同时省略两者，如，3.e16、.45e-16等等。</code></strong><ul><li>float：4个字节，范围是1.2E-38~3.4E+38，精度为6位小数。如，33.123456；使用f或F后缀，声明浮点型是float类型；</li><li>double：8个字节，范围是2.3E-308~1.7E+308，精度为15位小数。默认情况下，创建的浮点型都是double类型的；输出时，默认保留小数点后面6位；</li><li>long double：精度比double更高，但是C中只保证是15位小数。</li></ul></li></ul><p>&nbsp;</p><ul><li>布尔类型(<code>即C99添加的_Bool类型</code>)。<strong><code>注意：头文件&lt;stdbool.h&gt;中定义了用bool来表示C99添加的_Bool类型。</code></strong><ul><li>true：可用1表示true；</li><li>false：可用0表示false。</li></ul></li></ul><p>&nbsp;</p><ul><li>复数类型和虚数类型。<ul><li>复数类型：<ul><li>float_Complex；</li><li>double_Complex；</li><li>long double _Complex。</li></ul></li><li>虚数类型：<ul><li>float_Imaginary；</li><li>double_Imaginary；</li><li>long double _Imaginary。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-6-数据类型转换"><a href="#NO2-6-数据类型转换" class="headerlink" title="NO2.6 数据类型转换"></a>NO2.6 数据类型转换</h3><p>C语言中如果使用不同类型进行运算，会进行数据类型的转换。</p><ul><li><p>数据类型转换分为两种：</p><ul><li><p>自动类型转换：在表达式中，精度小的数据类型会被自动转为精度大的数据类型。<code>如，一般char和short都会被自动转成int</code>；</p><ul><li><p>基本语法格式：代码工具会自己识别并进行自动类转换；</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">char</span> a = <span class="hljs-string">'a'</span>;<span class="hljs-keyword">int</span> b = a;  <span class="hljs-comment">//这里自动将char转换成了int</span></code></pre></li></ul></li><li><p>强制类型转换：即表达式中，精度大的数据类型要转为精度小的数据类型，就需要使用强制数据类型转换；</p><ul><li><p>基本语法格式：<code>(数据类型) 需要强制类型转换的值</code>。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">long</span> a=<span class="hljs-number">100</span>;<span class="hljs-keyword">int</span> b = (<span class="hljs-keyword">int</span>)a;  <span class="hljs-comment">//这里将long类型的变量a强制转换成了int类型的变量</span></code></pre><p>  <img src="./Image-c19.png" srcset="/img/loading.gif" alt="Image"><br>  <strong><code>注意：当表达式中有多个不同数据类型的操作数进行运算时，会自动转为精度最大的那个数据类型，再进行运算。</code></strong></p></li></ul><p>&nbsp;</p></li></ul></li><li><p>数据类型的级别从高至低依次是：long double –&gt; double –&gt; float –&gt; unsigned long long  –&gt; long long  –&gt; unsigned long  –&gt; long  –&gt; unsigned int –&gt; int。之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int。</p></li></ul><p>&nbsp;</p><ul><li>当作为函数的参数进行传递时，char和short会被转换成int，float会被转换成double。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-7-获取地址值：-amp-运算符"><a href="#NO2-7-获取地址值：-amp-运算符" class="headerlink" title="NO2.7 获取地址值：&amp;运算符"></a>NO2.7 获取地址值：&amp;运算符</h3><p>在C语言中，&amp;运算符有多种作用。</p><ul><li>&amp;运算符的作用：<ul><li>取地址：用于变量前面；<ul><li>基本语法基本语法格式：<code>&amp;变量名</code>。<code>如，int a，&amp;a就表示变量a在内存中的地址值</code>；</li></ul></li><li>与操作符：用于二进制位的与运算，两个操作数的二进制，对位都为1，则与运算的值为1，否则为0。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-8-指针入门"><a href="#NO2-8-指针入门" class="headerlink" title="NO2.8 指针入门"></a>NO2.8 指针入门</h3><p>指针：其实就是内存地址；而指针变量，则是能够存储指针的变量，说白了指针变量存储的是地址值。</p><ul><li><p>指针变量：用来存储指针的变量。和普通变量的定义差不多，只不过要在变量名前多加一个“<code>*</code>”号即可，通常在星号和变量名之间空一格，但是星号与数据类型之间的空格可有可无。<strong><code>注意：指针变量前面的类型，跟其里面要存放的地址值所指向的数据的类型一致；如果在初始化指针变量的时候不确定值，那么可以先赋值一个NULL，赋值为NULL的指针称为空指针，NULL常量定义在&lt;stdio.h&gt;文件中：#define NULL 0。</code></strong></p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">int</span> a;<span class="hljs-comment">//int* p = &amp;a;  //*号与数据类型的之间的空格可有可无，都可以的</span><span class="hljs-keyword">int</span>* p = &amp;a;  <span class="hljs-comment">//这里定义了一个int类型的指针变量p(因为里面存放的int类型的变量a的地址值)，然后将变量a的地址值赋值给了指针变量p</span></code></pre></li></ul><p>&nbsp;</p><ul><li><p>“*”号的使用：</p><ul><li><p>放在变量前面可以声明这是一个指针变量；</p></li><li><p>“*”号还可以用在指针变量前面，将指针变量里内存地址取出来，然后将这个地址值所指向的值取出来，此时星号和指针变量之间不空格。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;    <span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>;  <span class="hljs-comment">//定义一个普通的变量1，是int类型的</span>    <span class="hljs-keyword">int</span>* bz;  <span class="hljs-comment">//定义一个指针变量bz，也是int类型的，用于存储变量b内存地址</span>    bz = &amp;b;  <span class="hljs-comment">//获取变量b的内存地址，并赋值给指针变量bz</span>    printf_s(<span class="hljs-string">"%d\n"</span>,bz);  <span class="hljs-comment">//打印指针变量，结果为变量b的内存地址</span>    printf_s(<span class="hljs-string">"%d"</span>, *bz);  <span class="hljs-comment">//打印解指针变量，也就是指针变量bz的值(也就是内存地址)所指向的值，结果为1</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-9-值传递和地址传递"><a href="#NO2-9-值传递和地址传递" class="headerlink" title="NO2.9 值传递和地址传递"></a>NO2.9 值传递和地址传递</h3><p>C语言中参数的传递，分为两种：一是值传递，也就是说传递的是值；二是地址传递，说白了传递的是一个地址值。</p><ul><li>值传递的数据类型有：<ul><li>基本数据类型：整型类型、小数类型、字符类型；</li><li>结构体类型(你可以理解为Java语言中的类)；</li><li>共用体类型。</li></ul></li></ul><p>&nbsp;</p><ul><li>地址传递的数据类型：<ul><li>指针；</li><li>数组。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-10-运算符"><a href="#NO2-10-运算符" class="headerlink" title="NO2.10 运算符"></a>NO2.10 运算符</h3><p>C的常用运算符类型包括：算术运算符、赋值运算符、关系运算符、逻辑运算符、位运算符、三元运算符以及其他运算符等等。<strong><code>注意：运算符优先级：有括号先括号，然后正负号，之后先乘除、后加减，最后赋值；即括号&gt;正负号&gt;乘除&gt;加减&gt;赋值。</code></strong></p><ul><li>算数运算符：<ul><li>加法运算符：<code>+</code>；<ul><li>基本语法格式：<code>值 + 值</code>，这里的值可以是常量，也可以是变量。<code>如，1+1、a+1(前提这里a要记得先赋值再使用，且是数值类型)</code>；</li></ul></li><li>减法运算符：-；<ul><li>基本语法格式：<code>值 - 值</code>，这里的值可以是常量，也可以是变量。<code>如，5-3、a-1(前提这里a要记得先赋值再使用，且是数值类型)</code>；<strong><code>注意：“-”除了当作减号之外，还可以当作负号使用，如，-12、-a等等。</code></strong></li></ul></li><li>乘法运算符：<code>*</code>；<ul><li>基本语法格式：<code>值 * 值</code>，这里的值可以是常量，也可以是变量。<code>如，52、a3(前提这里a要记得先赋值再使用，且是数值类型)</code>；</li></ul></li><li>除法运算符：<code>/</code>；<ul><li>基本语法格式：<code>值 / 值</code>，这里的值可以是常量，也可以是变量。<code>如，5/2、a/3(前提这里a要记得先赋值再使用，且是数值类型)</code>；<strong><code>注意：两个操作数都是整数，则结果为整数；若有一个操作数为浮点数，则结果为浮点数。如，5/2 = 2、5.0/2 = 2.5等等。</code></strong></li></ul></li><li>求模运算符(也叫取余运算符)：<code>%</code>；<ul><li>基本语法格式：<code>值 % 值</code>，这里的值可以是常量，也可以是变量。<code>如，5%2、a%2(前提这里a要记得先赋值再使用，且是数值类型)</code>。<strong><code>注意：其实取模运算可以看做是：a % b = a - a / b  b。</code></strong></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>赋值运算符：</p><ul><li><p>赋值运算符：=；这是赋值运算符，而不是等于号；</p><ul><li>基本语法格式：<code>变量名 = 值</code>。<code>如，int num = 1，表示把1赋值给num</code>；</li></ul></li><li><p>其他赋值运算符：<code>+=、-=、*=、/=、%=</code>。+=运算符就是将值相加后又赋值，其他运算符同理。</p><ul><li><p>基本语法格式：<code>值 +=或-=或*=或/= 值</code>。</p><p>  例如：</p>  <pre><code class="hljs c">num += <span class="hljs-number">20</span> 与 num = num + <span class="hljs-number">20</span> 相同num -= <span class="hljs-number">2</span> 与  num =  num - <span class="hljs-number">2</span> 相同num = <span class="hljs-number">2</span> 与  num =  num  <span class="hljs-number">2</span> 相同num /= <span class="hljs-number">2.5</span> 与  num =  num / <span class="hljs-number">2.5</span> 相同num %= <span class="hljs-number">3</span> 与  num =  num % <span class="hljs-number">3</span> 相同</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>关系运算符(也称为比较运算符)；<strong><code>注意：C99提供了stdbool.h头文件，该头文件规定bool成为_Bool的别名，且把true和false分别定义为1和0；关系运算符常常和关系表达式一起使用，而关系表达式的值，要么为true，要么为false(即0或1，所以就有了0是false，1是true转换)。</code></strong></p><p>  <img src="./Image-c20.png" srcset="/img/loading.gif" alt="Image"></p><p>  <img src="./Image-c21.png" srcset="/img/loading.gif" alt="Image"></p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> num = <span class="hljs-number">3</span>;    <span class="hljs-keyword">while</span> (num) &#123;        printf_s(<span class="hljs-string">"%d\n"</span>, num);        num--;    &#125;&#125;说明：只要num的值不为<span class="hljs-number">0</span>，即不为<span class="hljs-literal">false</span>，那么<span class="hljs-keyword">while</span>会一直循环，直到num的值为<span class="hljs-number">0</span>，也就是<span class="hljs-literal">false</span>。</code></pre></li></ul><p>&nbsp;</p><ul><li><p>逻辑运算符：</p><ul><li><p>如下图所示；<strong><code>注意：!运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相同，只比圆括号的优先级低。另外iso646.h头文件中，可用英文单词代替逻辑运算符，分别是and、or、not。</code></strong></p><p>  <img src="./Image-c22.png" srcset="/img/loading.gif" alt="Image"></p><p>  <img src="./Image-c23.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：当且仅当exp1和exp2都为真时，exp1 &amp;&amp; exp2才为真； 如果exp1或exp2为真，则exp1 || exp2为真； 如果exp1为假，则!exp1为真；如果exp1为真，则!exp1为假。</code></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>位运算符：</p><ul><li><p>&amp;(位与运算)、|(位或运算)、^(位异或运算)、~(按位取反运算)、&lt;&lt;(左移运算)、&gt;&gt;(右移运算)这些运算都是使用操作数的二进制补码进行运算的。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-number">3</span>的二进制：<span class="hljs-number">0x11</span><span class="hljs-number">4</span>的二进制：<span class="hljs-number">0x100</span>    <span class="hljs-number">3</span> &amp; <span class="hljs-number">4</span> (&amp;位与运算：有<span class="hljs-number">0</span>则<span class="hljs-number">0</span>，两<span class="hljs-number">1</span>为<span class="hljs-number">1</span>)：   <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000011</span> --<span class="hljs-number">-3</span>的二进制补码&amp;  <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000100</span> --<span class="hljs-number">-4</span>的二进制补码-----------------------------------------   <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> 结果为<span class="hljs-number">0</span>    <span class="hljs-number">3</span> | <span class="hljs-number">4</span> (|位或运算：有<span class="hljs-number">1</span>则<span class="hljs-number">1</span>，两<span class="hljs-number">0</span>为<span class="hljs-number">0</span>)：   <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000011</span> --<span class="hljs-number">-3</span>的二进制补码|  <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000100</span> --<span class="hljs-number">-4</span>的二进制补码-----------------------------------------   <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000111</span> 结果为<span class="hljs-number">7</span>    <span class="hljs-number">3</span> ^ <span class="hljs-number">4</span> (^位异或运算：相同则<span class="hljs-number">0</span>，不同则<span class="hljs-number">1</span>)：   <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000011</span> --<span class="hljs-number">-3</span>的二进制补码^  <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000100</span> --<span class="hljs-number">-4</span>的二进制补码-----------------------------------------   <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000111</span> 结果为<span class="hljs-number">7</span>    ~ <span class="hljs-number">3</span> (~按位取反运算：<span class="hljs-number">0</span>变<span class="hljs-number">1</span>，<span class="hljs-number">1</span>变<span class="hljs-number">0</span>)：~  <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000011</span> --<span class="hljs-number">-3</span>的二进制补码-----------------------------------------   <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111100</span>补码：<span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111100</span>反码：<span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111011</span>原码：<span class="hljs-number">10000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000100</span> ---结果为<span class="hljs-number">-4</span><span class="hljs-comment">//-----------------------------------------------------------</span><span class="hljs-number">10</span> &lt;&lt; <span class="hljs-number">2</span> = <span class="hljs-number">40</span><span class="hljs-number">10</span> &gt;&gt; <span class="hljs-number">2</span> = <span class="hljs-number">2</span><span class="hljs-number">-1</span> &gt;&gt; <span class="hljs-number">2</span> = <span class="hljs-number">-1</span>说明：正数的原反补都是一样的，所以可以直接乘以或除以n个<span class="hljs-number">2</span>，即&lt;&lt;<span class="hljs-number">2</span>表示乘以两个<span class="hljs-number">2</span>，&gt;&gt;<span class="hljs-number">2</span>表示除以两个<span class="hljs-number">2</span>；也可以转成原码后进行左移或右移位数操作；负数则需要转换成补码后再进行运行，&lt;&lt;n表示二进制补码向左移动n位，位数不够的地方补<span class="hljs-number">0</span>；&gt;&gt;n则是向右移动n位，符号位补<span class="hljs-number">1</span>，其他补<span class="hljs-number">0</span>。</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>三元运算符：</p><ul><li><p>基本语法格式：<code>判断表达式?表达式1:表达式2</code>，判断表达式如果符合条件就取表达式1，否则就取表达式2。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-number">1</span>+<span class="hljs-number">1</span>&gt;<span class="hljs-number">3</span> ? <span class="hljs-number">1</span>:<span class="hljs-number">2</span>  <span class="hljs-comment">//结果为2</span></code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>其他运算符：</p><ul><li><p>sizeof运算符：返回一个对象或类型所占内存字节数，返回的是size_t类型(其实就是unsigned int)，即无符号整数。</p><ul><li>基本语法格式：<code>sizeof(数据类型或对象)</code>。<code>如：char ch[10]，sizeof(ch) = 10，返回的是size_t类型的值，也就是字符数组ch所占内存的字节数</code>。</li></ul></li><li><p>自增和自减运算符：<code>++和--</code>，作用是对自身的值进行加1或减1，分两种使用情况：</p><ul><li><p>单独使用情况下，自增或自减运算符放在值的前面或后面都一样；</p></li><li><p>与其他运算符一起使用，++a(出现在值前面)和a++(出现在值后面)，前者先自增再作运算，后者是先运算后赋值；自减和自增一样，只是不是增加而是减少。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;printf_s(<span class="hljs-string">"%d"</span>,a++);printf_s(<span class="hljs-string">"%d"</span>,++a);<span class="hljs-comment">//上面两者的效果都是一样的</span><span class="hljs-comment">//--------------------------------------</span><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (++a &lt; <span class="hljs-number">3</span>)&#123;  <span class="hljs-comment">//先自增，后与3进行比较</span>...&#125;<span class="hljs-keyword">while</span> (a++ &lt; <span class="hljs-number">3</span>)&#123;  <span class="hljs-comment">//先与3进行比较，后自增</span>...&#125;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-11-标识符"><a href="#NO2-11-标识符" class="headerlink" title="NO2.11 标识符"></a>NO2.11 标识符</h3><p>所谓标识符，可以简单理解为取名字，即给变量、函数、常量等等取的名字都成为标识符。</p><ul><li>标识符命名规则：<ul><li>由26个英文字母的大小写、0~9、_或$组成；</li><li>不可以以数字开头；</li><li>不可以是C语言中的关键字(即在C中有特殊含义的名称)和保留字，但能包含关键字于其中；</li><li>不允许包含空格；</li><li>区分大小写，长度无限制；</li><li>尽量遵循驼峰命名法。<code>如，myName、getNumOfNumber等等</code>。</li></ul></li></ul><p>&nbsp;</p><ul><li>所有宏定义(即define)、枚举常数、常量全用大写字母命名，用下划线_分割单词，且记得初始化变量后再使用。<code>如，#define AGE 8、const double FREE_MONEY = 100.1等等</code>。</li></ul><p>&nbsp;</p><ul><li><p>C语言的关键字和保留字，如下图所示：</p><p>  <img src="./Image-c24.png" srcset="/img/loading.gif" alt="Image"><br>  <code>说明：粗斜体是C11新增的关键字。</code></p></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-12-printf-和scanf-，以及C语言的转换说明"><a href="#NO2-12-printf-和scanf-，以及C语言的转换说明" class="headerlink" title="NO2.12 printf()和scanf()，以及C语言的转换说明"></a>NO2.12 printf()和scanf()，以及C语言的转换说明</h3><p>printf()函数和scanf()函数能让用户可以与程序交流。<strong><code>注意：printf_s()和scanf_s()是printf()和scanf()的更安全的写法....微软公司整的。</code></strong></p><ul><li><p>printf_s()和scanf_s()函数，称为输入/输出函数，简称I/O函数。</p><ul><li><p>printf_s()：</p><ul><li><p>定义：该函数用于向用户输出信息；</p></li><li><p>函数的调用方式：<code>printf_s(转换说明字符串,待打印项1,待打印项2,...)</code>。<strong><code>注意：转换说明字符串中的转换说明一定要与后面的每个待打印项相匹配，否则会报错；另外printf_s()函数是有返回值的，返回值为打印的字符的个数，一般不常使用。</code></strong></p><p>  例如：</p>  <pre><code class="hljs c">printf_s(<span class="hljs-string">"i am %s"</span>,<span class="hljs-string">"john"</span>)printf_s(<span class="hljs-string">"it is %d%%"</span>,<span class="hljs-number">12</span>)  <span class="hljs-comment">//这里%d后面使用了两个%%，是因为我想输出12%，所以要使用另一个%来转义前一个%，就成了%%</span></code></pre></li></ul></li><li><p>scanf_s()：</p><ul><li><p>定义：该函数用于获取用户的输入；</p></li><li><p>函数的调用方式：<code>scanf_s(&quot;%用户的输入所属的数据类型&quot;,用于接收用户输入的变量名)</code>。<strong><code>注意：如果用scanf_s()读取基本变量类型的值，在变量名前要加上一个“&amp;”；如果把字符串读入到字符数组，则变量名前面不需要加“&amp;”。</code></strong></p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">char</span> arr[<span class="hljs-number">10</span>];  <span class="hljs-comment">//声明一个字符数组</span>scanf_s(<span class="hljs-string">"%s"</span>,arr);  <span class="hljs-comment">//接收用户输入的字符串，并将该字符串放入字符数组中，C中没有用于专门接收字符串的数据类型，只能用字符数组接收</span></code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>转换说明：</p><ul><li><p>定义：用来说明输入输出时的基本语法格式。</p></li><li><p>转换说明的意义：把给定的值转换成某种我们要求的形式并打印出来。常用的C语言中转换说明，如下图所示；另外还可以打印八进制、十进制等等。</p><ul><li><p>变量或常量的八进制、十进制、十六进制的显示。</p><ul><li><p>以八进制显示数值：使用“%o”，如果要显示进制的标识符号的话要使用“%#o”，其实就是八进制数值前面加个标识符号0。如，0123、046等等，都是八进制数；</p></li><li><p>以十进制显示数值：使用“%d”。如，15、20等等都是十进制数，我们常用的数字就是十进制数；</p></li><li><p>以十六进制显示数值：使用“%x”，如果要显示进制的标识符号的话使用“%#x”或“%#X”，这两个前缀的区别是“0x”和“0X”，都表示十六进制。</p><p>  <img src="./Image-c25.png" srcset="/img/loading.gif" alt="Image"></p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#includ <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> x = <span class="hljs-number">100</span>;    printf_s(<span class="hljs-string">"dec = %d; octal = %o; hex = %x\n"</span>, x, x, x);    printf_s(<span class="hljs-string">"dec = %d; octal = %#o; hex = %#x\n"</span>, x, x, x);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;以上输出结果为：dec = <span class="hljs-number">100</span>; octal = <span class="hljs-number">144</span>; hex = <span class="hljs-number">64</span>dec = <span class="hljs-number">100</span>; octal = <span class="hljs-number">0144</span>; hex = <span class="hljs-number">0x64</span></code></pre></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>使用字段宽度“*”，这个符号表示，让上下文来指定字符宽度，什么意思呢，就是让程序里的某个变量来指定字符宽度，那么啥又是字符宽度呢，说白了就是要展示给你看的字符的间隔而已。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> <span class="hljs-built_in">width</span> = <span class="hljs-number">9</span>;  <span class="hljs-comment">//字段宽度我们用width来表示</span>    <span class="hljs-keyword">int</span> res;    scanf_s(<span class="hljs-string">"%d"</span>,&amp;res);  <span class="hljs-comment">//获取用户输入</span>    printf_s(<span class="hljs-string">"%*d%*d"</span>,<span class="hljs-built_in">width</span>,res,<span class="hljs-built_in">width</span>,res);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;说明：%*d中，%d表示转换说明，*表示字符宽度；如果转换说明是%*d,那么参数列表中应包含*和d对应的值，而d从用户输入中获取，并赋值给了res；字段宽度，我们使用了<span class="hljs-built_in">width</span>变量的值(也就是<span class="hljs-number">9</span>)，所以输出结果：<span class="hljs-number">1</span><span class="hljs-number">1</span>。</code></pre></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-13-C语言中的进制"><a href="#NO2-13-C语言中的进制" class="headerlink" title="NO2.13 C语言中的进制"></a>NO2.13 C语言中的进制</h3><p>C语言中常用的进制有：二进制、八进制、十进制、十六进制。</p><ul><li>进制：<ul><li>定义：即一个数的表示。可以有二进制、八进制、十进制、十六进制等等；</li><li>常用进制：<ul><li>二进制：由0和1组成，满2进1，C中没有能标识二进制的方法；</li><li>八进制：由0-7组成，满8进1，C中以数字0开头表示八进制；</li><li>十进制：由0-9组成，满10进；</li><li>十六进制：由0-7、a-f(或A-F，表示10-15)组成。C中以0x或0X开头表示十六进制。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>进制转换：</p><ul><li><p>在学习常用进制转换之前，我们先来学习一些传说中的8421码：</p><ul><li><p>8421码：表示每个二进制位上的值对应十进制中的值。其实用于二进制和十进制的快速转换。如下所示：</p>  <pre><code class="hljs c">二进制<span class="hljs-number">1</span><span class="hljs-number">1</span><span class="hljs-number">1</span><span class="hljs-number">1</span><span class="hljs-number">1</span><span class="hljs-number">1</span><span class="hljs-number">1</span><span class="hljs-number">1</span>十进制<span class="hljs-number">128</span>  <span class="hljs-number">64</span>  <span class="hljs-number">32</span>  <span class="hljs-number">16</span><span class="hljs-number">8</span><span class="hljs-number">4</span><span class="hljs-number">2</span><span class="hljs-number">1</span>`</code></pre></li></ul></li><li><p>二进制转八进制、十进制、十六进制：aaa</p><ul><li><p>二进制转八进制：三位归并法：每三位一组，不够位数的左边添0，求出每个三位的二进制值，最后结果拼接即可；注意：该方法同样适用于八进制转二进制，只需逆向将一个八进制拆成三位的二进制即可，前提是需要明白8421码的转换；</p></li><li><p>其他进制转十进制(包括二进制转十进制)：每一位上的数据值进制(二进制乘以二，八进制乘以八，十六进制乘以十六)^从右往左且幂从0开始；</p></li><li><p>二进制转十六进制：四位归并法：每四位一组，不够位数的左边添0，求出每个四位的二进制值，最后结果拼接即可。注意：该方法同样适用于十六进制转二进制，只需逆向将一个十六进制拆成四位的二进制即可，前提是需要明白8421码的转换。</p><p> 例如：</p> <pre><code class="hljs c">二进制转换成十进制：二进制数<span class="hljs-number">01110101</span><span class="hljs-number">0</span>        <span class="hljs-number">1</span>        <span class="hljs-number">1</span>        <span class="hljs-number">1</span>        <span class="hljs-number">0</span>        <span class="hljs-number">1</span>        <span class="hljs-number">0</span>        <span class="hljs-number">1</span><span class="hljs-number">02</span>^<span class="hljs-number">7</span>   <span class="hljs-number">12</span>^<span class="hljs-number">6</span>     <span class="hljs-number">12</span>^<span class="hljs-number">5</span>      <span class="hljs-number">12</span>^<span class="hljs-number">4</span>    <span class="hljs-number">02</span>^<span class="hljs-number">3</span>     <span class="hljs-number">12</span>^<span class="hljs-number">2</span>     <span class="hljs-number">02</span>^<span class="hljs-number">1</span>      <span class="hljs-number">2</span>^<span class="hljs-number">0</span>=<span class="hljs-number">1</span><span class="hljs-number">0</span>       <span class="hljs-number">64</span>       <span class="hljs-number">32</span>        <span class="hljs-number">16</span>       <span class="hljs-number">0</span>       <span class="hljs-number">4</span>         <span class="hljs-number">0</span>        <span class="hljs-number">1</span>把所有的结果相加，得到最后的结果<span class="hljs-number">117</span>。其他进制转十进制只需要将<span class="hljs-number">2</span>换成<span class="hljs-number">8</span>、<span class="hljs-number">16</span>即可    <span class="hljs-comment">//------------------------------------------------------------------</span>    二进制<span class="hljs-number">0b1100110</span>转八进制：<span class="hljs-number">001</span> <span class="hljs-number">100</span> <span class="hljs-number">110</span><span class="hljs-number">1</span>   <span class="hljs-number">4</span>   <span class="hljs-number">6</span>   = <span class="hljs-number">0146</span><span class="hljs-comment">//------------------------------------------------------------------    </span>    二进制<span class="hljs-number">0b1100110</span>转十六进制：<span class="hljs-number">0110</span> <span class="hljs-number">0110</span><span class="hljs-number">6</span>    <span class="hljs-number">6</span>    = <span class="hljs-number">0x66</span></code></pre></li></ul></li><li><p>八进制转二进制、十进制、十六进制：</p><ul><li>八进制转二进制：采用8421码，即一个八进制位转换为3个二进制位；<strong><code>注意：这里不懂8421码的话，可以找一些视频来看，比较简单。</code></strong></li><li>其他进制转十进制(包括八进制转十进制)：每一位上的数据值进制(二进制乘以二，八进制乘以八，十六进制乘以十六)^从右往左且幂从0开始；</li><li>八进制转十六进制：先转成二进制或十进制，再转成十六进制即可。</li></ul></li><li><p>十进制转其他进制：直接用这个数除以进制数(二进制除以二，八进制除以八，十六进制除以十六)，直到商为0，取余数反转即可；</p></li><li><p>十六进制转二进制、八进制、十进制：</p><ul><li>十六进制转二进制：采用8421码，即一个十六进制位转换为4个二进制位；</li><li>十六进制转八进制：先转成二进制或十进制，再转成八进制即可；</li><li>十六进制转十进制：其他进制转十进制(包括十六进制转十进制)：每一位上的数据值进制(二进制乘以二，八进制乘以八，十六进制乘以十六)^从右往左且幂从0开始。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-14-原码、反码、补码"><a href="#NO2-14-原码、反码、补码" class="headerlink" title="NO2.14 原码、反码、补码"></a>NO2.14 原码、反码、补码</h3><p>计算机中所有的数据运算都采用补码进行的。对于有符号的数(即负数)而言，二进制的的最高位为符号位：0表示正数、1表示负数。</p><ul><li>正数的原、反、补码都是一样的，即正数的二进制既是原码，又是反码和补码。</li></ul><p>&nbsp;</p><ul><li><p>负数：</p><ul><li><p>原码：就是二进制本身，但符号位用0或1分别表示正数或负数；</p></li><li><p>反码：符号位不变，其他位取反(0变1,1变0)；</p></li><li><p>补码：在反码的基础上末位加1。</p><p>  例如：</p>  <pre><code class="hljs c">+<span class="hljs-number">7</span> 和 <span class="hljs-number">-7</span>二进制为：<span class="hljs-number">00000111</span>+<span class="hljs-number">7</span> 的原码为<span class="hljs-number">00000111</span><span class="hljs-number">-7</span> 的原码则为<span class="hljs-number">10000111</span><span class="hljs-comment">//------------------------------------------------------------------</span>+<span class="hljs-number">7</span> 的原码为<span class="hljs-number">00000111</span>，反码也是<span class="hljs-number">00000111</span><span class="hljs-number">-7</span> 的原码为<span class="hljs-number">10000111</span>，反码则是<span class="hljs-number">11111000</span><span class="hljs-comment">//------------------------------------------------------------------</span>+<span class="hljs-number">7</span> 的原码为<span class="hljs-number">00000111</span>，反码也是<span class="hljs-number">00000111</span>，补码仍然为<span class="hljs-number">00000111</span><span class="hljs-number">-7</span> 的原码为<span class="hljs-number">10000111</span>，反码则是<span class="hljs-number">11111000</span>，补码变成<span class="hljs-number">11111001</span></code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-15-程序流程控制"><a href="#NO2-15-程序流程控制" class="headerlink" title="NO2.15 程序流程控制"></a>NO2.15 程序流程控制</h3><p>C语言中的程序流程控制：即用来控制程序的流程走向。包括三大流程控制：顺序控制、分支控制、循环控制。</p><ul><li><p>顺序控制：即程序代码从上到下，逐行顺序执行，中间没有任何判断和跳转。</p><ul><li><p>基本语法格式：</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;  <span class="hljs-comment">//先执行这个</span>    <span class="hljs-keyword">int</span> age = <span class="hljs-number">2</span>;  <span class="hljs-comment">//再执行这个</span>&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>分支控制：即让程序代码有选择的执行，但只会执行其中的一种分支。<strong><code>注意：分支可以相互嵌套，但最多不要嵌套超过3层，否则代码可读性会大大降低。</code></strong>分支控制主要分为：</p><ul><li><p>单分支：即if语句，只有一个选择分支，符合条件则执行分支里的语句体，否则就跳过不执行，继续往下执行；</p><ul><li><p>基本语法格式：</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">if</span>(条件表达式)&#123;  <span class="hljs-comment">//条件表达式中只返回true或false，前者进入分支并执行语句体，后者不进入分支执行语句体，即跳过不执行</span>    需要执行的语句体&#125;如：<span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span><span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">0</span>)&#123;    printf_s(<span class="hljs-string">"a大于0哦"</span>);&#125;输出结果为：a大于<span class="hljs-number">0</span>哦</code></pre></li></ul></li><li><p>双分支：即if-else语句，用于两种情况的选择，即符合与不符合条件的情况，将执行不同的语句体；</p><ul><li><p>基本语法格式：</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">if</span>(条件表达式)&#123;  <span class="hljs-comment">//为true走这里</span>    需要执行的语句体<span class="hljs-number">1</span>&#125; <span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">//为false时走这里</span>    需要执行的语句体<span class="hljs-number">2</span>&#125;如：<span class="hljs-keyword">int</span> a = <span class="hljs-number">-2</span>;<span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">0</span>)&#123;    printf_s(<span class="hljs-string">"a大于0哦"</span>);&#125;<span class="hljs-keyword">else</span> &#123;    printf_s(<span class="hljs-string">"a小于0哦"</span>);&#125;输出结果为：a小于<span class="hljs-number">0</span>哦</code></pre></li></ul></li><li><p>多分支：即if-else if-else语句，用于多种情况的的选择；</p><ul><li><p>基本语法格式：</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">if</span>(条件表达式<span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">//符合条件1就进入这里</span>    需要执行的语句体<span class="hljs-number">1</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件表达式<span class="hljs-number">2</span>)&#123;  <span class="hljs-comment">//符合条件2就进入这里</span>    需要执行的语句体<span class="hljs-number">2</span>&#125; ....&#123;    ....&#125;<span class="hljs-keyword">else</span>&#123;    上面两种都不符合，就会执行这里&#125;如：<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">0</span>)&#123;    printf_s(<span class="hljs-string">"a大于0哦"</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a = <span class="hljs-number">0</span>)&#123;    printf_s(<span class="hljs-string">"a等于0哦"</span>);&#125; <span class="hljs-keyword">else</span> &#123;    printf_s(<span class="hljs-string">"a小于0哦"</span>);&#125;输出结果为：a等于<span class="hljs-number">0</span>哦</code></pre></li></ul></li><li><p>其他分支：即switch语句，用于匹配多重选择的情况。</p><ul><li><p>基本语法格式：</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">switch</span>(整数值)&#123;  <span class="hljs-comment">//这里的整数值也可以由一个表达式产生，也可以是枚举类型。如1+1，'a'等等</span>    <span class="hljs-keyword">case</span> 常量值<span class="hljs-number">1</span>:  <span class="hljs-comment">//switch中的表达式产生的值，如果与这里的值1匹配成功的话，那么就会执行限免的语句体1</span>        需要执行的语句体<span class="hljs-number">1</span>        <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//表示中断，意思就是分支程序执行到这里，那么分支就执行完毕了，可以跳出分支，进行分支外的代码执行</span>    <span class="hljs-keyword">case</span> 常量值<span class="hljs-number">2</span>:        需要执行的语句体<span class="hljs-number">2</span>        <span class="hljs-keyword">break</span>;    ....    <span class="hljs-keyword">default</span>:        都不符合时，才执行的语句体&#125;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>循环控制：即让程序的代码能够实现循环的执行。<strong><code>注意：循环也可以嵌套使用，但是只建议嵌套循环不超过3层，否则代码的可读性就会变差。</code></strong>可以分为：</p><ul><li><p>for循环：一般用于有次数限制的条件循环；</p><ul><li><p>基本语法格式：</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">for</span>(初始化语句;循环条件表达式;控制条件语句)&#123;    循环体&#125;如：<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>; i++)&#123;    printf_s(<span class="hljs-string">"i的值为：%d\n"</span>,i);&#125;<span class="hljs-comment">//还可以有逗哥初始化语句和控制条件语句，有多个时，用,隔开即可，但是要注意无论是初始化语句只能定义同一种数据类型</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>，j=<span class="hljs-number">1</span>;i &lt; <span class="hljs-number">5</span>; i++，j++)&#123;    printf_s(<span class="hljs-string">"i的值为：%d\n"</span>,i);    printf_s(<span class="hljs-string">"j的值为：%d\n"</span>,j);&#125;</code></pre></li></ul></li><li><p>while循环：一般用于不清楚循环次数时而使用的；</p><ul><li><p>基本语法格式：</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">while</span>(条件表达式)&#123;  <span class="hljs-comment">//表达式用来判断是否能够进入循环；当表达式不成立时，则不再进入循环</span>    循环体&#125;如：<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(num &lt; <span class="hljs-number">5</span>)&#123;  <span class="hljs-comment">//循环的入口，当表达式num&lt;5成立时，进入循环</span>        printf_s(<span class="hljs-string">"num的值为：%d\n"</span>,num);        num++;    &#125;&#125;</code></pre></li></ul></li><li><p>do-while循环：该循环和while循环差不多，不同的地方总是会先执行一次；</p><ul><li><p>基本语法格式：</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">do</span>&#123;    循环体&#125; <span class="hljs-keyword">while</span> (判断表达式)注意：该循环与<span class="hljs-keyword">while</span>表示的意义差不多，但是这种循环，是先执行一次，后判断。如：<span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span><span class="hljs-keyword">do</span>&#123;    num++;&#125;<span class="hljs-keyword">while</span>(num &lt; <span class="hljs-number">3</span>)</code></pre></li></ul></li><li><p>goto语句：作用是跳转到某一行代码去执行。嗯….这个不建议使用，其实continue和break就是goto的特殊形式，使用这两个就够用了。</p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-16-循环辅助：continue和break"><a href="#NO2-16-循环辅助：continue和break" class="headerlink" title="NO2.16 循环辅助：continue和break"></a>NO2.16 循环辅助：continue和break</h3><p>continue和break使用频率很高，各种循环语句里面都有它们的身影。</p><ul><li><p>continue：一般用于循环体内；执行到continue时，作用是跳过本次循环，continue后面的代码就不会再执行；如果有嵌套循环，则跳过有continue的那一层循环，并进行下一次循环。<strong><code>注意：continue不能单独跟switch和if，但是如果if外层有循环，则可以正常使用。</code></strong></p><ul><li><p>基本语法格式</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;num &lt; <span class="hljs-number">10</span>;num++)&#123;    <span class="hljs-keyword">if</span>( num == <span class="hljs-number">3</span>)&#123;        <span class="hljs-keyword">continue</span>;    &#125;    printf_s(<span class="hljs-string">"%d"</span>,num);&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>break：一般用于循环体内；执行到break时，直接结束循环；如果有嵌套循环，则结束有break的那一层循环。</p><ul><li><p>基本语法格式</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++)&#123;    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">3</span>)&#123;        <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//当执行到i等于3时，那么就会跳出当前的for循环，也就是停止for循环</span>    &#125;    printf_s(<span class="hljs-string">"%d',i);</span><span class="hljs-string">&#125;</span><span class="hljs-string">             </span><span class="hljs-string">拓展：return的使用</span><span class="hljs-string">一、return关键字的使用和break差不多，都有终止程序循环的作用，但不同的是，return不仅仅用于循环中，更常用于有返回值的函数中。</span><span class="hljs-string"></span><span class="hljs-string">如：</span><span class="hljs-string">int main()&#123;</span><span class="hljs-string"></span><span class="hljs-string">    ....省略了其他代码</span><span class="hljs-string">    return 0;  //这里的return就是运用在函数中，即main函数</span><span class="hljs-string">&#125;</span></code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-17-枚举类型"><a href="#NO2-17-枚举类型" class="headerlink" title="NO2.17 枚举类型"></a>NO2.17 枚举类型</h3><p>在实际编程中，有些数据的取值往往是有限的，只能是非常少量的整数，并且最好为每个值都取一个名字，以方便在后续代码中使用。如，一个星期只有七天，一年只有十二个月，一个班每周有六门课程等。</p><ul><li><p>枚举：</p><ul><li><p>定义：枚举是一组常量的集合；<strong><code>注意：C语言中枚举类型是被当作int或unsigned int类型来处理的。</code></strong></p></li><li><p>创建方式：enum 枚举名{枚举元素1、枚举元素2、枚举元素3….}。<strong><code>注意：如果枚举中的第一个元素没有赋值的话，默认值为0，后面的值按顺序在前一个值的基础上加1；如果中途某个元素又给了值，那么从这个值开始后面元素的值会依次加1。如，enum WEEK={MON、TUE=5、WED}，那么MON的值为0，而WED的值在TUE的基础上加1，即WED=6。</code></strong></p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-comment">//enum XINGQI &#123;MON=1,TUE=2,WED=3&#125; day2;  //还可以使用这种方式定义枚举和枚举变量</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;       <span class="hljs-keyword">enum</span> XINGQI &#123;MON=<span class="hljs-number">1</span>,TUE=<span class="hljs-number">2</span>,WED=<span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">//定义了一个枚举类型</span>       <span class="hljs-keyword">enum</span> XINGQI day = MON;  <span class="hljs-comment">//定义了一个枚举变量，用于接收枚举中的值</span>       printf_s(<span class="hljs-string">"%d"</span>,day);       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//-------------------------------</span><span class="hljs-comment">//枚举遍历</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-keyword">enum</span> XINGQI &#123;MON=<span class="hljs-number">1</span>,TUE,WED&#125; day2;  <span class="hljs-comment">//如果TUE、WED不赋值的话，会自动按照顺序赋值，即TUE=2、WED=3</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;    <span class="hljs-keyword">for</span>(day2 = MON;day &lt;= WED;day2++)&#123;  <span class="hljs-comment">//这里day++会给予警告，但是能够运行</span>        printf_s(<span class="hljs-string">"%d"</span>,day2);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-18-函数"><a href="#NO2-18-函数" class="headerlink" title="NO2.18 函数"></a>NO2.18 函数</h3><p>函数是能够完成特定任务的一个独立程序代码单元。</p><ul><li>函数类型主要分为两种：<ul><li>void函数：即没有返回值的函数，就称为void函数；</li><li>E 函数：指的是，如果返回值是E类型，那么该函数就称为E类型函数。<code>如，int count(int a,int b)，该函数返回int类型的值，那么该函数是int类型函数</code>。</li></ul></li></ul><p>&nbsp;</p><ul><li><p>函数原型：</p><ul><li><p>定义：就是对函数的定义；</p></li><li><p>基本语法格式：</p><p>  例如：</p>  <pre><code class="hljs c">返回值类型 函数名(参数类型 变量名,....);  <span class="hljs-comment">//后面的“....”表示，可以有多个参数，也可以没有一个参数</span>如：<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;  <span class="hljs-comment">//先声明一个新的函数，告诉系统，等会我们要使用这个函数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    printf_s(<span class="hljs-string">"hello,baby!"</span>);    test();  <span class="hljs-comment">//然后，使用该函数</span>    printf_s(<span class="hljs-string">"hi,darling!"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;  <span class="hljs-comment">//通过函数原型来定义要使用的test函数，其实就是和Java中的函数定义一样的</span>    printf_s(<span class="hljs-string">"double!"</span>);&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li>形参和实参：<ul><li>形参：即形式参数，用于定义函数时而使用的参数，告诉C，函数值要传入一个什么类型的参数；</li><li>实参：即实际参数，实际调用该函数时，传入函数的参数，那么这个值就称为实参。<code>如，定义一个函数：void count(int number)，number就是形参，调用函数：count(5)，那么这个5就是实参</code>。</li></ul></li></ul><p>&nbsp;</p><ul><li><p>头文件：</p><ul><li><p>定义：简单讲就是包含了一些功能性函数的声明、数据接口声明的一个文件，即将变量、处理函数抽取放到一个专门的文件中而已。在程序中，头文件的后缀主要是“.h”，也就是说函数声明写在了以“.h”结尾的头文件中。<strong><code>注意：一般自定义的头文件和源文件名称都是相同的。</code></strong></p></li><li><p>作用：头文件对程序编译执行而言，它仅仅在预编译时将其内容在#include的地方展开一下，说白了就是将头文件中的内容复制粘贴到你写的程序中，但是复制粘贴不方便，也不安全，所以采用了头文件；</p></li><li><p>自定义头文件的方式有两种；<strong><code>注意：#include&lt;...&gt;是调用标准头文件库的用法，自己写的头文件，调用时一般用#include&quot;....&quot;，而不用#include&lt;....&gt;，自定义头文件一般和项目文件放在一起，即同目录下即可。</code></strong></p><ul><li><p>第一种：函数的声明和实现都写在“.h”头文件中；</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-comment">//创建一个头文件，后缀以“.h”结尾即可，名称可以自定义</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123;       <span class="hljs-keyword">return</span> num1 + num2;&#125;;<span class="hljs-comment">//-----------------------------------------------</span><span class="hljs-comment">//在需要引用的程序中引入你自己定义的头文件即可</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"myheadfile.h"</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;       <span class="hljs-keyword">int</span> res = getSum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);       printf_s(<span class="hljs-string">"%d"</span>, res);       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p>第二种：函数的声明写在“.h”头文件中，函数的实现写在“.c”或“.cpp”文件中。<strong><code>注意：VS2019中，无法使用第二种，又或许是我的方式不对？</code></strong></p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-comment">//创建一个头文件，后缀以“.h”结尾即可，名称可以自定义，内容写上函数的声明</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1,<span class="hljs-keyword">int</span> num2)</span></span>;<span class="hljs-comment">//-----------------------------------------------</span><span class="hljs-comment">//创建一个源文件，后缀以“.c”或“.cpp”结尾即可，名称可以自定义，但最好和自定义的“.h”头文件名称一致，方便辨认；内容写上头文件中声明的函数的具体实现</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">""</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1,<span class="hljs-keyword">int</span> num2)</span></span>&#123;    <span class="hljs-keyword">return</span> num1 + num2;&#125;<span class="hljs-comment">//-----------------------------------------------</span><span class="hljs-comment">//在需要引用的程序中引入自己写的头文件即可</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"myheadfile.h"</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;       <span class="hljs-keyword">int</span> res = getSum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);       printf_s(<span class="hljs-string">"%d"</span>, res);       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>函数的递归调用：所谓递归调用，就是函数自己调用自己的意思，不需要想的太复杂。我们将放在return之前的递归调用，称为尾递归。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>;  <span class="hljs-comment">//声明函数原型</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> res = count(<span class="hljs-number">12</span>);  <span class="hljs-comment">//调用函数</span>    printf_s(<span class="hljs-string">"结果是：%d\n"</span>,res);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>&#123;    <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">10</span>)&#123;        num--;        <span class="hljs-keyword">return</span> count(num);    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;    &#125;&#125;</code></pre></li></ul><p>&nbsp;</p><ul><li><p>变量的作用域：所谓变量的作用域，就是指变量的有效范围。可分为：</p><ul><li><p>局部变量：</p><ul><li>作用域：定义在函数或代码块内部。即该类型变量的有效范围在函数或代码块内部。</li><li>存储区域：局部变量保存在栈中，函数被调用时才会为其分配存储单元。<code>如，形式参数就是局部变量</code>；<strong><code>注意：局部变量系统不会帮忙初始化，也就是说必须初始化才能用</code></strong></li></ul></li><li><p>全局变量：</p><ul><li><p>作用域：即定义在函数外部的变量。该类型变量的有限范围是在整个程序中。</p></li><li><p>存储区域：全局变量保存在内存中的全局存储区中，占用静态的存储单元。<strong><code>注意：全局变量系统会帮忙初始化；int类型默认是0、char类型默认是&#39;\0&#39;、float和double类型默认是0.0，指针类型默认是NULL。当局部变量和全局变量同名时，根据就近原则，会使用局部变量的值；但要注意，同一作用域中，不能出现同名变量。</code></strong></p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-keyword">int</span> a;  <span class="hljs-comment">//这就是全局变量，没赋值，但是系统会给我们初始化，默认是0</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>  <span class="hljs-comment">//这是局部变量，只用于man函数内部</span>    printf_s(<span class="hljs-string">"结果是：%d\n"</span>,a);  <span class="hljs-comment">//这里会输出最近的变量，即a=10</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++)&#123;         <span class="hljs-keyword">int</span> j = <span class="hljs-number">0.5</span>;  <span class="hljs-comment">//这也是局部变量</span>        printf_s(<span class="hljs-string">"%d"</span>,i+j);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-19-static关键字"><a href="#NO2-19-static关键字" class="headerlink" title="NO2.19 static关键字"></a>NO2.19 static关键字</h3><p>static关键字，意为静态的意思，可以修饰变量和函数。</p><ul><li><p>static修饰：</p><ul><li><p>修饰变量，分为两种：</p><ul><li><p>基本语法格式：<code>static 数据类型 变量名 = 值</code>；</p></li><li><p>修饰局部变量：静态局部变量如果没有初始化值，那么系统会根据不同的数据类型为静态局部变量初始化值；静态局部变量存储于内存的静态存储区，只会被初始化一次；</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;  <span class="hljs-comment">//这是普通局部变量</span>    printf_s(<span class="hljs-string">"结果是：%d\n"</span>,a);  <span class="hljs-comment">//这里会输出10</span>    a++;    printf_s(<span class="hljs-string">"结果是：%d\n"</span>,a);  <span class="hljs-comment">//这里会输出11</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a2; <span class="hljs-comment">//这是静态局部变量</span>    printf_s(<span class="hljs-string">"结果是：%d\n"</span>,a2);  <span class="hljs-comment">//这里会输出0</span>    a2++;    printf_s(<span class="hljs-string">"结果是：%d\n"</span>,a2);  <span class="hljs-comment">//这里会输出1</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">3</span>;i++) &#123;        f1();    &#125;    print_f(<span class="hljs-string">"----------------------------\n"</span>)    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">3</span>;i++) &#123;        f2();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;输出结果：结果是：<span class="hljs-number">10</span>  <span class="hljs-comment">//开始第一次调用函数</span>结果是：<span class="hljs-number">11</span>结果是：<span class="hljs-number">10</span>  <span class="hljs-comment">//开始第二次调用函数，当再次调用函数时，a的值又被重新初始化为10了</span>结果是：<span class="hljs-number">11</span>---------------------------结果是：<span class="hljs-number">0</span>  <span class="hljs-comment">//静态局部变量a2并没有被赋值，所以系统初始化了a的值为0</span>结果是：<span class="hljs-number">1</span>结果是：<span class="hljs-number">1</span>  <span class="hljs-comment">//第二次调用函数时，静态局部变量并没有重新初始化为0，因为静态局部变量只会被初始化一次</span>结果是：<span class="hljs-number">2</span></code></pre></li><li><p>修饰全局变量：静态全局变量会被私有化，即静态全局变量只能用在本文件当中，其他文件无法通过extern引用该静态全局变量。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-comment">//test1.c文件中</span><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;  <span class="hljs-comment">//定义了一个普通的全局变量</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a2 = <span class="hljs-number">10</span>;  <span class="hljs-comment">//如果使用了静态全局变量，则该变量只能用于test1.c文件中，无法被其他文件使用extern引用</span><span class="hljs-comment">//-----------------------------------</span><span class="hljs-comment">//test2.c文件中</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> a;  <span class="hljs-comment">//通过extern引用test1.c文件中的变量a</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> a2;  <span class="hljs-comment">//通过extern引用test1.c文件中的变量a2</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    print_s(<span class="hljs-string">"a的结果是：%d\n"</span>,a);  <span class="hljs-comment">//这里会输出10</span>    print_s(<span class="hljs-string">"a2的结果是：%d\n"</span>,a2;  <span class="hljs-comment">//这里会报错，即无法解析a2这个变量</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li><li><p>修饰函数：</p><ul><li><p>基本语法格式：<code>static 返回值类型 函数名(形参列表){....}</code>；</p></li><li><p>static修饰函数：与静态全局变量类似，静态函数只属于本文件，无法被其他文件用extern所引用；即哪个文件声明了静态函数，那么就只能被哪个文件调用，其他文件无法调用。反过来。普通函数可以被extern关键字所引用。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-comment">//test1.c文件中</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;  <span class="hljs-comment">//普通函数</span>    printf_s(<span class="hljs-string">"这里是f1函数"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;  <span class="hljs-comment">//静态函数</span>    printf_s(<span class="hljs-string">"这里是f2函数"</span>);&#125;<span class="hljs-comment">//-----------------------------------</span><span class="hljs-comment">//test2.c文件中</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;  <span class="hljs-comment">//通过extern引用test1.c文件中的函数f1</span><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;  <span class="hljs-comment">//通过extern引用test1.c文件中的函数f2</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;     f1();  <span class="hljs-comment">//成功输出：这里是f1函数</span>     f2();  <span class="hljs-comment">//报错：无法解析的外部符号，即静态函数只能在声明了它的那个文件中使用</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-20-字符串和数组"><a href="#NO2-20-字符串和数组" class="headerlink" title="NO2.20 字符串和数组"></a>NO2.20 字符串和数组</h3><p>C语言中没有存储字符串的变量类型。</p><ul><li><p>字符串：</p><ul><li><p>定义：是一个或多个字符的序列，属于派生类型。如，”dyf is climbing”、”be warm”等等，这些都是字符串；<strong><code>注意：如果创建的是字面量字符串，系统依然会默认给该字符串的最后添加一个&#39;\0&#39;。</code></strong></p></li><li><p>数据类型：C语言没有专门用于存储字符串的数据类型，字符串都被存储在char类型的数组中。<strong><code>注意：C中的字符串一定以空字符串结束，所以数组一般要多留一个位置给这个空字符串。字符串其实就是一个字符数组，如果函数的返回值是一个char*，即一个字符型的指针变量，那么一般就是返回一个字符串的意思，极少数有返回一个地址值。</code></strong></p></li><li><p>字符和字符串的区别：</p><ul><li><p>字符是基本类型，字符串是派生类型；</p></li><li><p>字符串的末尾有都有一个空字符：’\0’，而字符没有。</p><p>  <img src="./Image-c27.png" srcset="/img/loading.gif" alt="Image"><br>  <code>说明：上图中末尾的字符\0，这是用于标记字符串的结束而使用的空字符，它是非打印字符，其ASCII码值等价于0。</code></p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>数组：</p><ul><li><p>定义：数组是同类型的数据元素的有序序列，简单讲就是同一类型的数据元素的一个有序的集合。如，要么都是int，或者都是long….等等；</p></li><li><p>数组的创建方式：要使用数组，必须先创建数组，常用的几种方式如下；<strong><code>注意：用const修饰数组，表示只让用户查看数组中有哪些元素，但并不允许修改。如，const int nums[5]，表明了该数组只能用于查看有哪些元素，不允许用户修改数组的值；数组中每个元素的内存地址都是连续分布的，即第一个元素的地址值加上数据类型占用的字节大小等于第二个元素的地址，后面的以此类推；数组索引从0开始；字符数组如果只初始化了部分空间，那么剩下的空间都将被赋值为&#39;\0&#39;。</code></strong></p><ul><li>方式一：<code>数据类型 数组名称[size]</code>。用该方式创建的数组，包括，指定了的数据类型、数组名称，以及数组的容量(即size)；</li><li>方式二：<code>数据类型 数组名称[size] = {元素1,元素2,元素3,....}</code>。用该方式创建的数组，包括指定了的数据类型、数组名称，以及数组的容量(也可以不指定size大小，系统会根据已有的元素推断数组的size)，并且数组中的元素也已经确定，就是{}中的元素；</li><li>方式三：<code>数据类型 数组名称[size] = {[索引值]=值,....}</code>。用该方式创建的数组，给数组中指定索引的位置赋了值，这是C99引入的新特性，之前是不允许这样的，之前的规定：必须对要赋值元素之前的所有元素都赋值，才能给指定位置的元素赋值。<code>如，char nums[5] = {[0]=&#39;b&#39;,[4]=&#39;a&#39;}</code>。<strong><code>注意：如果指定赋值的索引有多个值，那么会将其他多出来的值，赋给指定索引后面的索引。如，char nums[3]={[0]=&#39;a&#39;,&#39;b&#39;,&#39;c&#39;}。</code></strong></li></ul></li><li><p>数组与指针的关系：数组名可以认为是一个指针常量，它指向数组的第0个元素的地址。即数组名的地址值==数组[0]的地址值，也就是说数组名的地址值和数组第一个元素的地址值是相同的。<code>如，int num[2]，那么&amp;num==&amp;(num[0])，且(&amp;num)+1==&amp;(num[1])</code>。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;    printf_s(<span class="hljs-string">"name?"</span>);    <span class="hljs-keyword">char</span> name[<span class="hljs-number">40</span>];  <span class="hljs-comment">//创建一个字符数组</span>    scanf_s(<span class="hljs-string">"%s"</span>,name);  <span class="hljs-comment">//获取用户输入一个字符串，并将该字符串存入名为name的字符数组</span>    printf_s(<span class="hljs-string">"hello, %s"</span>,name);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;注意：<span class="hljs-keyword">char</span> str[] =&#123;<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>&#125;和<span class="hljs-keyword">char</span> str2[<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>&#125;的区别一、<span class="hljs-keyword">char</span> str[] =&#123;<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>&#125;，该字符数组根据后面拥有的元素来推断数组的大小，所以大小为<span class="hljs-number">3</span>，但是如果以字符串的转换说明输出的话，会出现乱码，因为该字符串中没有足够的位置添加空字符<span class="hljs-string">'\0'</span>；二、<span class="hljs-keyword">char</span> str2[<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>&#125;，该字符数组大小为<span class="hljs-number">3</span>，且只占用了两个空间，在以字符串转换说明(即以<span class="hljs-string">"%s"</span>)输出时，不会报错，因为有空间添加空字符<span class="hljs-string">'\0'</span>，所以能够正常输出。<span class="hljs-comment">//============================================================    </span>    拓展：全局数组和局部数组的初始化(这里以整型数组为例，即<span class="hljs-keyword">int</span> arr[])一、未初始化：    <span class="hljs-number">1.</span>全局数组，被编译器初始化为<span class="hljs-number">0</span>；    <span class="hljs-number">2.</span>局部数组，为随机数。二、部分初始化：不论是全局数组还是局部数组，没有被初始化的部分，都会被初始化为<span class="hljs-number">0</span>。<span class="hljs-comment">//============================================================    </span>    拓展：“*”、指针变量、数组的使用一、<span class="hljs-keyword">int</span> arr[<span class="hljs-number">10</span>]，<span class="hljs-keyword">int</span>*  ar = &amp;arr，那么，*(ar + <span class="hljs-number">2</span>)，表示arr数组的第三个元素的值；二、arr + <span class="hljs-number">2</span>，表示arr数组的第一个元素的地址值加<span class="hljs-number">2</span>，即数组第三个元素的地址值。</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li>二维数组：<ul><li>定义：即数组的每个元素是一个一维数组(一维数组就是普通的数组)，这样的数组，我们称为二维数组。多维数组，以此类推。</li><li>二维数组的基本语法格式：<code>数据类型 数组名[size1][size2]</code>，其中size1表示，二维数组中有多少个一维数组，size2则表示每个一维数组中有多少个元素。<code>如，int nums[2][3]，表示这个二维数组中有2个一维数组元素，而每个一维数组中都有3个元素</code>。<strong><code>注意：其实二维数组的创建基本语法格式和一维数组差不多，这里只介绍了一种，还可以直接添加元素到数组中：int nums[2][2]={ {1,2},{3,4} }。</code></strong></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-21-C语言中的常用函数"><a href="#NO2-21-C语言中的常用函数" class="headerlink" title="NO2.21 C语言中的常用函数"></a>NO2.21 C语言中的常用函数</h3><p>函数是C程序中的主体。</p><ul><li><p>字符串函数：<strong><code>注意：这一类函数主要对字符串进行操作，存在于string.h头文件中，所以使用时需要引用头文件string.h头文件。</code></strong></p><ul><li><p>strlen(str)：用于表示字符串中的字符长度(包括空格和标点符号，但不会把用于结束的空字符算进去)。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;  //引入strlen()函数所在的头文件，该头文件还包含了其他与字符串相关的函数</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;    <span class="hljs-keyword">char</span> name[<span class="hljs-number">40</span>] = &#123;<span class="hljs-string">"abc"</span>&#125;;    printf_s(<span class="hljs-string">"数组的长度是：%d\n"</span>, <span class="hljs-keyword">sizeof</span>(name));  <span class="hljs-comment">//sizeof()表达式用于获取字符数组的大小，前面声明了开了40个字节，那么这里的结果就是40</span>    printf_s(<span class="hljs-string">"你名字的长度是：%d"</span>,<span class="hljs-built_in">strlen</span>(name));  <span class="hljs-comment">//strlen()表达式用于获取字符串的长度，但是不会把空字符(即\0)算进去，返回的结果为3</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;拓展：<span class="hljs-keyword">sizeof</span>一、<span class="hljs-keyword">sizeof</span>是C语言的一种单目操作符。<span class="hljs-keyword">sizeof</span>操作符以字节形式给出了其操作数的存储大小。<span class="hljs-keyword">sizeof</span>的返回值是<span class="hljs-keyword">size_t</span>，在<span class="hljs-number">64</span>位机器下，被定义为<span class="hljs-keyword">long</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>；二、用途：    <span class="hljs-number">1.</span>用于数据类型：使用形式为<span class="hljs-keyword">sizeof</span>(type)。表示这个类型占内存多少字节；    <span class="hljs-number">2.</span>用于变量：使用形式为<span class="hljs-keyword">sizeof</span>(var)或<span class="hljs-keyword">sizeof</span> var。表示常量、变量在内存中占用的字节数。</code></pre></li><li><p>strcpy_s(str,len,newStr)：将newStr复制到str中，str中的值会被覆盖掉；其中len表示将newStr复制到str时，创建的一个缓冲区的大小，一般的做法就是将len的大小定为newStr的长度加1，即strlen(newStr)+1，为什么要加1？是因为字符串中包含了空字符来表示字符串的结尾，所以需要在字符串本身长度的基础上多加1才能够将这个需要被复制的字符串放入缓冲区中；如果len小于或等于了newStr，那么程序会报错。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;    <span class="hljs-keyword">char</span> str[<span class="hljs-number">20</span>] = &#123;<span class="hljs-string">"abc"</span>&#125;;    strcpy_s(str , <span class="hljs-number">6</span>,<span class="hljs-string">"ddddd"</span>);  <span class="hljs-comment">//正常运行，最后的输出结果为：ddddd</span>    strcpy_s(str , <span class="hljs-number">4</span>,<span class="hljs-string">"ddddd"</span>);  <span class="hljs-comment">//报错，程序崩溃</span>    strcpy_s(str , <span class="hljs-number">5</span>,<span class="hljs-string">"ddddd"</span>);  <span class="hljs-comment">//报错，程序崩溃</span>    printf_s(<span class="hljs-string">"%s"</span>,str);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p>strcat_s(str,len,newStr)：将newStr追加到str中，并不会覆盖str的原有内容，只是做一个追加操作。len表示str的大小，即str数组的大小，一般len设置为sizeof(str)；添加len参数的原因是因为要确保新添加的newStr追加到str后，str的长度不会溢出，保证了程序的安全，这样也方便开发工具做一个检查。<strong><code>注意：len也可以超出str字符数组的长度，但是这样做会出现奇奇怪怪的结果。</code></strong></p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;    <span class="hljs-keyword">char</span> str[<span class="hljs-number">5</span>] = &#123;<span class="hljs-string">"abc"</span>&#125;;    strcat_s(str, <span class="hljs-number">5</span>, <span class="hljs-string">"dd"</span>);  <span class="hljs-comment">//报错，程序崩溃，因为"abcdd"总共需要占用6个字节(即"dd\0"，因为还有个空字符表示字符串结尾)</span>    strcat_s(str, <span class="hljs-number">5</span> , <span class="hljs-string">"d"</span>);  <span class="hljs-comment">//正常运行，输出结果为：abcd</span>    printf_s(<span class="hljs-string">"%s"</span>,str);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//-----------------------------------</span><span class="hljs-comment">//以下是len长度超出str长度的结果</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;       <span class="hljs-keyword">char</span> str[<span class="hljs-number">5</span>] = &#123;<span class="hljs-string">"abc"</span>&#125;;       strcat_s(str, <span class="hljs-number">10</span>, <span class="hljs-string">"ddd"</span>);  <span class="hljs-comment">//如果我将len的值设置为10</span>       printf_s(<span class="hljs-string">"%s\n"</span>,str);  <span class="hljs-comment">//输出结果为：abcddd</span>       printf_s(<span class="hljs-string">"%d\n"</span>, <span class="hljs-keyword">sizeof</span>(str));  <span class="hljs-comment">//字符数组的大小还是5</span>       printf_s(<span class="hljs-string">"%d\n"</span>, <span class="hljs-built_in">strlen</span>(str));  <span class="hljs-comment">//拼接后占用了6个字节大小的空间</span>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;注意：这里并没有报错，但是要明白，字符数组str只在内存中开辟了<span class="hljs-number">5</span>个字节大小的空间，那么该数组中也就只能存储<span class="hljs-number">4</span>个字节大小的数据(因为还要包括一个空字符的占用空间)，且已经放入了abc，即说明最多只能再放入一个数据，但是上面却显示输出了abcddd，那么为什么上面没有报错呢？那是因为数组中多出的两个元素占用了不该占用的别的内存的空间来满足自己的需要。在添加了ddd这个字符串之后，字符长度变为了<span class="hljs-number">6</span>，原本数组只能放<span class="hljs-number">4</span>个字符数据的，如今却放进去了<span class="hljs-number">6</span>个，就只能说明，多出的两个字符数据，占用了不该占用的其他内存空间，这是很危险的，假如别的内存空间中有数据，你占用了，就会出现不可预估的错误，所以一般才会将len的长度大小设置为<span class="hljs-keyword">sizeof</span>(str)，即数组本身的大小。</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>日期函数：这一类函数主要对日期和时间进行操作，存在于time.h头文件中，所以使用时需要引用头文件time.h头文件。</p><ul><li><p>time(time_t seconds)：该函数用于获取自格林威治时间1970年1月1日00:00凌晨至现在所经过的秒数，如果seconds不为空，那么获取的秒数也会存储在time_t类型的指针变量seconds中；其中time_t类型其实就是long int类型，简单讲time函数的参数要传入一个long int类型的指针变量；</p></li><li><p>ctime_s()：将传入的时间转换成字符串基本语法格式：星期几 月份 天数 时:分:秒 年份；</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;       <span class="hljs-keyword">time_t</span> myTime;  <span class="hljs-comment">//定义一个time_t类型的变量myTime</span>       <span class="hljs-keyword">time_t</span>  a= &amp;myTime;  <span class="hljs-comment">//获取myTime的地址值，并存入time_t类型的指针变量a中</span>       time(a);  <span class="hljs-comment">//调用函数获取到目前为止的时间秒数</span>       printf_s(<span class="hljs-string">"%u"</span>, myTime/<span class="hljs-number">60</span>/<span class="hljs-number">60</span>/<span class="hljs-number">24</span>/<span class="hljs-number">365</span>);  <span class="hljs-comment">//将秒数转化成年数，结果为距今50年</span>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li>数学函数：时间不够，暂时还未补充，有时间会补充上的。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-22-预处理命令"><a href="#NO2-22-预处理命令" class="headerlink" title="NO2.22 预处理命令"></a>NO2.22 预处理命令</h3><p>使用库函数之前，应该用#include引入对应的头文件。</p><ul><li><p>预处理命令：</p><ul><li><p>定义：在编译之前对源文件进行简单加工的过程就称为预处理。C语言中的预处理命令主要以#号开头。预处理命令要放在所有函数之外，而且一般放在源文件前面。预处理命令由预处理程序完成；</p></li><li><p>作用：使得程序便于阅读，修改、移植和调试，也有利于模块化程序的设计。C语言提供了许多预处理功能。如，宏定义、文件包含、条件编译等的。</p></li><li><p>C语言常见的预处理命令：</p><ul><li><p>#：空指令，无任何效果，可以用来注释；</p></li><li><p>#include：包含一个源代码文件，即头文件。<code>如，#include&lt;stdio.h&gt;</code>；</p></li><li><p>#define：宏定义命令，即用一个标识符来表示一个数值(不局限于整数，也可以是字符串、字符、表达式等等)，并对程序中所有同样的标识符做替换，这种替换称为宏替换；宏定义分为两种：</p><ul><li>无参宏定义：<ul><li>基本语法格式：<code>#define 宏名 值</code>。<code>如，#define AGE 10，如果程序中还出现了AGE，那么都将会被替换成10</code>；</li></ul></li><li>带参宏定义：<ul><li>基本语法格式：<code>#define 宏名(参数1,参数2,...,参数n) 值</code>。<code>如，#define MAX(a,b) ((a)&gt;(b)?(a) : (b))，那么程序中的int c=MAX(5,3)，会被替换成int c=((5)&gt;(3)?(5) : (3))</code>。<strong><code>注意：带参宏定义尽量多用小括号。</code></strong></li></ul></li></ul></li><li><p>#undef：取消已定义的宏；</p></li><li><p>#if：如果给定条件为真，则编译下面代码；</p></li><li><p>#elif：如果#if条件不为真，那么当前条件就会为真，编译下面代码；</p></li><li><p>#ifdef：如果宏已经定义，则编译下面代码；</p></li><li><p>#ifndef：如果宏没有定义，则编译下面代码；</p></li><li><p>#endif：结束#if…到…#elif条件编译快。</p>  <pre><code class="hljs c">拓展：宏定义和<span class="hljs-keyword">typedef</span>的区别一、宏定义只是简单的值替换，由预处理器进行处理；而<span class="hljs-keyword">typedef</span>则是给原有的数据类型起一个新的名字，基本语法格式为：<span class="hljs-keyword">typedef</span> 原数据类型 新的类型名，且<span class="hljs-keyword">typedef</span>是在由编译器在编译阶段才进行处理。如，<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> INT32，表示给<span class="hljs-keyword">int</span>类型起了一个新名字为INT32。       拓展：带参宏定义和函教调用的区别。一、调用发生的时间：    <span class="hljs-number">1.</span>在源程序进行编译之前，即预处理阶段进行宏替换；    <span class="hljs-number">2.</span>函数调用则发生在程序运行期间。二、参数类型检查：    <span class="hljs-number">1.</span>函数参数类型检查严格。程序在编译阶段，需要检查实参与形参个数是否相等及类型是否匹配或兼容，若参数个数不相同或类型不兼容，则会编译不通过；    <span class="hljs-number">2.</span>在预处理阶段，对带参宏调用中的参数不做检查。即宏定义时不需要指定参数类型，既可以认为这是宏的优点，即适用于多种数据类型，又可以认为这是宏的一个缺点，即类型不安全。故在宏调用时，需要程序设计者自行确保宏调用参数的类型正确。三、参数是否需要空间：    <span class="hljs-number">1.</span>函数调用时，需要为形参分配空间，并把实参的值复制一份赋给形参分配的空间中。    <span class="hljs-number">2.</span>宏替换，仅是简单的文本替换，且替换完就把宏名对应标识符删除掉，即不需要分配空间。四、执行速度：    <span class="hljs-number">1.</span>函数在编译阶段需要检查参数个数是否相同、类型等是否匹配等多个语法，且函数在运行阶段参数需入栈和出栈操作，速度相对较慢；    <span class="hljs-number">2.</span>宏替换仅是简单文本替换，不做任何语法或逻辑检查。五、代码长度：    <span class="hljs-number">1.</span>由于宏替换是文本替换，即如果需替换的文本较长，则替换后会影响代码长度；    <span class="hljs-number">2.</span>函数不会影响代码长度。故使用较频繁且代码量较小的功能，一般采用宏定义的形式，比采用函数形式更合适。</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-23-VS2019的DEBUG调试"><a href="#NO2-23-VS2019的DEBUG调试" class="headerlink" title="NO2.23 VS2019的DEBUG调试"></a>NO2.23 VS2019的DEBUG调试</h3><p>debug模式，是我们常用来调试程序而使用的，简单讲就是查看程序是否有问题。</p><ul><li><p>VS2019中的debug模式的使用：</p><ul><li><p>首先，在需要断点(你想要查看的语句)的程序语句行号前双击即可，这样就可以打上断点了。<strong><code>注意：一般都是断点都是打在函数第一行有效的语句上。</code></strong></p></li><li><p>然后，按F5，开始调试，进入debug模式的页面，按F10可以每一行每一行的查看和执行程序的语句。</p><p>  <img src="./Image-c28.png" srcset="/img/loading.gif" alt="Image"></p><p>  <img src="./Image-c29.png" srcset="/img/loading.gif" alt="Image"></p><p>  <img src="./Image-c30.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-24-指针变量和指针数组"><a href="#NO2-24-指针变量和指针数组" class="headerlink" title="NO2.24 指针变量和指针数组"></a>NO2.24 指针变量和指针数组</h3><p>指针其实就是地址值；指针变量存储的是地址值。</p><ul><li><p>指针变量的使用：</p><ul><li><p>赋值：即可以把地址赋给指针变量；</p></li><li><p>解引用：与*运算符一起使用，给出指针变量中存放的地址所指向的变量对应的值；<strong><code>注意：*无法用在字符串字面量前面来解引用。如，char* str =&quot;abc&quot;，那么*str就会报错，因为字符串本身就比较特殊，即字符串本身是字符数组，而数组本身就是指针变量，所以使用转换说明“%s”输入字符串时，不需要在str前面加上*号来解引用。</code></strong></p></li><li><p>取址：与&amp;运算符一起使用，给出指针变量本身的地址值，然后赋值给另一个指针变量；</p></li><li><p>指针变量与整数相加：即地址值与整数相加，得出初始地址与整数相加的结果地址值；</p></li><li><p>递增指针变量：一般用在数组上，地址值指向下一个数组元素的地址上；</p></li><li><p>递减指针变量：一般用在数组上，地址值指向上一个数组元素的地址上；</p></li><li><p>指针变量求差：一般用在数组上，地址值相减，得出两个元素之间的距离；</p></li><li><p>指针变量比较：比较的是两个指针中地址所指向的值。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-comment">//指针变量自增与自减</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;    <span class="hljs-keyword">int</span>* arrp = &amp;arr;    arrp++;  <span class="hljs-comment">//appr原本指向arr[0]的地址值，指针变量自增后，指向了a[1]的地址值</span>    printf_s(<span class="hljs-string">"%d\n"</span>, *arrp);  <span class="hljs-comment">//与arr[1]元素的值相同</span>    printf_s(<span class="hljs-string">"%d\n"</span>, arr[<span class="hljs-number">1</span>]);    arrp--;  <span class="hljs-comment">//指针变量自减</span>    printf_s(<span class="hljs-string">"%d"</span>, *arrp);  <span class="hljs-comment">//与arr[0]元素的值相同</span>    printf_s(<span class="hljs-string">"%d\n"</span>, arr[<span class="hljs-number">0</span>]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//------------------------------</span><span class="hljs-comment">//指针变量求差</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;       <span class="hljs-keyword">int</span> arr[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;       <span class="hljs-keyword">int</span> arrp = &amp;arr;       printf_s(<span class="hljs-string">"%p\n"</span>, &amp;(arr[<span class="hljs-number">1</span>])-arrp);  <span class="hljs-comment">//输出结果为0000000001</span>       printf_s(<span class="hljs-string">"%d\n"</span>, &amp;(arr[<span class="hljs-number">1</span>]) - arrp);  <span class="hljs-comment">//输出结果为1</span>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>指针数组：</p><ul><li><p>定义：即数组中存储的元素都是指向同一数据类型的指针变量；</p></li><li><p>基本语法格式：<code>数据类型* 数组名[size]或数据类型 *  数组名[size]，两者均可</code>。<code>如，int * ptr[5]与int* ptr[5]相同</code>。<strong><code>注意：多重指针的实质是：使用一个指针变量a来存放另一个指针变量b本身的地址，而b存放的则是另一个变量的地址值。</code></strong></p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span>* ap = &amp;a;<span class="hljs-keyword">int</span>** app = &amp;ap;  <span class="hljs-comment">//这就是多重指针，指向的是指针变量ap的地址，而指针变量ap存放的是变量a的地址值，说白了多重指针就是一个指针变量的多层嵌套</span></code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-25-函数指针和回调函数"><a href="#NO2-25-函数指针和回调函数" class="headerlink" title="NO2.25 函数指针和回调函数"></a>NO2.25 函数指针和回调函数</h3><p>代码中如果有函数的定义，那么系统也会在栈空间分配一块内存给这个函数，即这段存储空间的首地址称为这个函数的地址；函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。</p><ul><li><p>函数指针：</p><ul><li><p>定义：指向函数地址的指针变量就称为函数指针变量，也成为函数指针；</p></li><li><p>基本语法格式：<code>函数返回值类型 (* 指针变量名) (函数参数列表)</code>。其中，“函数返回值类型”表示该指针变量指向的函数具有什么返回值类型，“函数参数列表”表示该指针变量指向的函数具有什么参数列表。这个参数列表中可以只写形参的数据类型，也可以带上形参名。我们看到，函数指针的定义就是将“函数声明”中的“函数名”改成“(* 指针变量名)”。<strong><code>注意：函数指针中的()不可以省略。</code></strong></p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>;   <span class="hljs-comment">//声明一个函数</span><span class="hljs-keyword">int</span> (*p) (<span class="hljs-keyword">int</span> x);  <span class="hljs-comment">//定义一个函数指针</span>p = Func;          <span class="hljs-comment">//将Func函数的首地址赋给指针变量p</span><span class="hljs-comment">//------------------------------------------------------</span><span class="hljs-comment">//函数的调用</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>;  <span class="hljs-comment">//声明了一个函数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;  <span class="hljs-comment">//函数的实现</span>       <span class="hljs-keyword">return</span> a + b;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;       <span class="hljs-keyword">int</span> (*ptr) (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) = getSum;  <span class="hljs-comment">//声明了一个函数指针ptr，并将getSum函数赋值给了该函数指针ptr；函数指针还可以写成int (*ptr) (int ,int)，即省略形参名，但必须写形参数据类型</span>       <span class="hljs-keyword">int</span> res = (*ptr) (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">//通过调用函数指针来调用函数</span>       printf_s(<span class="hljs-string">"%d"</span>,res);       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>回调函数：就是将函数指针当作一个参数传入别人的函数中，这样别就可以通过函数指针调用你的函数了。<strong><code>注意：函数指针作为参数进行传递时，如果函数指针中带有参数，那么需要将参数取出来，也当做参数进行传递。</code></strong></p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSumA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> (*ptr) ())</span></span>;  <span class="hljs-comment">//声明了一个函数getSumA，其参数要传入一个函数指针变量，该函数指针中带有参数，所以将参数a、b取出来，也当做getSumA的参数进行传递，也就是说，这个函数指针变量原先是这样的：int (*ptr) (int a,int b)</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSumA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> (*ptr) ())</span> </span>&#123;  <span class="hljs-comment">//getSumA函数的实现</span>       <span class="hljs-keyword">return</span> ptr (a, b);  <span class="hljs-comment">//实际调用的是ptr这个函数指针，而我定义ptr这个函数指针其实就是getSumB的函数指针</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSumB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;  <span class="hljs-comment">//又声明了一个函数getSumB</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSumB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;  <span class="hljs-comment">//getSumB函数的实现</span>       <span class="hljs-keyword">return</span> a + b;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;       <span class="hljs-keyword">int</span> (*p) (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) = getSumB;  <span class="hljs-comment">//为getSumB创建了一个函数指针</span>       <span class="hljs-keyword">int</span> res = getSumA(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,p);  <span class="hljs-comment">//调用getSumA</span>       printf_s(<span class="hljs-string">"%d"</span>,res);       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;输出结果为：<span class="hljs-number">3</span></code></pre></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-26-C程序的不同数据的内存分配"><a href="#NO2-26-C程序的不同数据的内存分配" class="headerlink" title="NO2.26 C程序的不同数据的内存分配"></a>NO2.26 C程序的不同数据的内存分配</h3><p>C程序中，针对不同的数据，存放的位置也不一样。</p><ul><li>在C/C++中内存分为5个区，分别为栈区、堆区、全局/静态存储区、常量存储区、代码区。按内存分配类型划分为：<ul><li>静态内存分配：编译时分配。包括：全局变量、静态全局变量、静态局部变量这三种；</li><li>动态内存分配：运行时分配。包括：<ul><li>栈(stack)：局部变量；</li><li>堆(heap)：C语言中用到的临时数据被动态的分配在内存中。需要时随时开辟，不需要时及时释放。<code>如，malloc或calloc、realloc、free函数)</code>。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>栈区、堆区、全局/静态存储区、常量存储区、代码区的详细介绍：<ul><li>栈区(stack)：<ul><li>定义：指那些由编译器在需要的时候分配，不需要时自动清除的变量所在的储存区。<code>如，函数执行时，函数的形参以及函数内的局部变量分配在栈区，函数运行结束后，形参和局部变量自动释放</code>；</li><li>优缺点：栈内存分配效率高但是分配的内存空间有限。</li></ul></li><li>堆区(heap)：<ul><li>定义：指那些由程序员手动分配或释放的储存区；</li><li>优缺点：如果程序员不释放这块内存，内存将一直被占用，直到程序运行结束由系统自动收回。C语言中使用malloc，free申请和释放空间。</li></ul></li><li>静态储存区(static)：<ul><li>定义：存储全局变量和静态变量(包括静态局部变量、静态全局变量)的内存区域；</li><li>优缺点：这块空间当程序运行结束后由系统释放。</li></ul></li><li>常量储存区(const)：<ul><li>定义：常量字符串就是储存在这里的。<code>如，“ABC”字符串就储存在常量区，但储存在常量区的只读不可写</code>。另外const修饰的全局变量也储存在常量区，const修饰的局部变量依然在栈上。</li></ul></li><li>程序代码区：<ul><li>定义：存放源程序的二进制代码。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>堆与栈的对比：<ul><li>申请方式：<ul><li>栈由编译器管理；</li><li>堆的分配和释放由程序员管理。</li></ul></li><li>申请大小：<ul><li>栈是向低地址生长的数据结构，是一块连续的内存，能从栈中获得的内存较小，编译期间确定大小；</li><li>堆是向高地址生长的数据结构，是一个不连续的储存空间，，内存获取比较灵活，也较大。</li></ul></li><li>栈与堆中的储存内容：<ul><li>栈：在函数调用时，第一个进栈的是主函数中的最后一条指令的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量(静态变量是不入栈的)，当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点开始运行；</li><li>堆：一般是在堆的头部用一个字节存放堆的大小，堆中的具体内容由程序员安排。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>动态内存分配使用的函数。<strong><code>注意：下面的四个函数是放在stdlib.h头文件中。下面参数中的size_t其实就是在32位架构中被普遍定义为：unsigned int，而在64位架构中被普遍定义为：unsigned long；C99标准中，定义了void为无类型指针，即只表示一个地址，不指向任何具体的对象，说白了，void就指向一个纯地址值，且该地址不指向任何数据；堆内存，尽量不要分配大量的小内存块，且分配的内存用过后尽快释放。</code></strong><ul><li>malloc函数：<ul><li>函数原型：void  * malloc (size_ t size)；</li><li>功能：<ul><li>开辟一块size大小的连续堆内存；</li><li>size表示堆上所开辟内存的大小，单位是字节数；</li><li>函数返回值是一个指针，指向刚刚开辟的内存中第一个字节的地址；</li><li>如果开辟内存失败，返回一个空指针，即返回值为NULL；</li><li>当内存不再使用时，应使用free()函数将内存块释放；</li><li>使用时必须包含头文件&lt;stdlib.h&gt;或&lt;malloc.h&gt;。</li></ul></li></ul></li><li>calloc函数：<ul><li>函数原型：void  calloc(size_ t n, size t size)；</li><li>功能：<ul><li>在内存的动态存储区中分配n个长度为size的连续空间，即分配nsize大小的堆内存空间，该函数开辟的空间一般比较大；</li><li>函数返回一个指向分配空间的起始地址的地址；</li><li>如果分配不成功，返回NULL；</li><li>当内存不再使用时，应使用free()函数将内存块释放；</li><li>使用时必须包含头文件&lt;stdlib.h&gt;或&lt;malloc.h&gt;。</li></ul></li></ul></li><li>realloc函数：<ul><li>函数原型：void  realloc(void  mem_address, size_ t newsize)；</li><li>功能：<ul><li>为已有内存(即使用malloc或calloc函数开辟的空间)重新分配新的内存大小(可大、可小)；</li><li>先判断当前的指针是否有足够的连续空间，如果有，扩大mem_address指向的地址，并且将mem_ address返回；如果空间不够，先按照newsize指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来mem_address所指内存区域(注意：原来指针是自动释放，不需要使用free)，同时返回新分配的内存区域的首地址。即重新分配存储器块的地址；</li><li>如果重新分配成功则返回指向被分配内存的指针；</li><li>如果分配不成功，返回NULL；</li><li>当内存不再使用时，应使用free()函数将内存块释放；</li><li>使用时必须包含头文件&lt;stdlib.h&gt;或&lt;malloc.h&gt;。</li></ul></li></ul></li><li>free函数：<ul><li>函数原型： void free (void ptr)，ptr为要释放的内存指针；</li><li>free()：释放指针变量在堆区上的内存空间，不能释放栈上的内存空间，free要与malloc(calloc、realloc)成对使用。注意：如果malloc(calloc、realloc) 比 free 多， 会造成内存泄漏；如果malloc(calloc、realloc) 比 free 少，会造成二次删除， 破坏内存，导致程序崩溃。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-27-结构体和共用体"><a href="#NO2-27-结构体和共用体" class="headerlink" title="NO2.27 结构体和共用体"></a>NO2.27 结构体和共用体</h3><p>在C语言中，可以使用结构体(Struct)来存放一组不同类型的数据，即结构体中存放的数据，可以是不同数据类型的意思。</p><ul><li><p>结构体：</p><ul><li><p>定义：就是把其他各种数据类型组合起来，构成另一个新的数据类型以方便使用，说白了就是用来存放不同类型数据的另一个数据类型而已；这些成员会占用不同的内存，且不会互相影响；</p><ul><li><p>基本语法格式：</p><p>  例如：</p><pre><code><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名&#123;</span>  <span class="hljs-comment">//结构体面一般首字母大写。如，Cat、Student等等</span>    结构体所包含的变量或数组或指针或结构体等等&#125;;如：<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>&#123;</span>    <span class="hljs-keyword">char</span> name;  <span class="hljs-comment">//姓名</span>    <span class="hljs-keyword">int</span> num;  <span class="hljs-comment">//学号</span>    <span class="hljs-keyword">int</span> age;  <span class="hljs-comment">//年龄</span>    <span class="hljs-keyword">char</span> group;  <span class="hljs-comment">//所在学习小组</span>    <span class="hljs-keyword">float</span> score;  <span class="hljs-comment">//成绩</span>&#125;</code></pre></code></pre></li><li><p>结构体变量：既然结构体是一种数据类型，那么就可以用它来定义变量；</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名&#123;</span>    结构体所包含的变量或数组或指针或结构体等等&#125; 结构体变量名<span class="hljs-number">1</span>, 结构体变量名<span class="hljs-number">2.</span>...;  <span class="hljs-comment">//定义结构体的同时，还创建了结构体变量</span>注意：还可以使用匿名结构体方式创建结构体变量<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>      结构体所包含的变量或数组或指针或结构体等等&#125; 结构体变量名<span class="hljs-number">1</span>, 结构体变量名<span class="hljs-number">2.</span>...;  <span class="hljs-comment">//定义结构体的同时，还创建了结构体变量</span>注意：此时创建的结构体是没有名称的，只能使用上面的方式创建，要是还想再使用，必须重新创建    <span class="hljs-comment">//-----------------------------------------</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名 结构体变量名;</span>  <span class="hljs-comment">//该方式要求结构体已经创建好，否则会报错   </span>如：<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">st1</span>;</span>  <span class="hljs-comment">//定义了一个Student类型的变量st1</span></code></pre><ul><li><p>结构体变量，能够调用自己结构体内所用于的成员；</p><p>  例如：</p>  <pre><code class="hljs c">结构体变量.成员名称如：st1.namest1.age</code></pre></li><li><p>结构体变量内的成员也能够被赋值。</p><p>  例如：</p>  <pre><code class="hljs c">方式一赋值：    结构体变量.成员名称 = 值    <span class="hljs-comment">//-----------------------</span>方式二赋值：    struct 结构体名&#123;    结构体所包含的变量或数组或指针或结构体等等&#125; 结构体变量名<span class="hljs-number">1</span> = &#123;值<span class="hljs-number">1</span>,值<span class="hljs-number">2.</span>...&#125;, 结构体变量名<span class="hljs-number">2</span>= &#123;值<span class="hljs-number">1</span>,值<span class="hljs-number">2.</span>...&#125;....;</code></pre></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>共用体：</p><ul><li><p>定义：和结构体很类似，也是用于存储其他数据类型的一个数据类型，但和结构体不同的是，共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员；共用体占用的内存等于最长的成员占用的内存；共用体也成为联合或联合体；共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉；</p><ul><li><p>基本语法格式：</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">union</span> 共用体名&#123;    成员列表&#125;;如：<span class="hljs-keyword">union</span> stu&#123;    <span class="hljs-keyword">char</span> name;  <span class="hljs-comment">//char占用1个字节</span>    <span class="hljs-keyword">int</span> age;  <span class="hljs-comment">//int类型占用4个字节，所以该共用体占用的内存为4，即以最长数据类型占用的内存为共用体的占用内存</span>&#125;</code></pre></li><li><p>共用体变量也可以创建变量；</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">union</span> 共用体名&#123;    成员列表&#125;  共用体变量<span class="hljs-number">1</span>,共用体变量<span class="hljs-number">2.</span>...;  <span class="hljs-comment">//这里定义了共用体的同时还定义了共用体变量</span>注意：还可以使用匿名结构体方式创建共用体变量<span class="hljs-keyword">union</span> &#123;      结构体所包含的变量或数组或指针或结构体等等&#125; 共用体变量名<span class="hljs-number">1</span>, 共用体变量名<span class="hljs-number">2.</span>...;  <span class="hljs-comment">//定义共用体的同时，还创建了结构体变量</span>此时创建的共用体是没有名称的，只能使用上面的方式创建，要是还想再使用，必须重新创建    <span class="hljs-comment">//-------------------------------------------</span>  <span class="hljs-keyword">union</span> 共用体名 共用体变量名;</code></pre></li><li><p>共用体变量的成员也能够被赋值；</p><p>  例如：</p>  <pre><code class="hljs c">结共用体变量.成员名称 = 值</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-28-文件处理"><a href="#NO2-28-文件处理" class="headerlink" title="NO2.28 文件处理"></a>NO2.28 文件处理</h3><p>在操作系统中，为了统一对各种硬件的操作，简化接口，不同的硬件设备也都被看成一个文件。对这些文件的操作，等同于对磁盘上普通文件的操作。<code>如，通常把显示器称为标准输出文件，printf就是向这个文件输出数据；通常把键盘称为标准输入文件，scanf就是从这个文件读取数据等等</code>。</p><ul><li><p>按照文件数据流的走向可分为：</p><ul><li><p>输入流：数据从文件复制到内存的过程。也称为读文件；<strong><code>注意：EOF：指的是end of file，表示文件末尾，且在头文件stdio.h中已经定义好了EOF的值为-1。getchar()和scanf_s()函数检测到文件结尾时，这两个函数都返回EOF，所以C中使用EOF来当做I/O的结尾条件。</code></strong></p></li><li><p>输出流：从内存保存到文件的过程。也称为写文件。</p><p>  <img src="./Image-c31.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>C语言常见的其他输入和输出函数：</p><ul><li><p>getchar()和putchar()函数：</p><ul><li><p>int getchar(void)：用于获得用户输入的字符，等价于scanf_s(“%c”,&amp;ch)；</p></li><li><p>int putchar(int c)：输出放入函数中的字符，即putchar(‘字符’)，等价于printf_s(“%c”,ch)。<strong><code>注意：getchar()和putchar()函数这两个函数在stdio.h头文件中。</code></strong></p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;     <span class="hljs-keyword">char</span> c = getchar();  <span class="hljs-comment">//等价于scanf_s("%c",&amp;c);</span>    <span class="hljs-built_in">putchar</span>(c);  <span class="hljs-comment">//等价于printf_s("%c", c);</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li><li><p>gets_s()和puts()函数：</p><ul><li><p>char gets(char s,size_t size)：读取输入的字符串，直至接收到换行符或EOF时停止，其中size为允许输入的长度，一般长度为字符数组s的长度减1。读入成功时，返回接收读取结果的字符数组的首地址，读入发生错误或遇到EOF返回NULL；</p></li><li><p>int puts(const char s)：输出字符串并换行。该函数只能输出字符串，不能输出其他类型数值；执行成功返回非负数，执行失败返回EOF。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;       <span class="hljs-keyword">char</span> arr[<span class="hljs-number">3</span>];       gets_s(arr, <span class="hljs-keyword">sizeof</span>(arr) - <span class="hljs-number">1</span>);  <span class="hljs-comment">//如果输入的arr超出了后面的size的话，那么会报错</span>       <span class="hljs-built_in">puts</span>(arr);       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>操作文件的正确流程为：打开文件 –&gt; 读写文件 –&gt; 关闭文件。文件在进行读写操作之前要先打开，使用完毕要关闭。打开文件和关闭文件的函数如下：<ul><li>errno_t fopen(FILE p,char filename, char mode)函数：用于打开文件。函数中的filename字符串参数，表示要打开的文件的文件名(包括文件路径)，如果文件名存在就是打开文件，不存在该文件名就创建一个新文件，以该文件名命名并打开。该函数在&lt;stdio.h&gt;头文件中；mode字符串参数表示要以什么权限打开文件。<strong><code>注意：如果文件打开失败会返回非0，成功返回0。</code></strong>具体权限如下所示：<ul><li><code>&quot;r&quot;</code>：以“只读”方式打开文件。只允许读取，不允许写入。文件必须存在，否则打开失败；</li><li><code>&quot;w&quot;</code>：以“写入”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容(相当于删除原文件，再创建一个新文件)；</li><li><code>&quot;a&quot;</code>：以“追加”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾(文件原有的内容保留)；</li><li><code>&quot;r+&quot;</code>：以“读写”方式打开文件。既可以读取也可以写入，也就是随意更新文件。文件必须存在，否则打开失败；</li><li><code>&quot;w+&quot;</code>：以“写入/更新”方式打开文件，相当于w和r+叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容(相当于删除原文件，再创建一个新文件)；</li><li><code>&quot;a+&quot;</code>：以“追加/更新”方式打开文件，相当于a和r+叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾(文件原有的内容保留)。</li><li><code>&quot;t&quot;</code>：表示文本文件。如果不写，默认为”t”；<strong><code>注意：该选项一般放在上面读写权限的后面。</code></strong></li><li><code>&quot;b&quot;</code>：表示二进制文件。<strong><code>注意：如果打开的是二进制文件，那么一定要加“b”；该选项一般放在上面读写权限的后面，如，a+b、r+b等等。</code></strong></li></ul></li><li>int fclose(FILE fp)函数：文件一旦使用完毕，应该用fclose()函数把文件关闭，以释放相关资源，避免数据丢失。文件正常关闭时，fclose()的返回值为0，如果返回非零值则表示有错误发生。</li></ul></li></ul><p>&nbsp;</p><ul><li><p>读写文件相关的函数：</p><ul><li><p>读写一个字符：</p><ul><li>int fgetc (FILE fp)函数：从指定的文件中读取一个字符。参数fp为文件指针。fgetc()读取成功时返回读取到的字符，读取到文件末尾或读取失败时返回EOF。</li><li>int fputc(int ch, FILE fp )函数：向指定的文件中写入一个字符。参数ch为要写入的字符，参数fp为文件指针。fputc()写入成功时返回写入的字符，失败时返回 EOF，返回值类型为int也是为了容纳这个负数。</li></ul></li><li><p>读写一个字符串：</p><ul><li>char fgets(char str, int n, FILE fp )：从指定的文件中读取一个字符串，并保存到字符数组中。参数str为字符数组，参数n为要读取的字符数目，参数fp为文件指针。读取成功时返回字符数组首地址，也即str；读取失败时返回 NULL；如果开始读取时文件内部指针已经指向了文件末尾，那么将读取不到任何字符，也返回NULL。</li><li>int fputs(char str, FILE fp )：向指定的文件写入一个字符串。参数str为要写入的字符串，参数fp为文件指针。写入成功返回非负数，失败返回EOF。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-29-缓冲I-O和无缓冲I-O"><a href="#NO2-29-缓冲I-O和无缓冲I-O" class="headerlink" title="NO2.29 缓冲I/O和无缓冲I/O"></a>NO2.29 缓冲I/O和无缓冲I/O</h3><p>C中输入分为缓冲输入和无缓冲输入两种。</p><ul><li>缓冲I/O：通俗的理解为当用户输入之后，直到按回车键为止，期间用户输入的内容会存放在一个缓冲区里面。首先，把若干字符作为一个块进行传输比逐个发送这些字符节约时间。其次，如果用户打错字符，可以直接通过键盘修正错误。当最后按下Enter键时，传输的是正确的输入。缓冲分为两类：完全缓冲I/O和行缓冲I/O。<strong><code>注意：ANSI C和后续的C标准都规定输入是缓冲的。</code></strong><ul><li>完全缓冲I/O：指的是当缓冲区被填满时才刷新缓冲区，通常出现在文件输入中。缓冲区的大小取决于系统，常见的大小是512字节和4096字节；</li><li>行缓冲I/O：指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区。行缓冲函数有getchar()和scanf_s()。</li></ul></li></ul><p>&nbsp;</p><ul><li><p>无缓冲I/O：说白了，就是你输入什么，它都能立马给你执行函数后面的内容。看电脑是否支持无缓冲I/O，如果支持，那么编译器添加&lt;conio.h&gt;这个头文件后，有两个无缓冲的函数：_getche()函数和_getch()函数，前者会回显用户的输入到屏幕上，而后者不会回显用户的输入到屏幕上。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-comment">//测试_getche()函数和_getch()函数，代码如下</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;conio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<span class="hljs-keyword">char</span> ch;<span class="hljs-keyword">while</span> ((ch = _getche()) != <span class="hljs-string">'8'</span>) &#123;    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">'t'</span>);&#125;/<span class="hljs-keyword">while</span> ((ch = _getch()) != <span class="hljs-string">'8'</span>) &#123;    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">'t'</span>);&#125;/<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>  <img src="./Image-c32.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：测试_getche()函数，分别输入1、2、3，返回如上结果，有回显用户的输入。</code></p><p>  <img src="./Image-c33.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：测试_getch()函数，分别输入1、2、3，返回如上结果，没有回显用户的输入。</code></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>1.대학교 일 학년</category>
      
      <category>02.C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大一课程</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01.计算机科学导论--学习笔记</title>
    <link href="/2020/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机科学导论–学习笔记-包含计算机科学导论书籍"><a href="#计算机科学导论–学习笔记-包含计算机科学导论书籍" class="headerlink" title="计算机科学导论–学习笔记(包含计算机科学导论书籍)"></a>计算机科学导论–学习笔记(包含计算机科学导论书籍)</h1><h2 id="Lesson1-绪论"><a href="#Lesson1-绪论" class="headerlink" title="Lesson1 绪论"></a>Lesson1 绪论</h2><h3 id="NO1-1-图灵模型"><a href="#NO1-1-图灵模型" class="headerlink" title="NO1.1 图灵模型"></a>NO1.1 图灵模型</h3><p>根据图灵模型所得的通用图灵机是对现代计算机的首次描述。</p><ul><li><p>阿兰·图灵在1937年首次提出了一个通用计算设备的设想，他设想所有的计算都可能在一种特殊的机器上执行，这就是现在所说的图灵机</p><p>  <img src="./Image-jsj1.png" srcset="/img/loading.gif" alt="Image"></p></li></ul><p>&nbsp;</p><ul><li><p>图灵模型，该模型是在图灵机思想的基础上，演变而来的模型，它更适用于通用计算机，因为图灵模型添加了一个额外的元素到计算机中，这就是程序。</p><p>  <img src="./Image-jsj2.png" srcset="/img/loading.gif" alt="Image"></p></li></ul><p>&nbsp;</p><ul><li><p>简单讲，程序是一个有序的指令集合，作用是告诉计算机怎么对数据进行处理。</p><p>  <img src="./Image-jsj3.png" srcset="/img/loading.gif" alt="Image"></p></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-2-冯·诺依曼模型"><a href="#NO1-2-冯·诺依曼模型" class="headerlink" title="NO1.2 冯·诺依曼模型"></a>NO1.2 冯·诺依曼模型</h3><p>基于图灵机的思想，冯·诺依曼在1944~1945年期间指出了：鉴于程序和数据在逻辑上是相同的，因此程序也能存储在计算机的存储器中——这就是冯诺依曼模型。</p><ul><li><p>基于冯·诺依曼模型建造的计算机有四个模块：</p><ul><li><p>存储器，用来存储数据和程序的模块；</p></li><li><p>算数逻辑单元(ALU，即运算器)，用来进行计算和逻辑运算的模块；</p></li><li><p>控制单元(即控制器)，顾名思义，就是对存储器、算术逻辑单元、以及输入/输出设备进行控制的模块；</p></li><li><p>输入/输出单元(即输入/输出设备)，就是接收计算机外部的数据和程序，并将计算机的处理结果输出到外部的模块。</p><p>  <img src="./Image-jsj4.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>存储程序的概念：程序由指令组成，并和数据一起存放在存储器中，计算机启动后，能自动地按照程序指令的逻辑顺序逐条把指令从存储器中读出来，并且完成由程序所描述的处理工作；冯·诺依曼模型指出，程序必须存储在存储器中。</p><p>  <img src="./Image-jsj5.png" srcset="/img/loading.gif" alt="Image"></p></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-3-计算机的组成"><a href="#NO1-3-计算机的组成" class="headerlink" title="NO1.3 计算机的组成"></a>NO1.3 计算机的组成</h3><p>计算机由两大部分组成，即计算机硬件和计算机软件(包括了数据)。软件工程指的是结构化程序的设计和编写。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-4-计算机的发展历史"><a href="#NO1-4-计算机的发展历史" class="headerlink" title="NO1.4 计算机的发展历史"></a>NO1.4 计算机的发展历史</h3><p>计算机的发展历史，说白了就是计算机硬件的发展历史。</p><ul><li>计算机的发展历程，主要分为了以下几个阶段：<ul><li>机械计算机器(1930年以前)，该阶段，人们发明了一些用来进行计算的机器，但是它们与计算机的现代概念几乎没有什么关系；</li><li>电子计算机的诞生(1930~1950年)，在这个阶段里，电子计算机工业先驱的科学家们发明了一些计算机。如，1939年发明的第一台计算机，名为阿塔纳索夫-贝瑞计算机(又称ABC)、同时期被发明的还有德国的“Z1”、1946年诞生了著名的“ENIAC”、第一台基于冯氏思想(即存储程序思想)而诞生的计算机“EDVAC”等等；</li><li>计算机的诞生(1950年至今)，1950年以后出现的计算机差不多都基于冯·诺依曼模型。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson2-数字系统"><a href="#Lesson2-数字系统" class="headerlink" title="Lesson2 数字系统"></a>Lesson2 数字系统</h2><h3 id="NO2-1-数字系统的理解"><a href="#NO2-1-数字系统的理解" class="headerlink" title="NO2.1 数字系统的理解"></a>NO2.1 数字系统的理解</h3><p>数字系统，简单理解就是，在不同的系统中，数字表示的方法是不一样的。如，数字5，在十进制中就是5，在中文中是“五”，在罗马数字系统中是“V”，这三个符号表示的都是5，只不过符号不一样。数字系统又分为位置化数字系统和非位置化数字系统。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-2-位置化数字系统"><a href="#NO2-2-位置化数字系统" class="headerlink" title="NO2.2 位置化数字系统"></a>NO2.2 位置化数字系统</h3><p>所谓的位置化数字系统，指的是数字中符号所占据的位置决定了其表示的值。如，一个数字符号3，出现在不同的位置表示的意思也不同，如，个位(3)，十位(30)，百位(300)，千位(3000)等等。在位置化数字系统的眼里，任何的数字，采用任何的进制，都可以用一条公式概括出来，如下图所示：</p><p><img src="./Image-jsj6.png" srcset="/img/loading.gif" alt="Image"></p><p><code>说明：这条公式中字母S旁边的k-1....2、1、0、-1、-2、-3....-l表示的是数字所在位置。</code></p><p><img src="./Image-jsj7.png" srcset="/img/loading.gif" alt="Image"></p><p><code>说明：这是这个数字要表达的值的计算方式，其中b的零次方、一次方....通俗的讲，就是这个数字在这个位置所要表示的大小，而b表示这个数字是多少进制。</code></p><p><img src="./Image-jsj8.png" srcset="/img/loading.gif" alt="Image"></p><p><code>说明：十进制数789，用这个公式的表达。</code></p><p>&nbsp;</p><ul><li><p>常见的位置化数字系统包括：</p><ul><li><p>十进制系统，简单的讲就是用0~9这十个符号来表示数字的系统，而十进制系统的规则是“逢十进一”。生活中我们用的数字就是十进制系统的数字。如，9+1，这里已经满十了，根据规则“逢十进一”，所以就需要往前进一位，且9后面没有别的数字，就只能重新回到0，所以9变成0，又因为往前进了一位，所以结果就是10。其实我们常用的数字，正确的表示应该为：正负号(数值)₁₀，只是我们把符号、括号、以及底都省略了，但并不是真的都消失了；</p><p>  <img src="./Image-jsj9.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：这是正数224的表示。</code></p><p>  <img src="./Image-jsj10.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：这是小数24.13的表示。</code></p>  <pre><code class="hljs java">拓展：基数和位权(其实就是上面所说的位置化数字系统)一、基数，其实指的就是，在不同进制数中，进制是多少，那么它的基数就是多少；如二进制的基数就是<span class="hljs-number">2</span>，八进制的基数就是<span class="hljs-number">8</span>，同理十进制的基数是<span class="hljs-number">10</span>，十六进制的基数就是<span class="hljs-number">16</span>等等；    二、权值，简单理解就是幂，而幂的值是根据当前目标值的所在位数减<span class="hljs-number">1</span>，即n-<span class="hljs-number">1</span>；如，二进制<span class="hljs-number">101</span>，基数是<span class="hljs-number">2</span>，权值分别是<span class="hljs-number">12</span>^<span class="hljs-number">2</span>、<span class="hljs-number">02</span>^<span class="hljs-number">1</span>、<span class="hljs-number">12</span>^<span class="hljs-number">0</span>，百位上的<span class="hljs-number">1</span>，从右往左数，是第三位，所以它的权值就是<span class="hljs-number">3</span>-<span class="hljs-number">1</span>=<span class="hljs-number">2</span>，十位上的<span class="hljs-number">0</span>的权值就是<span class="hljs-number">2</span>-<span class="hljs-number">1</span>=<span class="hljs-number">1</span>，以此类推；三、位权，其实就是指以进制基数为底的幂，简单理解就是，二进制的位权就是以<span class="hljs-number">2</span>为底的幂，同理十六进制的位权则是以<span class="hljs-number">16</span>为底的幂，其他进制也是同理。</code></pre></li><li><p>二进制系统，就是使用0和1这两个符号来表示数字的系统，规则是“逢二进一”；</p><p>  <img src="./Image-jsj11.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：这是与十进制数25等值的二进制数11001。</code></p><p>  <img src="./Image-jsj12.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：这是与十进制数5.75等值的二进制数101.11。</code></p></li><li><p>十六进制系统，是指用0到9和(10)A、(11)B、(12)C、(13)D、(14)E、(15)F，这十六个符号来表示数字的系统，规则是“逢十六进一”；</p><p>  <img src="./Image-jsj13.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：这是与十进制数686等值的十六进制数2AE。</code></p></li><li><p>八进制系统，用数字0到7这八个符号来表示数字的系统，规则是“逢八进一”。</p><p>  <img src="./Image-jsj14.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：这是与十进制数686等值的八进制数1256。</code></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>十进制与其他进制的相互转换。</p><ul><li><p>其他进制到十进制的转换，在上面的介绍中，其实已经讲了，即：每一位上的数值x进制^权值^。如，八进制的1256，转换为十进制：1x8^3^+2x8^2^+5x8^1^+6x8^0^ = 686；<strong><code>注意：小数点左边的权值从0开始递增，如，1、2、3、4...依次递增，而小数点右边的位置量则是从-1开始递减，如，-1、-2、-3、-4....依次递减。</code></strong></p></li><li><p>十进制到其他进制的转换，分为两部分：</p><ul><li><p>整数部分的规则：十进制数/对应的进制，直到商为0，然后余数取反即可；</p></li><li><p>小数部分的规则：十进制小数*对应的进制，然后取整数部分，直到小数部分为0或达到足够的位数时结束即可。</p><p>  <img src="./Image-jsj15.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：十进制35转二进制。</code></p><p>  <img src="./Image-jsj16.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：十进制小数0.625转二进制，即0.101。</code></p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>二进制转八进制或十六进制，采用的方法很相似，二进制转八进制用的三位归纳法，二进制转十六进制用的四位归纳。</p><p>  <img src="./Image-jsj17.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：图示是八进制转十六进制的方法。</code></p></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-3-非位置化数字系统"><a href="#NO2-3-非位置化数字系统" class="headerlink" title="NO2.3 非位置化数字系统"></a>NO2.3 非位置化数字系统</h3><p>非位置化数字系统，指的是，使用有限的数字符号，且每个符号有一个值，这个值不会因为符号所处的位置改变而改变，简单讲就是，这个符号是什么值，在哪个位置都是这个值。如，罗马数字就是一个例子。</p><p><img src="./Image-jsj18.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson3-数据存储"><a href="#Lesson3-数据存储" class="headerlink" title="Lesson3 数据存储"></a>Lesson3 数据存储</h2><h3 id="NO3-1-计算机内部的数据"><a href="#NO3-1-计算机内部的数据" class="headerlink" title="NO3.1 计算机内部的数据"></a>NO3.1 计算机内部的数据</h3><p>所有计算机外部的数据，要转换为二进制数据后才存入计算机，当数据从计算机输出时，再还原回来。</p><ul><li>位(bit)是存储在计算机中的最小单位，它是0或1，换句话说，存入计算机的数据，都会转换为0或1来表示。</li></ul><p>&nbsp;</p><ul><li>二进制表示的数字串有8位的话，被称为1字节(Byte)，所以1 Byte = 8 bit，意思就是1个字节有8位。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-2-存储数字"><a href="#NO3-2-存储数字" class="headerlink" title="NO3.2 存储数字"></a>NO3.2 存储数字</h3><p>计算机使用定点和浮点来表示整数和小数。</p><ul><li><p>内存中存储整数使用的是定点表示法；整数中既有正整数、负整数、0，所以可以用以下几种方式来表示：</p><ul><li><p>无符号表示法，用于无符号整数(就是没有符号的整数)，范围是0到无穷大之间；但是计算机肯定是无法表示无穷大这个整数的，所以就定义了一个最大无符号整数，值为<img src="../_resources/33afb12e021fc746cc3d15592afa429c.png" srcset="/img/loading.gif" alt="">，这里的n代表计算机中分配用于表示无符号整数的二进制位数；</p></li><li><p>符号加绝对值表示法，即计算机分配的二进制的位数中，最高位(就是最左边的位置)必须是符号位，且0表示正，1表示负；范围是-(2^n-1^-1)至+(2^n-1^-1)；</p></li><li><p>二进制补码表示法，即用二进制的补码来存储有符号整数；简单理解就是，通过一个数的二进制，分别得到原码(就是二进制)、反码、补码，最后用补码的形式来进行存储这个数；<strong><code>注意：正数的原反补都是一样的；而负数的反码要在原码的基础上，逐位取反，符号位不变；负数的补码要在反码的基础上，末位加1。</code></strong></p><p>  例如：</p><p>  <img src="./Image-jsj19.png" srcset="/img/loading.gif" alt=""></p><p>  <code>说明：存储7到八位的存储单元中：先将7转换为二进制数，得到的二进制数为111，但是不足八位，所以在左边添0，变成00000111，这样就满八位了。</code><br>  <img src="./Image-jsj20.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：存储258到十六位的存储单元中：将258转为二进制数后得到100000010，还差七位才够十六位，所以往左边添0，直到满16位即可。</code><br>  <img src="./Image-jsj21.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：存储11到四位的存储单元中，又试图再加上9：首先存储11到四位的存储单元中，11转换为二进制为1011，原本这没有什么问题，但是如果11+9=20，那么就会造成值溢出的情况，因为20转为二进制为10100，五位，无法全部存储到四位的存储单元中去，所以计算机丢掉第五位，也就是最前面的1，最后存储的则是0100，值就是4了。</code><br>  <img src="./Image-jsj22.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：将-28存储到8位的存储单元中：先将28转为二进制，值为00011100，用符号加绝对值表示法，最左边的位置不应该用0，而是要用1，因为存储的是-28，而不是28，所以最后的存储的二进制的值为10011100。</code></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>存储小数使用的则是浮点表示法；浮点表示法表示的数都由三部分组成：符号(即正负号)、指数(进制数的幂)、尾数(小数点右边的数)；且十进制中的浮点表示法，我们很熟悉，就是科学计数法，而二进制中就叫做浮点表示法；<strong><code>注意：浮点表示法中，小数点左边必须是非零，这称为规范化。</code></strong></p><ul><li><p>科学计数法(用于十进制)；</p><p>  <img src="./Image-jsj23.png" srcset="/img/loading.gif" alt="Image"></p><p>  <img src="./Image-jsj24.png" srcset="/img/loading.gif" alt="Image"></p></li><li><p>浮点表示法(用于二进制)。</p><p>  <img src="./Image-jsj25.png" srcset="/img/loading.gif" alt="Image"></p><p>  <img src="./Image-jsj26.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>IEEE(电子和电子工程师协会)定义了多种存储浮点数的标准，常用的是单精度、双精度。</p><p>  <img src="./Image-jsj27.png" srcset="/img/loading.gif" alt="Image"></p><ul><li><p>单精度(32位)，即采用32位二进制来表示一个浮点数；</p><p>  <img src="./Image-jsj28.png" srcset="/img/loading.gif" alt="Image"></p><p>  <img src="./Image-jsj29.png" srcset="/img/loading.gif" alt="Image"></p><p>  <img src="./Image-jsj30.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：十进制5.75的单精度表示法。</code></p><p>  <img src="./Image-jsj31.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：十进制数-0.0234375的单精度表示法。</code></p></li><li><p>双精度(64位)，即采用64位二进制来存储一个浮点数。</p><p>  <img src="./Image-jsj32.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：将单精度表示的11001010000000000111000100001111转换为十进制。</code></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-3-存储文本"><a href="#NO3-3-存储文本" class="headerlink" title="NO3.3 存储文本"></a>NO3.3 存储文本</h3><p>字符是各种文字和符号的总称，而字符集则是多个字符的集合；我们使用字符集来存储文本数据。</p><ul><li>常见的主流字符集有：<ul><li>ASCII字符集，用7位的二进制来表示128种不同的符号；</li><li>Unicode字符集，用32位的二进制来表示4294967296种不同的符号，收集了来自全球不同的语言符号。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-4-存储音频"><a href="#NO3-4-存储音频" class="headerlink" title="NO3.4 存储音频"></a>NO3.4 存储音频</h3><p>音频表示声音或者音乐。</p><ul><li><p>我们说存储音频，实际存储的是这个音频信号的密度。通过以下几个步骤可以获取音频信号的密度：</p><ul><li><p>采样：即从无穷个点里，选取一部分点，但每个点仍然有无穷的信息。每秒钟40000个样本的采样率对音频信号来说是足够好的；</p></li><li><p>量化：将样本的值，截取为最接近的整数值的一种过程。如，实际值为17.2，可截取为17、实际值为17.7，则截取为18；</p></li><li><p>编码，将量化后的样本值，转为二进制。也就是将获取到的样本，每个样本都转化为n位的二进制来表示；当今主流的音频编码是MP3(MPEG Layer 3的简写，取44100个样本，且每个样本用16位来表示)，这是一种有损的音乐格式。</p><p>  <img src="./Image-jsj33.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>NO3.5 存储图像<br>图像又该使用什么方式存储呢。</p><ul><li>存储在计算机中的图像使用两种不同的技术：光栅图和矢量图；将图像转化为二进制进行存储，就是视频了；<ul><li>光栅图，用于存储模拟图像，即一个图像由模拟数据组成，数据密度随空间的变化而变化，这时候的采样称为扫描，样本称为像素；整个图像被分为小的像素，每个像素假定都有单独的密度值；</li><li>矢量图，使用几何图形来组合图像，而这些几何图形又用数学公式来表达，所以说矢量图是由定义如何绘制这些形状的一系列命令构成的。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson4-数据运算"><a href="#Lesson4-数据运算" class="headerlink" title="Lesson4 数据运算"></a>Lesson4 数据运算</h2><h3 id="NO4-1-逻辑运算"><a href="#NO4-1-逻辑运算" class="headerlink" title="NO4.1 逻辑运算"></a>NO4.1 逻辑运算</h3><p>这里的逻辑运算是指二进制的逻辑运算。</p><ul><li><p>二进制的逻辑运算有如下几种：</p><ul><li><p>与(AND)：两个二进制补码做与运算，位对齐，只要两位上的任意一位是0，那么与的结果就为0；</p></li><li><p>或(OR)：两个二进制补码做或运算，位对齐，只要两位上的任意一位是1，那么或的结果就为1；</p></li><li><p>异或(XOR)：两个二进制补码做异或运算，位对齐，只要两位上的数字都相同，则结果为0，不相同则为1；</p></li><li><p>非(NOT)：一个二进制补码做非运算，按位取反，如果位上是0，则非运算结果为1，如果位上是1，结果则为0。</p><p>  例如：</p>  <pre><code class="hljs java"><span class="hljs-comment">//与运算</span><span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span><span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>-----------------------<span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-comment">//或运算</span><span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span><span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>-----------------------<span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>        <span class="hljs-comment">//异或运算    </span><span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span><span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>-----------------------<span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>        <span class="hljs-comment">//非运算    </span><span class="hljs-number">1</span>    <span class="hljs-number">0</span>------------------------<span class="hljs-number">0</span>    <span class="hljs-number">1</span></code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;    </p><h3 id="NO4-2-移位运算"><a href="#NO4-2-移位运算" class="headerlink" title="NO4.2 移位运算"></a>NO4.2 移位运算</h3><p>所谓的移位运算，简单理解就是将二进制进行左移或者右移。移位运算分为两种，逻辑移位运算和算数移位运算：</p><ul><li><p>逻辑移位运算中，又分为逻辑移位、循环移位；</p><ul><li><p>逻辑移位，简单的理解就是将二进制向左移(不够的部分就添加)或者向右移(多出的部分会被丢弃)；</p><p>  例如：</p><p>  <img src="./Image-jsj34.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：逻辑左移，左边多的部分丢弃，右边少的部分添0。</code>    </p>  <pre><code class="hljs java"><span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    原始的二进制补码------------------------------------<span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    逻辑左移之后的二进制补码</code></pre><p>  <img src="./Image-jsj35.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：逻辑右移，左边少的部分添0，右边多的部分丢弃。</code></p>  <pre><code class="hljs java"><span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    原始的二进制补码------------------------------------<span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    逻辑右移之后的二进制补码</code></pre></li><li><p>循环移位，原理和逻辑移位差不多，只不过移位过程中，不会添加或丢弃二进制位，而是循环使用。</p><p>  例如：<br>  <img src="./Image-jsj36.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：循环左移，左边多的部分会循环到右边少的部分，意思就是左边多出来的，刚好给右边少的。</code></p>  <pre><code class="hljs java"><span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    原始的二进制补码------------------------------------<span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    循环左移之后的二进制补码</code></pre><p>  <img src="./Image-jsj37.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：循环右移，右边多的部分会循环到左边少的部分，意思就是右边多出来的，刚好给左边少的。</code></p>  <pre><code class="hljs java"><span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    原始的二进制补码------------------------------------<span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    循环右移之后的二进制补码</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>算数移位运算，其实跟逻辑移位差不多，只不过算数移位的时候要注意一下符号问题；<strong><code>注意：算数左移相当于二进制补码的十进制数乘以2，右移就是除以2。</code></strong></p><ul><li><p>算数左移：</p><p>  例如：</p><p>  <img src="./Image-jsj38.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：算数左移的话，符号位会被丢弃，这个时候看看新的符号位是不是跟以前是一样的，一样就正常左移，运算成功；不一样的话就出现上溢或下溢，结果就是非法的。</code></p>  <pre><code class="hljs java">运算成功：<span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    原始的二进制补码------------------------------------<span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    算数左移之后的二进制补码，符号位还是<span class="hljs-number">1</span>，那么运算成功----------------------------------------------------------------------------运算结果不合法：<span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    原始的二进制补码------------------------------------<span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    算数左移之后的二进制补码，符号位由<span class="hljs-number">1</span>变成了<span class="hljs-number">0</span>，结果出现上溢或下溢，那么这个结果就是非法的</code></pre></li><li><p>算数右移：</p><p>  例如：</p><p>  <img src="./Image-jsj39.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：算数右移的话，原先最左边的符号位是什么，右移之后，左边少的，就添加对应的符号位就可以了(正数就添0，负数就添1)。</code></p>  <pre><code class="hljs java"><span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    原始的二进制补码------------------------------------<span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    算数右移之后的二进制补码，移位之前符号位是<span class="hljs-number">1</span>，是一个负数，则右移之后，添加<span class="hljs-number">1</span>即可</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO4-3-算数运算"><a href="#NO4-3-算数运算" class="headerlink" title="NO4.3 算数运算"></a>NO4.3 算数运算</h3><p>算数运算包括加减乘除。</p><ul><li><p>二进制补码的加减法，很简单，加法就是二进制补码，对位相加即可；而减法则是将减数(无论正负数)诸位取反后再加一，然后相加即可。</p><p>  例如：</p>  <pre><code class="hljs java">加法：<span class="hljs-number">00010001</span> + <span class="hljs-number">00010110</span>              进<span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>+   <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>---------------------------------------------------------------    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    用十进制检查结果+<span class="hljs-number">17</span>+(+<span class="hljs-number">22</span>)=+<span class="hljs-number">39</span><span class="hljs-number">00011000</span> + <span class="hljs-number">11101111</span>进<span class="hljs-number">1</span>  进<span class="hljs-number">1</span>  进<span class="hljs-number">1</span>   进<span class="hljs-number">1</span>  进<span class="hljs-number">1</span>  进<span class="hljs-number">1</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>+    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>----------------------------------------------------------------     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    用十进制检查结果(+<span class="hljs-number">24</span>)+(-<span class="hljs-number">17</span>)=(+<span class="hljs-number">7</span>)注意：上面的结果是<span class="hljs-number">100000111</span>，但是只能存<span class="hljs-number">8</span>位，最左边进的<span class="hljs-number">1</span>，就被丢弃了。============================================================================减法：<span class="hljs-number">00011000</span> - <span class="hljs-number">11101111</span>               进<span class="hljs-number">1</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>+    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    将减数在原先的基础上诸位取反，然后加<span class="hljs-number">1</span>----------------------------------------------------------------     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    用十进制检查结果(<span class="hljs-number">24</span>)-(-<span class="hljs-number">17</span>)=(+<span class="hljs-number">41</span>)<span class="hljs-number">11011101</span> - <span class="hljs-number">00010100</span>进<span class="hljs-number">1</span> 进<span class="hljs-number">1</span>  进<span class="hljs-number">1</span>  进<span class="hljs-number">1</span>   进<span class="hljs-number">1</span>  进<span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>+   <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    将减数在原先的基础上诸位取反，然后加<span class="hljs-number">1</span>------------------------------------------------------------------    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    用十进制检查结果(-<span class="hljs-number">35</span>)-(+<span class="hljs-number">20</span>)=(-<span class="hljs-number">55</span>)注意：上面的结果为<span class="hljs-number">111001001</span>，只能存<span class="hljs-number">8</span>位，即最前面的<span class="hljs-number">1</span>被丢弃了。</code></pre></li></ul><p>&nbsp;</p><ul><li>8位补码能够表示数的范围是-128~127，即10000000-11111111表示-128到-1,  00000000-01111111表示0-127。</li></ul><p>&nbsp;</p><ul><li><p>使用符号加绝对值的格式进行运算的时候，符号位做异或操作，其他位上加法就对位相加，减法则是将将减数(无论正负数)诸位(除了符号位)取反后再加一，如果出现上溢或下溢，则对符号位操作就行。</p><p>  例如：</p>  <pre><code class="hljs java">加法：<span class="hljs-number">00010001</span> + <span class="hljs-number">00010110</span>   符号位     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>+    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>-------------------------------------------------------     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span><span class="hljs-number">00010001</span> + <span class="hljs-number">10010110</span>   符号位     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>+    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>-------------------------------------------------------     <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>============================================================减法：<span class="hljs-number">11010001</span> - <span class="hljs-number">10010110</span>   符号位 进<span class="hljs-number">1</span>     <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>+    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>-------------------------------------------------------     <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>注意：上面的结果符号位原本应该是<span class="hljs-number">0</span>，但是后面第<span class="hljs-number">7</span>位上有上溢，所以添加到符号位上。</code></pre></li></ul><p>&nbsp;</p><ul><li>带小数的加减法。</li></ul><p><img src="./Image-jsj40.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-jsj41.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-jsj42.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson5-计算机组成"><a href="#Lesson5-计算机组成" class="headerlink" title="Lesson5 计算机组成"></a>Lesson5 计算机组成</h2><h3 id="NO5-1-中央处理单元-CPU"><a href="#NO5-1-中央处理单元-CPU" class="headerlink" title="NO5.1 中央处理单元(CPU)"></a>NO5.1 中央处理单元(CPU)</h3><p>计算机的组成部件可以分为三大类：中央处理单元(CPU)、主存储器和输入/输出系统。中央处理单元(CPU)用于数据的运算。</p><ul><li>在大多数体系结构中，CPU有三个组成部分：<ul><li>算术逻辑单元(ALU)：用于对数据进行逻辑(如，与、或、异或运算等等)、移位(如，逻辑移位和算数移位)和算数运算(如，整数和带小数的运算)；</li><li>控制单元：用于控制各个部件的操作；</li><li>寄存器组(快速存储单元)：用于临时存放数据的存储单元，每个存储单元是高速且独立的。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO5-2-主存储器"><a href="#NO5-2-主存储器" class="headerlink" title="NO5.2 主存储器"></a>NO5.2 主存储器</h3><p>主存储器里面主要存放的是数据和指令。</p><ul><li>主存储器是存储单元的集合，每个存储单元都有唯一的标识，称为地址。放在存储单元里的数据，是以“位”为单位的(这是最小的单位)，而每8位称为1个字节。</li></ul><p>&nbsp;</p><ul><li>我们把所有存储器中的存储单元的地址的集合称为地址空间，简单讲，就是逻辑上，把所有的存储单元的地址，集合起来我们统称为地址空间。内存地址用无符号的二进制整数来定义。</li></ul><p>&nbsp;</p><ul><li>通常，如果一个计算机有N个字的存储空间的话，那就需要有log<del>2</del>N位的无符号整数来确定每一个存储单元；如，一台计算机有32MB内存，需要多少位来寻址内存中的任意一个字节？32MB的内存地址空间，也就是2^25^(2^5^x2^20^)，这就一位置需要log<del>2</del>2^25^，也就是25位来标识每一个字节。</li></ul><p>&nbsp;</p><ul><li>存储器的类型，主要有两种：<ul><li>RAM，即随机存取存储器，是计算机中主存的主要组成部分，用户可以读和写。根据技术，RAM又可以分为静态SRAM和动态DRAM，前者是用传统的触发器门电路(有0和1两个状态的门)来保存数据，通电时数据一直存在，不需要刷新，特点是速度快，但价格昂贵；后者则是使用电容器来保存数据，会随时间漏掉一部分点，所以需要周期性地刷新，特点是速度慢，但价格便宜；</li><li>ROM，即只读存储器，内容由制造商写进去，用户只能读不能写，断电后数据也会存在。</li></ul></li></ul><p>&nbsp;</p><ul><li>存储器的层次结构。</li></ul><p><img src="./Image-jsj43.png" srcset="/img/loading.gif" alt="Image"></p><p><code>说明：当对速度要求很苛刻时，可以使用少量高速存储器，寄存器就属于这一类；用适量的中速存储器来存储经常需要访问的数据，高速缓冲存储器属于这一类；存储那些不经常访问的数据，主存就属于这一类。</code></p><p>&nbsp;</p><ul><li>高速缓冲存储器；</li></ul><p><img src="./Image-jsj44.png" srcset="/img/loading.gif" alt="Image"></p><p><code>说明：CPU优先去高速缓冲存储器找自己需要的数据，如果有，就直接拿来使用；没有的话就去主存找，拿到数据之后，复制一份放入高速缓冲存储器中，以备下次使用；因为高速缓冲存储器速度比主存要快。</code></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO5-3-输入-输出系统"><a href="#NO5-3-输入-输出系统" class="headerlink" title="NO5.3 输入/输出系统"></a>NO5.3 输入/输出系统</h3><p>输入/输出系统的作用的是与外界进行通信，在断电情况下可以存储程序和数据。</p><ul><li>输入/输出系统可以分为两大类：<ul><li>非存储设备，这一类设备可以与外界通信，但不能存储信息；常用的有键盘、监视器、打印机等等；</li><li>存储设备，该类可以存储大量的信息以备后用，即断电后也不会丢失数据；常见的有磁盘、磁带、光盘等等。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO5-4-子系统的互连"><a href="#NO5-4-子系统的互连" class="headerlink" title="NO5.4 子系统的互连"></a>NO5.4 子系统的互连</h3><p>CPU和内存之间通常由称为总线(简单讲，其实就是线)的三组线路连接在一起。</p><ul><li>总线分为三种：<ul><li>数据总线：传输数据使用的总线。一根线一次性能传送1个位的数据。如，32根线就能传送一个32位的数据；</li><li>地址总线：用于访问内存地址或I/O设备的总线，存储空间的大小与总线的多少是有关系的。如，存储器容量为<img src="../_resources/4877edb6c2e6b619f637f843d0fad7cc.png" srcset="/img/loading.gif" alt="">，那么地址总线就有n条；</li><li>控制总线：负责控制CPU和内存之间的操作。如，CPU要读取某个内存的信息，就是控制总线发出信号给内存进行读取操作。</li></ul></li></ul><p>&nbsp;</p><ul><li>I/O设备不能够直接与总线相连，而是通过输入/输出控制器或接口卡的器件连接到总线上的。意思就是说，外围设备插入电脑，实际连接的是输入/输出控制器或接口卡，然后由输入/输出控制器或接口卡与总线相连。常用的控制器有SCSI、火线、和USB。输入/输出的寻址有两种方式：一是I/O独立寻址，二是I/O存储器映射寻址。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO5-5-程序的执行"><a href="#NO5-5-程序的执行" class="headerlink" title="NO5.5 程序的执行"></a>NO5.5 程序的执行</h3><p>程序，是一组有序指令的集合。</p><ul><li>指令，是指一串能够被计算机识别并执行的二进制代码。指令是计算机进行程序控制的最小单位。计算机所识别的指令集合称为计算机的指令系统。程序的执行，一般包括三个阶段：<ul><li>取指令：控制单元将需要执行的指令复制到CPU的指令寄存器中，且同时该指令的地址也会被放入到程序计数器中，当指令复制完成后，程序计数器自动加1指向内存中下一条指令；</li><li>译码：放在指令寄存器中的指令，会被控制单元负责译码，然后产生一系列的二进制代码；</li><li>执行：控制单元将译码完成后产生的二进制代码拿去执行。</li></ul></li></ul><p>&nbsp;</p><ul><li>I/O设备的运行速度是慢于CPU的，所以当I/O设备向CPU传输数据的时候，CPU要做一个同步(也就是CPU要知道I/O设备把想要传输的数据传输完成了的意思)。有三种方式用于同步：<ul><li>程序控制输入/输出：这是最简单的一种同步。简单理解就是CPU等待I/O设备的输入或输出，等完成了输入或输出，CPU再继续自己的工作。该方式比较浪费CPU的时间，即每次都要查询I/O设备的状态是否准备好输入或输出；</li><li>中断控制输入/输出：当I/O设备准备好了，告诉一声CPU就行，然后CPU进行输入或输出，在通知CPU之前，CPU一直在做自己的事情；</li><li>直接存储器存取(DMA)，该方式用于高速I/O设备间传输数据。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO5-6-介绍两个指令集-了解"><a href="#NO5-6-介绍两个指令集-了解" class="headerlink" title="NO5.6 介绍两个指令集(了解)"></a>NO5.6 介绍两个指令集(了解)</h3><p>计算机体系结构和组织，经历了CISC和RISC。</p><ul><li>计算机体系结构分为两大类：<ul><li>CISC：即复杂指令集。<code>如，英特尔开发的奔腾系列处理器属于这个体系</code>；</li><li>RISC：即精简指令集。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson6-计算机网络"><a href="#Lesson6-计算机网络" class="headerlink" title="Lesson6 计算机网络"></a>Lesson6 计算机网络</h2><h3 id="NO6-1-计算机网络的基本概念"><a href="#NO6-1-计算机网络的基本概念" class="headerlink" title="NO6.1 计算机网络的基本概念"></a>NO6.1 计算机网络的基本概念</h3><p>网络是硬件和软件的组合，它把数据从一个地方发送到另一个地方。硬件是指把信号从网络中的一点传送到另一点的物理设备，而软件由指令组成，这些指令可以使我们从网络上获得想要的服务。</p><ul><li>网络必须符合许多标准，其中最重要的是性能、可靠性和安全；<ul><li>性能：度量方式包括传输时间(即从一个设备传输到另一个设备)和响应时间(查询和响应间的时间间隔)。网络的性能还依赖于其他因素，如，用户数、传输介质类型、硬件的连接能力、软件的效率等等；</li><li>可靠性：即发送数据的准确性、发生故障的频率、从故障中恢复的时间等等；</li><li>安全：主要包括保护数据、防止非授权访问、损坏和修改等等。</li></ul></li></ul><p>&nbsp;</p><ul><li><p>网络由两个或两个以上通过链路连接的设备构成。链路是数据从一个设备传输到另一个设备的通信通道，通俗的讲，链路就是两个点之间的连线。连接类型有两种：</p><ul><li><p>点对点，指两个设备间的专用链路；</p></li><li><p>多点(也称多站连接)，指两个以上的指定设备共享一个链路。</p><p>  <img src="./Image-jsj45.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>物理拓扑，是指网络在物理上的布置方式。两个或多个设备连接到一个链路，一个或多个链路形成拓扑，而网络的拓扑是所有链路和设备间关系的几何表示。物理拓扑主要有四种基本结构：</p><ul><li><p>网状型，每个设备都有专用的点对点链路与其他设备相连；</p></li><li><p>星型，每个设备都有专用的点对点链路与称为集线器的中央控制器相连，这种类型的拓扑是唯一常用的；</p></li><li><p>总线型，每个设备使用分支线和连接器与总线相连；</p></li><li><p>环形，每个设备都有专用的点对点链路，只与两边的设备相连，信号沿着环从一个设备传输到另一个设备，环中的每个设备连接一个中继器。</p><p>  <img src="./Image-jsj46.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><ul><li>如今网络可以分为三类：<ul><li>局域网(LAN)：常常是作为私有的网络，即可能是个人电脑和打印机的连接等等，范围是几公里内，一般用于连接单个办公室、大楼或校园里的设备；</li><li>城域网(MAN)：通常范围是一个镇或一个城市；</li><li>广域网(WAN)：提供长距离的数据、图像、音频和视频信息的传输，范围可能包含一个国家、大洲或全球。</li></ul></li></ul><p>&nbsp;</p><ul><li>当两个或多个网络连接在一起时，就变成了互联网，即internet。</li></ul><p><img src="./Image-jsj47.png" srcset="/img/loading.gif" alt="Image"></p><p><code>说明：路由器是发送数据包(消息)，并使消息在互联网中传输的连接设备。</code></p><p>&nbsp;</p><ul><li>因特网(Internet)是最大的，也是最著名的互联网，它由成千上万个互相连接的网络组成，个人和各种组织都使用因特网。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO6-2-TCP-IP协议族"><a href="#NO6-2-TCP-IP协议族" class="headerlink" title="NO6.2 TCP/IP协议族"></a>NO6.2 TCP/IP协议族</h3><p>我们用微信聊天的时候，有想过发送的消息是怎么到达对方的微信上的吗？我们可以把发送消息当做一个任务，那么我们把发送消息这个任务过程稍微的拆分一下，肯定要确定每一步做什么，要不然就乱乱的，对吧？为此我们定义一个协议，但又因为我们使用了因特网来完成这个任务，就把这个协议称为TCP/IP协议族。</p><ul><li><p>如今的TCP/IP协议族通常被定义成五层：</p><ul><li><p>应用层；</p></li><li><p>传输层；</p></li><li><p>网络层；</p></li><li><p>数据链路层；</p></li><li><p>物理层。</p><p>  <img src="./Image-jsj48.png" srcset="/img/loading.gif" alt="Image"></p><p>  <code>说明：如上图，就是我们在聊天的时候，消息的传输，每一层都调用它直接下层的服务。</code></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO6-3-层"><a href="#NO6-3-层" class="headerlink" title="NO6.3 层"></a>NO6.3 层</h3><p>我们要明确TCP/IP协议族划分的每一层的功能。</p><ul><li>应用层：<ul><li>应用层的功能：<ul><li>这一层允许用户(人或者软件)访问网络，该层负责向用户提供服务。应用层是唯一一个大多数因特网用户能够看到的层。</li></ul></li><li>现在常用的两大网络结构分别是：C/S(即客户端/服务器端)和B/S(即浏览器端/服务器端)；</li><li>客户端想要获取服务器端的某个资源，就必须使用URL，即统一资源定位符。如，访问百度搜索，URL为<a href="http://www.baidu.com/" target="_blank" rel="noopener">www.baidu.com</a>；这个URL并不是服务器的实际地址，只是用于应用层的用户获取服务而使用的应用层地址；</li><li>网络中每一台计算机都有一个称为逻辑地址或IP地址的实际地址。当我们去访问URL的时候，都会经过一个叫做域名服务器的根服务器(国内有许多镜像域名服务器)，即DNS，这里面就存放有我们要访问的URL所对应的IP地址了；</li><li>应用层协议：三种常见的应用层协议为HTTP、FTP、SMTP。</li></ul></li></ul><p>&nbsp;</p><ul><li>传输层：<ul><li>传输层的功能：<ul><li>按端口号寻址：该层负责客户端和服务器端进程间消息的传输，简单讲就是你用什么程序发给我的，我就用什么程序来接收，主要靠的是传输层地址来识别程序。传输层也有一个地址，即端口号，这个端口号是用来干嘛的呢，就是我用某个程序给你发的消息，你也只能用同样的某个程序来接收，而这个程序在电脑上运行的时候，有一个唯一的进程地址表示，这个唯一的进程地址表示就是端口号。如，我用微信程序给小明发消息，这个微信程序运行在我的电脑上的端口号是1000，那么发送的消息就会从这个端口号出去，通过IP地址找到小明的电脑，然后再找到小明电脑上端口号为1000的微信程序(一般程序的端口号安装以后都不会自行改变，是固定的)来接收消息；</li><li>多路复用和解多路复用：简单讲，多路复用就是传输层会收集所有进程中要发出的数据；解多路复用就是把接收到的数据分发给进程，这个过程是使用端口号来完成的；</li><li>拥塞控制：即数据要发送前，传输层检测到网络可能会发生拥塞的话，那么就会把消息存储在缓冲区，发生拥塞就暂缓消息的发送，直到网络不拥塞时再发送消息；</li><li>流量控制：直白的讲，就是让发送方的发送速率不要太快，要让接收方来得及接收；</li><li>差错控制：发送方在发送数据前，传输层可以在缓冲区中保留一个数据的副本，直到发送方从接收方那里接收到包无损坏到达和次序正确的确认，否则发送方就重新发送数据包。</li></ul></li><li>传输层协议：在TCP/IP协议族中定义了三种传输层协议：UDP、TCP和SCTP。</li></ul></li></ul><p>&nbsp;</p><ul><li>网络层：<ul><li>网络层的功能：<ul><li>该层负责单个数据包从源主机到目的主机的发送。</li><li>网络层同样有个地址，网络层通过它的路由表找到下一跳的逻辑地址，然后把这个地址传递给数据链路层；</li><li>路由选择：即确定数据包的部分或全部路径。简单讲，就是数据包的传输不可能一下子就传送到你想要传送的电脑上，中间要经过许多的路由器，当到达一个路由器时，这个路由器会为目的地选择最佳的传输路径。</li></ul></li><li>网络层协议：该层主协议是IP协议，当前版本为IPv4，但IPv6也在使用，虽然不是很普及。IPv4负责从源计算机到目的地计算机的数据包发送，为此，全球的计算机和路由器都用32位的IP地址表示，该IP地址用点分十进制记法表示，该记法把地址分解成4个8位的部分，每个部分写成0~255的十进制数，用三个点来隔开这些部分。如，IPv4地址00001010 00011001 10101100 00001111用点分十进制记法写成10.20.172.15。但IPv4似乎不够用了，最终方案是IPv6，该地址由128位构成。</li></ul></li></ul><p>&nbsp;</p><ul><li>数据链路层：<ul><li>数据链路层的功能：<ul><li>从一个节点到另一个节点，传送数据帧是数据链路层的职责；</li><li>数据链路层地址：一个设备可以静态或动态地找到另一个设备的数据链路层地址。该层的地址不是通用的；</li><li>差错控制和流量控制，方法与传输层相同。</li></ul></li><li>数据链路层协议：以太网协议(当前使用的主流局域网)使用48位地址，该地址通常被写成十六进制格式。如，07:01:02:11:2C:5B。数据链路层地址经常被称为物理地址或介质访问控制地址(MAC)地址。</li></ul></li></ul><p>&nbsp;</p><ul><li>物理层：<ul><li>物理层的功能：使用物理介质传输二进制流。数据链路层的传送单元是帧，而物理层的传送单元是二进制位；帧中的每个位被转化为电磁信号，通过物理介质(无线或电缆)传播；</li><li>物理层不需要地址，传播方式是广播。</li></ul></li></ul><p>&nbsp;</p><ul><li>层的总结。</li></ul><p><img src="./Image-jsj49.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson7-操作系统"><a href="#Lesson7-操作系统" class="headerlink" title="Lesson7 操作系统"></a>Lesson7 操作系统</h2><h3 id="NO7-1-操作系统的功能"><a href="#NO7-1-操作系统的功能" class="headerlink" title="NO7.1 操作系统的功能"></a>NO7.1 操作系统的功能</h3><p>操作系统是计算机硬件和用户的一个接口。使得其它程序更加方便有效地运行，并能方便地对计算机硬件和软件资源进行访问。</p><ul><li>操作系统的功能：<ul><li>有效的使用硬件；</li><li>方便的使用资源。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO7-2-演化"><a href="#NO7-2-演化" class="headerlink" title="NO7.2 演化"></a>NO7.2 演化</h3><p>操作系统的演化过程：批处理系统—-分时系统—-个人系统—-并行系统—-分布式系统—-实时系统。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO7-3-组成部分"><a href="#NO7-3-组成部分" class="headerlink" title="NO7.3 组成部分"></a>NO7.3 组成部分</h3><p>现在的操作系统十分复杂，因为它必须可以管理系统中的不同资源。</p><ul><li>每个操作系统都有用户界面，简单讲就是用来接收用户输入，并向操作系统解释这些请求的程序。</li></ul><p>&nbsp;</p><ul><li><p>现代操作系统至少具有以下四种功能：</p><ul><li><p>内存管理；</p></li><li><p>进程管理；</p></li><li><p>设备管理；</p></li><li><p>文件管理。</p><p>  <img src="./Image-jsj50.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO7-4-主流的操作系统"><a href="#NO7-4-主流的操作系统" class="headerlink" title="NO7.4 主流的操作系统"></a>NO7.4 主流的操作系统</h3><p>了解常用的三种系统。</p><ul><li>日常生活常用的三种操作系统：<ul><li>UNIX：是多用户、多道程序、可移植的操作系统，被设计用来方便变成、文本处理、通信。主要由四个部分构成：内核、命令解释器、一组标准工具和应用程序；</li><li>Linux：主要由内核、系统库、系统工具组成；</li><li>Windows NT/2000/XP：微软发布，设计目标是可扩展性、可移植性、可靠性、兼容性和性能；</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson8-算法"><a href="#Lesson8-算法" class="headerlink" title="Lesson8 算法"></a>Lesson8 算法</h2><p>这一章在这里不做学习，会单独作为一门课程学习</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson9-程序设计语言"><a href="#Lesson9-程序设计语言" class="headerlink" title="Lesson9 程序设计语言"></a>Lesson9 程序设计语言</h2><h3 id="NO9-1-计算机语言的演化"><a href="#NO9-1-计算机语言的演化" class="headerlink" title="NO9.1 计算机语言的演化"></a>NO9.1 计算机语言的演化</h3><p>计算机语言经过多年的发展，已经从机器语言发展到了高级语言。</p><ul><li>计算机语言的演化过程：<ul><li>机器语言；<ul><li>在计算机发展的早期，唯一的程序设计语言是机器语言；</li><li>机器语言由“0”和“1”构成；</li><li>机器语言是计算机硬件唯一能理解的语言。</li></ul></li><li>汇编语言；<ul><li>由于机器语言的编写难度大等问题而产生的汇编语言；</li><li>汇编语言使用的是助记符，即是机器语言的一种便于记忆的书写格式；如，mov ax,8；</li><li>使用编译器，把汇编语言编写的程序转译成机器语言。</li></ul></li><li>高级语言。<ul><li>为了提高程序员效率以及从关注计算机转移到关注要解决的问题，导致了高级语言的发展；</li><li>高级语言最后仍然要被编译成机器语言，然后运行；</li><li>常见的高级语言有，C、C++、Java等等。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO9-2-翻译"><a href="#NO9-2-翻译" class="headerlink" title="NO9.2 翻译"></a>NO9.2 翻译</h3><p>使用高级语言编写的程序，称为源程序。被翻译成的机器语言称为目标程序。</p><ul><li>程序翻译成机器语言的方式有两种：<ul><li>编译：编译的时候，编译器会把源文件处理一遍，生成一个目标文件，然后再执行这个目标文件。该方式类似于做好了一桌子菜再吃饭；</li><li>解释：边处理源文件，边执行。这个方式类似于吃火锅，边烫边吃。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO9-3-编程模式"><a href="#NO9-3-编程模式" class="headerlink" title="NO9.3 编程模式"></a>NO9.3 编程模式</h3><p>编程模式：是指计算机语言看待要解决的问题的方式。</p><ul><li>计算机语言可以分成4种模式：<ul><li>过程式：面向业务逻辑，从上到下的写代码。常见的过程式语言有，C、Pascal等等；</li><li>面向对象：对函数进行分类和封装，让开发“更快更好更强”。常见的面向对象语言有，C++、Java等等；</li><li>函数式：将某个功能代码封装到函数值，以后就不需要重复编写，只要调用函数即可。常见的函数式语言有，LISP等等；</li><li>说明式：使用逻辑推理的逻辑型程序设计语言。如，Prolog。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson10-软件工程"><a href="#Lesson10-软件工程" class="headerlink" title="Lesson10 软件工程"></a>Lesson10 软件工程</h2><h3 id="NO10-1-软件生命周期"><a href="#NO10-1-软件生命周期" class="headerlink" title="NO10.1 软件生命周期"></a>NO10.1 软件生命周期</h3><p>开发一个软件需要经过许多的步骤。</p><ul><li>软件的生命周期：</li></ul><p><img src="./Image-jsj51.png" srcset="/img/loading.gif" alt="Image"></p><p><code>说明：使用和修改这两个步骤一直进行下去，直到软件过时。</code></p><p>&nbsp;</p><ul><li>软件的开发过程包括四个阶段：分析、设计、实现和测试。</li></ul><p>&nbsp;</p><ul><li><p>最常见的两种开发模型：</p><ul><li><p>瀑布模型，这个模型的特点是，前一个阶段不结束，后一个阶段不能开始，且一旦出现问题，必须要检查整个过程；</p></li><li><p>增量模型，该模型首先完成一个简略版本，但不包括细节，随着时间的增加，逐渐增加细节功能。</p><p><img src="./Image-jsj52.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-jsj53.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson11-数据结构"><a href="#Lesson11-数据结构" class="headerlink" title="Lesson11 数据结构"></a>Lesson11 数据结构</h2><p>这一章在这里不做学习，会单独作为一门课程学习</p><h2 id="Lesson12-抽象数据类型"><a href="#Lesson12-抽象数据类型" class="headerlink" title="Lesson12 抽象数据类型"></a>Lesson12 抽象数据类型</h2><p>这一章在这里不做学习，是数据结构的更抽象化，学习的性价比暂时不高</p><h2 id="Lesson13-文件结构"><a href="#Lesson13-文件结构" class="headerlink" title="Lesson13 文件结构"></a>Lesson13 文件结构</h2><p>这一章在这里不做学习，是数据库章节的前序，学习的性价比暂时不高</p><h2 id="Lesson14-数据库"><a href="#Lesson14-数据库" class="headerlink" title="Lesson14 数据库"></a>Lesson14 数据库</h2><p>这一章在这里不做学习，会单独作为一门课程学习</p><h2 id="Lesson15-数据压缩"><a href="#Lesson15-数据压缩" class="headerlink" title="Lesson15 数据压缩"></a>Lesson15 数据压缩</h2><p>这一章在这里不做学习，学习的性价比暂时不高</p><h2 id="Lesson16-安全"><a href="#Lesson16-安全" class="headerlink" title="Lesson16 安全"></a>Lesson16 安全</h2><p>这一章在这里不做学习，学习的性价比暂时不高    </p><h2 id="Lesson17-计算理论"><a href="#Lesson17-计算理论" class="headerlink" title="Lesson17 计算理论"></a>Lesson17 计算理论</h2><p>这一章在这里不做学习，学习的性价比暂时不高 </p><h2 id="Lesson18-人工智能"><a href="#Lesson18-人工智能" class="headerlink" title="Lesson18 人工智能"></a>Lesson18 人工智能</h2><p>这一章在这里不做学习，学习的性价比暂时不高 </p>]]></content>
    
    
    <categories>
      
      <category>1.대학교 일 학년</category>
      
      <category>01.计算机科学导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大一课程</tag>
      
      <tag>计算机</tag>
      
      <tag>科学导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01.Git和GitHub--学习笔记</title>
    <link href="/2020/06/25/GitAndGitHub--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/06/25/GitAndGitHub--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Git和GitHub–学习笔记-包含Git视频"><a href="#Git和GitHub–学习笔记-包含Git视频" class="headerlink" title="Git和GitHub–学习笔记(包含Git视频)"></a><strong>Git和GitHub–学习笔记(包含Git视频)</strong></h1><h2 id="Lesson1-Git概述"><a href="#Lesson1-Git概述" class="headerlink" title="Lesson1 Git概述"></a>Lesson1 Git概述</h2><h3 id="NO1-1-Git简介"><a href="#NO1-1-Git简介" class="headerlink" title="NO1.1 Git简介"></a>NO1.1 Git简介</h3><p>什么是Git呢？Git其实就是一个工具，用于控制代码版本的工具。</p><ul><li><p>Git：</p><ul><li><p>定义：是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或大或小的项目；</p></li><li><p>Git和Svn的区别：</p><ul><li><p>Git是分布式的，SVN不是。这是Git和其它非分布式的版本控制系统(如，SVN，CVS等)最核心的区别；</p></li><li><p>Git把内容按元数据方式存储，而SVN是按文件。所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn、.cvs等的文件夹里；</p></li><li><p>Git分支和SVN的分支不同。分支在SVN中一点都不特别，其实它就是版本库中的另外一个目录；</p></li><li><p>Git没有一个全局的版本号，而SVN有。目前为止这是跟SVN相比，Git缺少的最大的一个特征；</p></li><li><p>Git的内容完整性要优于SVN。Git的内容存储使用的是SHA-1哈希算法，这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</p><p>  <img src="./Image-git1.png" srcset="/img/loading.gif" alt="Image"></p></li></ul></li></ul><p>&nbsp;</p></li><li><p>Git结构可以抽象成几个区域：</p><ul><li><p>工作区：即workspace，也就是你在电脑里能看到的目录，其实就是自己写的文件；</p></li><li><p>暂存区(也叫索引)：即stage，也就是我们写好的代码文件你肯定要暂时保存起来吧(因为极大可能要修改或提交到版本库等等，常做变动)，就存放在这里，一般存放在”.git”目录下的index文件中，也就是”.git/index”中，所以我们把暂存区也叫做索引(index)；</p></li><li><p>版本库：存放已经提交的数据，执行git push命令的时候，就是把这个区的数据push到远程git仓库。</p><p>  <img src="./Image-git2.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul><p>&nbsp;</p><ul><li>Git的工作流程：<ul><li>写代码(修改工作区)；</li><li>把写好的或修改的文件加入到暂存区，使用命令：git add 文件名；</li><li>把暂存区的修改提交到版本库中，使用命令：git commit；</li><li>此时本地版本库就跟远程仓库(就是我们常用的GitHub、码云、GitLab等等)状态不同了，把版本库推送到远程仓库保持同步：git push。</li></ul></li></ul><p>&nbsp;</p><ul><li><p>Git安装：</p><ul><li><p>Git安装比较简单，按照一般的安装步骤操作即可，这里不做过多的叙述。安装完成后，对着桌面，单机鼠标右键，出现如下图所示，表示安装完成。</p><p>  <img src="./Image-git3.png" srcset="/img/loading.gif" alt=""></p><p>  <code>说明：Git Bash：是Unix与Linux风格的命令行，也是使用的最多，推荐的最多的；Git GUI：图形界面的Git，不建议初学者使用，因为无法熟悉常用Git命令。</code></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-2-GitHub简介"><a href="#NO1-2-GitHub简介" class="headerlink" title="NO1.2 GitHub简介"></a>NO1.2 GitHub简介</h3><p>GitHub、码云…等等，都是用来保存和管理代码。</p><ul><li><p>GithHub：</p><ul><li><p>定义：也叫代码托管中心，即用来维护Git的远程仓库的，说白了就是维护我们提交到远程仓库的代码。可分为：</p><ul><li><p>局域网环境，该环境下有：GitLab服务器；</p></li><li><p>互联网环境，该环境下有：GitHub、码云。</p><p>  <img src="./Image-git4.png" srcset="/img/loading.gif" alt=""></p><p>  <code>说明：执行流程解释：项目经理将项目，经过在工作区编写和修改、临时存入暂存区等待提交、提交到版本库(也叫版本库)中、最后再由版本库交给代码托管中心进行管理，体现了团队合作的流程。</code></p><p>  <img src="./Image-git5.png" srcset="/img/loading.gif" alt=""></p><p>  <code>说明：执行流程解释：和上面的执行流程基本一致，不同的是，多了一个第三方可以对目标项目进行修改等操作，当然在发送给第三方前会将项目复制一份给第三方，然后等到第三方提交的时候，会进行审核，毕竟不是什么代码都能加进某个项目中的；审核通过，才会将第三方修改的代码加入进项目中。如，Linux就是部分开源。</code></p></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="Lesson2-Git基础"><a href="#Lesson2-Git基础" class="headerlink" title="Lesson2 Git基础"></a>Lesson2 Git基础</h2><h3 id="NO2-1-Git常用命令"><a href="#NO2-1-Git常用命令" class="headerlink" title="NO2.1 Git常用命令"></a>NO2.1 Git常用命令</h3><p>我们使用Git，将我们编写好的代码上传到GitHub进行统一管理。</p><ul><li>创建版本库：<ul><li><code>git init</code>：在当前目录下创建版本仓库。因为Git的很多命令都需要在Git的仓库中运行，所以该命令是使用Git的第一个命令；</li></ul></li></ul><p>&nbsp;</p><ul><li><p>设置签名：</p><ul><li><p>作用：签名的作用是标识不同开发人员的身份，主要是名称和邮箱。不过这签名和代码托管中心没有任何关系，如果没有设置签名，那么有可能在使用命令时，系统由于分辨不出身份而导致出错。签名有两种级别：</p><ul><li>项目级别：即仅仅在当前版本库范围内有效；<ul><li><code>git config user.name xxx和git config user.email xxx</code>：分别设置开发者的名称和邮箱。</li></ul></li><li>系统级别：即登录当前操作系统的用户，这个范围内有效(常用的是这个级别)。<ul><li><code>git config --global user.name xxx和git config --global user.emailxxx</code>：分别设置开发者的名称和邮箱。<strong><code>注意：两个级别的签名信息都有时，根据就近原则，会以项目级别的为准。</code></strong></li></ul></li></ul></li><li><p><code>cat ~/.gitconfig</code>：查看自己设置的Git用户名称和邮箱。</p><p>  <img src="./Image-git6.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>查看状态：</p><ul><li><p><code>git status [选项]</code>：用于显示工作目录和暂存区的状态，但不会显示已经提交到项目历史中去的消息。选项如下：</p><ul><li><p><code>-s</code>：以简短模式查看本地仓库的状态，会显示两列，第一列是文件的状态，第二列是对应的文件；其中文件状态有：A表示新增，M表示修改，D表示删除，??表示未添加到Git中。</p><p>  <img src="./Image-git7.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>添加：</p><ul><li><p><code>git add 文件名  [选项]</code>：用于将工作区中指定的文件存添加暂存区；如果文件名前面不加路径，默认是在当前路径下找该文件。选项如下：</p><ul><li><p><code>-u/--update</code>：添加所有修改、已删除的文件到暂存区中；</p></li><li><p><code>-A/--all</code>：添加所有修改、已删除、新增的文件到暂存区中；</p></li><li><p><code>-i/--interactive</code>：查看所有修改、已删除但没有提交的文件，进入一个子命令系统。</p><p>  <img src="./Image-git8.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>提交：</p><ul><li><p><code>git commit [选项]</code>：用于将暂存区中的文件，提交到版本库，除了文件以外，修改文件内容的用户和日志信息也会一起存储在这个提交中。选项如下：</p><ul><li><p><code>-m</code>：格式为-m “本次提交的描述信息”，即将暂存区文件提交到版本库，并添加这一次提交的描述信息；如果不添加该参数，那么在提交时，会给你一个vim文本编辑器来编辑你要添加时的message；</p></li><li><p><code>-a</code>：将所有已跟踪文件中(即曾经有提交到版本库的记录)的执行修改或删除操作的文件都提交到本地仓库，即使它们没有经过git add添加到暂存区；但是新添加的文件，且没有提交过版本库的文件还是要先add再commit才行，即这些文件不适用-a参数；</p></li><li><p><code>--amend</code>：修改上次提交的描述信息。</p><p>  <img src="./Image-git9.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>删除：<ul><li><code>git rm  [选项] 文件名</code>：用于同时从工作区和索引(也就是暂存区)中删除文件。选项如下：<ul><li><code>--cached</code>：用于将暂存区的文件恢复到工作区，也就是从暂存区中删除这个文件，但是本地文件还存在，只是不想该文件再被版本控制；</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>查看日志：</p><ul><li><p><code>git log  [选项]</code>：用于显示提交的所有日志信息，也就是你提交过的历史版本信息；但是无法查看已删除的commit记录。选项如下：</p><ul><li><code>-n</code>：显示最新提交的n条记录；</li><li><code>commitID</code>：显示从第一次提交到指定commitID为止的所有提交的记录；</li><li><code>--oneline</code>：用一行来显示提交的日志信息；</li></ul></li><li><p><code>git reflog</code>：查看所有分支的所有操作记录(包括commit和reset的操作)，包括已经被删除的commit记录。</p><p>  <img src="./Image-git10.png" srcset="/img/loading.gif" alt=""></p><p>  <img src="./Image-git11.png" srcset="/img/loading.gif" alt=""></p><p>  <img src="./Image-git12.png" srcset="/img/loading.gif" alt=""></p><p>  <img src="./Image-git13.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>版本回退：</p><ul><li><p><code>git reset  [选项]</code>：将暂存区的文件撤回工作区，默认撤回的是HEAD指向的文件。选项如下：</p><ul><li><p><code>--soft  commitID</code>：将HEAD指向的文件的版本库版本移动到指定的版本。只移动版本库的HEAD指针，即版本库的版本落后了，但是暂存区和工作区的文件版本没有变更，也就是说，此时暂存区和工作区的版本要比版本库新一些；</p></li><li><p><code>--mixed commitID</code>：将HEAD指向的文件的版本库、暂存区(两个区)的版本都移动到指定的版本。只移动版本库和暂存区的HEAD，即此时版本库和暂存区的版本都落后了，而工作区的版本却是最新的；</p></li><li><p><code>--hard commitID</code>：将HEAD指向的文件的版本库、暂存区、工作区(三个区)的版本移动到指定的版本，但跳到该版本以后，其版本之后添加的文件内容将不会存在。</p><p>  <img src="./Image-git14.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>比较文件：</p><ul><li><p><code>git diff [选项] 文件名</code>：用于比较两个区域中的文件差异，默认比较的是工作区和暂存区；另外如果不带文件名进行比较，默认是将当前目录下所有文件与暂存区的版本进行比较(前提是要工作区里有修改过的文件)。选项如下：</p><ul><li><p><code>HEAD</code>：比较的是暂存区和版本库里的文件。</p><p>  <img src="./Image-git15.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-2-Git分支和分支常用命令"><a href="#NO2-2-Git分支和分支常用命令" class="headerlink" title="NO2.2 Git分支和分支常用命令"></a>NO2.2 Git分支和分支常用命令</h3><p>分支，顾名思义，就是从主干上分化出来的一部分，但不会影响主干(即master)。</p><ul><li>分支：<ul><li>定义：Git分支，其实就是将主干代码的副本，然后不同的开发人员在各自创建的分支上进行开发工作，最后再合并，既没有影响到原来主干的代码进度，开发人员也完成了他们的任务；</li><li>优点：<ul><li>可以同时并行多个开发任务；</li><li>就是分支开发失败，也不会影响主干。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>查看、创建、修改、删除分支：</p><ul><li><p><code>git branch  [选项]</code>：不添加参数选项，则列出本地所有的分支，当前所在分支以“*”标出。选项如下：</p><ul><li><p><code>-v</code>：列出本地所有的分支，当前所在分支以 “*” 标出，并显示最后一次提交；</p></li><li><p><code>分支名</code>：创建一个新的分支，新的分支基于上一次提交建立；</p></li><li><p><code>-m 原分支名称 新分支名称</code>：修改分支名称。如果不指定原分支名称则默认为当前所在分支；</p></li><li><p><code>-M 原分支名称 新分支名称</code>：强制修改分支名称。如果不指定原分支名称则默认为当前所在分支；</p></li><li><p><code>-d 分支名称</code>：删除指定的本地分支；</p></li><li><p><code>-D 分支名称</code>：强制删除指定的本地分支。</p><p>  <img src="./Image-git16.png" srcset="/img/loading.gif" alt=""></p><p>  <img src="./Image-git17.png" srcset="/img/loading.gif" alt=""></p><p>  <img src="./Image-git18.png" srcset="/img/loading.gif" alt=""> </p><p>  <img src="./Image-git19.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>切换分支和替换工作区文件：</p><ul><li><p><code>git checkout  [选项]</code>：该命令主要有两个功能；选项如下：</p><ul><li><p><code>分支名</code>：切换到已存在的指定分支中去；</p></li><li><p><code>-b 分支名</code>：创建并切换到指定的分支，保留所有的提交记录。等同于git branch和git checkout两个命令合并；</p></li><li><p><code>--orphan</code>：创建并切换到指定的分支，删除所有的提交记录；</p></li><li><p><code>文件名</code>：将暂存区的指定文件，替换掉当前工作区的指定文件，即同一个文件下，当前工作区里文件的内容，被暂存区里的文件内容替换掉了，也就是重写了工作区的文件内容。</p><p>  <img src="./Image-git20.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>合并分支：</p><ul><li><p><code>git merge 分支名</code>：首先要切换到被合并的分支下(一般都是主干)，把指定的分支合并到当前所在的分支下；另外如果从远程仓库拉取了文件的最新版本后，需要将该版本和本地工作区的文件进行合并，则使用：git merge 远程仓库别名/分支名。<strong><code>注意：当合并分支时出现合并冲突，我们需要转为手动合并：即在协商之后决定保留冲突中的哪一部分内容，最后需要git add和git commit -m &quot;提交信息&quot;这两个命令来结束合并状态即可。</code></strong></p><p>  <img src="./Image-git21.png" srcset="/img/loading.gif" alt=""> </p><p>  <img src="./Image-git22.png" srcset="/img/loading.gif" alt=""></p><p>  <img src="./Image-git23.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-3-Git版本库与GitHub-代码托管中心"><a href="#NO2-3-Git版本库与GitHub-代码托管中心" class="headerlink" title="NO2.3 Git版本库与GitHub(代码托管中心)"></a>NO2.3 Git版本库与GitHub(代码托管中心)</h3><p>Git只是用来与远程仓库互动的一个工具，我们还需要与代码托管中心进行关联。</p><ul><li><p>关联Git版本库与GitHub远程仓库，并push文件的步骤：</p><ul><li><p>注册GitHub，并登陆到GitHub上，创建一个public或者private权限的自定义名称的仓库，这个仓库就是我们用来存储从Git版本库上传的代码文件所使用的仓库；</p></li><li><p>在Git上，创建一个新的文件夹作为版本库，使用git init命令即可；然后编写一个代码文件，按顺序使用git add和git commit命令分别上传到暂存库、版本库中；</p></li><li><p>关联版本库和远程仓库，也就是告诉版本库，把我想要存储的代码文件发送到哪里去。使用如下命令进行操作：</p><ul><li><code>git remote [选项]</code>：列出已经存在的远程仓库；选项如下：<ul><li><code>-v/--verbose</code>：列出远程仓库的详细信息，在别名后面列出URL地址；</li><li><code>add 远程仓库的别名 远程仓库的URL地址</code>：添加远程仓库，即将当前的版本库与指导的远程仓库进行关联；</li><li><code>rename 原远程仓库的别名 新的别名</code>：修改远程仓库的别名；</li><li><code>remove 远程仓库的别名</code>：删除指定名称的远程仓库；</li><li><code>set-url 远程仓库的别名 新的远程仓库URL地址</code>：修改远程仓库的URL地址。</li></ul></li></ul></li><li><p>关联成功以后，就可以push代码文件了。使用如下命令进行操作：</p><ul><li><p><code>git push [选项]</code>：该命令用来将本地库中的文件推送到远程仓库中去。选项如下；<strong><code>注意：这里可能会出现一个异常，你的远程仓库有个文件README.md(也可能没有这个文件)，但是本地仓库却没有，就会出现“failed to push some refs to...”这种情况，所以无论远程仓库中是否有README.md文件，第一次push都需要把这个文件push到你的远程仓库中去，在当前目录下直接创建README.md文件，然后使用命令：git push -u 你自己的远程仓库别名 master，其中master是你每个新建远程仓库的默认分支，输入后，会要你输入登录到GitHub的账号和密码，要输入两次，第二次是免密SSH登录，输入后就可以顺利push文件到远程仓库了。</code></strong></p><ul><li><p><code>远程仓库的别名 本地分支名:远程分支名</code>：把本地仓库的分支推送到远程仓库的指定分支；如果省略远程分支名，则默认推送到与本地分支存在追踪关系的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建；</p></li><li><p><code>远程仓库的别名 :远程分支名/远程仓库的别名 --delete 远程分支名</code>：删除指定的远程仓库的分支。如，git push aaa :abc或者git push aaa –delete abc都是删除远程层库中的某个分支。</p><p>  <img src="./Image-git24.png" srcset="/img/loading.gif" alt=""></p><p>  <img src="./Image-git25.png" srcset="/img/loading.gif" alt=""></p><p>  <img src="./Image-git26.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>第一次从远程仓库下载代码文件到本地，有两种方式：</p><ul><li><p>一种是download(很简单)；</p></li><li><p>另一种则是使用git命令，我们介绍的是git命令的方式。</p><ul><li><p>从远程仓库中，找到Clone or download按钮，如下图；</p></li><li><p>开发人员在自己的工作目录中，打开Git，使用git命令：</p><ul><li><p><code>git clone 远程仓库URL [选项]</code>：不添加选项参数，则默认在当前目录下，创建和远程仓库名相同的文件夹，并下载文件到该文件夹下。选项如下；<strong><code>注意：clone命令会做三件事情：一是完整的把远程仓库下载到本地，二是创建远程地址别名(前提是要关联了本地本地库和远程仓库)，三是初始化本地库。</code></strong></p><ul><li><p><code>本地目录</code>：将clone的分支放到指定的本地仓库目录中；</p></li><li><p><code>b 分支名称 本地目录</code>：指定要克隆的分支，默认是master分支。</p><p>  <img src="./Image-git27.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>开发人员在修改了代码后，需要上传到GitHub中，但是这时候可能没有权限提交，所以项目经理一般都会将开发人员都邀请加入公司创建的GitHub中，这样开发人员就有权限提交代码到公司的GitHub中了；最后再使用git push命令，push修改过的代码就行了。</p><p>  <img src="./Image-git28.png" srcset="/img/loading.gif" alt=""></p></li></ul><p>&nbsp;</p><ul><li>如果需要拉取最新版本的文件到本地，则使用：<ul><li><code>git fetch [选项]</code>。选项如下：<ul><li><code>远程仓库的别名</code>：将远程仓库所有分支的最新版本全部取回到本地；</li><li><code>远程仓库的别名 分支名</code>：将远程仓库指定分支的最新版本取回到本地。</li></ul></li><li><code>git pull</code>：从远程仓库获取最新版本并合并到本地；即等同于执行了git fetch和git merge两条命令。效率上git pull更快一些，但是不一定安全，因为git fetch可以进行有选择的合并，所以根据工作中的需求，选择合适的拉取命令方式才是正确的。</li></ul></li><li>协同开发冲突问题：在开发者，经常会遇到两个人同时在修改一个文件的问题，即当同事A上传了对C文件的修改后，紧接着同事B也上传了对C文件的修改，此时GitHub就会出现冲突，即不知道该听那个开发者的，C文件中应该使用谁的内容才是正确的，所以为了避免出现这种问题，GitHub规定，出现这种情况时，另一个人应该先更新自己的本地文件，即保证自己本地是最新版本，然后再做修改即可。<strong><code>注意：解决冲突后，最后提交文件时，不要带文件名，只需要带上提交的说明信息(即-m参数)，直接提交即可。</code></strong></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-4-IDEA工具中使用Git"><a href="#NO2-4-IDEA工具中使用Git" class="headerlink" title="NO2.4 IDEA工具中使用Git"></a>NO2.4 IDEA工具中使用Git</h3><p>IDEA默认集成了Git工具。</p><ul><li><p>IDEA中使用Git将项目push到远程仓库，如下列图中所示：</p><p>  <img src="./Image-git29.png" srcset="/img/loading.gif" alt=""></p><p>  <img src="./Image-git30.png" srcset="/img/loading.gif" alt=""></p><p>  <img src="./Image-git31.png" srcset="/img/loading.gif" alt=""></p><p>  <code>说明：测试成功会出现这个。</code></p><p>  <img src="./Image-git32.png" srcset="/img/loading.gif" alt=""></p><p>  <img src="./Image-git33.png" srcset="/img/loading.gif" alt="">  </p><p>  <code>说明：点击Create Git Repository后，会出现如上所示，意思就是我要给这个项目init(也就是创建)一个版本库。</code></p><p>  <img src="./Image-git34.png" srcset="/img/loading.gif" alt=""></p><p>  <code>说明：将文件add到暂存区。</code></p><p>  <img src="./Image-git35.png" srcset="/img/loading.gif" alt=""></p><p>  <code>说明：选中项目，将项目add到暂存区。</code></p><p>  <img src="./Image-git36.png" srcset="/img/loading.gif" alt=""></p><p>  <code>说明：进行commit操作，提交到版本库中。</code></p><p>  <img src="./Image-git37.png" srcset="/img/loading.gif" alt=""></p><p>  <img src="./Image-git38.png" srcset="/img/loading.gif" alt=""></p><p>  <code>说明：使用IDEA集成Git，push代码文件到远程仓库；首先，需要配置登录到GitHub的账户，就是你平常登录到GitHub的账号和密码。</code></p><p>  <img src="./Image-git39.png" srcset="/img/loading.gif" alt=""></p><p>  <code>说明：配置远程仓库的url，也就是关联远程仓库。</code></p><p>  <img src="./Image-git40.png" srcset="/img/loading.gif" alt=""></p><p>  <code>说明：在这里面设置远程仓库的url即可。</code></p><p>  <img src="./Image-git41.png" srcset="/img/loading.gif" alt=""></p><p>  <code>说明：最后，选择push命令就可以将代码push到远程仓库了。</code></p><p>  <img src="./Image-git42.png" srcset="/img/loading.gif" alt=""></p><p>  <img src="./Image-git43.png" srcset="/img/loading.gif" alt=""></p></li></ul><p>&nbsp;</p><ul><li><p>开发人员从远程仓库clone项目代码到本地。</p><ul><li><p>首先在远程仓库里复制一下远程仓库的url；</p><p>  <img src="./Image-git44.png" srcset="/img/loading.gif" alt=""></p><p>  <img src="./Image-git45.png" srcset="/img/loading.gif" alt=""></p><p>  <code>说明：选择VCS，再选择Checkout from Version Control选项，最后选择Git。</code></p><p>  <img src="./Image-git46.png" srcset="/img/loading.gif" alt=""></p><p>  <code>说明：在弹出的框中，填入远程仓库的url，并可以点击Test，测试是否能够连接，连接成功会出现以上绿色框中的提示；其中Directory则是指你要将clone下来的项目文件放在本地哪个位置，最后点击Clone即可；另外当开发人员修改了项目代码之后，需要push项目文件到远程仓库，这个时候也要注意，需要得到远程仓库管理人员的权限邀请，即管理人员没有邀请你的话，你哪怕写好了代码，也是无法提交到远程仓库的；最后，远程仓库默认使用的是Clone时使用远程仓库url。</code></p></li></ul></li></ul><p>&nbsp;</p><ul><li><p>当别人push了新代码之后，你需要更新自己的本地代码，按下图操作即可。</p><p>  <img src="./Image-git47.png" srcset="/img/loading.gif" alt=""></p><p>  <img src="./Image-git48.png" srcset="/img/loading.gif" alt=""></p><p>  &nbsp;</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>5.다른 과정</category>
      
      <category>05.版本控制框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
