<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C语言--学习笔记</title>
    <link href="/2020/06/26/C%E8%AF%AD%E8%A8%80--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/06/26/C%E8%AF%AD%E8%A8%80--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言–学习笔记-包含C语言视频、C-Primer-Plus书籍"><a href="#C语言–学习笔记-包含C语言视频、C-Primer-Plus书籍" class="headerlink" title="C语言–学习笔记(包含C语言视频、C Primer Plus书籍)"></a>C语言–学习笔记(包含C语言视频、C Primer Plus书籍)</h1><h2 id="Lesson1-C语言概述"><a href="#Lesson1-C语言概述" class="headerlink" title="Lesson1 C语言概述"></a>Lesson1 C语言概述</h2><h3 id="NO1-1-C语言简介"><a href="#NO1-1-C语言简介" class="headerlink" title="NO1.1 C语言简介"></a>NO1.1 C语言简介</h3><p>1972年，贝尔实验室的丹尼斯·里奇(Dennis Ritch)和肯·汤普逊(Ken Thompson)在开发UNIX操作系统时设计了C语言，而C语言是在B语言的基础上进行设计的。</p><ul><li>C语言的特点：运行的高效性(C语言程序紧凑、运行速度很快)、可移植性(移植到别的平台时，几乎不用改什么代码)、强大而灵活(如，UNIX大部分是用C写的)等等。</li></ul><p>&nbsp;</p><ul><li>C语言的应用范围很广：游戏开发、嵌入式软件开发、操作系统等等。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-2-语言标准"><a href="#NO1-2-语言标准" class="headerlink" title="NO1.2 语言标准"></a>NO1.2 语言标准</h3><p>美国国家标准协会(ANSI)于1983年组建了一个委员会，开发了一套新标准，并于1989年正式公布。</p><ul><li>ANSI C标准定义了C语言和C标准库。国际标准化组织于1990年采用了这套C标准(ISO C)。ISO C和ANSI C是完全相同的标准。ANSI/ISO标准的最终版本通常叫作C89或C90。1994年，发布了C99标准。而在2011年12月8日，发布了C11标准。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-3-C语言的编程机制"><a href="#NO1-3-C语言的编程机制" class="headerlink" title="NO1.3 C语言的编程机制"></a>NO1.3 C语言的编程机制</h3><p>C编程的基本策略是：用程序把源代码文件转换为可执行文件(其中包含可直接运行的机器语言代码)。</p><ul><li>编程机制：<ul><li>用C语言编写程序时，编写的内容被储存在文本文件中，该文件被称为源代码文件；</li><li>编译器把源代码转换成中间代码，可因为中间文件有多种形式，我们在这里描述的是最普遍的一种形式，即把源代码转换为机器语言代码，虽然此时目标代码文件里包含了机器语言代码，但仍然不是一个完整的程序，所以还不能直接运行；</li><li>目标代码文件缺失启动代码，启动代码充当着程序和操作系统之间的接口，系统不一样，需要的启动代码也是不一样的；</li><li>目标代码还缺少库函数，几乎所有的C程序都要使用C标准库中的函数；</li><li>最后，链接器把你编写的目标代码、系统的标准启动代码和库代码这三部分合并成一个文件，即可执行文件。对于库代码，链接器只会把程序中要用到的库函数代码提取出来。</li></ul></li></ul><p><img src="./Image-c1.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-4-VS2019的安装和第一个C程序"><a href="#NO1-4-VS2019的安装和第一个C程序" class="headerlink" title="NO1.4 VS2019的安装和第一个C程序"></a>NO1.4 VS2019的安装和第一个C程序</h3><p>目前主流的C语言集成开发环境，有Visual Studio 2019等等，这里是从VS2019。</p><ul><li>我们到VS2019官网去下载最新版本的即可。<strong><code>注意：常用的注释快捷键为ctrl+k+c，取消注释的快捷键为ctrl+k+u。</code></strong></li></ul><p><img src="./Image-c2.png" srcset="/img/loading.gif" alt="Image"><br><code>说明：一般，Community版本就够我们个人使用了，其他两个版本需要购买并激活才能使用。</code></p><p>&nbsp;</p><p><img src="./Image-c3.png" srcset="/img/loading.gif" alt="Image"><br><code>说明：下载后，选择自己要安装的版本即可。</code></p><p>&nbsp;</p><p><img src="./Image-c4.png" srcset="/img/loading.gif" alt="Image"><br><code>说明：一般选择图中的Windows平台开发和C++的桌面开发就可以了，其他的默认即可，不需要改动什么。</code></p><p>&nbsp;</p><p><img src="./Image-c5.png" srcset="/img/loading.gif" alt="Image"><br><code>说明：中间的下载缓存里，那个“安装完成后保留下载缓存”选项一定要打勾，否则会出BUG。</code></p><p>&nbsp;</p><p><img src="./Image-c6.png" srcset="/img/loading.gif" alt="Image"><br><code>说明：下载完成后，打开VS2019，选择创建新项目。</code></p><p>&nbsp;</p><p><img src="./Image-c7.png" srcset="/img/loading.gif" alt="Image"></p><p><code>说明：选择Windows桌面向导。</code></p><p>&nbsp;</p><p><img src="./Image-c8.png" srcset="/img/loading.gif" alt="Image"><br><code>说明：添加项目名称，以及项目的工作空间，最后点击创建。</code></p><p>&nbsp;</p><p><img src="./Image-c9.png" srcset="/img/loading.gif" alt="Image"></p><p><code>说明：选择控制台应用程序，并勾选功空项目即可。</code></p><p>&nbsp;</p><p><img src="./Image-c10.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-c11.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-c12.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-c13.png" srcset="/img/loading.gif" alt="Image"><br><code>说明：点击工具，选择选项，分别在文本编辑器、命令窗口、输出窗口中将字体根据自己的偏好设置一下就可以了。</code></p><p>&nbsp;</p><p><img src="./Image-c14.png" srcset="/img/loading.gif" alt="Image"><br><code>说明：在右侧窗口，找到源文件，右键添加，选择新建项。</code></p><p>&nbsp;</p><p><img src="./Image-c15.png" srcset="/img/loading.gif" alt="Image"></p><p><code>说明：在弹出的对话框中，选择C++文件，在起名的时候，使用.c后缀名即可，就可以成功创建C文件了。注意：使用快捷键Ctrl+s保存文件内容，使用Ctrl+F5运行文件。</code></p><p>&nbsp;</p><p><img src="./Image-c16.png" srcset="/img/loading.gif" alt="Image"><br><code>说明：如果出现错误，勾选“不再显示次对话框”，并点击否。</code></p><p>&nbsp;</p><ul><li><p>第一个简单的C程序。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;   //#include这是预处理指令，该行告诉编译器把stdio.h中的内容都输入到该行所在的位置，相当于粘贴复制操作；所有C编译器软件都提供了stdio.h文件，该文件提供键盘输入和屏幕输出的函数(如，printf_s()函数等)，所以这个文件是标准的输入/输出头文件</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;   <span class="hljs-comment">//main函数总是第一个被调用的函数，函数是C程序的基本模块；void表示main()函数不带任何参数</span>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;   <span class="hljs-comment">//声明一个变量，但是要注意变量名称不能太长，C99的标准允许使用更长的变量名，但编译器只能识别前63个字符，超出就识别不了了；变量名不能以数字开头，但可以用小写字母、大写字母、数字和下划线来命名</span>    printf_s(<span class="hljs-string">"这是我使用VS2019创建的第一个C文件，hello world!!!!\n"</span>);   <span class="hljs-comment">//printf_s()是一个函数；“\n”表示换行的意思</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//返回值，就是将0返回给系统</span>&#125;<span class="hljs-comment">//----------------------------------</span>一个简单的C语言程序基本语法格式：<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    语句    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><h2 id="Lesson2-C语言基础"><a href="#Lesson2-C语言基础" class="headerlink" title="Lesson2 C语言基础"></a>Lesson2 C语言基础</h2><h3 id="NO2-1-转义字符"><a href="#NO2-1-转义字符" class="headerlink" title="NO2.1 转义字符"></a>NO2.1 转义字符</h3><p>转义字符一般以“\”开头，目的是为了转义“\”后面跟的符号。</p><ul><li>常用转义字符：<ul><li><code>\t</code>：表示水平制表，说白了就是让输出的代码有个间隔的意思。<code>如，printf_s(&quot;你\t好\t啊&quot;)，原本输出结果：你好啊；现在输出：你    好    啊，中间多了空格</code>；</li><li><code>\n</code>：表示换行的意思。<code>如，printf_s(&quot;你好\n啊&quot;)，原本输出：你好啊；现在输出：“你好”两个字占一行，“啊”字又占了一行</code>；</li><li><code>\\</code>：表示输出一个“\”。<code>如，printf_s(&quot;你好\\\啊&quot;)，原本输出：你好啊；现在输出：你好\啊</code>；</li><li><code>\&quot;</code>：表示输出一个“””。<code>如，printf_s(&quot;你好\&quot;啊&quot;)，原本输出：你好啊；现在输出：你好&quot;啊</code>；</li><li><code>\&#39;</code>：表示输出一个“’”。<code>如，printf_s(&quot;你好\\&#39;啊&quot;)，原本输出：你好啊；现在输出：你好&#39;啊</code>；</li><li><code>\r</code>：表示将光标移动到本行的开头。<code>如，printf_s(&quot;你好\r啊&quot;)，原本输出：你好啊；现在输出：啊好，也就是原本输出到你好，然后又回到本行开头打印”啊“，所以”啊“把”你“字覆盖了</code>。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-2-注释、语句、表达式"><a href="#NO2-2-注释、语句、表达式" class="headerlink" title="NO2.2 注释、语句、表达式"></a>NO2.2 注释、语句、表达式</h3><p>用于解释说明代码的文字就叫做注释。注释也可以用于代码，但是注释的代码不会被编译器执行。</p><ul><li><p>注释分两种：</p><ul><li><p>单行注释：</p><ul><li>基本语法格式：<code>//需要注释的文字</code>。<code>如，//这是单行注释</code>；</li></ul></li><li><p>多行注释：</p><ul><li>基本语法格式：<code>/* 需要注释的文字 */</code>。<code>如，/*这里是多行注释*/</code>。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>表达式和语句：</p><ul><li><p>表达式：由运算符和运算对象组成。运算对象可以是常量、也可以是变量；每个表达式都有一个值；最简单的表达式是一个单独的运算对象。<code>如，6、-4等等</code>；</p></li><li><p>语句：是C程序的基本构建块。一条语句相当于一条完整的指令。语句一般以分号结尾。最简单的语句是空语句：<code>;</code>，也就是一个分号。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-number">8</span>;<span class="hljs-number">3</span>+<span class="hljs-number">4</span>;<span class="hljs-comment">//以上这些都是语句，但不算真正有效的语句，因为什么也没做</span></code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-3-标准库"><a href="#NO2-3-标准库" class="headerlink" title="NO2.3 标准库"></a>NO2.3 标准库</h3><p>标准库其实就是一些写好了的函数所组成的文件。</p><ul><li>C语言中常用的标准库有：<ul><li>&lt;asset.h&gt;：设定插入点；</li><li>&lt;ctype.h&gt;：字符处理；</li><li>&lt;errno.h&gt;：定义错误码；</li><li>&lt;float.h&gt;：浮点数处理；</li><li>&lt;limits.h&gt;：定义各种数据类型最值常量；</li><li>&lt;locale.h&gt;：定义本地化函数；</li><li>&lt;math.h&gt;：定义数学函数；</li><li>&lt;stdlib.h&gt;：定义杂项函数及内存分配函数；</li><li>&lt;stdio.h&gt;：定义输入／输出函数；</li><li>&lt;string.h&gt;：字符串处理；</li><li>&lt;time.h&gt;：定义关于时间的函数；</li><li>….等等。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-4-变量和常量"><a href="#NO2-4-变量和常量" class="headerlink" title="NO2.4 变量和常量"></a>NO2.4 变量和常量</h3><p>C语言中需要用东西来承载数据。</p><ul><li><p>变量和常量：</p><ul><li><p>变量(variable)：</p><ul><li><p>定义：就是在程序运行过程中，内部存储的值，随时可以被改变的一段内存地址空间；</p></li><li><p>基本语法基本语法格式：<code>数据类型 变量名 = 数据值</code>。<strong><code>注意：变量必须先声明，再使用；在同一个程序中，变量名不允许相同，不能使用C语言的的关键字；变量名只能用字母或下划线开头，其它字母可以是字母、数组和下划线(除了下划线，不允许有其他特殊字符)。</code></strong></p><p>  例如：</p>  <pre><code class="hljs c">include&lt;stdio.h&gt;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    ...    <span class="hljs-keyword">int</span> num = <span class="hljs-number">8</span>;  <span class="hljs-comment">//声明一个int类型的变量num</span>    <span class="hljs-keyword">char</span> c = <span class="hljs-string">'a'</span>;  <span class="hljs-comment">//声明一个char类型的变量c</span>    ...&#125;</code></pre></li></ul></li><li><p>常量(constant)：</p><ul><li><p>定义：就是在程序运行过程中，所表示的值，无法被改变的量；</p></li><li><p>基本语法基本语法格式，有两种：</p><ul><li><p>使用C预处理器声明常量(即程序在进行预编译处理时就生效)：只要在程序的顶部，添加代码：<code>#define 大写常量名 值</code>，推荐使用该方式声明常量；如果想要取消定义的常量，并重新定义常量，使用：<code>undef 大写的常量名</code>，就可以重新定义常量的值了；<strong><code>注意：定义字符常量用单引号，定义字符串常量用双引号；该方式定义常量只是简单的替换。</code></strong></p></li><li><p>使用const修饰变量(即在程序编译、运行时才生效)：<code>const 变量名 = 值</code>，一旦被第一次赋值之后，那么该变量就变为只读，不能再更改值，也就变成常量了。</p><p>  例如：</p>  <pre><code class="hljs c">include&lt;stdio.h&gt;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AGE 8  <span class="hljs-comment">//定义了一个常量AGE，值为8，这样程序中所用的同名常量都会被替换成指定的值</span></span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> AGE  <span class="hljs-comment">//取消定义AGE常量</span></span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AGE 10  <span class="hljs-comment">//重新定义AGE常量</span></span>#define NAME 'JOHN'   //定义了一个字符常量<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  ADDRESS <span class="hljs-meta-string">"CHINA"</span>   <span class="hljs-comment">//定义了一个字符串常量</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    ...<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;  <span class="hljs-comment">//使用关键字const声明int类型的常量</span>    ...&#125;</code></pre></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>limits.h头文件中和float.h头文件中，提供了一些整数类型和浮点数类型使用的常量；(了解即可)</li></ul><p><img src="./Image-c17.png" srcset="/img/loading.gif" alt="Image"> </p><p>&nbsp;</p><ul><li>位、字节和字的关系。<ul><li>位(bit)：最小的存储单元，可以储存0或1；</li><li>字节(byte)：是常用的计算机存储单位。对于几乎所有的机器，1个字节 = 8位，即1 byte = 8 bit，这是字节的标准定义；</li><li>字(word)：是设计计算机时给定的自然存储单位。不同位系统中，字所占的位数也不同：<ul><li>在16位的系统中(比如8086微机)，1字(word) = 2字节(byte) = 16(bit)；</li><li>在32位的系统中(比如win32)，1字(word) = 4字节(byte) = 32(bit)；</li><li>在64位的系统中(比如win64)，1字(word) = 8字节(byte) = 64(bit)。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-5-数据类型"><a href="#NO2-5-数据类型" class="headerlink" title="NO2.5 数据类型"></a>NO2.5 数据类型</h3><p>C语言让程序员针对不同情况选择不同的数据类型。</p><ul><li>C语言中的数据类型主要分为以下几种：<ul><li>基本类型：它们是算数类型，包括整数类型和浮点类型；</li><li>枚举类型：它们是算数类型，被用来定义在程序中只能赋予其一定的离散整数值的变量；</li><li>void类型：void表明没有可用的值；</li><li>派生类型：包括：指针类型、数组类型、结构类型、共用体类型和函数类型。</li></ul></li></ul><p>&nbsp;</p><ul><li>整型(以32位或64位系统为标准，不含小数点和指数的数称为整数)。<strong><code>注意：signed表示有符号的类型，unsigned表示无符号类型，优先考虑使用无符号类型的数据类型；当超出了数据类型的最大值，那么重新从最小值开始计算。如，int num = 2147483647 + 1，num的结果为-2147483648，而不是2147483648，因为结果已经超出了int的最大范围，就重新回到int最小值开始算，其他数据类型也是同理。</code></strong><ul><li>char：1个字节，范围是0~255，很奇怪为什么char是整型的一种是吗？那是因为在ASCII码表中，所有的字符都可以转为整型，且char也可以是字符；ASCII表中，字符0对应的十进制为48，’A’为65，’a’为97；</li><li>unsigned char：1个字节，范围是0~255；</li><li>signed char：1个字节，范围是-128~127；</li><li>short(也叫short int、signed short、signed short int)：2个字节，范围是-32768~32767；</li><li>unsigned short(也叫unsigned short int)：2个字节，范围是0~65535；</li><li>int(也叫signed、signed int)：4个字节，范围是-2147483648~2147483647；推荐使用int；</li><li>unsigned int(也叫unsigned)：4个字节，范围是0~4294967295，只能用于非负值；</li><li>long(也叫long int、signed long、signed long int)：4个字节，范围是-2147483648~2147483647；使用后缀l或L表名是long类型，推荐使用L；</li><li>unsigned long(也叫unsigned long int)：4个字节，范围是0~4294967295；</li><li>long long(也叫long long int、signed long long、signed long long int)：8个字节，范围为-9223372036854775808~9223372036854775807；</li><li>unsigned long long：8个字节，范围是0~18446744073709551615。</li></ul></li></ul><p>&nbsp;</p><ul><li>浮点类型。<strong><code>注意：浮点型常量，可以没有小数点或指数部分，但是不能同时省略两者，如2e5、19.88等等；也可以没有小数部分或整数部分，但是不能同时省略两者，如，3.e16、.45e-16等等。</code></strong><ul><li>float：4个字节，范围是1.2E-38~3.4E+38，精度为6位小数。如，33.123456；使用f或F后缀，声明浮点型是float类型；</li><li>double：8个字节，范围是2.3E-308~1.7E+308，精度为15位小数。默认情况下，创建的浮点型都是double类型的；输出时，默认保留小数点后面6位；</li><li>long double：精度比double更高，但是C中只保证是15位小数。</li></ul></li></ul><p>&nbsp;</p><ul><li>布尔类型(<code>即C99添加的_Bool类型</code>)。<strong><code>注意：头文件&lt;stdbool.h&gt;中定义了用bool来表示C99添加的_Bool类型。</code></strong><ul><li>true：可用1表示true；</li><li>false：可用0表示false。</li></ul></li></ul><p>&nbsp;</p><ul><li>复数类型和虚数类型。<ul><li>复数类型：<ul><li>float_Complex；</li><li>double_Complex；</li><li>long double _Complex。</li></ul></li><li>虚数类型：<ul><li>float_Imaginary；</li><li>double_Imaginary；</li><li>long double _Imaginary。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-6-数据类型转换"><a href="#NO2-6-数据类型转换" class="headerlink" title="NO2.6 数据类型转换"></a>NO2.6 数据类型转换</h3><p>C语言中如果使用不同类型进行运算，会进行数据类型的转换。</p><ul><li><p>数据类型转换分为两种：</p><ul><li><p>自动类型转换：在表达式中，精度小的数据类型会被自动转为精度大的数据类型。<code>如，一般char和short都会被自动转成int</code>；</p><ul><li><p>基本语法格式：代码工具会自己识别并进行自动类转换；</p><p>例如：</p><pre><code class="hljs pgsql"><span class="hljs-type">char</span> a = <span class="hljs-string">'a'</span>;<span class="hljs-type">int</span> b = a;  //这里自动将<span class="hljs-type">char</span>转换成了<span class="hljs-type">int</span></code></pre></li></ul></li><li><p>强制类型转换：即表达式中，精度大的数据类型要转为精度小的数据类型，就需要使用强制数据类型转换；</p><ul><li><p>基本语法格式：<code>(数据类型) 需要强制类型转换的值</code>。</p><p>例如：</p><pre><code class="hljs c"><span class="hljs-keyword">long</span> a=<span class="hljs-number">100</span>;<span class="hljs-keyword">int</span> b = (<span class="hljs-keyword">int</span>)a;  <span class="hljs-comment">//这里将long类型的变量a强制转换成了int类型的变量</span></code></pre></li></ul></li></ul></li></ul><p><img src="./Image-c19.png" srcset="/img/loading.gif" alt="Image"><br><strong><code>注意：当表达式中有多个不同数据类型的操作数进行运算时，会自动转为精度最大的那个数据类型，再进行运算。</code></strong></p><p>&nbsp;</p><ul><li>数据类型的级别从高至低依次是：long double –&gt; double –&gt; float –&gt; unsigned long long  –&gt; long long  –&gt; unsigned long  –&gt; long  –&gt; unsigned int –&gt; int。之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int。</li></ul><p>&nbsp;</p><ul><li>当作为函数的参数进行传递时，char和short会被转换成int，float会被转换成double。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-7-获取地址值：-amp-运算符"><a href="#NO2-7-获取地址值：-amp-运算符" class="headerlink" title="NO2.7 获取地址值：&amp;运算符"></a>NO2.7 获取地址值：&amp;运算符</h3><p>在C语言中，&amp;运算符有多种作用。</p><ul><li>&amp;运算符的作用：<ul><li>取地址：用于变量前面；<ul><li>基本语法基本语法格式：<code>&amp;变量名</code>。<code>如，int a，&amp;a就表示变量a在内存中的地址值</code>；</li></ul></li><li>与操作符：用于二进制位的与运算，两个操作数的二进制，对位都为1，则与运算的值为1，否则为0。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-8-指针入门"><a href="#NO2-8-指针入门" class="headerlink" title="NO2.8 指针入门"></a>NO2.8 指针入门</h3><p>指针：其实就是内存地址；而指针变量，则是能够存储指针的变量，说白了指针变量存储的是地址值。</p><ul><li><p>指针变量：用来存储指针的变量。和普通变量的定义差不多，只不过要在变量名前多加一个“<code>*</code>”号即可，通常在星号和变量名之间空一格，但是星号与数据类型之间的空格可有可无。<strong><code>注意：指针变量前面的类型，跟其里面要存放的地址值所指向的数据的类型一致；如果在初始化指针变量的时候不确定值，那么可以先赋值一个NULL，赋值为NULL的指针称为空指针，NULL常量定义在&lt;stdio.h&gt;文件中：#define NULL 0。</code></strong></p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">int</span> a;<span class="hljs-comment">//int* p = &amp;a;  //*号与数据类型的之间的空格可有可无，都可以的</span><span class="hljs-keyword">int</span>* p = &amp;a;  <span class="hljs-comment">//这里定义了一个int类型的指针变量p(因为里面存放的int类型的变量a的地址值)，然后将变量a的地址值赋值给了指针变量p</span></code></pre></li></ul><p>&nbsp;</p><ul><li><p>“*”号的使用：</p><ul><li><p>放在变量前面可以声明这是一个指针变量；</p></li><li><p>“*”号还可以用在指针变量前面，将指针变量里内存地址取出来，然后将这个地址值所指向的值取出来，此时星号和指针变量之间不空格。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;    <span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>;  <span class="hljs-comment">//定义一个普通的变量1，是int类型的</span>    <span class="hljs-keyword">int</span>* bz;  <span class="hljs-comment">//定义一个指针变量bz，也是int类型的，用于存储变量b内存地址</span>    bz = &amp;b;  <span class="hljs-comment">//获取变量b的内存地址，并赋值给指针变量bz</span>    printf_s(<span class="hljs-string">"%d\n"</span>,bz);  <span class="hljs-comment">//打印指针变量，结果为变量b的内存地址</span>    printf_s(<span class="hljs-string">"%d"</span>, *bz);  <span class="hljs-comment">//打印解指针变量，也就是指针变量bz的值(也就是内存地址)所指向的值，结果为1</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-9-值传递和地址传递"><a href="#NO2-9-值传递和地址传递" class="headerlink" title="NO2.9 值传递和地址传递"></a>NO2.9 值传递和地址传递</h3><p>C语言中参数的传递，分为两种：一是值传递，也就是说传递的是值；二是地址传递，说白了传递的是一个地址值。</p><ul><li>值传递的数据类型有：<ul><li>基本数据类型：整型类型、小数类型、字符类型；</li><li>结构体类型(你可以理解为Java语言中的类)；</li><li>共用体类型。</li></ul></li></ul><p>&nbsp;</p><ul><li>地址传递的数据类型：<ul><li>指针；</li><li>数组。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-10-运算符"><a href="#NO2-10-运算符" class="headerlink" title="NO2.10 运算符"></a>NO2.10 运算符</h3><p>C的常用运算符类型包括：算术运算符、赋值运算符、关系运算符、逻辑运算符、位运算符、三元运算符以及其他运算符等等。<strong><code>注意：运算符优先级：有括号先括号，然后正负号，之后先乘除、后加减，最后赋值；即括号&gt;正负号&gt;乘除&gt;加减&gt;赋值。</code></strong></p><ul><li>算数运算符：<ul><li>加法运算符：<code>+</code>；<ul><li>基本语法格式：<code>值 + 值</code>，这里的值可以是常量，也可以是变量。<code>如，1+1、a+1(前提这里a要记得先赋值再使用，且是数值类型)</code>；</li></ul></li><li>减法运算符：-；<ul><li>基本语法格式：<code>值 - 值</code>，这里的值可以是常量，也可以是变量。<code>如，5-3、a-1(前提这里a要记得先赋值再使用，且是数值类型)</code>；<strong><code>注意：“-”除了当作减号之外，还可以当作负号使用，如，-12、-a等等。</code></strong></li></ul></li><li>乘法运算符：<code>*</code>；<ul><li>基本语法格式：<code>值 * 值</code>，这里的值可以是常量，也可以是变量。<code>如，52、a3(前提这里a要记得先赋值再使用，且是数值类型)</code>；</li></ul></li><li>除法运算符：<code>/</code>；<ul><li>基本语法格式：<code>值 / 值</code>，这里的值可以是常量，也可以是变量。<code>如，5/2、a/3(前提这里a要记得先赋值再使用，且是数值类型)</code>；<strong><code>注意：两个操作数都是整数，则结果为整数；若有一个操作数为浮点数，则结果为浮点数。如，5/2 = 2、5.0/2 = 2.5等等。</code></strong></li></ul></li><li>求模运算符(也叫取余运算符)：<code>%</code>；<ul><li>基本语法格式：<code>值 % 值</code>，这里的值可以是常量，也可以是变量。<code>如，5%2、a%2(前提这里a要记得先赋值再使用，且是数值类型)</code>。<strong><code>注意：其实取模运算可以看做是：a % b = a - a / b  b。</code></strong></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>赋值运算符：</p><ul><li><p>赋值运算符：=；这是赋值运算符，而不是等于号；</p><ul><li>基本语法格式：<code>变量名 = 值</code>。<code>如，int num = 1，表示把1赋值给num</code>；</li></ul></li><li><p>其他赋值运算符：<code>+=、-=、*=、/=、%=</code>。+=运算符就是将值相加后又赋值，其他运算符同理。</p><ul><li><p>基本语法格式：<code>值 +=或-=或*=或/= 值</code>。</p><p>  例如：</p>  <pre><code class="hljs c">num += <span class="hljs-number">20</span> 与 num = num + <span class="hljs-number">20</span> 相同num -= <span class="hljs-number">2</span> 与  num =  num - <span class="hljs-number">2</span> 相同num = <span class="hljs-number">2</span> 与  num =  num  <span class="hljs-number">2</span> 相同num /= <span class="hljs-number">2.5</span> 与  num =  num / <span class="hljs-number">2.5</span> 相同num %= <span class="hljs-number">3</span> 与  num =  num % <span class="hljs-number">3</span> 相同</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>关系运算符(也称为比较运算符)；<strong><code>注意：C99提供了stdbool.h头文件，该头文件规定bool成为_Bool的别名，且把true和false分别定义为1和0；关系运算符常常和关系表达式一起使用，而关系表达式的值，要么为true，要么为false(即0或1，所以就有了0是false，1是true转换)。</code></strong></p><p>  <img src="./Image-c20.png" srcset="/img/loading.gif" alt="Image"></p><p>  <img src="./Image-c21.png" srcset="/img/loading.gif" alt="Image"></p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> num = <span class="hljs-number">3</span>;    <span class="hljs-keyword">while</span> (num) &#123;        printf_s(<span class="hljs-string">"%d\n"</span>, num);        num--;    &#125;&#125;说明：只要num的值不为<span class="hljs-number">0</span>，即不为<span class="hljs-literal">false</span>，那么<span class="hljs-keyword">while</span>会一直循环，直到num的值为<span class="hljs-number">0</span>，也就是<span class="hljs-literal">false</span>。</code></pre></li></ul><p>&nbsp;</p><ul><li>逻辑运算符：<ul><li>如下图所示；<strong><code>注意：!运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相同，只比圆括号的优先级低。另外iso646.h头文件中，可用英文单词代替逻辑运算符，分别是and、or、not。</code></strong></li></ul></li></ul><p><img src="./Image-c22.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-c23.png" srcset="/img/loading.gif" alt="Image"></p><p><code>说明：当且仅当exp1和exp2都为真时，exp1 &amp;&amp; exp2才为真； 如果exp1或exp2为真，则exp1 || exp2为真； 如果exp1为假，则!exp1为真；如果exp1为真，则!exp1为假。</code></p><p>&nbsp;</p><ul><li><p>位运算符：</p><ul><li><p>&amp;(位与运算)、|(位或运算)、^(位异或运算)、~(按位取反运算)、&lt;&lt;(左移运算)、&gt;&gt;(右移运算)这些运算都是使用操作数的二进制补码进行运算的。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-number">3</span>的二进制：<span class="hljs-number">0x11</span><span class="hljs-number">4</span>的二进制：<span class="hljs-number">0x100</span>    <span class="hljs-number">3</span> &amp; <span class="hljs-number">4</span> (&amp;位与运算：有<span class="hljs-number">0</span>则<span class="hljs-number">0</span>，两<span class="hljs-number">1</span>为<span class="hljs-number">1</span>)：   <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000011</span> --<span class="hljs-number">-3</span>的二进制补码&amp;  <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000100</span> --<span class="hljs-number">-4</span>的二进制补码-----------------------------------------   <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> 结果为<span class="hljs-number">0</span>    <span class="hljs-number">3</span> | <span class="hljs-number">4</span> (|位或运算：有<span class="hljs-number">1</span>则<span class="hljs-number">1</span>，两<span class="hljs-number">0</span>为<span class="hljs-number">0</span>)：   <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000011</span> --<span class="hljs-number">-3</span>的二进制补码|  <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000100</span> --<span class="hljs-number">-4</span>的二进制补码-----------------------------------------   <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000111</span> 结果为<span class="hljs-number">7</span>    <span class="hljs-number">3</span> ^ <span class="hljs-number">4</span> (^位异或运算：相同则<span class="hljs-number">0</span>，不同则<span class="hljs-number">1</span>)：   <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000011</span> --<span class="hljs-number">-3</span>的二进制补码^  <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000100</span> --<span class="hljs-number">-4</span>的二进制补码-----------------------------------------   <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000111</span> 结果为<span class="hljs-number">7</span>    ~ <span class="hljs-number">3</span> (~按位取反运算：<span class="hljs-number">0</span>变<span class="hljs-number">1</span>，<span class="hljs-number">1</span>变<span class="hljs-number">0</span>)：~  <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000011</span> --<span class="hljs-number">-3</span>的二进制补码-----------------------------------------   <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111100</span>补码：<span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111100</span>反码：<span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111011</span>原码：<span class="hljs-number">10000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000100</span> ---结果为<span class="hljs-number">-4</span><span class="hljs-comment">//-----------------------------------------------------------</span><span class="hljs-number">10</span> &lt;&lt; <span class="hljs-number">2</span> = <span class="hljs-number">40</span><span class="hljs-number">10</span> &gt;&gt; <span class="hljs-number">2</span> = <span class="hljs-number">2</span><span class="hljs-number">-1</span> &gt;&gt; <span class="hljs-number">2</span> = <span class="hljs-number">-1</span>说明：正数的原反补都是一样的，所以可以直接乘以或除以n个<span class="hljs-number">2</span>，即&lt;&lt;<span class="hljs-number">2</span>表示乘以两个<span class="hljs-number">2</span>，&gt;&gt;<span class="hljs-number">2</span>表示除以两个<span class="hljs-number">2</span>；也可以转成原码后进行左移或右移位数操作；负数则需要转换成补码后再进行运行，&lt;&lt;n表示二进制补码向左移动n位，位数不够的地方补<span class="hljs-number">0</span>；&gt;&gt;n则是向右移动n位，符号位补<span class="hljs-number">1</span>，其他补<span class="hljs-number">0</span>。</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>三元运算符：</p><ul><li><p>基本语法格式：<code>判断表达式?表达式1:表达式2</code>，判断表达式如果符合条件就取表达式1，否则就取表达式2。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-number">1</span>+<span class="hljs-number">1</span>&gt;<span class="hljs-number">3</span> ? <span class="hljs-number">1</span>:<span class="hljs-number">2</span>  <span class="hljs-comment">//结果为2</span></code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>其他运算符：</p><ul><li><p>sizeof运算符：返回一个对象或类型所占内存字节数，返回的是size_t类型(其实就是unsigned int)，即无符号整数。</p><ul><li>基本语法格式：<code>sizeof(数据类型或对象)</code>。<code>如：char ch[10]，sizeof(ch) = 10，返回的是size_t类型的值，也就是字符数组ch所占内存的字节数</code>。</li></ul></li><li><p>自增和自减运算符：<code>++和--</code>，作用是对自身的值进行加1或减1，分两种使用情况：</p><ul><li><p>单独使用情况下，自增或自减运算符放在值的前面或后面都一样；</p></li><li><p>与其他运算符一起使用，++a(出现在值前面)和a++(出现在值后面)，前者先自增再作运算，后者是先运算后赋值；自减和自增一样，只是不是增加而是减少。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;printf_s(<span class="hljs-string">"%d"</span>,a++);printf_s(<span class="hljs-string">"%d"</span>,++a);<span class="hljs-comment">//上面两者的效果都是一样的</span><span class="hljs-comment">//--------------------------------------</span><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (++a &lt; <span class="hljs-number">3</span>)&#123;  <span class="hljs-comment">//先自增，后与3进行比较</span>...&#125;<span class="hljs-keyword">while</span> (a++ &lt; <span class="hljs-number">3</span>)&#123;  <span class="hljs-comment">//先与3进行比较，后自增</span>...&#125;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-11-标识符"><a href="#NO2-11-标识符" class="headerlink" title="NO2.11 标识符"></a>NO2.11 标识符</h3><p>所谓标识符，可以简单理解为取名字，即给变量、函数、常量等等取的名字都成为标识符。</p><ul><li>标识符命名规则：<ul><li>由26个英文字母的大小写、0~9、_或$组成；</li><li>不可以以数字开头；</li><li>不可以是C语言中的关键字(即在C中有特殊含义的名称)和保留字，但能包含关键字于其中；</li><li>不允许包含空格；</li><li>区分大小写，长度无限制；</li><li>尽量遵循驼峰命名法。<code>如，myName、getNumOfNumber等等</code>。</li></ul></li></ul><p>&nbsp;</p><ul><li>所有宏定义(即define)、枚举常数、常量全用大写字母命名，用下划线_分割单词，且记得初始化变量后再使用。<code>如，#define AGE 8、const double FREE_MONEY = 100.1等等</code>。</li></ul><p>&nbsp;</p><ul><li>C语言的关键字和保留字，如下图所示：</li></ul><p><img src="./Image-c24.png" srcset="/img/loading.gif" alt="Image"><br><code>说明：粗斜体是C11新增的关键字。</code></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-12-printf-和scanf-，以及C语言的转换说明"><a href="#NO2-12-printf-和scanf-，以及C语言的转换说明" class="headerlink" title="NO2.12 printf()和scanf()，以及C语言的转换说明"></a>NO2.12 printf()和scanf()，以及C语言的转换说明</h3><p>printf()函数和scanf()函数能让用户可以与程序交流。<strong><code>注意：printf_s()和scanf_s()是printf()和scanf()的更安全的写法....微软公司整的。</code></strong></p><ul><li><p>printf_s()和scanf_s()函数，称为输入/输出函数，简称I/O函数。</p><ul><li><p>printf_s()：</p><ul><li><p>定义：该函数用于向用户输出信息；</p></li><li><p>函数的调用方式：<code>printf_s(转换说明字符串,待打印项1,待打印项2,...)</code>。<strong><code>注意：转换说明字符串中的转换说明一定要与后面的每个待打印项相匹配，否则会报错；另外printf_s()函数是有返回值的，返回值为打印的字符的个数，一般不常使用。</code></strong></p><p>  例如：</p>  <pre><code class="hljs c">printf_s(<span class="hljs-string">"i am %s"</span>,<span class="hljs-string">"john"</span>)printf_s(<span class="hljs-string">"it is %d%%"</span>,<span class="hljs-number">12</span>)  <span class="hljs-comment">//这里%d后面使用了两个%%，是因为我想输出12%，所以要使用另一个%来转义前一个%，就成了%%</span></code></pre></li></ul></li><li><p>scanf_s()：</p><ul><li><p>定义：该函数用于获取用户的输入；</p></li><li><p>函数的调用方式：<code>scanf_s(&quot;%用户的输入所属的数据类型&quot;,用于接收用户输入的变量名)</code>。<strong><code>注意：如果用scanf_s()读取基本变量类型的值，在变量名前要加上一个“&amp;”；如果把字符串读入到字符数组，则变量名前面不需要加“&amp;”。</code></strong></p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">char</span> arr[<span class="hljs-number">10</span>];  <span class="hljs-comment">//声明一个字符数组</span>scanf_s(<span class="hljs-string">"%s"</span>,arr);  <span class="hljs-comment">//接收用户输入的字符串，并将该字符串放入字符数组中，C中没有用于专门接收字符串的数据类型，只能用字符数组接收</span></code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>转换说明：</p><ul><li><p>定义：用来说明输入输出时的基本语法格式。</p></li><li><p>转换说明的意义：把给定的值转换成某种我们要求的形式并打印出来。常用的C语言中转换说明，如下图所示；另外还可以打印八进制、十进制等等。</p><ul><li><p>变量或常量的八进制、十进制、十六进制的显示。</p><ul><li><p>以八进制显示数值：使用“%o”，如果要显示进制的标识符号的话要使用“%#o”，其实就是八进制数值前面加个标识符号0。如，0123、046等等，都是八进制数；</p></li><li><p>以十进制显示数值：使用“%d”。如，15、20等等都是十进制数，我们常用的数字就是十进制数；</p></li><li><p>以十六进制显示数值：使用“%x”，如果要显示进制的标识符号的话使用“%#x”或“%#X”，这两个前缀的区别是“0x”和“0X”，都表示十六进制。</p><p>  <img src="./Image-c25.png" srcset="/img/loading.gif" alt="Image"></p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#includ <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> x = <span class="hljs-number">100</span>;    printf_s(<span class="hljs-string">"dec = %d; octal = %o; hex = %x\n"</span>, x, x, x);    printf_s(<span class="hljs-string">"dec = %d; octal = %#o; hex = %#x\n"</span>, x, x, x);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;以上输出结果为：dec = <span class="hljs-number">100</span>; octal = <span class="hljs-number">144</span>; hex = <span class="hljs-number">64</span>dec = <span class="hljs-number">100</span>; octal = <span class="hljs-number">0144</span>; hex = <span class="hljs-number">0x64</span></code></pre></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>使用字段宽度“*”，这个符号表示，让上下文来指定字符宽度，什么意思呢，就是让程序里的某个变量来指定字符宽度，那么啥又是字符宽度呢，说白了就是要展示给你看的字符的间隔而已。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> <span class="hljs-built_in">width</span> = <span class="hljs-number">9</span>;  <span class="hljs-comment">//字段宽度我们用width来表示</span>    <span class="hljs-keyword">int</span> res;    scanf_s(<span class="hljs-string">"%d"</span>,&amp;res);  <span class="hljs-comment">//获取用户输入</span>    printf_s(<span class="hljs-string">"%*d%*d"</span>,<span class="hljs-built_in">width</span>,res,<span class="hljs-built_in">width</span>,res);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;说明：%*d中，%d表示转换说明，*表示字符宽度；如果转换说明是%*d,那么参数列表中应包含*和d对应的值，而d从用户输入中获取，并赋值给了res；字段宽度，我们使用了<span class="hljs-built_in">width</span>变量的值(也就是<span class="hljs-number">9</span>)，所以输出结果：<span class="hljs-number">1</span><span class="hljs-number">1</span>。</code></pre></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-13-C语言中的进制"><a href="#NO2-13-C语言中的进制" class="headerlink" title="NO2.13 C语言中的进制"></a>NO2.13 C语言中的进制</h3><p>C语言中常用的进制有：二进制、八进制、十进制、十六进制。</p><ul><li>进制：<ul><li>定义：即一个数的表示。可以有二进制、八进制、十进制、十六进制等等；</li><li>常用进制：<ul><li>二进制：由0和1组成，满2进1，C中没有能标识二进制的方法；</li><li>八进制：由0-7组成，满8进1，C中以数字0开头表示八进制；</li><li>十进制：由0-9组成，满10进；</li><li>十六进制：由0-7、a-f(或A-F，表示10-15)组成。C中以0x或0X开头表示十六进制。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>进制转换：</p><ul><li><p>在学习常用进制转换之前，我们先来学习一些传说中的8421码：</p><ul><li><p>8421码：表示每个二进制位上的值对应十进制中的值。其实用于二进制和十进制的快速转换。如下所示：</p>  <pre><code class="hljs c">二进制<span class="hljs-number">1</span><span class="hljs-number">1</span><span class="hljs-number">1</span><span class="hljs-number">1</span><span class="hljs-number">1</span><span class="hljs-number">1</span><span class="hljs-number">1</span><span class="hljs-number">1</span>十进制<span class="hljs-number">128</span>  <span class="hljs-number">64</span>  <span class="hljs-number">32</span>  <span class="hljs-number">16</span><span class="hljs-number">8</span><span class="hljs-number">4</span><span class="hljs-number">2</span><span class="hljs-number">1</span>`</code></pre></li></ul></li><li><p>二进制转八进制、十进制、十六进制：aaa</p><ul><li><p>二进制转八进制：三位归并法：每三位一组，不够位数的左边添0，求出每个三位的二进制值，最后结果拼接即可；注意：该方法同样适用于八进制转二进制，只需逆向将一个八进制拆成三位的二进制即可，前提是需要明白8421码的转换；</p></li><li><p>其他进制转十进制(包括二进制转十进制)：每一位上的数据值进制(二进制乘以二，八进制乘以八，十六进制乘以十六)^从右往左且幂从0开始；</p></li><li><p>二进制转十六进制：四位归并法：每四位一组，不够位数的左边添0，求出每个四位的二进制值，最后结果拼接即可。注意：该方法同样适用于十六进制转二进制，只需逆向将一个十六进制拆成四位的二进制即可，前提是需要明白8421码的转换。</p><p> 例如：</p> <pre><code class="hljs c">二进制转换成十进制：二进制数<span class="hljs-number">01110101</span><span class="hljs-number">0</span>        <span class="hljs-number">1</span>        <span class="hljs-number">1</span>        <span class="hljs-number">1</span>        <span class="hljs-number">0</span>        <span class="hljs-number">1</span>        <span class="hljs-number">0</span>        <span class="hljs-number">1</span><span class="hljs-number">02</span>^<span class="hljs-number">7</span>   <span class="hljs-number">12</span>^<span class="hljs-number">6</span>     <span class="hljs-number">12</span>^<span class="hljs-number">5</span>      <span class="hljs-number">12</span>^<span class="hljs-number">4</span>    <span class="hljs-number">02</span>^<span class="hljs-number">3</span>     <span class="hljs-number">12</span>^<span class="hljs-number">2</span>     <span class="hljs-number">02</span>^<span class="hljs-number">1</span>      <span class="hljs-number">2</span>^<span class="hljs-number">0</span>=<span class="hljs-number">1</span><span class="hljs-number">0</span>       <span class="hljs-number">64</span>       <span class="hljs-number">32</span>        <span class="hljs-number">16</span>       <span class="hljs-number">0</span>       <span class="hljs-number">4</span>         <span class="hljs-number">0</span>        <span class="hljs-number">1</span>把所有的结果相加，得到最后的结果<span class="hljs-number">117</span>。其他进制转十进制只需要将<span class="hljs-number">2</span>换成<span class="hljs-number">8</span>、<span class="hljs-number">16</span>即可    <span class="hljs-comment">//------------------------------------------------------------------</span>    二进制<span class="hljs-number">0b1100110</span>转八进制：<span class="hljs-number">001</span> <span class="hljs-number">100</span> <span class="hljs-number">110</span><span class="hljs-number">1</span>   <span class="hljs-number">4</span>   <span class="hljs-number">6</span>   = <span class="hljs-number">0146</span><span class="hljs-comment">//------------------------------------------------------------------    </span>    二进制<span class="hljs-number">0b1100110</span>转十六进制：<span class="hljs-number">0110</span> <span class="hljs-number">0110</span><span class="hljs-number">6</span>    <span class="hljs-number">6</span>    = <span class="hljs-number">0x66</span></code></pre></li></ul></li><li><p>八进制转二进制、十进制、十六进制：</p><ul><li>八进制转二进制：采用8421码，即一个八进制位转换为3个二进制位；<strong><code>注意：这里不懂8421码的话，可以找一些视频来看，比较简单。</code></strong></li><li>其他进制转十进制(包括八进制转十进制)：每一位上的数据值进制(二进制乘以二，八进制乘以八，十六进制乘以十六)^从右往左且幂从0开始；</li><li>八进制转十六进制：先转成二进制或十进制，再转成十六进制即可。</li></ul></li><li><p>十进制转其他进制：直接用这个数除以进制数(二进制除以二，八进制除以八，十六进制除以十六)，直到商为0，取余数反转即可；</p></li><li><p>十六进制转二进制、八进制、十进制：</p><ul><li>十六进制转二进制：采用8421码，即一个十六进制位转换为4个二进制位；</li><li>十六进制转八进制：先转成二进制或十进制，再转成八进制即可；</li><li>十六进制转十进制：其他进制转十进制(包括十六进制转十进制)：每一位上的数据值进制(二进制乘以二，八进制乘以八，十六进制乘以十六)^从右往左且幂从0开始。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-14-原码、反码、补码"><a href="#NO2-14-原码、反码、补码" class="headerlink" title="NO2.14 原码、反码、补码"></a>NO2.14 原码、反码、补码</h3><p>计算机中所有的数据运算都采用补码进行的。对于有符号的数(即负数)而言，二进制的的最高位为符号位：0表示正数、1表示负数。</p><ul><li>正数的原、反、补码都是一样的，即正数的二进制既是原码，又是反码和补码。</li></ul><p>&nbsp;</p><ul><li><p>负数：</p><ul><li><p>原码：就是二进制本身，但符号位用0或1分别表示正数或负数；</p></li><li><p>反码：符号位不变，其他位取反(0变1,1变0)；</p></li><li><p>补码：在反码的基础上末位加1。</p><p>  例如：</p>  <pre><code class="hljs c">+<span class="hljs-number">7</span> 和 <span class="hljs-number">-7</span>二进制为：<span class="hljs-number">00000111</span>+<span class="hljs-number">7</span> 的原码为<span class="hljs-number">00000111</span><span class="hljs-number">-7</span> 的原码则为<span class="hljs-number">10000111</span><span class="hljs-comment">//------------------------------------------------------------------</span>+<span class="hljs-number">7</span> 的原码为<span class="hljs-number">00000111</span>，反码也是<span class="hljs-number">00000111</span><span class="hljs-number">-7</span> 的原码为<span class="hljs-number">10000111</span>，反码则是<span class="hljs-number">11111000</span><span class="hljs-comment">//------------------------------------------------------------------</span>+<span class="hljs-number">7</span> 的原码为<span class="hljs-number">00000111</span>，反码也是<span class="hljs-number">00000111</span>，补码仍然为<span class="hljs-number">00000111</span><span class="hljs-number">-7</span> 的原码为<span class="hljs-number">10000111</span>，反码则是<span class="hljs-number">11111000</span>，补码变成<span class="hljs-number">11111001</span></code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-15-程序流程控制"><a href="#NO2-15-程序流程控制" class="headerlink" title="NO2.15 程序流程控制"></a>NO2.15 程序流程控制</h3><p>C语言中的程序流程控制：即用来控制程序的流程走向。包括三大流程控制：顺序控制、分支控制、循环控制。</p><ul><li><p>顺序控制：即程序代码从上到下，逐行顺序执行，中间没有任何判断和跳转。</p><ul><li><p>基本语法格式：</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;  <span class="hljs-comment">//先执行这个</span>    <span class="hljs-keyword">int</span> age = <span class="hljs-number">2</span>;  <span class="hljs-comment">//再执行这个</span>&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>分支控制：即让程序代码有选择的执行，但只会执行其中的一种分支。<strong><code>注意：分支可以相互嵌套，但最多不要嵌套超过3层，否则代码可读性会大大降低。</code></strong>分支控制主要分为：</p><ul><li><p>单分支：即if语句，只有一个选择分支，符合条件则执行分支里的语句体，否则就跳过不执行，继续往下执行；</p><ul><li><p>基本语法格式：</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">if</span>(条件表达式)&#123;  <span class="hljs-comment">//条件表达式中只返回true或false，前者进入分支并执行语句体，后者不进入分支执行语句体，即跳过不执行</span>    需要执行的语句体&#125;如：<span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span><span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">0</span>)&#123;    printf_s(<span class="hljs-string">"a大于0哦"</span>);&#125;输出结果为：a大于<span class="hljs-number">0</span>哦</code></pre></li></ul></li><li><p>双分支：即if-else语句，用于两种情况的选择，即符合与不符合条件的情况，将执行不同的语句体；</p><ul><li><p>基本语法格式：</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">if</span>(条件表达式)&#123;  <span class="hljs-comment">//为true走这里</span>    需要执行的语句体<span class="hljs-number">1</span>&#125; <span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">//为false时走这里</span>    需要执行的语句体<span class="hljs-number">2</span>&#125;如：<span class="hljs-keyword">int</span> a = <span class="hljs-number">-2</span>;<span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">0</span>)&#123;    printf_s(<span class="hljs-string">"a大于0哦"</span>);&#125;<span class="hljs-keyword">else</span> &#123;    printf_s(<span class="hljs-string">"a小于0哦"</span>);&#125;输出结果为：a小于<span class="hljs-number">0</span>哦</code></pre></li></ul></li><li><p>多分支：即if-else if-else语句，用于多种情况的的选择；</p><ul><li><p>基本语法格式：</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">if</span>(条件表达式<span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">//符合条件1就进入这里</span>    需要执行的语句体<span class="hljs-number">1</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件表达式<span class="hljs-number">2</span>)&#123;  <span class="hljs-comment">//符合条件2就进入这里</span>    需要执行的语句体<span class="hljs-number">2</span>&#125; ....&#123;    ....&#125;<span class="hljs-keyword">else</span>&#123;    上面两种都不符合，就会执行这里&#125;如：<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">0</span>)&#123;    printf_s(<span class="hljs-string">"a大于0哦"</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a = <span class="hljs-number">0</span>)&#123;    printf_s(<span class="hljs-string">"a等于0哦"</span>);&#125; <span class="hljs-keyword">else</span> &#123;    printf_s(<span class="hljs-string">"a小于0哦"</span>);&#125;输出结果为：a等于<span class="hljs-number">0</span>哦</code></pre></li></ul></li><li><p>其他分支：即switch语句，用于匹配多重选择的情况。</p><ul><li><p>基本语法格式：</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">switch</span>(整数值)&#123;  <span class="hljs-comment">//这里的整数值也可以由一个表达式产生，也可以是枚举类型。如1+1，'a'等等</span>    <span class="hljs-keyword">case</span> 常量值<span class="hljs-number">1</span>:  <span class="hljs-comment">//switch中的表达式产生的值，如果与这里的值1匹配成功的话，那么就会执行限免的语句体1</span>        需要执行的语句体<span class="hljs-number">1</span>        <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//表示中断，意思就是分支程序执行到这里，那么分支就执行完毕了，可以跳出分支，进行分支外的代码执行</span>    <span class="hljs-keyword">case</span> 常量值<span class="hljs-number">2</span>:        需要执行的语句体<span class="hljs-number">2</span>        <span class="hljs-keyword">break</span>;    ....    <span class="hljs-keyword">default</span>:        都不符合时，才执行的语句体&#125;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>循环控制：即让程序的代码能够实现循环的执行。<strong><code>注意：循环也可以嵌套使用，但是只建议嵌套循环不超过3层，否则代码的可读性就会变差。</code></strong>可以分为：</p><ul><li><p>for循环：一般用于有次数限制的条件循环；</p><ul><li><p>基本语法格式：</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">for</span>(初始化语句;循环条件表达式;控制条件语句)&#123;    循环体&#125;如：<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>; i++)&#123;    printf_s(<span class="hljs-string">"i的值为：%d\n"</span>,i);&#125;<span class="hljs-comment">//还可以有逗哥初始化语句和控制条件语句，有多个时，用,隔开即可，但是要注意无论是初始化语句只能定义同一种数据类型</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>，j=<span class="hljs-number">1</span>;i &lt; <span class="hljs-number">5</span>; i++，j++)&#123;    printf_s(<span class="hljs-string">"i的值为：%d\n"</span>,i);    printf_s(<span class="hljs-string">"j的值为：%d\n"</span>,j);&#125;</code></pre></li></ul></li><li><p>while循环：一般用于不清楚循环次数时而使用的；</p><ul><li><p>基本语法格式：</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">while</span>(条件表达式)&#123;  <span class="hljs-comment">//表达式用来判断是否能够进入循环；当表达式不成立时，则不再进入循环</span>    循环体&#125;如：<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(num &lt; <span class="hljs-number">5</span>)&#123;  <span class="hljs-comment">//循环的入口，当表达式num&lt;5成立时，进入循环</span>        printf_s(<span class="hljs-string">"num的值为：%d\n"</span>,num);        num++;    &#125;&#125;</code></pre></li></ul></li><li><p>do-while循环：该循环和while循环差不多，不同的地方总是会先执行一次；</p><ul><li><p>基本语法格式：</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">do</span>&#123;    循环体&#125; <span class="hljs-keyword">while</span> (判断表达式)注意：该循环与<span class="hljs-keyword">while</span>表示的意义差不多，但是这种循环，是先执行一次，后判断。如：<span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span><span class="hljs-keyword">do</span>&#123;    num++;&#125;<span class="hljs-keyword">while</span>(num &lt; <span class="hljs-number">3</span>)</code></pre></li></ul></li><li><p>goto语句：作用是跳转到某一行代码去执行。嗯….这个不建议使用，其实continue和break就是goto的特殊形式，使用这两个就够用了。</p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-16-循环辅助：continue和break"><a href="#NO2-16-循环辅助：continue和break" class="headerlink" title="NO2.16 循环辅助：continue和break"></a>NO2.16 循环辅助：continue和break</h3><p>continue和break使用频率很高，各种循环语句里面都有它们的身影。</p><ul><li><p>continue：一般用于循环体内；执行到continue时，作用是跳过本次循环，continue后面的代码就不会再执行；如果有嵌套循环，则跳过有continue的那一层循环，并进行下一次循环。<strong><code>注意：continue不能单独跟switch和if，但是如果if外层有循环，则可以正常使用。</code></strong></p><ul><li><p>基本语法格式</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;num &lt; <span class="hljs-number">10</span>;num++)&#123;    <span class="hljs-keyword">if</span>( num == <span class="hljs-number">3</span>)&#123;        <span class="hljs-keyword">continue</span>;    &#125;    printf_s(<span class="hljs-string">"%d"</span>,num);&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li><p>break：一般用于循环体内；执行到break时，直接结束循环；如果有嵌套循环，则结束有break的那一层循环。</p><ul><li><p>基本语法格式</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++)&#123;    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">3</span>)&#123;        <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//当执行到i等于3时，那么就会跳出当前的for循环，也就是停止for循环</span>    &#125;    printf_s(<span class="hljs-string">"%d',i);</span><span class="hljs-string">&#125;</span><span class="hljs-string">             </span><span class="hljs-string">拓展：return的使用</span><span class="hljs-string">一、return关键字的使用和break差不多，都有终止程序循环的作用，但不同的是，return不仅仅用于循环中，更常用于有返回值的函数中。</span><span class="hljs-string"></span><span class="hljs-string">如：</span><span class="hljs-string">int main()&#123;</span><span class="hljs-string"></span><span class="hljs-string">    ....省略了其他代码</span><span class="hljs-string">    return 0;  //这里的return就是运用在函数中，即main函数</span><span class="hljs-string">&#125;</span></code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-17-枚举类型"><a href="#NO2-17-枚举类型" class="headerlink" title="NO2.17 枚举类型"></a>NO2.17 枚举类型</h3><p>在实际编程中，有些数据的取值往往是有限的，只能是非常少量的整数，并且最好为每个值都取一个名字，以方便在后续代码中使用。如，一个星期只有七天，一年只有十二个月，一个班每周有六门课程等。</p><ul><li><p>枚举：</p><ul><li><p>定义：枚举是一组常量的集合；<strong><code>注意：C语言中枚举类型是被当作int或unsigned int类型来处理的。</code></strong></p></li><li><p>创建方式：enum 枚举名{枚举元素1、枚举元素2、枚举元素3….}。<strong><code>注意：如果枚举中的第一个元素没有赋值的话，默认值为0，后面的值按顺序在前一个值的基础上加1；如果中途某个元素又给了值，那么从这个值开始后面元素的值会依次加1。如，enum WEEK={MON、TUE=5、WED}，那么MON的值为0，而WED的值在TUE的基础上加1，即WED=6。</code></strong></p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-comment">//enum XINGQI &#123;MON=1,TUE=2,WED=3&#125; day2;  //还可以使用这种方式定义枚举和枚举变量</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;       <span class="hljs-keyword">enum</span> XINGQI &#123;MON=<span class="hljs-number">1</span>,TUE=<span class="hljs-number">2</span>,WED=<span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">//定义了一个枚举类型</span>       <span class="hljs-keyword">enum</span> XINGQI day = MON;  <span class="hljs-comment">//定义了一个枚举变量，用于接收枚举中的值</span>       printf_s(<span class="hljs-string">"%d"</span>,day);       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//-------------------------------</span><span class="hljs-comment">//枚举遍历</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-keyword">enum</span> XINGQI &#123;MON=<span class="hljs-number">1</span>,TUE,WED&#125; day2;  <span class="hljs-comment">//如果TUE、WED不赋值的话，会自动按照顺序赋值，即TUE=2、WED=3</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;    <span class="hljs-keyword">for</span>(day2 = MON;day &lt;= WED;day2++)&#123;  <span class="hljs-comment">//这里day++会给予警告，但是能够运行</span>        printf_s(<span class="hljs-string">"%d"</span>,day2);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-18-函数"><a href="#NO2-18-函数" class="headerlink" title="NO2.18 函数"></a>NO2.18 函数</h3><p>函数是能够完成特定任务的一个独立程序代码单元。</p><ul><li>函数类型主要分为两种：<ul><li>void函数：即没有返回值的函数，就称为void函数；</li><li>E 函数：指的是，如果返回值是E类型，那么该函数就称为E类型函数。<code>如，int count(int a,int b)，该函数返回int类型的值，那么该函数是int类型函数</code>。</li></ul></li></ul><p>&nbsp;</p><ul><li><p>函数原型：</p><ul><li><p>定义：就是对函数的定义；</p></li><li><p>基本语法格式：</p><p>  例如：</p>  <pre><code class="hljs c">返回值类型 函数名(参数类型 变量名,....);  <span class="hljs-comment">//后面的“....”表示，可以有多个参数，也可以没有一个参数</span>如：<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;  <span class="hljs-comment">//先声明一个新的函数，告诉系统，等会我们要使用这个函数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    printf_s(<span class="hljs-string">"hello,baby!"</span>);    test();  <span class="hljs-comment">//然后，使用该函数</span>    printf_s(<span class="hljs-string">"hi,darling!"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;  <span class="hljs-comment">//通过函数原型来定义要使用的test函数，其实就是和Java中的函数定义一样的</span>    printf_s(<span class="hljs-string">"double!"</span>);&#125;</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li>形参和实参：<ul><li>形参：即形式参数，用于定义函数时而使用的参数，告诉C，函数值要传入一个什么类型的参数；</li><li>实参：即实际参数，实际调用该函数时，传入函数的参数，那么这个值就称为实参。<code>如，定义一个函数：void count(int number)，number就是形参，调用函数：count(5)，那么这个5就是实参</code>。</li></ul></li></ul><p>&nbsp;</p><ul><li><p>头文件：</p><ul><li><p>定义：简单讲就是包含了一些功能性函数的声明、数据接口声明的一个文件，即将变量、处理函数抽取放到一个专门的文件中而已。在程序中，头文件的后缀主要是“.h”，也就是说函数声明写在了以“.h”结尾的头文件中。<strong><code>注意：一般自定义的头文件和源文件名称都是相同的。</code></strong></p></li><li><p>作用：头文件对程序编译执行而言，它仅仅在预编译时将其内容在#include的地方展开一下，说白了就是将头文件中的内容复制粘贴到你写的程序中，但是复制粘贴不方便，也不安全，所以采用了头文件；</p></li><li><p>自定义头文件的方式有两种；<strong><code>注意：#include&lt;...&gt;是调用标准头文件库的用法，自己写的头文件，调用时一般用#include&quot;....&quot;，而不用#include&lt;....&gt;，自定义头文件一般和项目文件放在一起，即同目录下即可。</code></strong></p><ul><li><p>第一种：函数的声明和实现都写在“.h”头文件中；</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-comment">//创建一个头文件，后缀以“.h”结尾即可，名称可以自定义</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123;       <span class="hljs-keyword">return</span> num1 + num2;&#125;;<span class="hljs-comment">//-----------------------------------------------</span><span class="hljs-comment">//在需要引用的程序中引入你自己定义的头文件即可</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"myheadfile.h"</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;       <span class="hljs-keyword">int</span> res = getSum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);       printf_s(<span class="hljs-string">"%d"</span>, res);       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p>第二种：函数的声明写在“.h”头文件中，函数的实现写在“.c”或“.cpp”文件中。<strong><code>注意：VS2019中，无法使用第二种，又或许是我的方式不对？</code></strong></p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-comment">//创建一个头文件，后缀以“.h”结尾即可，名称可以自定义，内容写上函数的声明</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1,<span class="hljs-keyword">int</span> num2)</span></span>;<span class="hljs-comment">//-----------------------------------------------</span><span class="hljs-comment">//创建一个源文件，后缀以“.c”或“.cpp”结尾即可，名称可以自定义，但最好和自定义的“.h”头文件名称一致，方便辨认；内容写上头文件中声明的函数的具体实现</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">""</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1,<span class="hljs-keyword">int</span> num2)</span></span>&#123;    <span class="hljs-keyword">return</span> num1 + num2;&#125;<span class="hljs-comment">//-----------------------------------------------</span><span class="hljs-comment">//在需要引用的程序中引入自己写的头文件即可</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"myheadfile.h"</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;       <span class="hljs-keyword">int</span> res = getSum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);       printf_s(<span class="hljs-string">"%d"</span>, res);       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li><p>函数的递归调用：所谓递归调用，就是函数自己调用自己的意思，不需要想的太复杂。我们将放在return之前的递归调用，称为尾递归。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>;  <span class="hljs-comment">//声明函数原型</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> res = count(<span class="hljs-number">12</span>);  <span class="hljs-comment">//调用函数</span>    printf_s(<span class="hljs-string">"结果是：%d\n"</span>,res);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>&#123;    <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">10</span>)&#123;        num--;        <span class="hljs-keyword">return</span> count(num);    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;    &#125;&#125;</code></pre></li></ul><p>&nbsp;</p><ul><li><p>变量的作用域：所谓变量的作用域，就是指变量的有效范围。可分为：</p><ul><li><p>局部变量：</p><ul><li>作用域：定义在函数或代码块内部。即该类型变量的有效范围在函数或代码块内部。</li><li>存储区域：局部变量保存在栈中，函数被调用时才会为其分配存储单元。<code>如，形式参数就是局部变量</code>；<strong><code>注意：局部变量系统不会帮忙初始化，也就是说必须初始化才能用</code></strong></li></ul></li><li><p>全局变量：</p><ul><li><p>作用域：即定义在函数外部的变量。该类型变量的有限范围是在整个程序中。</p></li><li><p>存储区域：全局变量保存在内存中的全局存储区中，占用静态的存储单元。<strong><code>注意：全局变量系统会帮忙初始化；int类型默认是0、char类型默认是&#39;\0&#39;、float和double类型默认是0.0，指针类型默认是NULL。当局部变量和全局变量同名时，根据就近原则，会使用局部变量的值；但要注意，同一作用域中，不能出现同名变量。</code></strong></p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-keyword">int</span> a;  <span class="hljs-comment">//这就是全局变量，没赋值，但是系统会给我们初始化，默认是0</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>  <span class="hljs-comment">//这是局部变量，只用于man函数内部</span>    printf_s(<span class="hljs-string">"结果是：%d\n"</span>,a);  <span class="hljs-comment">//这里会输出最近的变量，即a=10</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++)&#123;         <span class="hljs-keyword">int</span> j = <span class="hljs-number">0.5</span>;  <span class="hljs-comment">//这也是局部变量</span>        printf_s(<span class="hljs-string">"%d"</span>,i+j);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-19-static关键字"><a href="#NO2-19-static关键字" class="headerlink" title="NO2.19 static关键字"></a>NO2.19 static关键字</h3><p>static关键字，意为静态的意思，可以修饰变量和函数。</p><ul><li><p>static修饰：</p><ul><li><p>修饰变量，分为两种：</p><ul><li><p>基本语法格式：<code>static 数据类型 变量名 = 值</code>；</p></li><li><p>修饰局部变量：静态局部变量如果没有初始化值，那么系统会根据不同的数据类型为静态局部变量初始化值；静态局部变量存储于内存的静态存储区，只会被初始化一次；</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;  <span class="hljs-comment">//这是普通局部变量</span>    printf_s(<span class="hljs-string">"结果是：%d\n"</span>,a);  <span class="hljs-comment">//这里会输出10</span>    a++;    printf_s(<span class="hljs-string">"结果是：%d\n"</span>,a);  <span class="hljs-comment">//这里会输出11</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a2; <span class="hljs-comment">//这是静态局部变量</span>    printf_s(<span class="hljs-string">"结果是：%d\n"</span>,a2);  <span class="hljs-comment">//这里会输出0</span>    a2++;    printf_s(<span class="hljs-string">"结果是：%d\n"</span>,a2);  <span class="hljs-comment">//这里会输出1</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">3</span>;i++) &#123;        f1();    &#125;    print_f(<span class="hljs-string">"----------------------------\n"</span>)    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">3</span>;i++) &#123;        f2();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;输出结果：结果是：<span class="hljs-number">10</span>  <span class="hljs-comment">//开始第一次调用函数</span>结果是：<span class="hljs-number">11</span>结果是：<span class="hljs-number">10</span>  <span class="hljs-comment">//开始第二次调用函数，当再次调用函数时，a的值又被重新初始化为10了</span>结果是：<span class="hljs-number">11</span>---------------------------结果是：<span class="hljs-number">0</span>  <span class="hljs-comment">//静态局部变量a2并没有被赋值，所以系统初始化了a的值为0</span>结果是：<span class="hljs-number">1</span>结果是：<span class="hljs-number">1</span>  <span class="hljs-comment">//第二次调用函数时，静态局部变量并没有重新初始化为0，因为静态局部变量只会被初始化一次</span>结果是：<span class="hljs-number">2</span></code></pre></li><li><p>修饰全局变量：静态全局变量会被私有化，即静态全局变量只能用在本文件当中，其他文件无法通过extern引用该静态全局变量。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-comment">//test1.c文件中</span><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;  <span class="hljs-comment">//定义了一个普通的全局变量</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a2 = <span class="hljs-number">10</span>;  <span class="hljs-comment">//如果使用了静态全局变量，则该变量只能用于test1.c文件中，无法被其他文件使用extern引用</span><span class="hljs-comment">//-----------------------------------</span><span class="hljs-comment">//test2.c文件中</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> a;  <span class="hljs-comment">//通过extern引用test1.c文件中的变量a</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> a2;  <span class="hljs-comment">//通过extern引用test1.c文件中的变量a2</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    print_s(<span class="hljs-string">"a的结果是：%d\n"</span>,a);  <span class="hljs-comment">//这里会输出10</span>    print_s(<span class="hljs-string">"a2的结果是：%d\n"</span>,a2;  <span class="hljs-comment">//这里会报错，即无法解析a2这个变量</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li><li><p>修饰函数：</p><ul><li><p>基本语法格式：<code>static 返回值类型 函数名(形参列表){....}</code>；</p></li><li><p>static修饰函数：与静态全局变量类似，静态函数只属于本文件，无法被其他文件用extern所引用；即哪个文件声明了静态函数，那么就只能被哪个文件调用，其他文件无法调用。反过来。普通函数可以被extern关键字所引用。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-comment">//test1.c文件中</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;  <span class="hljs-comment">//普通函数</span>    printf_s(<span class="hljs-string">"这里是f1函数"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;  <span class="hljs-comment">//静态函数</span>    printf_s(<span class="hljs-string">"这里是f2函数"</span>);&#125;<span class="hljs-comment">//-----------------------------------</span><span class="hljs-comment">//test2.c文件中</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;  <span class="hljs-comment">//通过extern引用test1.c文件中的函数f1</span><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;  <span class="hljs-comment">//通过extern引用test1.c文件中的函数f2</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;     f1();  <span class="hljs-comment">//成功输出：这里是f1函数</span>     f2();  <span class="hljs-comment">//报错：无法解析的外部符号，即静态函数只能在声明了它的那个文件中使用</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-20-字符串和数组"><a href="#NO2-20-字符串和数组" class="headerlink" title="NO2.20 字符串和数组"></a>NO2.20 字符串和数组</h3><p>C语言中没有存储字符串的变量类型。</p><ul><li>字符串：<ul><li>定义：是一个或多个字符的序列，属于派生类型。如，”dyf is climbing”、”be warm”等等，这些都是字符串；<strong><code>注意：如果创建的是字面量字符串，系统依然会默认给该字符串的最后添加一个&#39;\0&#39;。</code></strong></li><li>数据类型：C语言没有专门用于存储字符串的数据类型，字符串都被存储在char类型的数组中。<strong><code>注意：C中的字符串一定以空字符串结束，所以数组一般要多留一个位置给这个空字符串。字符串其实就是一个字符数组，如果函数的返回值是一个char*，即一个字符型的指针变量，那么一般就是返回一个字符串的意思，极少数有返回一个地址值。</code></strong></li><li>字符和字符串的区别：<ul><li>字符是基本类型，字符串是派生类型；</li><li>字符串的末尾有都有一个空字符：’\0’，而字符没有。</li></ul></li></ul></li></ul><p><img src="./Image-c27.png" srcset="/img/loading.gif" alt="Image"><br><code>说明：上图中末尾的字符\0，这是用于标记字符串的结束而使用的空字符，它是非打印字符，其ASCII码值等价于0。</code></p><p>&nbsp;</p><ul><li><p>数组：</p><ul><li><p>定义：数组是同类型的数据元素的有序序列，简单讲就是同一类型的数据元素的一个有序的集合。如，要么都是int，或者都是long….等等；</p></li><li><p>数组的创建方式：要使用数组，必须先创建数组，常用的几种方式如下；<strong><code>注意：用const修饰数组，表示只让用户查看数组中有哪些元素，但并不允许修改。如，const int nums[5]，表明了该数组只能用于查看有哪些元素，不允许用户修改数组的值；数组中每个元素的内存地址都是连续分布的，即第一个元素的地址值加上数据类型占用的字节大小等于第二个元素的地址，后面的以此类推；数组索引从0开始；字符数组如果只初始化了部分空间，那么剩下的空间都将被赋值为&#39;\0&#39;。</code></strong></p><ul><li>方式一：<code>数据类型 数组名称[size]</code>。用该方式创建的数组，包括，指定了的数据类型、数组名称，以及数组的容量(即size)；</li><li>方式二：<code>数据类型 数组名称[size] = {元素1,元素2,元素3,....}</code>。用该方式创建的数组，包括指定了的数据类型、数组名称，以及数组的容量(也可以不指定size大小，系统会根据已有的元素推断数组的size)，并且数组中的元素也已经确定，就是{}中的元素；</li><li>方式三：<code>数据类型 数组名称[size] = {[索引值]=值,....}</code>。用该方式创建的数组，给数组中指定索引的位置赋了值，这是C99引入的新特性，之前是不允许这样的，之前的规定：必须对要赋值元素之前的所有元素都赋值，才能给指定位置的元素赋值。<code>如，char nums[5] = {[0]=&#39;b&#39;,[4]=&#39;a&#39;}</code>。<strong><code>注意：如果指定赋值的索引有多个值，那么会将其他多出来的值，赋给指定索引后面的索引。如，char nums[3]={[0]=&#39;a&#39;,&#39;b&#39;,&#39;c&#39;}。</code></strong></li></ul></li><li><p>数组与指针的关系：数组名可以认为是一个指针常量，它指向数组的第0个元素的地址。即数组名的地址值==数组[0]的地址值，也就是说数组名的地址值和数组第一个元素的地址值是相同的。<code>如，int num[2]，那么&amp;num==&amp;(num[0])，且(&amp;num)+1==&amp;(num[1])</code>。</p><p>  例如：</p>  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;    printf_s(<span class="hljs-string">"name?"</span>);    <span class="hljs-keyword">char</span> name[<span class="hljs-number">40</span>];  <span class="hljs-comment">//创建一个字符数组</span>    scanf_s(<span class="hljs-string">"%s"</span>,name);  <span class="hljs-comment">//获取用户输入一个字符串，并将该字符串存入名为name的字符数组</span>    printf_s(<span class="hljs-string">"hello, %s"</span>,name);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;注意：<span class="hljs-keyword">char</span> str[] =&#123;<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>&#125;和<span class="hljs-keyword">char</span> str2[<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>&#125;的区别一、<span class="hljs-keyword">char</span> str[] =&#123;<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>&#125;，该字符数组根据后面拥有的元素来推断数组的大小，所以大小为<span class="hljs-number">3</span>，但是如果以字符串的转换说明输出的话，会出现乱码，因为该字符串中没有足够的位置添加空字符<span class="hljs-string">'\0'</span>；二、<span class="hljs-keyword">char</span> str2[<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>&#125;，该字符数组大小为<span class="hljs-number">3</span>，且只占用了两个空间，在以字符串转换说明(即以<span class="hljs-string">"%s"</span>)输出时，不会报错，因为有空间添加空字符<span class="hljs-string">'\0'</span>，所以能够正常输出。拓展：全局数组和局部数据的初始化一、未初始化，其值有两种可能：    <span class="hljs-number">1.</span>一种是全局数组，被编译器初始化为<span class="hljs-number">0</span>；    <span class="hljs-number">2.</span>一种是局部数组，为随机数。二、部分初始化：不论是全局数组还是局部数组，没有被初始化的部分，都会被初始化为<span class="hljs-number">0</span>。拓展：“*”、指针变量、数组的使用一、<span class="hljs-keyword">int</span> arr[<span class="hljs-number">10</span>]，<span class="hljs-keyword">int</span>  arr = &amp;arr，(arr + <span class="hljs-number">2</span>)，表示arr数组的第三个元素的值；二、arr + <span class="hljs-number">2</span>，表示arr数组的第一个元素的值加<span class="hljs-number">2</span>。</code></pre></li></ul></li></ul><p>&nbsp;</p><ul><li>二维数组：即数组的每个元素是一个一维数组(一维数组就是普通的数组)，这样的数组，我们称为二维数组。多维数组，以此类推。<ul><li>二维数组的基本语法格式：数据类型 数组名称[size1][size2]，其中size1表示，二维数组中有多少个一维数组，size2则表示每个一维数组中有多少个元素。如，int nums[2][3]，表示这个二维数组中有2个一维数组元素，而每个一维数组中都有3个元素。<strong>注意：其实二维数组的创建基本语法格式和一维数组差不多，这里只介绍了一种，还可以直接添加元素到数组中：int nums[2][2]={ {1,2},{3,4} }。</strong></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-21-C语言中的常用函数"><a href="#NO2-21-C语言中的常用函数" class="headerlink" title="NO2.21 C语言中的常用函数"></a>NO2.21 C语言中的常用函数</h3><p>函数是C程序中的主体。</p><ul><li>字符串函数：这一类函数主要对字符串进行操作，存在于string.h头文件中，所以使用时需要引用头文件string.h头文件。<ul><li>strlen(str)：用于表示字符串中的字符长度(包括空格和标点符号，但不会把用于结束的空字符算进去)。<strong>注意：C把函数库中的函数进行归类，为每类函数提供一个头文件。如，printf_s()和scanf_s()都在stdio.h头文件中，strlen()函数则在string.h头文件中等等。</strong></li><li>strcpy_s(str,len,newStr)：将newStr复制到str中，str中的值会被覆盖掉；其中len表示将newStr复制到str时，创建的一个缓冲区的大小，一般的做法就是将len的大小定为newStr的长度加1，即strlen(newStr)+1，为什么要加1？是因为字符串中包含了空字符来表示字符串的结尾，所以需要在字符串本身长度的基础上多加1才能够将这个需要被复制的字符串放入缓冲区中；如果len小于或等于了newStr，那么程序会报错。</li><li>strcat_s(str,len,newStr)：将newStr追加到str中，并不会覆盖str的原有内容，只是做一个追加操作。len表示str的大小，即str数组的大小，一般len设置为sizeof(str)；添加len参数的原因是因为要确保新添加的newStr追加到str后，str的长度不会溢出，保证了程序的安全，这样也方便开发工具做一个检查。<strong>注意：len也可以超出str字符数组的长度，但是这样做会出现奇奇怪怪的结果。</strong></li></ul></li></ul><p>例如：</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;  //引入strlen()函数所在的头文件，该头文件还包含了其他与字符串相关的函数</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;    <span class="hljs-keyword">char</span> name[<span class="hljs-number">40</span>] = &#123;<span class="hljs-string">"abc"</span>&#125;;    printf_s(<span class="hljs-string">"数组的长度是：%d\n"</span>, <span class="hljs-keyword">sizeof</span>(name));  <span class="hljs-comment">//sizeof()表达式用于获取字符数组的大小，前面声明了开了40个字节，那么这里的结果就是40</span>    printf_s(<span class="hljs-string">"你名字的长度是：%d"</span>,<span class="hljs-built_in">strlen</span>(name));  <span class="hljs-comment">//strlen()表达式用于获取字符串的长度，但是不会把空字符(即\0)算进去，返回的结果为3</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;拓展：<span class="hljs-keyword">sizeof</span>一、<span class="hljs-keyword">sizeof</span>是C语言的一种单目操作符。<span class="hljs-keyword">sizeof</span>操作符以字节形式给出了其操作数的存储大小。<span class="hljs-keyword">sizeof</span>的返回值是<span class="hljs-keyword">size_t</span>，在<span class="hljs-number">64</span>位机器下，被定义为<span class="hljs-keyword">long</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>；二、用途：    <span class="hljs-number">1.</span>用于数据类型：使用形式为<span class="hljs-keyword">sizeof</span>(type)。表示这个类型占内存多少字节；    <span class="hljs-number">2.</span>用于变量：使用形式为<span class="hljs-keyword">sizeof</span>(var)或<span class="hljs-keyword">sizeof</span> var。表示常量、变量在内存中占用的字节数。    <span class="hljs-comment">//=====================================================================</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;    <span class="hljs-keyword">char</span> str[<span class="hljs-number">20</span>] = &#123;<span class="hljs-string">"abc"</span>&#125;;    strcpy_s(str , <span class="hljs-number">6</span>,<span class="hljs-string">"ddddd"</span>);  <span class="hljs-comment">//正常运行，最后的输出结果为：ddddd</span>    strcpy_s(str , <span class="hljs-number">4</span>,<span class="hljs-string">"ddddd"</span>);  <span class="hljs-comment">//报错，程序崩溃</span>    strcpy_s(str , <span class="hljs-number">5</span>,<span class="hljs-string">"ddddd"</span>);  <span class="hljs-comment">//报错，程序崩溃</span>    printf_s(<span class="hljs-string">"%s"</span>,str);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//=====================================================================</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;    <span class="hljs-keyword">char</span> str[<span class="hljs-number">5</span>] = &#123;<span class="hljs-string">"abc"</span>&#125;;    strcat_s(str, <span class="hljs-number">5</span>, <span class="hljs-string">"dd"</span>);  <span class="hljs-comment">//报错，程序崩溃，因为"abcdd"总共需要占用6个字节(即"dd\0"，因为还有个空字符表示字符串结尾)</span>    strcat_s(str, <span class="hljs-number">5</span> , <span class="hljs-string">"d"</span>);  <span class="hljs-comment">//正常运行，输出结果为：abcd</span>    printf_s(<span class="hljs-string">"%s"</span>,str);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//-----------------------------------</span><span class="hljs-comment">//以下是len长度超出str长度的结果</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;       <span class="hljs-keyword">char</span> str[<span class="hljs-number">5</span>] = &#123;<span class="hljs-string">"abc"</span>&#125;;       strcat_s(str, <span class="hljs-number">10</span>, <span class="hljs-string">"ddd"</span>);  <span class="hljs-comment">//如果我将len的值设置为10</span>       printf_s(<span class="hljs-string">"%s\n"</span>,str);  <span class="hljs-comment">//输出结果为：abcddd</span>       printf_s(<span class="hljs-string">"%d\n"</span>, <span class="hljs-keyword">sizeof</span>(str));  <span class="hljs-comment">//字符数组的大小还是5</span>       printf_s(<span class="hljs-string">"%d\n"</span>, <span class="hljs-built_in">strlen</span>(str));  <span class="hljs-comment">//拼接后占用了6个字节大小的空间</span>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;注意：这里并没有报错，但是要明白，字符数组str只在内存中开辟了<span class="hljs-number">5</span>个字节大小的空间，那么该数组中也就只能存储<span class="hljs-number">4</span>个字节大小的数据(因为还要包括一个空字符的占用空间)，且已经放入了abc，即说明最多只能再放入一个数据，但是上面却显示输出了abcddd，那么为什么上面没有报错呢？那是因为数组中多出的两个元素占用了不该占用的别的内存的空间来满足自己的需要。在添加了ddd这个字符串之后，字符长度变为了<span class="hljs-number">6</span>，原本数组只能放<span class="hljs-number">4</span>个字符数据的，如今却放进去了<span class="hljs-number">6</span>个，就只能说明，多出的两个字符数据，占用了不该占用的其他内存空间，这是很危险的，假如别的内存空间中有数据，你占用了，就会出现不可预估的错误，所以一般才会将len的长度大小设置为<span class="hljs-keyword">sizeof</span>(str)，即数组本身的大小。</code></pre><p>&nbsp;</p><ul><li>日期函数：这一类函数主要对日期和时间进行操作，存在于time.h头文件中，所以使用时需要引用头文件time.h头文件。<ul><li>time(time_t seconds)：该函数用于获取自格林威治时间1970年1月1日00:00凌晨至现在所经过的秒数，如果seconds不为空，那么获取的秒数也会存储在time_t类型的指针变量seconds中；其中time_t类型其实就是long int类型，简单讲time函数的参数要传入一个long int类型的指针变量；</li><li>ctime_s()：将传入的时间转换成字符串基本语法格式：星期几 月份 天数 时:分:秒 年份；</li></ul></li></ul><p>例如：</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;       <span class="hljs-keyword">time_t</span> myTime;  <span class="hljs-comment">//定义一个time_t类型的变量myTime</span>       <span class="hljs-keyword">time_t</span>  a= &amp;myTime;  <span class="hljs-comment">//获取myTime的地址值，并存入time_t类型的指针变量a中</span>       time(a);  <span class="hljs-comment">//调用函数获取到目前为止的时间秒数</span>       printf_s(<span class="hljs-string">"%u"</span>, myTime/<span class="hljs-number">60</span>/<span class="hljs-number">60</span>/<span class="hljs-number">24</span>/<span class="hljs-number">365</span>);  <span class="hljs-comment">//将秒数转化成年数，结果为距今50年</span>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>&nbsp;</p><ul><li>数学函数</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-22-预处理命令"><a href="#NO2-22-预处理命令" class="headerlink" title="NO2.22 预处理命令"></a>NO2.22 预处理命令</h3><p>使用库函数之前，应该用#include引入对应的头文件。</p><ul><li>预处理命令：<ul><li>定义：在编译之前对源文件进行简单加工的过程就称为预处理。C语言中的预处理命令主要以#号开头。预处理命令要放在所有函数之外，而且一般放在源文件前面。预处理命令由预处理程序完成；</li><li>作用：使得程序便于阅读，修改、移植和调试，也有利于模块化程序的设计。C语言提供了许多预处理功能。如，宏定义、文件包含、条件编译等的。</li><li>C语言常见的预处理命令：<ul><li>#：空指令，无任何效果，可以用来注释；</li><li>#include：包含一个源代码文件，即头文件。如，#include&lt;stdio.h&gt;；</li><li>#define：宏定义命令，即用一个标识符来表示一个数值(不局限于整数，也可以是字符串、字符、表达式等等)，并对程序中所有同样的标识符做替换，这种替换称为宏替换；宏定义分为两种：<ul><li>无参宏定义：基本语法格式：#define 宏名 值。如，#define AGE 10，如果程序中还出现了AGE，那么都将会被替换成10；</li><li>带参宏定义：基本语法格式：#define 宏名(参数1,参数2,…,参数n) 值。如，#define MAX(a,b) ((a)&gt;(b)?(a) : (b))，那么程序中的int c=MAX(5,3)，会被替换成int c=((5)&gt;(3)?(5) : (3))。<strong>注意：带参宏定义尽量多用小括号。</strong></li></ul></li><li>#undef：取消已定义的宏；</li><li>#if：如果给定条件为真，则编译下面代码；</li><li>#elif：如果#if条件不为真，那么当前条件就会为真，编译下面代码；</li><li>#ifdef：如果宏已经定义，则编译下面代码；</li><li>#ifndef：如果宏没有定义，则编译下面代码；</li><li>#endif：结束#if…到…#elif条件编译快。</li></ul></li></ul></li></ul><pre><code class="hljs c">拓展：宏定义和<span class="hljs-keyword">typedef</span>的区别一、宏定义只是简单的值替换，由预处理器进行处理；而<span class="hljs-keyword">typedef</span>则是给原有的数据类型起一个新的名字，基本语法格式为：<span class="hljs-keyword">typedef</span> 原数据类型 新的类型名，且<span class="hljs-keyword">typedef</span>是在由编译器在编译阶段才进行处理。如，<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> INT32，表示把<span class="hljs-keyword">int</span>类型起了一个新名字为INT32。       拓展：带参宏定义和函教调用的区别。一、调用发生的时间：    <span class="hljs-number">1.</span>在源程序进行编译之前，即预处理阶段进行宏替换；    <span class="hljs-number">2.</span>函数调用则发生在程序运行期间。二、参数类型检查：    <span class="hljs-number">1.</span>函数参数类型检查严格。程序在编译阶段，需要检查实参与形参个数是否相等及类型是否匹配或兼容，若参数个数不相同或类型不兼容，则会编译不通过；    <span class="hljs-number">2.</span>在预处理阶段，对带参宏调用中的参数不做检查。即宏定义时不需要指定参数类型，既可以认为这是宏的优点，即适用于多种数据类型，又可以认为这是宏的一个缺点，即类型不安全。故在宏调用时，需要程序设计者自行确保宏调用参数的类型正确。三、参数是否需要空间：    <span class="hljs-number">1.</span>函数调用时，需要为形参分配空间，并把实参的值复制一份赋给形参分配的空间中。    <span class="hljs-number">2.</span>宏替换，仅是简单的文本替换，且替换完就把宏名对应标识符删除掉，即不需要分配空间。四、执行速度：    <span class="hljs-number">1.</span>函数在编译阶段需要检查参数个数是否相同、类型等是否匹配等多个语法，且函数在运行阶段参数需入栈和出栈操作，速度相对较慢；    <span class="hljs-number">2.</span>宏替换仅是简单文本替换，不做任何语法或逻辑检查。五、代码长度：    <span class="hljs-number">1.</span>由于宏替换是文本替换，即如果需替换的文本较长，则替换后会影响代码长度；    <span class="hljs-number">2.</span>函数不会影响代码长度。故使用较频繁且代码量较小的功能，一般采用宏定义的形式，比采用函数形式更合适。</code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-23-VS2019的DEBUG调试的使用"><a href="#NO2-23-VS2019的DEBUG调试的使用" class="headerlink" title="NO2.23 VS2019的DEBUG调试的使用"></a>NO2.23 VS2019的DEBUG调试的使用</h3><p>debug模式，是我们常用来调试程序而使用的，简单讲就是查看程序是否有问题。</p><ul><li>VS2019中的debug模式的使用：<ul><li>首先，在需要断点(你想要查看的语句)的程序语句行号前双击即可，这样就可以打上断点了。<strong>注意：一般都是断点都是打在函数第一行有效的语句上。</strong></li><li>然后，按F5，开始调试，进入debug模式的页面，按F10可以每一行每一行的查看和执行程序的语句；</li></ul></li></ul><p><img src="./Image-c28.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-c29.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-c30.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-24-指针变量和指针数组"><a href="#NO2-24-指针变量和指针数组" class="headerlink" title="NO2.24 指针变量和指针数组"></a>NO2.24 指针变量和指针数组</h3><p>指针其实就是地址值；指针变量存储的是地址值。</p><ul><li>指针变量的使用：<ul><li>赋值：即可以把地址赋给指针变量；</li><li>解引用：*运算符给出指针变量中指向地址上储存的值；<strong>注意：*无法用在字符串字面量前面来解引用。如，char* str =”abc”，那么*str就会报错，因为字符串本身就比较特殊，即字符串本身是字符数组，而数组本身就是指针变量，所以使用转换说明“%s”输入字符串时，不需要在str前面加上*号来解引用。</strong></li><li>取址：&amp;运算符给出变量本身的地址值，然后赋值给指针变量；</li><li>指针变量与整数相加：即地址值与整数相加，得出初始地址与整数相加的结果地址值；</li><li>递增指针变量：一般用在数组上，地址值指向下一个数组元素的地址上；</li><li>递减指针变量：一般用在数组上，地址值指向上一个数组元素的地址上；</li><li>指针变量求差：一般用在数组上，地址值相减，得出两个元素之间的距离；</li><li>指针变量比较：比较的是两个指针中地址所指向的值。</li></ul></li></ul><p>例如：</p><pre><code class="hljs c"><span class="hljs-comment">//指针变量自增与自减</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;    <span class="hljs-keyword">int</span>* arrp = &amp;arr;    arrp++;  <span class="hljs-comment">//appr原本指向arr[0]的地址值，指针变量自增后，指向了a[1]的地址值</span>    printf_s(<span class="hljs-string">"%d\n"</span>, *arrp);  <span class="hljs-comment">//与arr[1]元素的值相同</span>    printf_s(<span class="hljs-string">"%d\n"</span>, arr[<span class="hljs-number">1</span>]);    arrp--;  <span class="hljs-comment">//指针变量自减</span>    printf_s(<span class="hljs-string">"%d"</span>, *arrp);  <span class="hljs-comment">//与arr[0]元素的值相同</span>    printf_s(<span class="hljs-string">"%d\n"</span>, arr[<span class="hljs-number">0</span>]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//------------------------------</span><span class="hljs-comment">//指针变量求差</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;       <span class="hljs-keyword">int</span> arr[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;       <span class="hljs-keyword">int</span> arrp = &amp;arr;       printf_s(<span class="hljs-string">"%p\n"</span>, &amp;(arr[<span class="hljs-number">1</span>])-arrp);  <span class="hljs-comment">//输出结果为0000000001</span>       printf_s(<span class="hljs-string">"%d\n"</span>, &amp;(arr[<span class="hljs-number">1</span>]) - arrp);  <span class="hljs-comment">//输出结果为1</span>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>&nbsp;</p><ul><li>指针数组：<ul><li>定义：即数组中存储的元素都是指向同一数据类型的指针变量；</li><li>基本语法基本语法格式：数据类型* 数组名[size]或数据类型 *  数组名[size]，两者均可。如，int * ptr[5]。<strong>注意：多重指针的实质是：使用一个指针变量a来存放另一个指针变量b本身的地址，而b存放的则是另一个变量的地址值。</strong></li></ul></li></ul><p>例如：</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span>* ap = &amp;a;<span class="hljs-keyword">int</span>** app = &amp;ap;  <span class="hljs-comment">//这就是多重指针，指向的是指针变量ap的地址，而指针变量ap存放的是变量a的地址值，说白了多重指针就是一个指针变量的多层嵌套</span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-25-函数指针和回调函数"><a href="#NO2-25-函数指针和回调函数" class="headerlink" title="NO2.25 函数指针和回调函数"></a>NO2.25 函数指针和回调函数</h3><p>代码中如果有函数的定义，那么系统也会在栈空间分配一块内存给这个函数，即这段存储空间的首地址称为这个函数的地址；函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。</p><ul><li>函数指针的定义方式为：函数返回值类型 ( 指针变量名) (* 函数参数列表)。其中，“函数返回值类型”表示该指针变量可以指向具有什么返回值类型的函数，“函数参数列表”表示该指针变量可以指向具有什么参数列表的函数。这个参数列表中只需要写函数的参数类型即可。我们看到，函数指针的定义就是将“函数声明”中的“函数名”改成“(* 指针变量名)”。<strong>注意：函数指针中的()不可以省略。</strong></li></ul><p>例如：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>;   <span class="hljs-comment">//声明一个函数</span><span class="hljs-keyword">int</span> (*p) (<span class="hljs-keyword">int</span> x);  <span class="hljs-comment">//定义一个函数指针</span>p = Func;          <span class="hljs-comment">//将Func函数的首地址赋给指针变量p</span><span class="hljs-keyword">int</span> (* ptr) (<span class="hljs-keyword">int</span> x) = Func；<span class="hljs-comment">//------------------------------------------------------</span><span class="hljs-comment">//函数的调用</span>#include&lt;stdio.h&gt;<span class="hljs-keyword">int</span> getSum(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b);  <span class="hljs-comment">//声明了一个函数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;       <span class="hljs-keyword">int</span> (*ptr) (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) = getSum;  <span class="hljs-comment">//声明了一个函数指针ptr，并将getSum函数赋值给了该函数指针ptr</span>       <span class="hljs-keyword">int</span> res = (*ptr) (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">//通过调用函数指针来调用函数</span>       printf_s(<span class="hljs-string">"%d"</span>,res);       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;  <span class="hljs-comment">//函数的实现</span>       <span class="hljs-keyword">return</span> a + b;&#125;</code></pre><p>&nbsp;</p><ul><li>回调函数：就是将函数指针当作一个参数传入别人的函数中，这样别就可以通过函数指针调用你的函数了。注意：函数指针作为参数进行传递时，如果函数指针中带有参数，那么需要将参数取出来，也当做参数进行传递。</li></ul><p>例如：</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSumA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> (*ptr) ())</span></span>;  <span class="hljs-comment">//声明了一个函数getSumA，其参数要传入一个函数指针变量，该函数指针中带有参数，所以将参数a、b取出来，也当做getSumA的参数进行传递</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSumB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;  <span class="hljs-comment">//又声明了一个函数getSumB</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;       <span class="hljs-keyword">int</span> (*p) (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) = getSumB;  <span class="hljs-comment">//为getSumB创建了一个函数指针</span>       <span class="hljs-keyword">int</span> res = getSumA(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,p);  <span class="hljs-comment">//调用getSumA</span>       printf_s(<span class="hljs-string">"%d"</span>,res);       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSumA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> (*ptr) ())</span> </span>&#123;  <span class="hljs-comment">//getSumA函数的实现</span>       <span class="hljs-keyword">return</span> ptr (a, b);  <span class="hljs-comment">//实际调用getSumB的函数指针</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSumB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;  <span class="hljs-comment">//getSumB函数的实现</span>       <span class="hljs-keyword">return</span> a + b;&#125;输出结果为：<span class="hljs-number">3</span></code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-26-C程序的不同数据的内存分配"><a href="#NO2-26-C程序的不同数据的内存分配" class="headerlink" title="NO2.26 C程序的不同数据的内存分配"></a>NO2.26 C程序的不同数据的内存分配</h3><p>C程序中，针对不同的数据，存放的位置也不一样。</p><ul><li>在C/C++中内存分为5个区，分别为栈区、堆区、全局/静态存储区、常量存储区、代码区。按内存分配类型划分为：<ul><li>静态内存分配：编译时分配。包括：全局变量、静态全局变量、静态局部变量这三种；</li><li>动态内存分配：运行时分配。包括：<ul><li>栈(stack): 局部变量；</li><li>堆(heap): C语言中用到的临时数据被动态的分配在内存中。需要时随时开辟，不需要时及时释放。如，malloc或calloc、realloc、free函数)。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>栈区、堆区、全局/静态存储区、常量存储区、代码区的详细介绍：<ul><li>栈区(stack)：指那些由编译器在需要的时候分配，不需要时自动清除的变量所在的储存区。如，函数执行时，函数的形参以及函数内的局部变量分配在栈区，函数运行结束后，形参和局部变量自动释放。栈内存分配效率高但是分配的内存空间有限；</li><li>堆区(heap)：指那些由程序员手动分配或释放的储存区，如果程序员不释放这块内存，内存将一直被占用，直到程序运行结束由系统自动收回。C语言中使用malloc，free申请和释放空间；</li><li>静态储存区(static)：全局变量和静态变量的储存是放在一起的。其中已初始化的全局变量和静态变量在一个区域，这块空间当程序运行结束后由系统释放；</li><li>常量储存区(const)：常量字符串就是储存在这里的。如，“ABC”字符串就储存在常量区，但储存在常量区的只读不可写。const修饰的全局变量也储存在常量区，const修饰的局部变量依然在栈上。</li><li>程序代码区：存放源程序的二进制代码。</li></ul></li></ul><p>&nbsp;</p><ul><li>堆与栈的对比：<ul><li>申请方式：<ul><li>栈由编译器管理；</li><li>堆的分配和释放由程序员管理。</li></ul></li><li>申请大小：<ul><li>栈是向低地址生长的数据结构，是一块连续的内存，能从栈中获得的内存较小，编译期间确定大小；</li><li>堆是向高地址生长的数据结构，是一个不连续的储存空间，，内存获取比较灵活，也较大。</li></ul></li><li>栈与堆中的储存内容：<ul><li>栈：在函数调用时，第一个进栈的是主函数中的最后一条指令的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量(静态变量是不入栈的)，当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点开始运行；</li><li>堆：一般是在堆的头部用一个字节存放堆的大小，堆中的具体内容由程序员安排。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>动态内存分配使用的函数。<strong>注意：下面的四个函数是放在stdlib.h头文件中。下面参数中的size_t其实就是在32位架构中被普遍定义为：unsigned int，而在64位架构中被普遍定义为：unsigned long；C99标准中，定义了void为无类型指针，即只表示一个地址，不指向任何具体的对象，说白了，void就指向一个纯地址值，且该地址不指向任何数据；堆内存，尽量不要分配大量的小内存块，且分配的内存用过后尽快释放。</strong><ul><li>malloc函数：<ul><li>函数原型: void  * malloc (size_ t size)；</li><li>功能：<ul><li>开辟一块size大小的连续堆内存；</li><li>size表示堆上所开辟内存的大小，单位是字节数；</li><li>函数返回值是一个指针，指向刚刚开辟的内存中第一个字节的地址；</li><li>如果开辟内存失败，返回一个空指针，即返回值为NULL；</li><li>当内存不再使用时，应使用free()函数将内存块释放；</li><li>使用时必须包含头文件&lt;stdlib.h&gt;或&lt;malloc.h&gt;。</li></ul></li></ul></li><li>calloc函数：<ul><li>函数原型: void  calloc(size_ t n, size t size)；</li><li>功能：<ul><li>在内存的动态存储区中分配n个长度为size的连续空间，即分配nsize大小的堆内存空间，该函数开辟的空间一般比较大；</li><li>函数返回一个指向分配空间的起始地址的地址；</li><li>如果分配不成功，返回NULL；</li><li>当内存不再使用时，应使用free()函数将内存块释放；</li><li>使用时必须包含头文件&lt;stdlib.h&gt;或&lt;malloc.h&gt;。</li></ul></li></ul></li><li>realloc函数：<ul><li>函数原型：void  realloc(void  mem_address, size_ t newsize)；</li><li>功能：<ul><li>为已有内存(即使用malloc或calloc函数开辟的空间)重新分配新的内存大小(可大、可小)；</li><li>先判断当前的指针是否有足够的连续空间，如果有，扩大mem_address指向的地址，并且将mem_ address返回；如果空间不够，先按照newsize指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来mem_address所指内存区域(注意：原来指针是自动释放，不需要使用free)，同时返回新分配的内存区域的首地址。即重新分配存储器块的地址；</li><li>如果重新分配成功则返回指向被分配内存的指针；</li><li>如果分配不成功，返回NULL；</li><li>当内存不再使用时，应使用free()函数将内存块释放；</li><li>使用时必须包含头文件&lt;stdlib.h&gt;或&lt;malloc.h&gt;。</li></ul></li></ul></li><li>free函数：<ul><li>函数原型: void free (void ptr)，ptr为要释放的内存指针；</li><li>free()：释放指针变量在堆区上的内存空间，不能释放栈上的内存空间，free要与malloc(calloc、realloc)成对使用。注意：如果malloc（calloc、realloc） 比 free 多， 会造成内存泄漏；如果malloc（calloc、realloc） 比 free 少，会造成二次删除， 破坏内存，导致程序崩溃。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-27-结构体和共用体"><a href="#NO2-27-结构体和共用体" class="headerlink" title="NO2.27 结构体和共用体"></a>NO2.27 结构体和共用体</h3><p>在C语言中，可以使用结构体(Struct)来存放一组不同类型的数据，即结构体中存放的数据，可以是不同数据类型的意思。</p><ul><li><p>结构体：</p><ul><li><p>定义：就是将一个个数据类型构成一个数据类型以方便使用，说白了就是用来存放不同类型数据的另一个数据类型而已；这些成员会占用不同的内存，且不会互相影响；</p></li><li><p>结构体变量：既然结构体是一种数据类型，那么就可以用它来定义变量；</p><ul><li>结构体变量，能够调用自己结构体内所用于的成员；</li><li>结构体变量的成员也能够被赋值。</li></ul></li><li><p>基本语法基本语法格式：</p></li></ul></li></ul><pre><code class="hljs c"><span class="hljs-comment">//基本语法格式一</span><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名&#123;</span>  <span class="hljs-comment">//结构体面一般首字母大写。如，Cat、Student等等</span>    结构体所包含的变量或数组或指针或结构体等等&#125;;如：<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>&#123;</span>    <span class="hljs-keyword">char</span> name;  <span class="hljs-comment">//姓名</span>    <span class="hljs-keyword">int</span> num;  <span class="hljs-comment">//学号</span>    <span class="hljs-keyword">int</span> age;  <span class="hljs-comment">//年龄</span>    <span class="hljs-keyword">char</span> group;  <span class="hljs-comment">//所在学习小组</span>    <span class="hljs-keyword">float</span> score;  <span class="hljs-comment">//成绩</span>&#125;<span class="hljs-comment">//----------------------------------------------------------</span><span class="hljs-comment">//基本语法格式二</span><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名&#123;</span>    结构体所包含的变量或数组或指针或结构体等等&#125; 结构体变量名<span class="hljs-number">1</span>, 结构体变量名<span class="hljs-number">2.</span>...;  <span class="hljs-comment">//定义结构体的同时，还创建了结构体变量</span>注意：还可以使用匿名结构体方式创建结构体变量<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>      结构体所包含的变量或数组或指针或结构体等等&#125; 结构体变量名<span class="hljs-number">1</span>, 结构体变量名<span class="hljs-number">2.</span>...;  <span class="hljs-comment">//定义结构体的同时，还创建了结构体变量</span>此时创建的结构体是没有名称的，只能使用上面的方式创建，要是还想再使用，必须重新创建    <span class="hljs-comment">//================================================================</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名 结构体变量名;</span>如：<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">st1</span>;</span>  <span class="hljs-comment">//定义了一个Student类型的变量st1</span><span class="hljs-comment">//================================================================</span>结构体变量.成员名称如：st1.namest1.age    <span class="hljs-comment">//================================================================  </span>    方式一赋值：    结构体变量.成员名称 = 值    <span class="hljs-comment">//-----------------------</span>方式二赋值：    struct 结构体名&#123;    结构体所包含的变量或数组或指针或结构体等等&#125; 结构体变量名<span class="hljs-number">1</span> = &#123;值<span class="hljs-number">1</span>,值<span class="hljs-number">2.</span>...&#125;, 结构体变量名<span class="hljs-number">2</span>= &#123;值<span class="hljs-number">1</span>,值<span class="hljs-number">2.</span>...&#125;....;</code></pre><p>&nbsp;</p><ul><li>共用体：<ul><li>定义：和结构体很类似，也是用于存储其他数据类型的一个数据类型，但和结构体不同的是，共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员；共用体占用的内存等于最长的成员占用的内存；共用体也成为联合或联合体；共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。</li><li>共用体变量也可以创建变量；</li><li>共用体变量的成员也能够被赋值；</li><li>基本语法基本语法格式：</li></ul></li></ul><pre><code class="hljs c"><span class="hljs-keyword">union</span> 共用体名&#123;    成员列表&#125;;如：<span class="hljs-keyword">union</span> stu&#123;    <span class="hljs-keyword">char</span> name;  <span class="hljs-comment">//char占用1个字节</span>    <span class="hljs-keyword">int</span> age;  <span class="hljs-comment">//int类型占用4个字节，所以该共用体占用的内存为4，即以最长数据类型占用的内存为共用体的占用内存</span>&#125;<span class="hljs-comment">//--------------------------------------</span><span class="hljs-keyword">union</span> 共用体名&#123;    成员列表&#125;  共用体变量<span class="hljs-number">1</span>,共用体变量<span class="hljs-number">2.</span>...;  <span class="hljs-comment">//这里定义了共用体的同时还定义了共用体变量</span>注意：还可以使用匿名结构体方式创建共用体变量<span class="hljs-keyword">union</span> &#123;      结构体所包含的变量或数组或指针或结构体等等&#125; 共用体变量名<span class="hljs-number">1</span>, 共用体变量名<span class="hljs-number">2.</span>...;  <span class="hljs-comment">//定义共用体的同时，还创建了结构体变量</span>此时创建的共用体是没有名称的，只能使用上面的方式创建，要是还想再使用，必须重新创建    <span class="hljs-comment">//================================================</span>  <span class="hljs-keyword">union</span> 共用体名 共用体变量名;<span class="hljs-comment">//=================================================</span>结共用体变量.成员名称 = 值</code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-28-文件处理"><a href="#NO2-28-文件处理" class="headerlink" title="NO2.28 文件处理"></a>NO2.28 文件处理</h3><p>在操作系统中，为了统一对各种硬件的操作，简化接口，不同的硬件设备也都被看成一个文件。对这些文件的操作，等同于对磁盘上普通文件的操作。如，<br>通常把显示器称为标准输出文件，printf就是向这个文件输出数据；通常把键盘称为标准输入文件，scanf就是从这个文件读取数据等等。</p><ul><li>按照文件数据流的走向可分为：<ul><li>数据从文件复制到内存的过程叫做输入流，也成为读文件；</li><li>从内存保存到文件的过程叫做输出流，也成为写文件。</li><li>EOF：指的是end of file，表示文件末尾，且在头文件stdio.h中已经定义好了EOF的值为-1。getchar()和scanf_s()函数检测到文件结尾时，这两个函数都返回EOF，所以C中使用EOF来当做I/O的结尾条件。</li></ul></li></ul><p><img src="./Image-c31.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><ul><li>C语言常见的其他输入和输出函数：<ul><li>getchar()和putchar()函数：<ul><li>int getchar(void)：用于获得用户输入的字符，等价于scanf_s(“%c”,&amp;ch)；</li><li>int putchar(int c)：输出放入函数中的字符，即putchar(‘字符’)，等价于printf_s(“%c”,ch)。<strong>注意：getchar()和putchar()函数这两个函数在stdio.h头文件中。</strong></li></ul></li><li>gets_s()和puts()函数：<pre><code>- char gets(char s,size_t size)：读取输入的字符串，直至接收到换行符或EOF时停止，其中size为允许输入的长度，一般长度为字符数组s的长度减1。读入成功时，返回接收读取结果的字符数组的首地址，读入发生错误或遇到EOF返回NULL；    - int puts(const char s)：输出字符串并换行。该函数只能输出字符串，不能输出其他类型数值；执行成功返回非负数，执行失败返回EOF。</code></pre></li></ul></li></ul><p>例如：</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;     <span class="hljs-keyword">char</span> c = getchar();  <span class="hljs-comment">//等价于scanf_s("%c",&amp;c);</span>    <span class="hljs-built_in">putchar</span>(c);  <span class="hljs-comment">//等价于printf_s("%c", c);</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//=================================================</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;       <span class="hljs-keyword">char</span> arr[<span class="hljs-number">3</span>];       gets_s(arr, <span class="hljs-keyword">sizeof</span>(arr) - <span class="hljs-number">1</span>);  <span class="hljs-comment">//如果输入的arr超出了后面的size的话，那么会报错</span>       <span class="hljs-built_in">puts</span>(arr);       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>&nbsp;</p><ul><li>操作文件的正确流程为：打开文件 –&gt; 读写文件 –&gt; 关闭文件。文件在进行读写操作之前要先打开，使用完毕要关闭。打开文件和关闭文件的函数如下：<ul><li>errno_t fopen(FILE p,char filename, char mode)函数：用于打开文件。函数中的filename字符串参数，表示要打开的文件的文件名(包括文件路径)，如果文件名存在就是打开文件，不存在该文件名就创建一个新文件，以该文件名命名并打开。该函数在&lt;stdio.h&gt;头文件中；mode字符串参数表示要以什么权限打开文件。<strong>注意：如果文件打开失败会返回非0，成功返回0。</strong>具体权限如下所示：<ul><li>“r”：以“只读”方式打开文件。只允许读取，不允许写入。文件必须存在，否则打开失败；</li><li>“w”：以“写入”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容(相当于删除原文件，再创建一个新文件)；</li><li>“a”：以“追加”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾(文件原有的内容保留)；</li><li>“r+”：以“读写”方式打开文件。既可以读取也可以写入，也就是随意更新文件。文件必须存在，否则打开失败；</li><li>“w+”：以“写入/更新”方式打开文件，相当于w和r+叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容(相当于删除原文件，再创建一个新文件)；</li><li>“a+”：以“追加/更新”方式打开文件，相当于a和r+叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾(文件原有的内容保留)。</li><li>“t”：表示文本文件。如果不写，默认为”t”；注意：该选项一般放在上面读写权限的后面。</li><li>“b”：表示二进制文件。<strong>注意：如果打开的是二进制文件，那么一定要加“b”；该选项一般放在上面读写权限的后面，如，a+b、r+b等等。</strong></li></ul></li></ul></li><li>int fclose(FILE fp)函数：文件一旦使用完毕，应该用fclose()函数把文件关闭，以释放相关资源，避免数据丢失。文件正常关闭时，fclose()的返回值为0，如果返回非零值则表示有错误发生。</li></ul><p>&nbsp;</p><ul><li><p>读写文件相关的函数：</p><ul><li><p>读写一个字符：</p><ul><li>int fgetc (FILE fp)函数：从指定的文件中读取一个字符。参数fp为文件指针。fgetc()读取成功时返回读取到的字符，读取到文件末尾或读取失败时返回EOF。</li><li>int fputc(int ch, FILE fp )函数：向指定的文件中写入一个字符。参数ch为要写入的字符，参数fp为文件指针。fputc()写入成功时返回写入的字符，失败时返回 EOF，返回值类型为int也是为了容纳这个负数。</li></ul></li><li><p>读写一个字符串：</p><ul><li>char fgets(char str, int n, FILE fp )：从指定的文件中读取一个字符串，并保存到字符数组中。参数str为字符数组，参数n为要读取的字符数目，参数fp为文件指针。读取成功时返回字符数组首地址，也即str；读取失败时返回 NULL；如果开始读取时文件内部指针已经指向了文件末尾，那么将读取不到任何字符，也返回NULL。</li><li>int fputs(char str, FILE fp )：向指定的文件写入一个字符串。参数str为要写入的字符串，参数fp为文件指针。写入成功返回非负数，失败返回EOF。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-29-缓冲I-O和无缓冲I-O"><a href="#NO2-29-缓冲I-O和无缓冲I-O" class="headerlink" title="NO2.29 缓冲I/O和无缓冲I/O"></a>NO2.29 缓冲I/O和无缓冲I/O</h3><p>C中输入分为缓冲和无缓冲两种。</p><ul><li>缓冲I/O：通俗的理解为当用户输入之后，直到按回车键为止，期间用户输入的内容会存放在一个缓冲区里面。首先，把若干字符作为一个块进行传输比逐个发送这些字符节约时间。其次，如果用户打错字符，可以直接通过键盘修正错误。当最后按下Enter键时，传输的是正确的输入。缓冲分为两类：完全缓冲I/O和行缓冲I/O。注意：ANSI C和后续的C标准都规定输入是缓冲的。<ul><li>完全缓冲I/O：指的是当缓冲区被填满时才刷新缓冲区，通常出现在文件输入中。缓冲区的大小取决于系统，常见的大小是512字节和4096字节；</li><li>行缓冲I/O：指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区。行缓冲函数有getchar()和scanf_s()。</li></ul></li></ul><p>&nbsp;</p><ul><li>无缓冲I/O：说白了，就是你输入什么，它都能立马给你执行函数后面的内容。看电脑是否支持无缓冲I/O，如果支持，那么编译器添加&lt;conio.h&gt;这个头文件后，有两个无缓冲的函数：_getche()函数和_getch()函数，前者会回显用户的输入到屏幕上，而后者不会回显用户的输入到屏幕上。</li></ul><p>例如：</p><pre><code class="hljs c"><span class="hljs-comment">//测试_getche()函数和_getch()函数，代码如下</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;conio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">char</span> ch;<span class="hljs-keyword">while</span> ((ch = _getche()) != <span class="hljs-string">'8'</span>) &#123;    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">'t'</span>);&#125;/<span class="hljs-keyword">while</span> ((ch = _getch()) != <span class="hljs-string">'8'</span>) &#123;    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">'t'</span>);&#125;/<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><img src="./Image-c32.png" srcset="/img/loading.gif" alt="Image"><br>说明：测试_getche()函数，分别输入1、2、3，返回如上结果，有回显用户的输入。</p><p>&nbsp;</p><p><img src="./Image-c33.png" srcset="/img/loading.gif" alt="Image"><br>说明：测试_getch()函数，分别输入1、2、3，返回如上结果，没有回显用户的输入。</p><p>&nbsp;</p>]]></content>
    
    
    <categories>
      
      <category>大一课程</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大一课程</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机科学导论--学习笔记</title>
    <link href="/2020/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机科学导论–学习笔记-包含计算机科学导论书籍"><a href="#计算机科学导论–学习笔记-包含计算机科学导论书籍" class="headerlink" title="计算机科学导论–学习笔记(包含计算机科学导论书籍)"></a>计算机科学导论–学习笔记(包含计算机科学导论书籍)</h1><h2 id="Lesson1-绪论"><a href="#Lesson1-绪论" class="headerlink" title="Lesson1 绪论"></a>Lesson1 绪论</h2><h3 id="NO1-1-图灵模型"><a href="#NO1-1-图灵模型" class="headerlink" title="NO1.1 图灵模型"></a>NO1.1 图灵模型</h3><p>根据图灵模型所得的通用图灵机是对现代计算机的首次描述。</p><ul><li>阿兰·图灵在1937年首次提出了一个通用计算设备的设想，他设想所有的计算都可能在一种特殊的机器上执行，这就是现在所说的图灵机。</li></ul><p><img src="./Image-jsj1.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><ul><li>图灵模型，该模型是在图灵机思想的基础上，演变而来的模型，它更适用于通用计算机，因为图灵模型添加了一个额外的元素到计算机中，这就是程序。</li></ul><p><img src="./Image-jsj2.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><ul><li>简单讲，程序是一个有序的指令集合，作用是告诉计算机怎么对数据进行处理。</li></ul><p><img src="./Image-jsj3.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-2-冯·诺依曼模型"><a href="#NO1-2-冯·诺依曼模型" class="headerlink" title="NO1.2 冯·诺依曼模型"></a>NO1.2 冯·诺依曼模型</h3><p>基于图灵机的思想，冯·诺依曼在1944~1945年期间指出了：鉴于程序和数据在逻辑上是相同的，因此程序也能存储在计算机的存储器中——这就是冯诺依曼模型。</p><ul><li>基于冯·诺依曼模型建造的计算机有四个模块：<ul><li>存储器，用来存储数据和程序的模块；</li><li>算数逻辑单元(ALU，即运算器)，用来进行计算和逻辑运算的模块；</li><li>控制单元(即控制器)，顾名思义，就是对存储器、算术逻辑单元、以及输入/输出设备进行控制的模块；</li><li>输入/输出单元(即输入/输出设备)，就是接收计算机外部的数据和程序，并将计算机的处理结果输出到外部的模块。</li></ul></li></ul><p><img src="./Image-jsj4.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><ul><li>存储程序的概念：程序由指令组成，并和数据一起存放在存储器中，计算机启动后，能自动地按照程序指令的逻辑顺序逐条把指令从存储器中读出来，并且完成由程序所描述的处理工作；冯·诺依曼模型指出，程序必须存储在存储器中。</li></ul><p><img src="./Image-jsj5.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-3-计算机的组成"><a href="#NO1-3-计算机的组成" class="headerlink" title="NO1.3 计算机的组成"></a>NO1.3 计算机的组成</h3><p>计算机由两大部分组成，即计算机硬件和计算机软件(包括了数据)。软件工程指的是结构化程序的设计和编写。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-4-计算机的发展历史"><a href="#NO1-4-计算机的发展历史" class="headerlink" title="NO1.4 计算机的发展历史"></a>NO1.4 计算机的发展历史</h3><p>计算机的发展历史，说白了就是计算机硬件的发展历史。</p><ul><li>计算机的发展历程，主要分为了以下几个阶段：<ul><li>机械计算机器(1930年以前)，该阶段，人们发明了一些用来进行计算的机器，但是它们与计算机的现代概念几乎没有什么关系；</li><li>电子计算机的诞生(1930~1950年)，在这个阶段里，电子计算机工业先驱的科学家们发明了一些计算机。如，1939年发明的第一台计算机，名为阿塔纳索夫-贝瑞计算机(又称ABC)、同时期被发明的还有德国的“Z1”、1946年诞生了著名的“ENIAC”、第一台基于冯氏思想(即存储程序思想)而诞生的计算机“EDVAC”等等；</li><li>计算机的诞生(1950年至今)，1950年以后出现的计算机差不多都基于冯·诺依曼模型。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><h2 id="Lesson2-数字系统"><a href="#Lesson2-数字系统" class="headerlink" title="Lesson2 数字系统"></a>Lesson2 数字系统</h2><h3 id="NO2-1-数字系统的理解"><a href="#NO2-1-数字系统的理解" class="headerlink" title="NO2.1 数字系统的理解"></a>NO2.1 数字系统的理解</h3><p>数字系统，简单理解就是，在不同的系统中，数字表示的方法是不一样的。如，数字5，在十进制中就是5，在中文中是“五”，在罗马数字系统中是“V”，这三个符号表示的都是5，只不过符号不一样。数字系统又分为位置化数字系统和非位置化数字系统。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-2-位置化数字系统"><a href="#NO2-2-位置化数字系统" class="headerlink" title="NO2.2 位置化数字系统"></a>NO2.2 位置化数字系统</h3><p>所谓的位置化数字系统，指的是数字中符号所占据的位置决定了其表示的值。如，一个数字符号3，出现在不同的位置表示的意思也不同，如，个位(3)，十位(30)，百位(300)，千位(3000)等等。在位置化数字系统的眼里，任何的数字，采用任何的进制，都可以用一条公式概括出来，如下图所示：</p><p><img src="./Image-jsj6.png" srcset="/img/loading.gif" alt="Image"></p><p><strong>说明：这条公式中字母S旁边的k-1….2、1、0、-1、-2、-3….-l表示的是数字所在位置。</strong></p><p>&nbsp;</p><p><img src="./Image-jsj7.png" srcset="/img/loading.gif" alt="Image"><br><strong>说明：这是这个数字要表达的值的计算方式，其中b的零次方、一次方….通俗的讲，就是这个数字在这个位置所要表示的大小，而b表示这个数字是多少进制。</strong></p><p>&nbsp;</p><p><img src="./Image-jsj8.png" srcset="/img/loading.gif" alt="Image"><br><strong>说明：十进制数789，用这个公式的表达。</strong></p><p>&nbsp;</p><ul><li>常见的位置化数字系统包括：<ul><li>十进制系统，简单的讲就是用0~9这十个符号来表示数字的系统，而十进制系统的规则是“逢十进一”。生活中我们用的数字就是十进制系统的数字。如，9+1，这里已经满十了，根据规则“逢十进一”，所以就需要往前进一位，且9后面没有别的数字，就只能重新回到0，所以9变成0，又因为往前进了一位，所以结果就是10。其实我们常用的数字，正确的表示应该为：正负号(数值)₁₀，只是我们把符号、括号、以及底都省略了，但并不是真的都消失了；</li><li>二进制系统，就是使用0和1这两个符号来表示数字的系统，规则是“逢二进一”；</li><li>十六进制系统，是指用0到9和(10)A、(11)B、(12)C、(13)D、(14)E、(15)F，这十六个符号来表示数字的系统，规则是“逢十六进一”；</li><li>八进制系统，用数字0到7这八个符号来表示数字的系统，规则是“逢八进一”。</li></ul></li></ul><p><img src="./Image-jsj9.png" srcset="/img/loading.gif" alt="Image"><br><strong>说明：这是正数224的表示。</strong></p><p>&nbsp;</p><p><img src="./Image-jsj10.png" srcset="/img/loading.gif" alt="Image"><br><strong>说明：这是小数24.13的表示。</strong></p><pre><code class="hljs java">拓展：基数和位权(其实就是上面所说的位置化数字系统)一、基数，其实指的就是，在不同进制数中，进制是多少，那么它的基数就是多少；如二进制的基数就是<span class="hljs-number">2</span>，八进制的基数就是<span class="hljs-number">8</span>，同理十进制的基数是<span class="hljs-number">10</span>，十六进制的基数就是<span class="hljs-number">16</span>等等；    二、权值，简单理解就是幂，而幂的值是根据当前目标值的所在位数减<span class="hljs-number">1</span>，即n-<span class="hljs-number">1</span>；如，二进制<span class="hljs-number">101</span>，基数是<span class="hljs-number">2</span>，权值分别是<span class="hljs-number">12</span>^<span class="hljs-number">2</span>、<span class="hljs-number">02</span>^<span class="hljs-number">1</span>、<span class="hljs-number">12</span>^<span class="hljs-number">0</span>，百位上的<span class="hljs-number">1</span>，从右往左数，是第三位，所以它的权值就是<span class="hljs-number">3</span>-<span class="hljs-number">1</span>=<span class="hljs-number">2</span>，十位上的<span class="hljs-number">0</span>的权值就是<span class="hljs-number">2</span>-<span class="hljs-number">1</span>=<span class="hljs-number">1</span>，以此类推；三、位权，其实就是指以进制基数为底的幂，简单理解就是，二进制的位权就是以<span class="hljs-number">2</span>为底的幂，同理十六进制的位权则是以<span class="hljs-number">16</span>为底的幂，其他进制也是同理。</code></pre><p>&nbsp;</p><p><img src="./Image-jsj11.png" srcset="/img/loading.gif" alt="Image"><br><strong>说明：这是与十进制数25等值的二进制数11001。</strong></p><p>&nbsp;</p><p><img src="./Image-jsj12.png" srcset="/img/loading.gif" alt="Image"><br><strong>说明：这是与十进制数5.75等值的二进制数101.11。</strong></p><p>&nbsp;</p><p><img src="./Image-jsj13.png" srcset="/img/loading.gif" alt="Image"><br><strong>说明：这是与十进制数686等值的十六进制数2AE。</strong></p><p>&nbsp;</p><p><img src="./Image-jsj14.png" srcset="/img/loading.gif" alt="Image"><br><strong>说明：这是与十进制数686等值的八进制数1256。</strong></p><p>&nbsp;</p><ul><li><p>十进制与其他进制的相互转换。</p><ul><li><p>其他进制到十进制的转换，在上面的介绍中，其实已经讲了，即：每一位上的数值x进制^权值^。如，八进制的1256，转换为十进制：1x8^3^+2x8^2^+5x8^1^+6x8^0^ = 686；<strong>注意：小数点左边的权值从0开始递增，如，1、2、3、4…依次递增，而小数点右边的位置量则是从-1开始递减，如，-1、-2、-3、-4….依次递减。</strong></p></li><li><p>十进制到其他进制的转换，分为两部分：</p><ul><li>整数部分的规则：十进制数/对应的进制，直到商为0，然后余数取反即可；</li><li>小数部分的规则：十进制小数对应的进制，然后取整数部分，直到小数部分为0或达到足够的位数时结束即可。</li></ul></li></ul></li></ul><p><img src="./Image-jsj15.png" srcset="/img/loading.gif" alt="Image"><br><strong>说明：十进制35转二进制。</strong></p><p>&nbsp;</p><p><img src="./Image-jsj16.png" srcset="/img/loading.gif" alt="Image"><br><strong>说明：十进制小数0.625转二进制，即0.101。</strong></p><p>&nbsp;</p><ul><li>二进制转八进制或十六进制，采用的方法很相似，二进制转八进制用的三位归纳法，二进制转十六进制用的四位归纳。</li></ul><p><img src="./Image-jsj17.png" srcset="/img/loading.gif" alt="Image"><br><strong>说明：图示是八进制转十六进制的方法。</strong></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-3-非位置化数字系统"><a href="#NO2-3-非位置化数字系统" class="headerlink" title="NO2.3 非位置化数字系统"></a>NO2.3 非位置化数字系统</h3><p>非位置化数字系统，指的是，使用有限的数字符号，且每个符号有一个值，这个值不会因为符号所处的位置改变而改变，简单讲就是，这个符号是什么值，在哪个位置都是这个值。如，罗马数字就是一个例子。</p><p><img src="./Image-jsj18.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><h2 id="Lesson3-数据存储"><a href="#Lesson3-数据存储" class="headerlink" title="Lesson3 数据存储"></a>Lesson3 数据存储</h2><h3 id="NO3-1-计算机内部的数据"><a href="#NO3-1-计算机内部的数据" class="headerlink" title="NO3.1 计算机内部的数据"></a>NO3.1 计算机内部的数据</h3><p>所有计算机外部的数据，要转换为二进制数据后才存入计算机，当数据从计算机输出时，再还原回来。</p><ul><li>位(bit)是存储在计算机中的最小单位，它是0或1，换句话说，存入计算机的数据，都会转换为0或1来表示。</li></ul><p>&nbsp;</p><ul><li>二进制表示的数字串有8位的话，被称为1字节(Byte)，所以1 Byte = 8 bit，意思就是1个字节有8位。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-2-存储数字"><a href="#NO3-2-存储数字" class="headerlink" title="NO3.2 存储数字"></a>NO3.2 存储数字</h3><p>计算机使用定点和浮点来表示整数和小数。</p><ul><li>内存中存储整数使用的是定点表示法；整数中既有正整数、负整数、0，所以可以用以下几种方式来表示：<ul><li>无符号表示法，用于无符号整数(就是没有符号的整数)，范围是0到无穷大之间；但是计算机肯定是无法表示无穷大这个整数的，所以就定义了一个最大无符号整数，值为<img src="../_resources/33afb12e021fc746cc3d15592afa429c.png" srcset="/img/loading.gif" alt="">，这里的n代表计算机中分配用于表示无符号整数的二进制位数；</li><li>符号加绝对值表示法，即计算机分配的二进制的位数中，最高位(就是最左边的位置)必须是符号位，且0表示正，1表示负；范围是-(2^n-1^-1)至+(2^n-1^-1)；</li><li>二进制补码表示法，即用二进制的补码来存储有符号整数；简单理解就是，通过一个数的二进制，分别得到原码(就是二进制)、反码、补码，最后用补码的形式来进行存储这个数；<strong>注意：正数的原反补都是一样的；而负数的反码要在原码的基础上，逐位取反，符号位不变；负数的补码要在反码的基础上，末位加1。</strong></li></ul></li></ul><p>例如：</p><p><img src="./Image-jsj19.png" srcset="/img/loading.gif" alt=""></p><p><strong>说明：存储7到八位的存储单元中：先将7转换为二进制数，得到的二进制数为111，但是不足八位，所以在左边添0，变成00000111，这样就满八位了。</strong></p><p>&nbsp;<br><img src="./Image-jsj20.png" srcset="/img/loading.gif" alt="Image"></p><p><strong>说明：存储258到十六位的存储单元中：将258转为二进制数后得到100000010，还差七位才够十六位，所以往左边添0，直到满16位即可。</strong></p><p>&nbsp;<br><img src="./Image-jsj21.png" srcset="/img/loading.gif" alt="Image"></p><p><strong>说明：存储11到四位的存储单元中，又试图再加上9：首先存储11到四位的存储单元中，11转换为二进制为1011，原本这没有什么问题，但是如果11+9=20，那么就会造成值溢出的情况，因为20转为二进制为10100，五位，无法全部存储到四位的存储单元中去，所以计算机丢掉第五位，也就是最前面的1，最后存储的则是0100，值就是4了。</strong></p><p>&nbsp;<br><img src="./Image-jsj22.png" srcset="/img/loading.gif" alt="Image"></p><p><strong>说明：将-28存储到8位的存储单元中：先将28转为二进制，值为00011100，用符号加绝对值表示法，最左边的位置不应该用0，而是要用1，因为存储的是-28，而不是28，所以最后的存储的二进制的值为10011100。</strong></p><p>&nbsp;</p><ul><li>存储小数使用的则是浮点表示法；浮点表示法表示的数都由三部分组成：符号(即正负号)、指数(进制数的幂)、尾数(小数点右边的数)；且十进制中的浮点表示法，我们很熟悉，就是科学计数法，而二进制中就叫做浮点表示法；<strong>注意：浮点表示法中，小数点左边必须是非零，这称为规范化。</strong><ul><li>科学计数法(用于十进制)；</li><li>浮点表示法(用于二进制)。</li></ul></li></ul><p><img src="./Image-jsj23.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><p><img src="./Image-jsj24.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><p><img src="./Image-jsj25.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><p><img src="./Image-jsj26.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><ul><li>IEEE(电子和电子工程师协会)定义了多种存储浮点数的标准，常用的是单精度、双精度。<ul><li>单精度(32位)，即采用32位二进制来表示一个浮点数；</li><li>双精度(64位)，即采用64位二进制来存储一个浮点数。</li></ul></li></ul><p><img src="./Image-jsj27.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><p><img src="./Image-jsj28.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-jsj29.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><p>例如：<br><img src="./Image-jsj30.png" srcset="/img/loading.gif" alt="Image"><br><strong>说明：十进制5.75的单精度表示法。</strong></p><p>&nbsp;<br><img src="./Image-jsj31.png" srcset="/img/loading.gif" alt="Image"><br><strong>说明：十进制数-0.0234375的单精度表示法。</strong></p><p>&nbsp;<br><img src="./Image-jsj32.png" srcset="/img/loading.gif" alt="Image"><br>说明：将单精度表示的11001010000000000111000100001111转换为十进制。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-3-存储文本"><a href="#NO3-3-存储文本" class="headerlink" title="NO3.3 存储文本"></a>NO3.3 存储文本</h3><p>字符是各种文字和符号的总称，而字符集则是多个字符的集合；我们使用字符集来存储文本数据。</p><ul><li>常见的主流字符集有：<ul><li>ASCII字符集，用7位的二进制来表示128种不同的符号；</li><li>Unicode字符集，用32位的二进制来表示4294967296种不同的符号，收集了来自全球不同的语言符号。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO3-4-存储音频"><a href="#NO3-4-存储音频" class="headerlink" title="NO3.4 存储音频"></a>NO3.4 存储音频</h3><p>音频表示声音或者音乐。</p><ul><li>我们说存储音频，实际存储的是这个音频信号的密度。通过以下几个步骤可以获取音频信号的密度：<ul><li>采样：即从无穷个点里，选取一部分点，但每个点仍然有无穷的信息。每秒钟40000个样本的采样率对音频信号来说是足够好的；</li><li>量化：将样本的值，截取为最接近的整数值的一种过程。如，实际值为17.2，可截取为17、实际值为17.7，则截取为18；</li><li>编码，将量化后的样本值，转为二进制。也就是将获取到的样本，每个样本都转化为n位的二进制来表示；当今主流的音频编码是MP3(MPEG Layer 3的简写，取44100个样本，且每个样本用16位来表示)，这是一种有损的音乐格式。</li></ul></li></ul><p><img src="./Image-jsj33.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><p>&nbsp;</p><p>NO3.5 存储图像<br>图像又该使用什么方式存储呢。</p><ul><li>存储在计算机中的图像使用两种不同的技术：光栅图和矢量图；将图像转化为二进制进行存储，就是视频了；<ul><li>光栅图，用于存储模拟图像，即一个图像由模拟数据组成，数据密度随空间的变化而变化，这时候的采样称为扫描，样本称为像素；整个图像被分为小的像素，每个像素假定都有单独的密度值；</li><li>矢量图，使用几何图形来组合图像，而这些几何图形又用数学公式来表达，所以说矢量图是由定义如何绘制这些形状的一系列命令构成的。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><h2 id="Lesson4-数据运算"><a href="#Lesson4-数据运算" class="headerlink" title="Lesson4 数据运算"></a>Lesson4 数据运算</h2><h3 id="NO4-1-逻辑运算"><a href="#NO4-1-逻辑运算" class="headerlink" title="NO4.1 逻辑运算"></a>NO4.1 逻辑运算</h3><p>这里的逻辑运算是指二进制的逻辑运算。</p><ul><li>二进制的逻辑运算有如下几种：<ul><li>与(AND)：两个二进制补码做与运算，位对齐，只要两位上的任意一位是0，那么与的结果就为0；</li><li>或(OR)：两个二进制补码做或运算，位对齐，只要两位上的任意一位是1，那么或的结果就为1；</li><li>异或(XOR)：两个二进制补码做异或运算，位对齐，只要两位上的数字都相同，则结果为0，不相同则为1；</li><li>非(NOT)：一个二进制补码做非运算，按位取反，如果位上是0，则非运算结果为1，如果位上是1，结果则为0。</li></ul></li></ul><p>例如：</p><pre><code class="hljs java"><span class="hljs-comment">//与运算</span><span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span><span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>-----------------------<span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-comment">//或运算</span><span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span><span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>-----------------------<span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>        <span class="hljs-comment">//异或运算    </span><span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span><span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>-----------------------<span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>        <span class="hljs-comment">//非运算    </span><span class="hljs-number">1</span>    <span class="hljs-number">0</span>------------------------<span class="hljs-number">0</span>    <span class="hljs-number">1</span></code></pre><p>&nbsp;</p><p>&nbsp;    </p><h3 id="NO4-2-移位运算"><a href="#NO4-2-移位运算" class="headerlink" title="NO4.2 移位运算"></a>NO4.2 移位运算</h3><p>所谓的移位运算，简单理解就是将二进制进行左移或者右移。移位运算分为两种，逻辑移位运算和算数移位运算：</p><ul><li>逻辑移位运算中，又分为逻辑移位、循环移位；<ul><li>逻辑移位，简单的理解就是将二进制向左移(不够的部分就添加)或者向右移(多出的部分会被丢弃)；</li><li>循环移位，原理和逻辑移位差不多，只不过移位过程中，不会添加或丢弃二进制位，而是循环使用。</li></ul></li></ul><p>例如：<br><img src="./Image-jsj34.png" srcset="/img/loading.gif" alt="Image"><br><strong>说明：逻辑左移，左边多的部分丢弃，右边少的部分添0。</strong>    </p><pre><code class="hljs java"><span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    原始的二进制补码------------------------------------<span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    逻辑左移之后的二进制补码</code></pre><p>&nbsp;<br><img src="./Image-jsj35.png" srcset="/img/loading.gif" alt="Image"><br><strong>说明：逻辑右移，左边少的部分添0，右边多的部分丢弃。</strong></p><pre><code class="hljs java"><span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    原始的二进制补码------------------------------------<span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    逻辑右移之后的二进制补码</code></pre><p>&nbsp;<br><img src="./Image-jsj36.png" srcset="/img/loading.gif" alt="Image"><br><strong>说明：循环左移，左边多的部分会循环到右边少的部分，意思就是左边多出来的，刚好给右边少的。</strong></p><pre><code class="hljs java"><span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    原始的二进制补码------------------------------------<span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    循环左移之后的二进制补码</code></pre><p>&nbsp;<br><img src="./Image-jsj37.png" srcset="/img/loading.gif" alt="Image"><br><strong>说明：循环右移，右边多的部分会循环到左边少的部分，意思就是右边多出来的，刚好给左边少的。</strong></p><pre><code class="hljs java"><span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    原始的二进制补码------------------------------------<span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    循环右移之后的二进制补码</code></pre><p>&nbsp;</p><ul><li>算数移位运算，其实跟逻辑移位差不多，只不过算数移位的时候要注意一下符号问题；<strong>注意：算数左移相当于二进制补码的十进制数乘以2，右移就是除以2。</strong></li></ul><p>例如：<br><img src="./Image-jsj38.png" srcset="/img/loading.gif" alt="Image"><br><strong>说明：算数左移的话，符号位会被丢弃，这个时候看看新的符号位是不是跟以前是一样的，一样就正常左移，运算成功；不一样的话就出现上溢或下溢，结果就是非法的。</strong></p><pre><code class="hljs java">运算成功：<span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    原始的二进制补码------------------------------------<span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    算数左移之后的二进制补码，符号位还是<span class="hljs-number">1</span>，那么运算成功----------------------------------------------------------------------------运算结果不合法：<span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    原始的二进制补码------------------------------------<span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    算数左移之后的二进制补码，符号位由<span class="hljs-number">1</span>变成了<span class="hljs-number">0</span>，结果出现上溢或下溢，那么这个结果就是非法的</code></pre><p>&nbsp;<br><img src="./Image-jsj39.png" srcset="/img/loading.gif" alt="Image"><br><strong>说明：算数右移的话，原先最左边的符号位是什么，右移之后，左边少的，就添加对应的符号位就可以了(正数就添0，负数就添1)。</strong></p><pre><code class="hljs java"><span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    原始的二进制补码------------------------------------<span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    算数右移之后的二进制补码，移位之前符号位是<span class="hljs-number">1</span>，是一个负数，则右移之后，添加<span class="hljs-number">1</span>即可</code></pre><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO4-3-算数运算"><a href="#NO4-3-算数运算" class="headerlink" title="NO4.3 算数运算"></a>NO4.3 算数运算</h3><p>算数运算包括加减乘除。</p><ul><li>二进制补码的加减法，很简单，加法就是二进制补码，对位相加即可；而减法则是将减数(无论正负数)诸位取反后再加一，然后相加即可。</li></ul><p>例如：</p><pre><code class="hljs java">加法：<span class="hljs-number">00010001</span> + <span class="hljs-number">00010110</span>              进<span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>+   <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>---------------------------------------------------------------    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    用十进制检查结果+<span class="hljs-number">17</span>+(+<span class="hljs-number">22</span>)=+<span class="hljs-number">39</span><span class="hljs-number">00011000</span> + <span class="hljs-number">11101111</span>进<span class="hljs-number">1</span>  进<span class="hljs-number">1</span>  进<span class="hljs-number">1</span>   进<span class="hljs-number">1</span>  进<span class="hljs-number">1</span>  进<span class="hljs-number">1</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>+    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>----------------------------------------------------------------     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    用十进制检查结果(+<span class="hljs-number">24</span>)+(-<span class="hljs-number">17</span>)=(+<span class="hljs-number">7</span>)注意：上面的结果是<span class="hljs-number">100000111</span>，但是只能存<span class="hljs-number">8</span>位，最左边进的<span class="hljs-number">1</span>，就被丢弃了。============================================================================减法：<span class="hljs-number">00011000</span> - <span class="hljs-number">11101111</span>               进<span class="hljs-number">1</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>+    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    将减数在原先的基础上诸位取反，然后加<span class="hljs-number">1</span>----------------------------------------------------------------     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    用十进制检查结果(<span class="hljs-number">24</span>)-(-<span class="hljs-number">17</span>)=(+<span class="hljs-number">41</span>)<span class="hljs-number">11011101</span> - <span class="hljs-number">00010100</span>进<span class="hljs-number">1</span> 进<span class="hljs-number">1</span>  进<span class="hljs-number">1</span>  进<span class="hljs-number">1</span>   进<span class="hljs-number">1</span>  进<span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>+   <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    将减数在原先的基础上诸位取反，然后加<span class="hljs-number">1</span>------------------------------------------------------------------    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    用十进制检查结果(-<span class="hljs-number">35</span>)-(+<span class="hljs-number">20</span>)=(-<span class="hljs-number">55</span>)注意：上面的结果为<span class="hljs-number">111001001</span>，只能存<span class="hljs-number">8</span>位，即最前面的<span class="hljs-number">1</span>被丢弃了。</code></pre><p>&nbsp;</p><ul><li>8位补码能够表示数的范围是-128~127，即10000000-11111111表示-128到-1,  00000000-01111111表示0-127。</li></ul><p>&nbsp;</p><ul><li>使用符号加绝对值的格式进行运算的时候，符号位做异或操作，其他位上加法就对位相加，减法则是将将减数(无论正负数)诸位(除了符号位)取反后再加一，如果出现上溢或下溢，则对符号位操作就行。</li></ul><p>例如：</p><pre><code class="hljs java">加法：<span class="hljs-number">00010001</span> + <span class="hljs-number">00010110</span>   符号位     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>+    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>-------------------------------------------------------     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span><span class="hljs-number">00010001</span> + <span class="hljs-number">10010110</span>   符号位     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>+    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>-------------------------------------------------------     <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>============================================================减法：<span class="hljs-number">11010001</span> - <span class="hljs-number">10010110</span>   符号位 进<span class="hljs-number">1</span>     <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>+    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>-------------------------------------------------------     <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">1</span>注意：上面的结果符号位原本应该是<span class="hljs-number">0</span>，但是后面第<span class="hljs-number">7</span>位上有上溢，所以添加到符号位上。</code></pre><p>&nbsp;</p><ul><li>带小数的加减法。</li></ul><p><img src="./Image-jsj40.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><p><img src="./Image-jsj41.png" srcset="/img/loading.gif" alt="Image"><br><img src="./Image-jsj42.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><h2 id="Lesson5-计算机组成"><a href="#Lesson5-计算机组成" class="headerlink" title="Lesson5 计算机组成"></a>Lesson5 计算机组成</h2><h3 id="NO5-1-中央处理单元-CPU"><a href="#NO5-1-中央处理单元-CPU" class="headerlink" title="NO5.1 中央处理单元(CPU)"></a>NO5.1 中央处理单元(CPU)</h3><p>计算机的组成部件可以分为三大类：中央处理单元(CPU)、主存储器和输入/输出系统。中央处理单元(CPU)用于数据的运算。</p><ul><li>在大多数体系结构中，CPU有三个组成部分：<ul><li>算术逻辑单元(ALU)：用于对数据进行逻辑(如，与、或、异或运算等等)、移位(如，逻辑移位和算数移位)和算数运算(如，整数和带小数的运算)；</li><li>控制单元：用于控制各个部件的操作；</li><li>寄存器组(快速存储单元)：用于临时存放数据的存储单元，每个存储单元是高速且独立的。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO5-2-主存储器"><a href="#NO5-2-主存储器" class="headerlink" title="NO5.2 主存储器"></a>NO5.2 主存储器</h3><p>主存储器里面主要存放的是数据和指令。</p><ul><li>主存储器是存储单元的集合，每个存储单元都有唯一的标识，称为地址。放在存储单元里的数据，是以“位”为单位的(这是最小的单位)，而每8位称为1个字节。</li></ul><p>&nbsp;</p><ul><li>我们把所有存储器中的存储单元的地址的集合称为地址空间，简单讲，就是逻辑上，把所有的存储单元的地址，集合起来我们统称为地址空间。内存地址用无符号的二进制整数来定义。</li></ul><p>&nbsp;</p><ul><li>通常，如果一个计算机有N个字的存储空间的话，那就需要有log<del>2</del>N位的无符号整数来确定每一个存储单元；如，一台计算机有32MB内存，需要多少位来寻址内存中的任意一个字节？32MB的内存地址空间，也就是2^25^(2^5^x2^20^)，这就一位置需要log<del>2</del>2^25^，也就是25位来标识每一个字节。</li></ul><p>&nbsp;</p><ul><li>存储器的类型，主要有两种：<ul><li>RAM，即随机存取存储器，是计算机中主存的主要组成部分，用户可以读和写。根据技术，RAM又可以分为静态SRAM和动态DRAM，前者是用传统的触发器门电路(有0和1两个状态的门)来保存数据，通电时数据一直存在，不需要刷新，特点是速度快，但价格昂贵；后者则是使用电容器来保存数据，会随时间漏掉一部分点，所以需要周期性地刷新，特点是速度慢，但价格便宜；</li><li>ROM，即只读存储器，内容由制造商写进去，用户只能读不能写，断电后数据也会存在。</li></ul></li></ul><p>&nbsp;</p><ul><li>存储器的层次结构。</li></ul><p><img src="./Image-jsj43.png" srcset="/img/loading.gif" alt="Image"></p><p><strong>说明：当对速度要求很苛刻时，可以使用少量高速存储器，寄存器就属于这一类；用适量的中速存储器来存储经常需要访问的数据，高速缓冲存储器属于这一类；存储那些不经常访问的数据，主存就属于这一类。</strong></p><p>&nbsp;</p><ul><li>高速缓冲存储器；</li></ul><p><img src="./Image-jsj44.png" srcset="/img/loading.gif" alt="Image"></p><p><strong>说明：CPU优先去高速缓冲存储器找自己需要的数据，如果有，就直接拿来使用；没有的话就去主存找，拿到数据之后，复制一份放入高速缓冲存储器中，以备下次使用；因为高速缓冲存储器速度比主存要快。</strong></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO5-3-输入-输出系统"><a href="#NO5-3-输入-输出系统" class="headerlink" title="NO5.3 输入/输出系统"></a>NO5.3 输入/输出系统</h3><p>输入/输出系统的作用的是与外界进行通信，在断电情况下可以存储程序和数据。</p><ul><li>输入/输出系统可以分为两大类：<ul><li>非存储设备，这一类设备可以与外界通信，但不能存储信息；常用的有键盘、监视器、打印机等等；</li><li>存储设备，该类可以存储大量的信息以备后用，即断电后也不会丢失数据；常见的有磁盘、磁带、光盘等等。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO5-4-子系统的互连"><a href="#NO5-4-子系统的互连" class="headerlink" title="NO5.4 子系统的互连"></a>NO5.4 子系统的互连</h3><p>CPU和内存之间通常由称为总线(简单讲，其实就是线)的三组线路连接在一起。</p><ul><li>总线分为三种：<ul><li>数据总线：传输数据使用的总线。一根线一次性能传送1个位的数据。如，32根线就能传送一个32位的数据；</li><li>地址总线：用于访问内存地址或I/O设备的总线，存储空间的大小与总线的多少是有关系的。如，存储器容量为<img src="../_resources/4877edb6c2e6b619f637f843d0fad7cc.png" srcset="/img/loading.gif" alt="">，那么地址总线就有n条；</li><li>控制总线：负责控制CPU和内存之间的操作。如，CPU要读取某个内存的信息，就是控制总线发出信号给内存进行读取操作。</li></ul></li></ul><p>&nbsp;</p><ul><li>I/O设备不能够直接与总线相连，而是通过输入/输出控制器或接口卡的器件连接到总线上的。意思就是说，外围设备插入电脑，实际连接的是输入/输出控制器或接口卡，然后由输入/输出控制器或接口卡与总线相连。常用的控制器有SCSI、火线、和USB。输入/输出的寻址有两种方式：一是I/O独立寻址，二是I/O存储器映射寻址。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO5-5-程序的执行"><a href="#NO5-5-程序的执行" class="headerlink" title="NO5.5 程序的执行"></a>NO5.5 程序的执行</h3><p>程序，是一组有序指令的集合。</p><ul><li>指令，是指一串能够被计算机识别并执行的二进制代码。指令是计算机进行程序控制的最小单位。计算机所识别的指令集合称为计算机的指令系统。程序的执行，一般包括三个阶段：<ul><li>取指令：控制单元将需要执行的指令复制到CPU的指令寄存器中，且同时该指令的地址也会被放入到程序计数器中，当指令复制完成后，程序计数器自动加1指向内存中下一条指令；</li><li>译码：放在指令寄存器中的指令，会被控制单元负责译码，然后产生一系列的二进制代码；</li><li>执行：控制单元将译码完成后产生的二进制代码拿去执行。</li></ul></li></ul><p>&nbsp;</p><ul><li>I/O设备的运行速度是慢于CPU的，所以当I/O设备向CPU传输数据的时候，CPU要做一个同步(也就是CPU要知道I/O设备把想要传输的数据传输完成了的意思)。有三种方式用于同步：<ul><li>程序控制输入/输出：这是最简单的一种同步。简单理解就是CPU等待I/O设备的输入或输出，等完成了输入或输出，CPU再继续自己的工作。该方式比较浪费CPU的时间，即每次都要查询I/O设备的状态是否准备好输入或输出；</li><li>中断控制输入/输出：当I/O设备准备好了，告诉一声CPU就行，然后CPU进行输入或输出，在通知CPU之前，CPU一直在做自己的事情；</li><li>直接存储器存取(DMA)，该方式用于高速I/O设备间传输数据。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO5-6-介绍两个指令集-了解"><a href="#NO5-6-介绍两个指令集-了解" class="headerlink" title="NO5.6 介绍两个指令集(了解)"></a>NO5.6 介绍两个指令集(了解)</h3><p>计算机体系结构和组织，经历了CISC和RISC。</p><ul><li>计算机体系结构分为两大类：<ul><li>CISC，即复杂指令集。如，英特尔开发的奔腾系列处理器属于这个体系；</li><li>RISC，即精简指令集。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><h2 id="Lesson6-计算机网络"><a href="#Lesson6-计算机网络" class="headerlink" title="Lesson6 计算机网络"></a>Lesson6 计算机网络</h2><h3 id="NO6-1-计算机网络的基本概念"><a href="#NO6-1-计算机网络的基本概念" class="headerlink" title="NO6.1 计算机网络的基本概念"></a>NO6.1 计算机网络的基本概念</h3><p>网络是硬件和软件的组合，它把数据从一个地方发送到另一个地方。硬件是指把信号从网络中的一点传送到另一点的物理设备，而软件由指令组成，这些指令可以使我们从网络上获得想要的服务。</p><ul><li>网络必须符合许多标准，其中最重要的是性能、可靠性和安全；<ul><li>性能：度量方式包括传输时间(即从一个设备传输到另一个设备)和响应时间(查询和响应间的时间间隔)。网络的性能还依赖于其他因素，如，用户数、传输介质类型、硬件的连接能力、软件的效率等等；</li><li>可靠性：即发送数据的准确性、发生故障的频率、从故障中恢复的时间等等；</li><li>安全：主要包括保护数据、防止非授权访问、损坏和修改等等。</li></ul></li></ul><p>&nbsp;</p><ul><li>网络由两个或两个以上通过链路连接的设备构成。链路是数据从一个设备传输到另一个设备的通信通道，通俗的讲，链路就是两个点之间的连线。连接类型有两种：<ul><li>点对点，指两个设备间的专用链路；</li><li>多点(也称多站连接)，指两个以上的指定设备共享一个链路。</li></ul></li></ul><p><img src="./Image-jsj45.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><ul><li>物理拓扑，是指网络在物理上的布置方式。两个或多个设备连接到一个链路，一个或多个链路形成拓扑，而网络的拓扑是所有链路和设备间关系的几何表示。物理拓扑主要有四种基本结构：<ul><li>网状型，每个设备都有专用的点对点链路与其他设备相连；</li><li>星型，每个设备都有专用的点对点链路与称为集线器的中央控制器相连，这种类型的拓扑是唯一常用的；</li><li>总线型，每个设备使用分支线和连接器与总线相连；</li><li>环形，每个设备都有专用的点对点链路，只与两边的设备相连，信号沿着环从一个设备传输到另一个设备，环中的每个设备连接一个中继器。</li></ul></li></ul><p><img src="./Image-jsj46.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><ul><li>如今网络可以分为三类：<ul><li>局域网(LAN)：常常是作为私有的网络，即可能是个人电脑和打印机的连接等等，范围是几公里内，一般用于连接单个办公室、大楼或校园里的设备；</li><li>城域网(MAN)：通常范围是一个镇或一个城市；</li><li>广域网(WAN)：提供长距离的数据、图像、音频和视频信息的传输，范围可能包含一个国家、大洲或全球。</li></ul></li></ul><p>&nbsp;</p><ul><li>当两个或多个网络连接在一起时，就变成了互联网，即internet。</li></ul><p><img src="./Image-jsj47.png" srcset="/img/loading.gif" alt="Image"><br><strong>说明：路由器是发送数据包(消息)，并使消息在互联网中传输的连接设备。</strong></p><p>&nbsp;</p><ul><li>因特网(Internet)是最大的，也是最著名的互联网，它由成千上万个互相连接的网络组成，个人和各种组织都使用因特网。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO6-2-TCP-IP协议族"><a href="#NO6-2-TCP-IP协议族" class="headerlink" title="NO6.2 TCP/IP协议族"></a>NO6.2 TCP/IP协议族</h3><p>我们用微信聊天的时候，有想过发送的消息是怎么到达对方的微信上的吗？我们可以把发送消息当做一个任务，那么我们把发送消息这个任务过程稍微的拆分一下，肯定要确定每一步做什么，要不然就乱乱的，对吧？为此我们定义一个协议，但又因为我们使用了因特网来完成这个任务，就把这个协议称为TCP/IP协议族。</p><ul><li>如今的TCP/IP协议族通常被定义成五层：<ul><li>应用层；</li><li>传输层；</li><li>网络层；</li><li>数据链路层；</li><li>物理层。</li></ul></li></ul><p><img src="./Image-jsj48.png" srcset="/img/loading.gif" alt="Image"><br><strong>说明：如上图，就是我们在聊天的时候，消息的传输，每一层都调用它直接下层的服务。</strong></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO6-3-层"><a href="#NO6-3-层" class="headerlink" title="NO6.3 层"></a>NO6.3 层</h3><p>我们要明确TCP/IP协议族划分的每一层的功能。</p><ul><li>应用层：<ul><li>应用层的功能：<ul><li>这一层允许用户(人或者软件)访问网络，该层负责向用户提供服务。应用层是唯一一个大多数因特网用户能够看到的层。</li></ul></li><li>现在常用的两大网络结构分别是：C/S(即客户端/服务器端)和B/S(即浏览器端/服务器端)；</li><li>客户端想要获取服务器端的某个资源，就必须使用URL，即统一资源定位符。如，访问百度搜索，URL为<a href="http://www.baidu.com/" target="_blank" rel="noopener">www.baidu.com</a>；这个URL并不是服务器的实际地址，只是用于应用层的用户获取服务而使用的应用层地址；</li><li>网络中每一台计算机都有一个称为逻辑地址或IP地址的实际地址。当我们去访问URL的时候，都会经过一个叫做域名服务器的根服务器(国内有许多镜像域名服务器)，即DNS，这里面就存放有我们要访问的URL所对应的IP地址了；</li><li>应用层协议：三种常见的应用层协议为HTTP、FTP、SMTP。</li></ul></li></ul><p>&nbsp;</p><ul><li>传输层：<ul><li>传输层的功能：<ul><li>按端口号寻址：该层负责客户端和服务器端进程间消息的传输，简单讲就是你用什么程序发给我的，我就用什么程序来接收，主要靠的是传输层地址来识别程序。传输层也有一个地址，即端口号，这个端口号是用来干嘛的呢，就是我用某个程序给你发的消息，你也只能用同样的某个程序来接收，而这个程序在电脑上运行的时候，有一个唯一的进程地址表示，这个唯一的进程地址表示就是端口号。如，我用微信程序给小明发消息，这个微信程序运行在我的电脑上的端口号是1000，那么发送的消息就会从这个端口号出去，通过IP地址找到小明的电脑，然后再找到小明电脑上端口号为1000的微信程序(一般程序的端口号安装以后都不会自行改变，是固定的)来接收消息；</li><li>多路复用和解多路复用：简单讲，多路复用就是传输层会收集所有进程中要发出的数据；解多路复用就是把接收到的数据分发给进程，这个过程是使用端口号来完成的；</li><li>拥塞控制：即数据要发送前，传输层检测到网络可能会发生拥塞的话，那么就会把消息存储在缓冲区，发生拥塞就暂缓消息的发送，直到网络不拥塞时再发送消息；</li><li>流量控制：直白的讲，就是让发送方的发送速率不要太快，要让接收方来得及接收；</li><li>差错控制：发送方在发送数据前，传输层可以在缓冲区中保留一个数据的副本，直到发送方从接收方那里接收到包无损坏到达和次序正确的确认，否则发送方就重新发送数据包。</li></ul></li><li>传输层协议：在TCP/IP协议族中定义了三种传输层协议：UDP、TCP和SCTP。</li></ul></li></ul><p>&nbsp;</p><ul><li>网络层：<ul><li>网络层的功能：<ul><li>该层负责单个数据包从源主机到目的主机的发送。</li><li>网络层同样有个地址，网络层通过它的路由表找到下一跳的逻辑地址，然后把这个地址传递给数据链路层；</li><li>路由选择：即确定数据包的部分或全部路径。简单讲，就是数据包的传输不可能一下子就传送到你想要传送的电脑上，中间要经过许多的路由器，当到达一个路由器时，这个路由器会为目的地选择最佳的传输路径。</li></ul></li><li>网络层协议：该层主协议是IP协议，当前版本为IPv4，但IPv6也在使用，虽然不是很普及。IPv4负责从源计算机到目的地计算机的数据包发送，为此，全球的计算机和路由器都用32位的IP地址表示，该IP地址用点分十进制记法表示，该记法把地址分解成4个8位的部分，每个部分写成0~255的十进制数，用三个点来隔开这些部分。如，IPv4地址00001010 00011001 10101100 00001111用点分十进制记法写成10.20.172.15。但IPv4似乎不够用了，最终方案是IPv6，该地址由128位构成。</li></ul></li></ul><p>&nbsp;</p><ul><li>数据链路层：<ul><li>数据链路层的功能：<ul><li>从一个节点到另一个节点，传送数据帧是数据链路层的职责；</li><li>数据链路层地址：一个设备可以静态或动态地找到另一个设备的数据链路层地址。该层的地址不是通用的；</li><li>差错控制和流量控制，方法与传输层相同。</li></ul></li><li>数据链路层协议：以太网协议(当前使用的主流局域网)使用48位地址，该地址通常被写成十六进制格式。如，07:01:02:11:2C:5B。数据链路层地址经常被称为物理地址或介质访问控制地址(MAC)地址。</li></ul></li></ul><p>&nbsp;</p><ul><li>物理层：<ul><li>物理层的功能：使用物理介质传输二进制流。数据链路层的传送单元是帧，而物理层的传送单元是二进制位；帧中的每个位被转化为电磁信号，通过物理介质(无线或电缆)传播；</li><li>物理层不需要地址，传播方式是广播。</li></ul></li></ul><p>&nbsp;</p><ul><li>层的总结。</li></ul><p><img src="./Image-jsj49.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><h2 id="Lesson7-操作系统"><a href="#Lesson7-操作系统" class="headerlink" title="Lesson7 操作系统"></a>Lesson7 操作系统</h2><h3 id="NO7-1-操作系统的功能"><a href="#NO7-1-操作系统的功能" class="headerlink" title="NO7.1 操作系统的功能"></a>NO7.1 操作系统的功能</h3><p>操作系统是计算机硬件和用户的一个接口。使得其它程序更加方便有效地运行，并能方便地对计算机硬件和软件资源进行访问。</p><ul><li>操作系统的功能：<ul><li>有效的使用硬件；</li><li>方便的使用资源。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO7-2-演化"><a href="#NO7-2-演化" class="headerlink" title="NO7.2 演化"></a>NO7.2 演化</h3><p>操作系统的演化过程：批处理系统—-分时系统—-个人系统—-并行系统—-分布式系统—-实时系统。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO7-3-组成部分"><a href="#NO7-3-组成部分" class="headerlink" title="NO7.3 组成部分"></a>NO7.3 组成部分</h3><p>现在的操作系统十分复杂，因为它必须可以管理系统中的不同资源。</p><ul><li>每个操作系统都有用户界面，简单讲就是用来接收用户输入，并向操作系统解释这些请求的程序。</li></ul><p>&nbsp;</p><ul><li>现代操作系统至少具有以下四种功能：<ul><li>内存管理；</li><li>进程管理；</li><li>设备管理；</li><li>文件管理。</li></ul></li></ul><p><img src="./Image-jsj50.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO7-4-主流的操作系统"><a href="#NO7-4-主流的操作系统" class="headerlink" title="NO7.4 主流的操作系统"></a>NO7.4 主流的操作系统</h3><p>了解常用的三种系统。</p><ul><li>日常生活常用的三种操作系统：<ul><li>UNIX：是多用户、多道程序、可移植的操作系统，被设计用来方便变成、文本处理、通信。主要由四个部分构成：内核、命令解释器、一组标准工具和应用程序；</li><li>Linux：主要由内核、系统库、系统工具组成；</li><li>Windows NT/2000/XP：微软发布，设计目标是可扩展性、可移植性、可靠性、兼容性和性能；</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><h2 id="Lesson8-算法"><a href="#Lesson8-算法" class="headerlink" title="Lesson8 算法"></a>Lesson8 算法</h2><p>这一章在这里不做学习，会单独作为一门课程学习</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><h2 id="Lesson9-程序设计语言"><a href="#Lesson9-程序设计语言" class="headerlink" title="Lesson9 程序设计语言"></a>Lesson9 程序设计语言</h2><h3 id="NO9-1-计算机语言的演化"><a href="#NO9-1-计算机语言的演化" class="headerlink" title="NO9.1 计算机语言的演化"></a>NO9.1 计算机语言的演化</h3><p>计算机语言经过多年的发展，已经从机器语言发展到了高级语言。</p><ul><li>计算机语言的演化过程：<ul><li>机器语言；<ul><li>在计算机发展的早期，唯一的程序设计语言是机器语言；</li><li>机器语言由“0”和“1”构成；</li><li>机器语言是计算机硬件唯一能理解的语言。</li></ul></li><li>汇编语言；<ul><li>由于机器语言的编写难度大等问题而产生的汇编语言；</li><li>汇编语言使用的是助记符，即是机器语言的一种便于记忆的书写格式；如，mov ax,8；</li><li>使用编译器，把汇编语言编写的程序转译成机器语言。</li></ul></li><li>高级语言。<ul><li>为了提高程序员效率以及从关注计算机转移到关注要解决的问题，导致了高级语言的发展；</li><li>高级语言最后仍然要被编译成机器语言，然后运行；</li><li>常见的高级语言有，C、C++、Java等等。</li></ul></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO9-2-翻译"><a href="#NO9-2-翻译" class="headerlink" title="NO9.2 翻译"></a>NO9.2 翻译</h3><p>使用高级语言编写的程序，称为源程序。被翻译成的机器语言称为目标程序。</p><ul><li>程序翻译成机器语言的方式有两种：<ul><li>编译：编译的时候，编译器会把源文件处理一遍，生成一个目标文件，然后再执行这个目标文件。该方式类似于做好了一桌子菜再吃饭；</li><li>解释：边处理源文件，边执行。这个方式类似于吃火锅，边烫边吃。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO9-3-编程模式"><a href="#NO9-3-编程模式" class="headerlink" title="NO9.3 编程模式"></a>NO9.3 编程模式</h3><p>编程模式：是指计算机语言看待要解决的问题的方式。</p><ul><li>计算机语言可以分成4种模式：<ul><li>过程式：面向业务逻辑，从上到下的写代码。常见的过程式语言有，C、Pascal等等；</li><li>面向对象：对函数进行分类和封装，让开发“更快更好更强”。常见的面向对象语言有，C++、Java等等；</li><li>函数式：将某个功能代码封装到函数值，以后就不需要重复编写，只要调用函数即可。常见的函数式语言有，LISP等等；</li><li>说明式：使用逻辑推理的逻辑型程序设计语言。如，Prolog。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><h2 id="Lesson10-软件工程"><a href="#Lesson10-软件工程" class="headerlink" title="Lesson10 软件工程"></a>Lesson10 软件工程</h2><h3 id="NO10-1-软件生命周期"><a href="#NO10-1-软件生命周期" class="headerlink" title="NO10.1 软件生命周期"></a>NO10.1 软件生命周期</h3><p>开发一个软件需要经过许多的步骤。</p><ul><li>软件的生命周期：</li></ul><p><img src="./Image-jsj51.png" srcset="/img/loading.gif" alt="Image"><br><strong>说明：使用和修改这两个步骤一直进行下去，直到软件过时。</strong></p><p>&nbsp;</p><ul><li>软件的开发过程包括四个阶段：分析、设计、实现和测试。</li></ul><p>&nbsp;</p><ul><li>最常见的两种开发模型：<ul><li>瀑布模型，这个模型的特点是，前一个阶段不结束，后一个阶段不能开始，且一旦出现问题，必须要检查整个过程；</li><li>增量模型，该模型首先完成一个简略版本，但不包括细节，随着时间的增加，逐渐增加细节功能。</li></ul></li></ul><p><img src="./Image-jsj52.png" srcset="/img/loading.gif" alt="Image"></p><p><img src="./Image-jsj53.png" srcset="/img/loading.gif" alt="Image"></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><h2 id="Lesson11-数据结构"><a href="#Lesson11-数据结构" class="headerlink" title="Lesson11 数据结构"></a>Lesson11 数据结构</h2><p>这一章在这里不做学习，会单独作为一门课程学习</p><hr><h2 id="Lesson12-抽象数据类型"><a href="#Lesson12-抽象数据类型" class="headerlink" title="Lesson12 抽象数据类型"></a>Lesson12 抽象数据类型</h2><p>这一章在这里不做学习，是数据结构的更抽象化，学习的性价比暂时不高</p><hr><h2 id="Lesson13-文件结构"><a href="#Lesson13-文件结构" class="headerlink" title="Lesson13 文件结构"></a>Lesson13 文件结构</h2><p>这一章在这里不做学习，是数据库章节的前序，学习的性价比暂时不高</p><hr><h2 id="Lesson14-数据库"><a href="#Lesson14-数据库" class="headerlink" title="Lesson14 数据库"></a>Lesson14 数据库</h2><p>这一章在这里不做学习，会单独作为一门课程学习</p><hr><h2 id="Lesson15-数据压缩"><a href="#Lesson15-数据压缩" class="headerlink" title="Lesson15 数据压缩"></a>Lesson15 数据压缩</h2><p>这一章在这里不做学习，学习的性价比暂时不高</p><hr><h2 id="Lesson16-安全"><a href="#Lesson16-安全" class="headerlink" title="Lesson16 安全"></a>Lesson16 安全</h2><p>这一章在这里不做学习，学习的性价比暂时不高    </p><hr><h2 id="Lesson17-计算理论"><a href="#Lesson17-计算理论" class="headerlink" title="Lesson17 计算理论"></a>Lesson17 计算理论</h2><p>这一章在这里不做学习，学习的性价比暂时不高 </p><hr><h2 id="Lesson18-人工智能"><a href="#Lesson18-人工智能" class="headerlink" title="Lesson18 人工智能"></a>Lesson18 人工智能</h2><p>这一章在这里不做学习，学习的性价比暂时不高 </p>]]></content>
    
    
    <categories>
      
      <category>大一课程</category>
      
      <category>计算机科学导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大一课程</tag>
      
      <tag>计算机</tag>
      
      <tag>科学导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git和GitHub--学习笔记</title>
    <link href="/2020/06/25/Git%E5%92%8CGitHub--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/06/25/Git%E5%92%8CGitHub--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Git和GitHub–学习笔记-包含Git视频"><a href="#Git和GitHub–学习笔记-包含Git视频" class="headerlink" title="Git和GitHub–学习笔记(包含Git视频)"></a><strong>Git和GitHub–学习笔记(包含Git视频)</strong></h1><h2 id="Lesson1-Git概述"><a href="#Lesson1-Git概述" class="headerlink" title="Lesson1 Git概述"></a>Lesson1 Git概述</h2><h3 id="NO1-1-Git简介"><a href="#NO1-1-Git简介" class="headerlink" title="NO1.1 Git简介"></a>NO1.1 Git简介</h3><p>什么是Git呢？Git其实就是一个工具，用于控制代码版本的工具。</p><ul><li>Git：<ul><li>定义：是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或大或小的项目；</li><li>Git和Svn的区别：<ul><li>Git是分布式的，SVN不是。这是Git和其它非分布式的版本控制系统(如，SVN，CVS等)最核心的区别；</li><li>Git把内容按元数据方式存储，而SVN是按文件。所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn、.cvs等的文件夹里；</li><li>Git分支和SVN的分支不同。分支在SVN中一点都不特别，其实它就是版本库中的另外一个目录；</li><li>Git没有一个全局的版本号，而SVN有。目前为止这是跟SVN相比，Git缺少的最大的一个特征；</li><li>Git的内容完整性要优于SVN。Git的内容存储使用的是SHA-1哈希算法，这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</li></ul></li></ul></li></ul><p><img src="./Image-git1.png" srcset="/img/loading.gif" alt="Image"></p><p> &nbsp;</p><ul><li>Git结构可以抽象成几个区域：<ul><li>工作区：即workspace，也就是你在电脑里能看到的目录，其实就是自己写的文件；</li><li>暂存区(也叫索引)：即stage，也就是我们写好的代码文件你肯定要暂时保存起来吧(因为极大可能要修改或提交到版本库等等，常做变动)，就存放在这里，一般存放在”.git”目录下的index文件中，也就是”.git/index”中，所以我们把暂存区也叫做索引(index)；</li><li>版本库：存放已经提交的数据，执行git push命令的时候，就是把这个区的数据push到远程git仓库。</li></ul></li></ul><p><img src="./Image-git2.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><ul><li>Git的工作流程：<ul><li>写代码(修改工作区)；</li><li>把写好的或修改的文件加入到暂存区，使用命令：git add 文件名；</li><li>把暂存区的修改提交到版本库中，使用命令：git commit；</li><li>此时本地版本库就跟远程仓库(就是我们常用的GitHub、码云、GitLab等等)状态不同了，把版本库推送到远程仓库保持同步：git push。</li></ul></li></ul><p>&nbsp;</p><ul><li>Git安装：<ul><li>Git安装比较简单，按照一般的安装步骤操作即可，这里不做过多的叙述。安装完成后，对着桌面，单机鼠标右键，出现如下图所示，表示安装完成。</li></ul></li></ul><p><img src="./Image-git3.png" srcset="/img/loading.gif" alt=""></p><p><strong>说明：Git Bash：是Unix与Linux风格的命令行，也是使用的最多，推荐的最多的；Git GUI：图形界面的Git，不建议初学者使用，因为无法熟悉常用Git命令</strong>。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO1-2-GitHub简介"><a href="#NO1-2-GitHub简介" class="headerlink" title="NO1.2 GitHub简介"></a>NO1.2 GitHub简介</h3><p>GitHub、码云…等等，都是用来保存和管理代码。</p><ul><li>GithHub：<ul><li>定义：也叫代码托管中心，即用来维护Git的远程仓库的，说白了就是维护我们提交到远程仓库的代码。可分为：<ul><li>局域网环境，该环境下有：GitLab服务器；</li><li>互联网环境，该环境下有：GitHub、码云。</li></ul></li></ul></li></ul><p><img src="./Image-git4.png" srcset="/img/loading.gif" alt=""><br><strong>说明：执行流程解释：项目经理将项目，经过在工作区编写和修改、临时存入暂存区等待提交、提交到版本库(也叫版本库)中、最后再由版本库交给代码托管中心进行管理，体现了团队合作的流程。</strong></p><p>&nbsp;</p><p><img src="./Image-git5.png" srcset="/img/loading.gif" alt=""><br><strong>说明：执行流程解释：和上面的执行流程基本一致，不同的是，多了一个第三方可以对目标项目进行修改等操作，当然在发送给第三方前会将项目复制一份给第三方，然后等到第三方提交的时候，会进行审核，毕竟不是什么代码都能加进某个项目中的；审核通过，才会将第三方修改的代码加入进项目中。如，Linux就是部分开源。</strong></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><h2 id="Lesson2-Git基础"><a href="#Lesson2-Git基础" class="headerlink" title="Lesson2 Git基础"></a>Lesson2 Git基础</h2><h3 id="NO2-1-Git常用命令"><a href="#NO2-1-Git常用命令" class="headerlink" title="NO2.1 Git常用命令"></a>NO2.1 Git常用命令</h3><p>我们使用Git，将我们编写好的代码上传到GitHub进行统一管理。</p><ul><li>创建版本库：<ul><li>git init：在当前目录下创建版本仓库。因为Git的很多命令都需要在Git的仓库中运行，所以该命令是使用Git的第一个命令；</li></ul></li></ul><p>&nbsp;</p><ul><li>设置签名：<ul><li>作用：签名的作用是标识不同开发人员的身份，主要是名称和邮箱。不过这签名和代码托管中心没有任何关系，如果没有设置签名，那么有可能在使用命令时，系统由于分辨不出身份而导致出错。签名有两种级别：<ul><li>项目级别：即仅仅在当前版本库范围内有效；<ul><li>git config user.name xxx和git config user.email xxx：分别设置开发者的名称和邮箱。</li></ul></li><li>系统级别：即登录当前操作系统的用户，这个范围内有效(常用的是这个级别)。<ul><li>git config –global user.name xxx和git config –global user.emailxxx：分别设置开发者的名称和邮箱。<strong>注意：两个级别的签名信息都有时，根据就近原则，会以项目级别的为准。</strong></li></ul></li></ul></li><li>cat ~/.gitconfig：查看自己设置的Git用户名称和邮箱。</li></ul></li></ul><p><img src="./Image-git6.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><ul><li>查看状态：<ul><li>git status [选项]：用于显示工作目录和暂存区的状态，但不会显示已经提交到项目历史中去的消息。选项如下：<ul><li>-s：以简短模式查看本地仓库的状态，会显示两列，第一列是文件的状态，第二列是对应的文件；其中文件状态有：A表示新增，M表示修改，D表示删除，??表示未添加到Git中。</li></ul></li></ul></li></ul><p><img src="./Image-git7.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><ul><li>添加：<ul><li>git add 文件名  [选项]：用于将工作区中指定的文件存添加暂存区；如果文件名前面不加路径，默认是在当前路径下找该文件。选项如下：<ul><li>-u/–update：添加所有修改、已删除的文件到暂存区中；</li><li>-A/–all：添加所有修改、已删除、新增的文件到暂存区中；</li><li>-i/–interactive：查看所有修改、已删除但没有提交的文件，进入一个子命令系统。</li></ul></li></ul></li></ul><p><img src="./Image-git8.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><ul><li>提交：<ul><li>git commit [选项]：用于将暂存区中的文件，提交到版本库，除了文件以外，修改文件内容的用户和日志信息也会一起存储在这个提交中。选项如下：<ul><li>-m：格式为-m “本次提交的描述信息”，即将暂存区文件提交到版本库，并添加这一次提交的描述信息；如果不添加该参数，那么在提交时，会给你一个vim文本编辑器来编辑你要添加时的message；</li><li>-a：将所有已跟踪文件中(即曾经有提交到版本库的记录)的执行修改或删除操作的文件都提交到本地仓库，即使它们没有经过git add添加到暂存区；但是新添加的文件，且没有提交过版本库的文件还是要先add再commit才行，即这些文件不适用-a参数；</li><li>–amend：修改上次提交的描述信息。</li></ul></li></ul></li></ul><p><img src="./Image-git9.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><ul><li>删除：<ul><li>git rm  [选项] 文件名：用于同时从工作区和索引(也就是暂存区)中删除文件。选项如下：<ul><li>–cached：用于将暂存区的文件恢复到工作区，也就是从暂存区中删除这个文件，但是本地文件还存在，只是不想该文件再被版本控制；</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>查看日志：<ul><li>git log  [选项]：用于显示提交的所有日志信息，也就是你提交过的历史版本信息；但是无法查看已删除的commit记录。选项如下：<ul><li>-n：显示最新提交的n条记录；</li><li>commitID：显示从第一次提交到指定commitID为止的所有提交的记录；</li><li>–oneline：用一行来显示提交的日志信息；</li></ul></li><li>git reflog：查看所有分支的所有操作记录(包括commit和reset的操作)，包括已经被删除的commit记录。</li></ul></li></ul><p><img src="./Image-git10.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><p><img src="./Image-git11.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><p><img src="./Image-git12.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><p><img src="./Image-git13.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><ul><li>版本回退：<ul><li>git reset  [选项]：将暂存区的文件撤回工作区，默认撤回的是HEAD指向的文件。选项如下：<ul><li>–soft  commitID：将HEAD指向的文件的版本库版本移动到指定的版本。只移动版本库的HEAD指针，即版本库的版本落后了，但是暂存区和工作区的文件版本没有变更，也就是说，此时暂存区和工作区的版本要比版本库新一些；</li><li>–mixed commitID：将HEAD指向的文件的版本库、暂存区(两个区)的版本都移动到指定的版本。只移动版本库和暂存区的HEAD，即此时版本库和暂存区的版本都落后了，而工作区的版本却是最新的；</li><li>–hard commitID：将HEAD指向的文件的版本库、暂存区、工作区(三个区)的版本移动到指定的版本，但跳到该版本以后，其版本之后添加的文件内容将不会存在。</li></ul></li></ul></li></ul><p><img src="./Image-git14.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><ul><li>比较文件：<ul><li>git diff [选项] 文件名：用于比较两个区域中的文件差异，默认比较的是工作区和暂存区；另外如果不带文件名进行比较，默认是将当前目录下所有文件与暂存区的版本进行比较(前提是要工作区里有修改过的文件)。选项如下：<ul><li>HEAD：比较的是暂存区和版本库里的文件。</li></ul></li></ul></li></ul><p><img src="./Image-git15.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-2-Git分支和分支常用命令"><a href="#NO2-2-Git分支和分支常用命令" class="headerlink" title="NO2.2 Git分支和分支常用命令"></a>NO2.2 Git分支和分支常用命令</h3><p>分支，顾名思义，就是从主干上分化出来的一部分，但不会影响主干(即master)。</p><ul><li>分支：<ul><li>定义：Git分支，其实就是将主干代码的副本，然后不同的开发人员在各自创建的分支上进行开发工作，最后再合并，既没有影响到原来主干的代码进度，开发人员也完成了他们的任务；</li><li>优点：<ul><li>可以同时并行多个开发任务；</li><li>就是分支开发失败，也不会影响主干。</li></ul></li></ul></li></ul><p>&nbsp;</p><ul><li>查看、创建、修改、删除分支：<ul><li>git branch  [选项]：不添加参数选项，则列出本地所有的分支，当前所在分支以“*”标出。选项如下：<ul><li>-v：列出本地所有的分支，当前所在分支以 “*” 标出，并显示最后一次提交；</li><li>分支名：创建一个新的分支，新的分支基于上一次提交建立；</li><li>-m 原分支名称 新分支名称：修改分支名称。如果不指定原分支名称则默认为当前所在分支；</li><li>-M 原分支名称 新分支名称：强制修改分支名称。如果不指定原分支名称则默认为当前所在分支；</li><li>-d 分支名称：删除指定的本地分支；</li><li>-D 分支名称：强制删除指定的本地分支。</li></ul></li></ul></li></ul><p><img src="./Image-git16.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><p><img src="./Image-git17.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><p><img src="./Image-git18.png" srcset="/img/loading.gif" alt=""> </p><p>&nbsp;</p><p><img src="./Image-git19.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><ul><li>切换分支和替换工作区文件：<ul><li>git checkout  [选项]：该命令主要有两个功能；选项如下：<ul><li>分支名：切换到已存在的指定分支中去；</li><li>-b 分支名：创建并切换到指定的分支，保留所有的提交记录。等同于git branch和git checkout两个命令合并；</li><li>–orphan：创建并切换到指定的分支，删除所有的提交记录；</li><li>文件名：将暂存区的指定文件，替换掉当前工作区的指定文件，即同一个文件下，当前工作区里文件的内容，被暂存区里的文件内容替换掉了，也就是重写了工作区的文件内容。</li></ul></li></ul></li></ul><p><img src="./Image-git20.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><ul><li>合并分支：<ul><li>git merge 分支名：首先要切换到被合并的分支下(一般都是主干)，把指定的分支合并到当前所在的分支下；另外如果从远程仓库拉取了文件的最新版本后，需要将该版本和本地工作区的文件进行合并，则使用：git merge 远程仓库别名/分支名。<strong>注意：当合并分支时出现合并冲突，我们需要转为手动合并：即在协商之后决定保留冲突中的哪一部分内容，最后需要git add和git commit -m “提交信息”这两个命令来结束合并状态即可。</strong></li></ul></li></ul><p><img src="./Image-git21.png" srcset="/img/loading.gif" alt=""> </p><p>&nbsp;</p><p><img src="./Image-git22.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><p><img src="./Image-git23.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-3-Git版本库与GitHub-代码托管中心"><a href="#NO2-3-Git版本库与GitHub-代码托管中心" class="headerlink" title="NO2.3 Git版本库与GitHub(代码托管中心)"></a>NO2.3 Git版本库与GitHub(代码托管中心)</h3><p>Git只是用来与远程仓库互动的一个工具，我们还需要与代码托管中心进行关联。</p><ul><li>关联Git版本库与GitHub远程仓库，并push文件的步骤：<ul><li>注册GitHub，并登陆到GitHub上，创建一个public或者private权限的自定义名称的仓库，这个仓库就是我们用来存储从Git版本库上传的代码文件所使用的仓库；</li><li>在Git上，创建一个新的文件夹作为版本库，使用git init命令即可；然后编写一个代码文件，按顺序使用git add和git commit命令分别上传到暂存库、版本库中；</li><li>关联版本库和远程仓库，也就是告诉版本库，把我想要存储的代码文件发送到哪里去。使用如下命令进行操作：<ul><li>git remote [选项]：列出已经存在的远程仓库；选项如下：<ul><li>-v/–verbose：列出远程仓库的详细信息，在别名后面列出URL地址；</li><li>add 远程仓库的别名 远程仓库的URL地址：添加远程仓库，即将当前的版本库与指导的远程仓库进行关联；</li><li>rename 原远程仓库的别名 新的别名：修改远程仓库的别名；</li><li>remove 远程仓库的别名：删除指定名称的远程仓库；</li><li>set-url 远程仓库的别名 新的远程仓库URL地址：修改远程仓库的URL地址。</li></ul></li></ul></li><li>关联成功以后，就可以push代码文件了。使用如下命令进行操作：<ul><li>git push [选项]：该命令用来将本地库中的文件推送到远程仓库中去。选项如下；<strong>注意：这里可能会出现一个异常，你的远程仓库有个文件README.md(也可能没有这个文件)，但是本地仓库却没有，就会出现“failed to push some refs to…”这种情况，所以无论远程仓库中是否有README.md文件，第一次push都需要把这个文件push到你的远程仓库中去，在当前目录下直接创建README.md文件，然后使用命令：git push -u 你自己的远程仓库别名 master，其中master是你每个新建远程仓库的默认分支，输入后，会要你输入登录到GitHub的账号和密码，要输入两次，第二次是免密SSH登录，输入后就可以顺利push文件到远程仓库了。</strong><ul><li>远程仓库的别名 本地分支名:远程分支名：把本地仓库的分支推送到远程仓库的指定分支；如果省略远程分支名，则默认推送到与本地分支存在追踪关系的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建；</li><li>远程仓库的别名 :远程分支名/远程仓库的别名 –delete 远程分支名：删除指定的远程仓库的分支。如，git push aaa :abc或者git push aaa –delete abc都是删除远程层库中的某个分支。</li></ul></li></ul></li></ul></li></ul><p><img src="./Image-git24.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><p><img src="./Image-git25.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><p><img src="./Image-git26.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><ul><li>第一次从远程仓库下载代码文件到本地，有两种方式：<ul><li>一种是download(很简单)；</li><li>另一种则是使用git命令，我们介绍的是git命令的方式。<ul><li>从远程仓库中，找到Clone or download按钮，如下图；</li><li>开发人员在自己的工作目录中，打开Git，使用git命令：<ul><li>git clone 远程仓库URL [选项]：不添加选项参数，则默认在当前目录下，创建和远程仓库名相同的文件夹，并下载文件到该文件夹下。选项如下；<strong>注意：clone命令会做三件事情：一是完整的把远程仓库下载到本地，二是创建远程地址别名(前提是要关联了本地本地库和远程仓库)，三是初始化本地库。</strong></li><li>本地目录：将clone的分支放到指定的本地仓库目录中；</li><li>b 分支名称 本地目录：指定要克隆的分支，默认是master分支。</li></ul></li></ul></li></ul></li></ul><p><img src="./Image-git27.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><ul><li>开发人员在修改了代码后，需要上传到GitHub中，但是这时候可能没有权限提交，所以项目经理一般都会将开发人员都邀请加入公司创建的GitHub中，这样开发人员就有权限提交代码到公司的GitHub中了；最后再使用git push命令，push修改过的代码就行了。</li></ul><p><img src="./Image-git28.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><ul><li>如果需要拉取最新版本的文件到本地，则使用：<ul><li>git fetch [选项]。选项如下：<ul><li>远程仓库的别名：将远程仓库所有分支的最新版本全部取回到本地；</li><li>远程仓库的别名 分支名：将远程仓库指定分支的最新版本取回到本地。</li></ul></li><li>git pull：从远程仓库获取最新版本并合并到本地；即等同于执行了git fetch和git merge两条命令。效率上git pull更快一些，但是不一定安全，因为git fetch可以进行有选择的合并，所以根据工作中的需求，选择合适的拉取命令方式才是正确的。</li></ul></li><li>协同开发冲突问题：在开发者，经常会遇到两个人同时在修改一个文件的问题，即当同事A上传了对C文件的修改后，紧接着同事B也上传了对C文件的修改，此时GitHub就会出现冲突，即不知道该听那个开发者的，C文件中应该使用谁的内容才是正确的，所以为了避免出现这种问题，GitHub规定，出现这种情况时，另一个人应该先更新自己的本地文件，即保证自己本地是最新版本，然后再做修改即可。<strong>注意：解决冲突后，最后提交文件时，不要带文件名，只需要带上提交的说明信息(即-m参数)，直接提交即可。</strong></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3 id="NO2-4-IDEA工具中使用Git"><a href="#NO2-4-IDEA工具中使用Git" class="headerlink" title="NO2.4 IDEA工具中使用Git"></a>NO2.4 IDEA工具中使用Git</h3><p>IDEA默认集成了Git工具。</p><ul><li>IDEA中使用Git将项目push到远程仓库，如下列图中所示：</li></ul><p><img src="./Image-git29.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><p><img src="./Image-git30.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><p><img src="./Image-git31.png" srcset="/img/loading.gif" alt=""><br><strong>说明：测试成功会出现这个。</strong></p><p>&nbsp;</p><p><img src="./Image-git32.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><p><img src="./Image-git33.png" srcset="/img/loading.gif" alt=""><br><strong>说明：点击Create Git Repository后，会出现如上所示，意思就是我要给这个项目init(也就是创建)一个版本库。</strong></p><p>&nbsp;</p><p><img src="./Image-git34.png" srcset="/img/loading.gif" alt=""><br><strong>说明：将文件add到暂存区。</strong></p><p>&nbsp;</p><p><img src="./Image-git35.png" srcset="/img/loading.gif" alt=""><br><strong>说明：选中项目，将项目add到暂存区。</strong></p><p>&nbsp;</p><p><img src="./Image-git36.png" srcset="/img/loading.gif" alt=""><br><strong>说明：进行commit操作，提交到版本库中。</strong></p><p>&nbsp;</p><p><img src="./Image-git37.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><p><img src="./Image-git38.png" srcset="/img/loading.gif" alt=""></p><p><strong>说明：使用IDEA集成Git，push代码文件到远程仓库；首先，需要配置登录到GitHub的账户，就是你平常登录到GitHub的账号和密码。</strong></p><p>&nbsp;</p><p><img src="./Image-git39.png" srcset="/img/loading.gif" alt=""><br><strong>说明：配置远程仓库的url，也就是关联远程仓库。</strong></p><p>&nbsp;</p><p><img src="./Image-git40.png" srcset="/img/loading.gif" alt=""><br><strong>说明：在这里面设置远程仓库的url即可。</strong></p><p>&nbsp;</p><p><img src="./Image-git41.png" srcset="/img/loading.gif" alt=""><br><strong>说明：最后，选择push命令就可以将代码push到远程仓库了。</strong></p><p>&nbsp;</p><p><img src="./Image-git42.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><p><img src="./Image-git43.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><ul><li>开发人员从远程仓库clone项目代码到本地。<ul><li>首先在远程仓库里复制一下远程仓库的url；</li></ul></li></ul><p><img src="./Image-git44.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><p><img src="./Image-git45.png" srcset="/img/loading.gif" alt=""></p><p><strong>说明：选择VCS，再选择Checkout from Version Control选项，最后选择Git。</strong></p><p>&nbsp;</p><p><img src="./Image-git46.png" srcset="/img/loading.gif" alt=""></p><p><strong>说明：在弹出的框中，填入远程仓库的url，并可以点击Test，测试是否能够连接，连接成功会出现以上绿色框中的提示；其中Directory则是指你要将clone下来的项目文件放在本地哪个位置，最后点击Clone即可；另外当开发人员修改了项目代码之后，需要push项目文件到远程仓库，这个时候也要注意，需要得到远程仓库管理人员的权限邀请，即管理人员没有邀请你的话，你哪怕写好了代码，也是无法提交到远程仓库的；最后，远程仓库默认使用的是Clone时使用远程仓库url。</strong></p><p>&nbsp;</p><ul><li>当别人push了新代码之后，你需要更新自己的本地代码，按下图操作即可。</li></ul><p><img src="./Image-git47.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p><p><img src="./Image-git48.png" srcset="/img/loading.gif" alt=""></p><p>&nbsp;</p>]]></content>
    
    
    <categories>
      
      <category>扩展课程</category>
      
      <category>版本控制工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
