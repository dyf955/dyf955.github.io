<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="o一行瑠璃o">
  <meta name="keywords" content="学习笔记,Java,C">
  <title>03.SSM框架--学习笔记 - 知晓天空之蓝的人啊</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Hello World</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                目录
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/indexbg/sun.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-07-03 21:21">
      2020年7月3日 晚上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      30.5k 字
    </span>
  

  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="SSM框架–学习笔记-包含SSM视频"><a href="#SSM框架–学习笔记-包含SSM视频" class="headerlink" title="SSM框架–学习笔记(包含SSM视频)"></a>SSM框架–学习笔记(包含SSM视频)</h1><h2 id="Lesson1-Spring框架"><a href="#Lesson1-Spring框架" class="headerlink" title="Lesson1 Spring框架"></a>Lesson1 Spring框架</h2><h3 id="NO1-1-Spring概述"><a href="#NO1-1-Spring概述" class="headerlink" title="NO1.1 Spring概述"></a>NO1.1 Spring概述</h3><p>Spring是service层的框架。</p>
<ul>
<li>Spring框架：<ul>
<li>定义：该框架是一个轻量级的、开源的Java EE框架；</li>
<li>应用：解决企业应用开发的复杂性；</li>
<li>核心：<code>IOC和AOP</code>，即控制反转和面向切面编程；</li>
<li>特点：<ul>
<li>方便解耦，简化开发；</li>
<li>兼容与其他框架的开发；</li>
<li>便捷的事务操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>入门案例：</p>
<ul>
<li><p>使用IDEA创建一个Java工程，下载Spring5.x版本的JAR包，或者使用Maven导入Spring5的依赖即可；</p>
<p><img src="./image-ssm1.png" srcset="/img/loading.gif" alt="image-20200704004514715"></p>
</li>
<li><p>创建包路径：cn.dyf.domain，然后再domain包中，创建一个User类；</p>
</li>
<li><p>在项目中你自定义的包路径下，创建Spring的核心配置文件：<code>applicationContext.xml</code>；我这里创建的是cn.dyf.domain，所以我打算把Spirng配置文件放在cn.dyf包下(入门案例，你放哪里都行)。Spring配置文件的标准头信息如下：</p>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">"http://www.springframework.org/schema/p"</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span>
<span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/context</span></span>
<span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>

	<span class="hljs-comment">&lt;!--配置了一个User类的对象，对象名为user，然后Spring中不叫对象名，而是叫id，所以，配置了一个id为user的User类的对象--&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.dyf.domain.User"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre>
</li>
<li><p>编写一个测试类：</p>
<pre><code class="hljs java">
piblic  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;
	<span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;

		<span class="hljs-comment">//加载Spring的配置文件applicationContext.xml，获得</span>
		ClassPathXmlApplicationContext cac = <span class="hljs-keyword">new</span>
ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:applicationContext.xml"</span>);

        <span class="hljs-comment">//获取你刚刚配置的user对象</span>
		User u= cac.getBean(<span class="hljs-string">"user"</span>,User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
		
        <span class="hljs-comment">//输出了u对象，这个u对象，其实就是刚刚配置的user对象</span>
		System.out.println(u);
	&#125;
&#125;</code></pre>


</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO1-2-IOC和DI"><a href="#NO1-2-IOC和DI" class="headerlink" title="NO1.2 IOC和DI"></a>NO1.2 IOC和DI</h3><p>IOC极大的提高了Java的编程效率。</p>
<ul>
<li><p>IOC：</p>
<ul>
<li><p>定义：即控制反转，也就是将创建对象的操作交给Spring去管理；</p>
</li>
<li><p>底层原理：</p>
<ul>
<li>首先，将配置在applicationContext.xml中的<code>&lt;bean&gt;</code>标签进行解析，也就是告诉Spring要生成哪些类的对象；</li>
</ul>
</li>
<li><p>然后，Spring中有个工厂类，这个工厂类会根据xml文件解析出的结果来创建对象，没错，这个工厂类就是专门用于创建某一类对象的工厂；</p>
</li>
<li><p>最后，在工厂类中，通过反射的方式来获取xml文件解析结果中要求创建的类的对象，这就是<code>&lt;bean&gt;</code>标签中，class属性的作用，为反射提供了类，而反射会根据类获得该类的字节码文件对象，然后该类的字节码文件对象使用newInstance()方法就能够得到你配置在xml文件中的类的对象了。</p>
</li>
<li><p>两个接口：IOC思想基于IOC容器，而IOC容器的底层就是能够创建对象的工厂类；</p>
<ul>
<li><p><code>BeanFactory</code>：该接口就是IOC容器的基本实现，即创建对象的功能就是这个接口的一个方法。但该接口是Spring内部接口，常常是Spring内部在使用，所以一般我们开发者不使用该接口来创建工厂实现类；</p>
</li>
<li><p><code>ApplicationContext</code>：是BeanFactory的子接口，但添加了更多更强大的功能在该接口中，一般开发者实现的就是这个接口来创建工厂类。</p>
<pre><code class="hljs lasso">拓展：BeanFactory与ApplicationContext的区别
一、BeanFactory创建的实现类在加载Spring的<span class="hljs-built_in">xml</span>配置文件时，是不会立即生成你要求创建的那些类的对象，也就是说只有到真正用到的时候，才会创建；

二、ApplicationContext则是在加载<span class="hljs-built_in">xml</span>配置文件时就完成了创建对象工作，因为我们在真实的开发中一般都希望将耗费时间和资源的事情在开启服务器时就完成，而不是等到用户真正去使用时，才去创建要用的对象，这对用户体验很不友好。

<span class="hljs-comment">//============================================================</span>

拓展：ApplicationContext的两个实现类的区别
一、FileSystemXmlApplicationContext，该实现类用于加载Spring的核心配置文件
applicationContext.<span class="hljs-built_in">xml</span>，但路径名称必须写该配置文件在你电脑上的绝对路径，也就是带盘符的路径

二、ClassPathXmlApplicationContext，该实现类也是用于加载Spring的核心配置文件，但不同的是，加载的是这个配置文件在当前项目中的位置，也就是相对路径。</code></pre>
</li>
</ul>
</li>
<li><p>基本语法格式：</p>
<ul>
<li><p>创建Spring的核心配置文件：<code>applicationContext.xml</code>文件；</p>
</li>
<li><p>在applicationContext配置文件中配置类：要想实现IOC，只需要把自己写的类在<code>applicationContext.xml</code>中配置一下即可；</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"你想要创建的对象的名称"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"你想要创建对象的所属类的全包名路径"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>

<ul>
<li><code>&lt;bean&gt;</code>标签解析：<ul>
<li><code>id</code>：被Spring管理的类所生成的对象的名称；如果是通过类型获取bean的过程中，则可以不设置，也就是说当使用ac.getBean(xxx.class)这种方式获取bean对象时，id属性可以不用设置，但只能有一个这样的类，即被管理的User类只能写一个；</li>
<li><code>name(了解)</code>：和id属性拥有同样的效果，只不过name属性中还可以添加一些符合，而id属性则不可以，该属性一般用于和Struts框架整合使用，但现在一般不用Struts框架了，name属性也就不再使用了；</li>
<li><code>scope</code>：配置bean的作用范围。该属性取值：<ul>
<li><code>singleton</code>：单例模式，不设置则默认是该值；</li>
<li><code>prototype</code>：多例模式</li>
<li><code>request</code>：应用在Web项目中，Spring创建该类对象后，会存入request域中</li>
<li><code>session</code>：应用在Web项目中，Spring创建该类对象后，会存入session域中</li>
<li><code>globalsession</code>：应用在Web项目中，必须在porlet环境下使用，即配置后，在子资源中不需要重复做某些操作。<code>如，重复登录</code>。</li>
</ul>
</li>
<li><code>init-method</code>：bean的初始方法，在创建好bean后会调用该方法；</li>
<li><code>destory-method</code>：bean的销毁方法，在销毁bean之前调用该方法，一般在该方法中释放资源；</li>
<li><code>autowire</code>：表示bean的自动装配。autowire的值有：<ul>
<li><code>no</code>：默认值，不进行自动装配；</li>
<li><code>byName</code>：根据名称自动装配。某行代码需要装配某个对象，那么这个对象肯定有个名称，然后根据这个名称，去容器中查找与之名称相同的bean，相同就装配，不相同就不装配；</li>
<li><code>byType</code>：如果容器中存在一个与需要装配的对象，类型相同的bean，那么将与该属性自动装配。如果存在多个该类型bean，那么抛出异常，并指出不能使用byType方式进行自动装配；如果没有找到相匹配的bean，则什么事都不发生，也可以通过设置dependency-check=”objects” 让Spring抛出异常(该值允许自动装配的bean对象有继承或有接口实现关系，也就是说该bean对象可以是父类对象或接口对象)；</li>
<li><code>constructor</code>：与byType方式类似，不同之处在于它应用于构造器参数；如果容器中没有找到与构造器参数类型一致的bean， 那么抛出异常；</li>
<li><code>autodetect</code>：通过bean类的内省机制(introspection)来决定是使用constructor还是byType方式进行自动装配；如果发现默认的构造器，那么将使用byType方式，否则采用constructor；</li>
<li><code>default</code>：由上级标签的default-autowire属性确定。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>如果是想要在测试类中获取bean对象：通过配置文件初始化Spring容器，然后通过反射获取类的实例：</p>
<pre><code class="hljs java">ApplicationContext ac= <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"applicationContext.xml"</span>);

类名 对象名 = ac.getBean(<span class="hljs-string">"配置文件中你想要获取的类的bean标签的id"</span>,你想要获取的类<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>DI：</p>
<ul>
<li><p>定义：是指依赖注入。前提是必须要有IOC的环境，让Spring来管理类时，会将类所依赖的属性(属性中可能会有基本数据类型或引用类型)也一起设置进来；</p>
</li>
<li><p>基本语法格式：</p>
<ul>
<li><p>这是set()方法注入属性(推荐该方式)；</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--普通类型：使用value赋值--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"被Spring管理的类的对象的名称"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"被Spring管理的类的全包名路径"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"依赖的属性名"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"依赖的属性的值"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

//----------------------------------------------------------------

<span class="hljs-comment">&lt;!--对象类型：使用ref赋值，值一般是其他对象的id或者name--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"被Spring管理的类的对象的名称"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"被Spring管理的类的全包名路径"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"依赖的属性名"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"依赖的属性的对象的id"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

拓展：设置null值和含有特殊符号的值
一、设置null值，如下所示：
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"依赖的属性名"</span> &gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">null</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

二、设置包含特殊符号的值，如下所示：
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"依赖的属性名"</span> &gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">![CTATA[这里填含有特殊符号的值]]</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

//----------------------------------------------------------------

<span class="hljs-comment">&lt;!--集合类型：在&lt;property&gt;标签中使用&lt;list&gt;标签(或&lt;array&gt;标签或&lt;set&gt;标签或&lt;map&gt;标签，根据需要选择就行)，然后赋值即可--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"被Spring管理的类的对象的名称"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"被Spring管理的类的全包名路径"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"依赖的属性名"</span> &gt;</span>    
        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>
            <span class="hljs-comment">&lt;!--集合里面是普通元素用value标签--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>666<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>666<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>

            <span class="hljs-comment">&lt;!--集合里面是对象元素用ref标签--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"要引用的bean的id值"</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"要引用的bean的id值"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>
        
        <span class="hljs-comment">&lt;!--map标签--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>
            <span class="hljs-comment">&lt;!--使用这种--&gt;</span>
    		<span class="hljs-tag">&lt;<span class="hljs-name">entry</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>111<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span>
            
            <span class="hljs-comment">&lt;!--或者使用这种--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">""</span> <span class="hljs-attr">value</span>=<span class="hljs-string">""</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

拓展：提取公共集合
一、添加名称空间
http://www.springframework.org/schema/util
http://www.springframework.org/schema/util/spring-util.xsd

二、在xml中添加标签：<span class="hljs-tag">&lt;<span class="hljs-name">util:集合名称</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">util:集合名称</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">util:集合名称</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"给这个集合取个名称"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 下面二选一即可 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">util:集合名称</span>&gt;</span></code></pre>
</li>
<li><p>这是有参构造方法注入属性；</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--普通类型：使用value赋值；其他类型就用ref，参考上方的set()方法注入属性--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"被Spring管理的类的对象的名称"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"被Spring管理的类的全包名路径"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"依赖的属性名"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"依赖的属性的值"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 当注入的属性是一个对象时，使用ref属性即可</span>
<span class="hljs-comment">    &lt;constructor-arg name="依赖的属性名" ref="依赖的对象的id"&gt;&lt;/constructor-arg&gt;</span>
<span class="hljs-comment">    --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
</li>
<li><p>P命名空间注入属性；</p>
<pre><code class="hljs xml">//在xml中添加命名空间
xmlns:p="http://www.springframework.org/schema/p"

//-----------------------------------------------------

//使用p命名空间为属性赋值

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.dyf.domain.User"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">p:name</span>=<span class="hljs-string">"hanyan"</span> <span class="hljs-attr">p:age</span>=<span class="hljs-string">"24"</span> <span class="hljs-attr">p:product</span>=<span class="hljs-string">"product对象的id值"</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>


</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>FactoryBean：</p>
<ul>
<li><p>定义：是一个工厂Bean，可以生成某一个类型Bean实例；</p>
</li>
<li><p>作用：可以让我们自定义Bean的创建过程。BeanFactory是Spring容器中的一个基本类也是很重要的一个类，在BeanFactory中可以创建和管理Spring容器中的Bean，它对于Bean的创建有一个统一的流程；</p>
<pre><code class="hljs java"><span class="hljs-comment">//FactoryBean是一个接口</span>
        
        <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
        
            <span class="hljs-comment">//返回的对象实例</span>
            <span class="hljs-function">T <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;
        
            <span class="hljs-comment">//Bean的类型</span>
            Class&lt;?&gt; getObjectType();
        
            <span class="hljs-comment">//true是单例，false是非单例。在Spring5.0中此方法利用了JDK1.8的新特性变成了default方法，返回true</span>
            <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span></span>;
        &#125;
        
        <span class="hljs-comment">//--------------------------------------------</span>
        
        <span class="hljs-comment">//FactoryBean接口的实现类</span>
        
        <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span> </span>&#123;
            
            <span class="hljs-comment">//Bean实例</span>
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        
                <span class="hljs-comment">//这个Bean是我们自己new的，这里我们就可以控制Bean的创建过程了</span>
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-string">"小明"</span>,<span class="hljs-number">11</span>);
            &#125;
        
            <span class="hljs-comment">//Bean类型</span>
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;
                <span class="hljs-keyword">return</span> User<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;
            &#125;
        
            <span class="hljs-comment">//是否单例</span>
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span> </span>&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            &#125;
        &#125;
        
        <span class="hljs-comment">//--------------------------------------------</span>
        
        &lt;!--配置MyFactory的bean--&gt;
        
        &lt;bean id="myFactory" class="cn.dyf.domain.MyFactory"&gt;&lt;/bean&gt;
        
        <span class="hljs-comment">//--------------------------------------------</span>
        
        <span class="hljs-meta">@Test</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;
        
                ClassPathXmlApplicationContext cac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:applicationContext.xml"</span>);
                MyFactory mf= cac.getBean(MyFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
                System.out.println(mf);
            &#125;
        
        <span class="hljs-comment">//--------------------------------------------</span>
        
        测试结果：User [name = 小明， age= <span class="hljs-number">11</span>]
        
        说明：配置的是MyFactory，也就是本该生成的应该是MyFactory的bean，却得到了MyFactory工厂里生产的User对象，其原因是MyFactory实现了FactoryBean接口</code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>Spring中bean的生命周期。</p>
<p><img src="./Image-ssm2.png" srcset="/img/loading.gif" alt="Image"></p>
<ul>
<li>Spring中的bean在创建过程中大概分为以下几个步骤：实例化-&gt;填充属性-&gt;执行Aware接口-&gt;初始化-&gt;可用状态-&gt;销毁；解析过程：<ul>
<li>实例化：就是调用类的构造器进行对象创建的过程；</li>
<li>填充属性：是指注入bean的依赖或者给属性赋值，一般会调用set方法；</li>
<li>Aware接口：是Spring中的“觉醒”接口，是Spring容器通过回调向bean注入相关对象的接口；<ul>
<li>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法；</li>
<li>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</li>
<li>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来；</li>
<li>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法，即初始化之前对bean进行操作；</li>
<li>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用；</li>
<li>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法，即初始化之后对bean进行操作；</li>
</ul>
</li>
<li>初始化：是指完成bean的创建和依赖注入后进行的一个回调，可以利用这个回调进行一些自定义的工作，实现初始化的方式有三种，分别是实现InitializingBean接口、使用@PostConstruct注解和xml中通过init-method属性指定初始化方法;</li>
<li>可用状态：是指bean已经准备就绪，可以被应用程序使用了，此时bean会一直存在于Spring容器中；</li>
<li>销毁：是指这个bean从Spring容器中消除，这个操作往往伴随着Spring容器的销毁。实现销毁方法的方式有3中，分别为实现DisposableBean接口、使用@PreDestroy注解和xml中通过destroy-method属性指定</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>分模块开发：</p>
<ul>
<li><p>定义：是指开发者一般会负责不同的功代码编写，因此可能会需要引入外部文件或引入不同的配置文件。<code>如，数据库配置文件等等</code>；</p>
</li>
<li><p>解决引入外部资源文件的问题：</p>
<ul>
<li><p>引入context名称空间；</p>
<pre><code class="hljs xml">//先添加这个
    xmlns:context="http://www.springframework.org/schema/context
    
    //后添加这个
http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd</code></pre>
</li>
<li><p>使用标签<code>&lt;context:property-placeholder&gt;</code>。</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:外部配置文件名称，要带上后缀"</span>&gt;</span>
    
说明：location属性，是指加载指定位置下的配置文件</code></pre>
</li>
</ul>
</li>
<li><p>解决存在多个配置文件的问题：</p>
<ul>
<li><p>在生产环境中：在applicationContext.xml主配置文件中使用标签引入分配置文件即可(推荐)；</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"需要引入的其他的配置文件"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span>;</code></pre>
</li>
<li><p>在测试类中：创建Spring的工厂对象时，只需要多写几个配置文件参数即可；</p>
<pre><code class="hljs java">ApplicationContext springFactory = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"applicationContext1.xml,applicationContext2.xml"</span>);</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>使用Spring的IOC注解开发(推荐)：</p>
<ul>
<li><p>在applicationContext配置文件中，引入context名称空间后，需要配置扫描组件标签；</p>
<pre><code class="hljs xml">//引入context名称空间
//先添加这个
xmlns:context="http://www.springframework.org/schema/context

//后添加这个
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd

//---------------------------------------

<span class="hljs-comment">&lt;!--这个标签是用于扫描类里的注解--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"配置需要扫描的包的路径"</span> /&gt;</span></code></pre>
<ul>
<li><code>&lt;context:component-scan&gt;</code>标签解析：<ul>
<li><code>use-default-filters</code>：是否使用默认的扫描进行过滤，而默认扫描就是扫描base-pachage属性的值；另外该属性默认是true；如果是false，那么就表示要用自己的扫描规则。<code>&lt;context:component-scan&gt;</code>中有两个子标签：<ul>
<li><code>&lt;context:include-filter&gt;</code>：在base-package属性的范围下，用来告知哪些类需要注册成Bean对象，使用该子标签type和expression属性一起协作来定义组件扫描策略。使用这个子标签的时候，use-default-filters属性必须设置为false；<ul>
<li>type：<ul>
<li>annotation：扫描指定注解所标注的类。通过expression属性指定要扫描的注解；</li>
<li>assignable：扫描派生于expression属性所指定类型的那些类；</li>
<li>aspectj：扫描与expression属性所指定的AspectJ表达式所匹配的那些类</li>
<li>custom：使用自定义的org.springframework.core.type.TypeFliter实现类，该类由expression属性指定；</li>
<li>regex：过滤器扫描类的名称与expression属性所指定正则表示式所匹配的那些类。</li>
</ul>
</li>
</ul>
</li>
<li><code>&lt;context:exclude-filter&gt;</code>：在base-package属性的范围下，用来告知哪些类不需要注册成Bean对象，使用type和expression属性一起协作来定义组件扫描策略。使用这个子标签的时候，use-default-filters属性必须设置为true。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在需要使用注解开发的类的上面一行，添加注解：</p>
<ul>
<li><p>@Component：用于告诉Spring，这是一个组件，你只管帮我生成对应的bean对象即可；</p>
</li>
<li><p>@Controller：用于Web层；</p>
</li>
<li><p>@Service：用于Service层；</p>
</li>
<li><p>@Repository：用于Dao层。</p>
<pre><code class="hljs java">拓展：<span class="hljs-meta">@Component</span>、<span class="hljs-meta">@Controller</span>、<span class="hljs-meta">@Service</span>、<span class="hljs-meta">@Repository</span>四个注解的区别
一、这四个注解没区别，功能都是为注解的类生成bean对象；即哪怕你用<span class="hljs-meta">@Controller</span>、<span class="hljs-meta">@Service</span>、<span class="hljs-meta">@Repository</span>注解的类都用<span class="hljs-meta">@Component</span>去注解，完全没有问题；

二、你硬要说区别的话，那就是让开发人员分清楚，哪一层是哪一层，明确的分清每一层的作用。
    
三、这四个注解中都有一个value属性，就是当前注解的类所生成的对象的名称。不写的话，默认是当前类名首字母小写。如，User类，生成的对象名称为user。</code></pre>
</li>
</ul>
</li>
<li><p>如果有代码需要DI，意思就是某一行代码需要用到某个对象，则在xml中为那个对象的所属类进行配置<code>&lt;bean&gt;</code>标签即可；然后在需要用到的地方，使用以下注解引用即可：</p>
<ul>
<li><p>普通类型：</p>
<ul>
<li><p>@Value：即为变量中注入一个值，使用value属性写入要注入的值。<code>如，@Value(value=&quot;aaa&quot;)，表示给当前注解的变量注入了字符串aaa</code>；其他形式：</p>
<ul>
<li><p><code>@Value(&quot;#{}&quot;)</code>：该形式其实是SpEL表达式，可以表示常量的值，或者获取bean中的属性；</p>
<pre><code class="hljs java"><span class="hljs-meta">@Value</span>(<span class="hljs-string">"#&#123;4&#125;"</span>)  <span class="hljs-comment">//获取数字4</span>
                    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;  
                    
                    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"#&#123;'hello world!'&#125;"</span>)  <span class="hljs-comment">//获取字符串常量</span>
                    <span class="hljs-keyword">private</span> String str;
                    
                    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"#&#123;user.name&#125;"</span>)  <span class="hljs-comment">//获取bean的属性</span>
                    <span class="hljs-keyword">private</span> String username;</code></pre>
</li>
<li><p><code>@Value(&quot;${}&quot;)</code>：该形式用于获取配置文件中的属性值，通常用于获取写在xxx.properties中的内容。</p>
<pre><code class="hljs java"><span class="hljs-comment">//xxx.properties文件中的值</span>
                
jdbc.driverClass=aaa
dbc.url=aaa
jdbc.user=ccc

<span class="hljs-comment">//--------------------------</span>

<span class="hljs-comment">//类中可以通过@Value("$&#123;&#125;")来获取相应的值</span>

<span class="hljs-meta">@Value</span>(<span class="hljs-string">""</span>$&#123;jdbc.user&#125;)
<span class="hljs-keyword">private</span> String name;</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对象类型：</p>
<ul>
<li><p><code>@Autowired(推荐)</code>：根据需要注入的对象的Class类型，进行自动装配；</p>
</li>
<li><p><code>@Qualifier</code>：根据需要注入的对象的名称，进行自动装配；该注解一般和<code>@Autowired</code>注解一起使用；具有属性：</p>
<ul>
<li><p>value：注入指定名称的bean对象；</p>
<pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>
<span class="hljs-meta">@Qualifier</span>(“value=user”)  <span class="hljs-comment">//在容器中找一个bean的id为user的对象，注入到这下面的</span>
<span class="hljs-keyword">private</span> User user;</code></pre>
</li>
</ul>
</li>
<li><p><code>Resource</code>：根据对象的Class类型或名称，进行自动装配，该是Javax包中的注解；根据名称注入时，需要添加一个name属性来指定要注入到当前对象中的bean的id；</p>
<pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span></span>&#123;

	<span class="hljs-meta">@Resources</span>  <span class="hljs-comment">//引用UserService的bean对象，这时是按类型自动装配</span>
	UserService userService;

	<span class="hljs-meta">@Resources</span>(name=<span class="hljs-string">"userDao"</span>)  <span class="hljs-comment">//这时是按名称自动装配，将容器中bean的id为userDao的对象，注入到当前ud对象中去</span>
	UserDao ud;

	....
&#125;</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>xml文件也可以用配置类来进行替换，需要使用到注解：</p>
<ul>
<li><p><code>@Configuration</code>：用于类上，告诉Spring，当前使用该注解的类是一个配置类，且也会生成bean对象，因为该注解中包含了@Conponent注解；</p>
</li>
<li><p><code>@ComponentScan</code>：扫描指定包下的@Component注解并生成相应的bean对象；除此之外还可以使用@Bean注解来指定生成某些类的bean对象；</p>
<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan</span>(basePackage=<span class="hljs-string">"要扫描的包路径"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfig</span></span>&#123;

    <span class="hljs-meta">@Bean</span>  <span class="hljs-comment">//可以自己手动添加要生成的bean对象</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User;
    &#125;

&#125;</code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
</li>
<li><p>Spring也集合了Test，也支持测试类的注解开发，只需导入相应的test的JAR包或依赖，然后再在测试类上面添加相应的<code>@Runwith</code>和<code>@ContextConfiguration</code>注解即可；</p>
<pre><code class="hljs java"><span class="hljs-meta">@Runwith</span>(SpringJUnit4ClassRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>
@ContextConfiguration("classpath:applicationContext.xml")
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;

    ...
&#125;

说明：也就是说有了注解之后可以不需要创建工厂获取实例，意思就是不需要再写ApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"applicationContext1.xml,applicationContext2.xml"</span>)和ac.getBean(<span class="hljs-string">"xxx"</span>)这两个方法了</code></pre>

</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO1-3-AOP"><a href="#NO1-3-AOP" class="headerlink" title="NO1.3 AOP"></a>NO1.3 AOP</h3><p>AOP是Spring的特性之一。</p>
<ul>
<li><p>AOP：</p>
<ul>
<li><p>定义：是指面向切面编程；</p>
</li>
<li><p>作用：降低业务逻辑各部分之间的耦合度，提高程序的可重用性；</p>
</li>
<li><p>影响：AOP是OOP(面向对象)的扩展和延伸，解决OOP开发遇到的问题；Spring中的AOP可以理解为是一种思想，而AspectJ则是这种AOP思想的具体实现，因为Spring的AOP开发，使用的是基于AspectJ的AOP开发；</p>
</li>
<li><p>底层原理：</p>
<ul>
<li><p>问题的提出：当我们在项目开发中遇到一个问题：我想给用户登陆接口添加一些别的功能，像什么权限校验功能，日志记录功能等等，但又不能改动源码，这怎么办呢？这个时候，AOP就可以为这种问题提供解决的办法；</p>
</li>
<li><p>Spring中的AOP其实是基于动态代理来实现的，什么叫动态代理呢？个人理解为，就是让系统实时地为你创建一个动态代理类，而这个类实现了你想要的基本功能和增强功能，两者兼具。<code>如，上面登录接口中的登录功能就是该接口中基本的功能，而像什么权限校验功能，日志记录功能等等，这些就是增强的功能</code>；而在Spring中，动态代理有两种，默认如果目标对象是个接口，则使用JDK动态代理，否则使用CGLIB来生成代理类：</p>
<ul>
<li><p><code>JDK动态代理</code>：一般用于接口的动态代理。其实，所谓的JDK动态代理，如上面所说，就是系统实时的帮你造一个动态代理类，实现了目标接口，并且实现类中有你想要的基本功能和增强功能；</p>
<pre><code class="hljs java"><span class="hljs-comment">//登录接口</span>
                <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Login</span></span>&#123;
                	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String username,String password)</span></span>;
                &#125;
                
                <span class="hljs-comment">//------------------------</span>
                
                <span class="hljs-comment">//登录接口的实现类</span>
                <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Login</span></span>&#123;
                
                	<span class="hljs-meta">@Override</span>
                	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String username,String password)</span></span>&#123;
                		<span class="hljs-comment">//登录代码</span>
                	&#125;
                &#125; 
                
                <span class="hljs-comment">//------------------------</span>
                
                <span class="hljs-comment">//JDK动态代理类</span>
                <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Login</span></span>&#123;
                
                	<span class="hljs-comment">//权限校验功能</span>
                
                	<span class="hljs-meta">@Override</span>
                	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String username,String password)</span></span>&#123;
                		<span class="hljs-comment">//登录代码</span>
                	&#125;
                	
                	<span class="hljs-comment">//日志记录功能</span>
                &#125;</code></pre>
</li>
<li><p><code>CGLIB动态代理</code>：一般用于非接口的动态代理。既然用于非接口，那么肯定就是用于一个类，所以CGLIB的动态代理，就是继承了目标类而产生的动态代理类，当然，新产生的这个动态代理类中肯定也包含了基本功能和增强功能；</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>JDK动态代理具体实现：</p>
<ul>
<li><p>如上面原理所说，JDK动态代理就是让系统实时的帮你创建一个类，然后该类中实现类你想要的基本功能以及增强功能。当然，实际的动态代理不可能两行代码搞定，所以我们需要手动创建JDK动态代理来学习动态代理的实现；</p>
</li>
<li><p>首先，JDK动态代理要使用到一个类：Proxy，这个类就是动态代理类，该类有以下方法：</p>
<ul>
<li>protected Proxy(InvocationHandler h)：构造函数，用于给内部的h赋值；</li>
</ul>
</li>
<li><p>static Class getProxyClass (ClassLoaderloader, Class[] interfaces)：获得一个代理类，其中loader是类加载器，interfaces是目标类所拥有的全部接口的class的数组；</p>
</li>
<li><p>static Object newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)：返回代理类生成的一个对象；前两个参数我们都了解过了，第三个参数就是你想要的增强的功能所在的对象(意思就是把增强的功能放到了h对象里)，但InvocationHandler是一个接口，所以我们需要创建一个InvocationHandler接口的实现类才能使用。</p>
</li>
</ul>
</li>
<li><p>然后，创建InvocationHandler接口的实现类；该接口要重写一个invoke方法，即<code>invoke(Object obj,Method method, Object[] args)</code>；</p>
<pre><code>-   obj：一般是指被代理类的真正对象；</code></pre><ul>
<li><p>method：是被代理类所拥有的方法；</p>
<ul>
<li>args：被代理类的方法的参数数组。</li>
</ul>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;
        
        <span class="hljs-comment">//这个就是我们要代理的真正的对象</span>
        <span class="hljs-keyword">private</span> Object obj;
     
    
        <span class="hljs-comment">//构造方法，给我们要代理的真实对象赋初值</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InvocationHandlerImpl</span><span class="hljs-params">(Object obj)</span></span>&#123;
            <span class="hljs-keyword">this</span>.obj = obj;
        &#125;
    
        <span class="hljs-comment">//在这个方法里写如增强的功能，以及调用被代理类的基本功能</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable</span>&#123;
            
            <span class="hljs-comment">//在调用代理的真正对象的基本功能前，我们可以添加一些自己的操作，也就是增强功能1</span>
            System.out.println(<span class="hljs-string">"这是基本功能前的增强功能"</span>);
     
            System.out.println(<span class="hljs-string">"Method:"</span> + method);
     
            <span class="hljs-comment">//调用被代理的真正对象中的方法</span>
            Object res = method.invoke(obj, args);
     
            <span class="hljs-comment">//增强功能2</span>
            System.out.println(<span class="hljs-string">"这是基本功能后的增强功能"</span>);
     
            <span class="hljs-keyword">return</span> res;
        &#125;
    &#125;</code></pre>
</li>
</ul>
</li>
<li><p>之后，调用Proxy类中的newProxyInstance()方法，生成动态代理类的一个对象；最后生成测试类，测试。</p>
<pre><code><pre><code class="hljs java"><span class="hljs-comment">//登录接口</span>
    <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Login</span></span>&#123;
    	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String username,String password)</span></span>;
    &#125;
    
    <span class="hljs-comment">//------------------------</span>
    
    <span class="hljs-comment">//登录接口的实现类，也就是需要被代理的类</span>
    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Login</span></span>&#123;
    
    	<span class="hljs-meta">@Override</span>
    	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String username,String password)</span></span>&#123;
    		System.out.println(<span class="hljs-string">"登录成功"</span>);
    	&#125;
    &#125; 
    
    <span class="hljs-comment">//---------------------------</span>
    
    <span class="hljs-comment">//JDK动态代理类</span>
    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyProxy</span></span>&#123;
    
    	<span class="hljs-comment">//被代理类所实现的接口的Class对象数组</span>
    	<span class="hljs-keyword">private</span> Class[] interfaces;
    	
    	<span class="hljs-comment">//被代理类想要增强的功能所在的代理类</span>
    	<span class="hljs-keyword">private</span> InvocationHandler h;
    
    	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyProxy</span><span class="hljs-params">(Class[] interfaces,InvocationHandler h)</span></span>&#123;
    		<span class="hljs-keyword">this</span>.interfaces = interfaces;
    		<span class="hljs-keyword">this</span>.h = h;
    	&#125;
    
    	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-keyword">static</span> <span class="hljs-title">getTargetProxy</span><span class="hljs-params">()</span></span>&#123;
            
    		<span class="hljs-comment">//调用Proxy类中的newProxyInstance()方法</span>
    		Proxy.newProxyInstance(
    			MyProxy<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getClassLoader</span>(),</span>
<span class="hljs-class">    			<span class="hljs-title">interfaces</span>,</span>
<span class="hljs-class">    			<span class="hljs-title">h</span></span>
<span class="hljs-class">    		)</span>;
    	&#125;
    &#125; 
    
    <span class="hljs-comment">//---------------------------</span>
    
    <span class="hljs-comment">//测试类</span>
    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span></span>&#123;
        
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;
            
            <span class="hljs-comment">//这个是需要被代理的对象</span>
            LoginImpl myLogin = <span class="hljs-keyword">new</span> LoginImpl();
            
            <span class="hljs-comment">//这个是需要被代理的对象，其类所实现的接口</span>
            Class[] interfaces = &#123;Login<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;</span>;
            
            <span class="hljs-comment">//先创建一个Handler对象，该类实现了接口InvocationHandler</span>
            Handler hand = <span class="hljs-keyword">new</span> Handler(myLogin);
            
            <span class="hljs-comment">//创建MyProxy类，生成代理类对象</span>
            Login mp = (Login)<span class="hljs-keyword">new</span> MyProxy(hand, interfaces);
            
            <span class="hljs-comment">//调用登录方法</span>
            mp.login(“dyf”,<span class="hljs-string">"666"</span>);
        &#125;
    &#125;
    
    输出结果：
    这是基本功能前的增强功能
    login
    登录成功
    这是基本功能后的增强功能</code></pre></code></pre></li>
</ul>
</li>
<li><p>AOP中的概念：</p>
<ul>
<li><p><code>Joinpoint</code>：连接点，其实就是方法，意思就是理论上只要是个方法都可以被增强；</p>
</li>
<li><p><code>Pointcut</code>：切入点，即在实际开发中，实际被增强了的方法，则该方法就是切入点；</p>
</li>
<li><p><code>Advice</code>：通知或者增强，即对被增强的方法，加入想要增强的代码，这部分代码就是通知或者增强；</p>
<ul>
<li><p><code>前置通知(使用@before注解)</code>：在连接点前面执行，前置通知不会影响连接点的执行，除非此处抛出异常；</p>
</li>
<li><p><code>后置通知(使用@after-returning注解)</code>：在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行；</p>
</li>
<li><p><code>最终通知(使用@after注解)</code>：在连接点执行完成后执行，不管是正常执行完成，还是抛出异常，都会执行最终通知中的内容；</p>
</li>
<li><p><code>异常通知</code>：在连接点抛出异常后执行(使用@after-throwing注解)；</p>
</li>
<li><p><code>环绕通知(使用@around注解)</code>：环绕通知围绕在连接点前后。这是最强大的通知类型，能在方法调用前后自定义一些操作；环绕通知还需要负责决定是继续处理join point(调用ProceedingJoinPoint的proceed方法)还是中断执行。</p>
<p><img src="./Image-ssm3.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-ssm4.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
<li><p><code>Introduction</code>：引介，即类层面的增强，往类里面添加新的属性、新的方法等；</p>
</li>
<li><p><code>Target</code>：被增强的对象；</p>
</li>
<li><p><code>Weaving</code>：织入，即将想要增强的代码应用到目标对象的过程；</p>
</li>
<li><p><code>proxy</code>：代理对象，即增强后所产生的代理类对象；</p>
</li>
<li><p><code>Aspect</code>：切面，即多个通知和多个切入点的组合；</p>
</li>
</ul>
</li>
<li><p>AOP开发，包括两种方式：</p>
<ul>
<li><p>与XML方式：</p>
<ul>
<li><p>创建项目后，导入跟AOP和IOC相关的JAR包或依赖；</p>
</li>
<li><p>编写切面类，即编写一个普通类，里面定义切入点和通知；</p>
<pre><code><pre><code class="hljs java"><span class="hljs-comment">//这就是切面类，里面包含了增强的功能方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspectXML</span></span>&#123;
    
        <span class="hljs-comment">//切入点</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">anyMethod</span><span class="hljs-params">()</span></span>&#123;&#125;
    
        <span class="hljs-comment">//前置通知：可以获得切入点信息，增强方法需要JoinPoint类型的参数joinPoint，就是会把目标对象方法的一些信息封装到这个对象里面，供你使用</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeTest</span><span class="hljs-params">(JoinPoint joinPoint)</span></span>&#123;
    
            System.out.println(<span class="hljs-string">"前置-----权限校验"</span>+joinPoint);
        &#125;
    
        <span class="hljs-comment">//后置通知：可以通过AOP配置里的属性：returning获得方法返回值；</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterTest</span><span class="hljs-params">(Object result)</span></span>&#123;
    
            System.out.println(<span class="hljs-string">"后置-----记录运行日志"</span>+result);
        &#125;
    
        <span class="hljs-comment">//最终通知，无论是否会发生异常，都会执行的通知</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finallyTest</span><span class="hljs-params">()</span></span>&#123;
    
            System.out.println(<span class="hljs-string">"最终-----通知运行完毕"</span>);
        &#125;
    
        <span class="hljs-comment">//异常通知：可以通过AOP配置里的属性：throwing属性获得异常的返回信息，并将其封装到了ex这个变量中；</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceTest</span><span class="hljs-params">(Exception ex)</span></span>&#123;
    
            System.out.println(<span class="hljs-string">"异常-----出现异常了"</span>+ex);
        &#125;
    
        <span class="hljs-comment">//环绕通知：该通知必须返回Object，增强方法需要参数ProceedingJoinPoint，并用该类的对象调用proceed()方法代执行目标方法</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">roundTest</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span></span>&#123;
    
            System.out.println(<span class="hljs-string">"环绕-----测试1"</span>);
    
            <span class="hljs-keyword">try</span>&#123;
            
                <span class="hljs-comment">//代执行目标方法，且有可能目标方法有返回值，用Object接收</span>
                Object obj = joinPoint.proceed();
    
            &#125; <span class="hljs-keyword">catch</span> (Throwable e)&#123;
                e.printStackTrance();
            &#125;
    
            System.out.println(<span class="hljs-string">"环绕-----测试2"</span>);
        &#125;
    &#125;</code></pre></code></pre></li>
<li><p>在applicationContext.xml中，通过AOP标签的配置完成对目标类产生代理；</p>
<ul>
<li><p>首先，添加AOP的XML配置根标签：<code>&lt;aop:config&gt;</code>，表示要对AOP进行配置；</p>
<pre><code><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>
    	<span class="hljs-comment">&lt;!--所有的AOP配置均在该标签下完成--&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre></code></pre></li>
<li><p>其次，在AOP根标签中，添加标签：<code>&lt;aop:pointcut&gt;</code>，表示要给哪些方法进行增强；可以定义多个该标签，以满足业务逻辑需要；</p>
<pre><code><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>
    
    	<span class="hljs-comment">&lt;!--该标签配置的是哪些方法需要进行增强--&gt;</span>
    	<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> </span>
<span class="hljs-tag">    		<span class="hljs-attr">expression</span>=<span class="hljs-string">"切入点表达式"</span></span>
<span class="hljs-tag">            <span class="hljs-attr">id</span>=<span class="hljs-string">"切入点id"</span> /&gt;</span>
            
    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre></code></pre><ul>
<li><p><code>&lt;aop:pointcut&gt;</code>标签解析：</p>
<ul>
<li><p><code>expression</code>：该属性表示需要写入一个切入点表达式，用于指定具体要增强的方法；基本语法格式：</p>
<pre><code class="hljs java">expression([权限修饰符] 方法返回值 包名路径.类名.方法名(参数))
        
    说明：
    一、权限修饰符我们一般都写*，即任意权限修饰符；
    
    二、方法返回值可以省略不写，也可以写*，即不管你方法有没有返回值；
        
    三、参数一般用..代替，即表示任意参数；返回值用*，表示任意返回值；</code></pre>
</li>
<li><p><code>id</code>：即切入点的id，用于通知标签中的<code>pointcut-ref</code>属性；也就是说，到时候增强会根据这个id来找到需要增强的方法；</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>然后，仍然在AOP根标签中，添加标签：<code>&lt;aop:aspect&gt;</code>，表示增强方法的具体配置，即增强的功能都在这里面进行详细配置；</p>
<pre><code><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>
    
    	<span class="hljs-comment">&lt;!--该标签配置的是哪些方法需要进行增强--&gt;</span>
    	<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> </span>
<span class="hljs-tag">    		<span class="hljs-attr">expression</span>=<span class="hljs-string">"切入点表达式"</span></span>
<span class="hljs-tag">            <span class="hljs-attr">id</span>=<span class="hljs-string">"切入点id"</span> /&gt;</span>


​    
​    	<span class="hljs-comment">&lt;!--该标签是给上面需要增强的方法，配置使用哪种增强的功能--&gt;</span>
​    	<span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"切面类的引用"</span>&gt;</span>
​    
​            <span class="hljs-comment">&lt;!--前置通知标签，增强的功能在目标方法之前触发，</span>
<span class="hljs-comment">​              可以获得切入点信息(增强方法需要参数JoinPoint)--&gt;</span>
​            <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> </span>
<span class="hljs-tag">​            	<span class="hljs-attr">method</span>=<span class="hljs-string">"切面类中增强方法的名称"</span> </span>
<span class="hljs-tag">​            	<span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">"上面切入点的id"</span> /&gt;</span>
​    
            <span class="hljs-comment">&lt;!--后置通知标签，可以通过returning属性获得方法返回值--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-returning</span> </span>
<span class="hljs-tag">            	<span class="hljs-attr">method</span>=<span class="hljs-string">"切面类中增强方法的名称"</span> </span>
<span class="hljs-tag">            	<span class="hljs-attr">pointcut</span>=<span class="hljs-string">"expression表达式"</span> </span>
<span class="hljs-tag">            	<span class="hljs-attr">returning</span>=<span class="hljs-string">"result"</span> /&gt;</span>
    
            <span class="hljs-comment">&lt;!--环绕通知(增强方法需要参数ProceedingJoinPoint，</span>
<span class="hljs-comment">            并用该类的对象调用proceed()方法代执行目标方法)--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">aop:around</span> </span>
<span class="hljs-tag">            <span class="hljs-attr">method</span>=<span class="hljs-string">"切面类中增强方法的名称"</span> </span>
<span class="hljs-tag">            <span class="hljs-attr">pointcut</span>=<span class="hljs-string">"expression表达式"</span> /&gt;</span>
    
            <span class="hljs-comment">&lt;!--最终通知，无论是否有异常，都会执行通知里面的代码--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> </span>
<span class="hljs-tag">            <span class="hljs-attr">method</span>=<span class="hljs-string">"切面类中增强方法的名称"</span> </span>
<span class="hljs-tag">            <span class="hljs-attr">pointcut</span>=<span class="hljs-string">"expression表达式"</span> /&gt;</span>
    
            <span class="hljs-comment">&lt;!--异常通知，出现异常时，会执行异常通知里面的代码，</span>
<span class="hljs-comment">            通过throwing属性获取异常的信息--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-throwing</span> </span>
<span class="hljs-tag">            <span class="hljs-attr">method</span>=<span class="hljs-string">"切面类中增强方法的名称"</span> </span>
<span class="hljs-tag">            <span class="hljs-attr">pointcut</span>=<span class="hljs-string">"expression表达式"</span> </span>
<span class="hljs-tag">            <span class="hljs-attr">throwing</span>=<span class="hljs-string">"ex"</span>/&gt;</span>
    
        <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre>
-   `&lt;aop:aspect&gt;`标签解析：</code></pre><ul>
<li>ref：该属性用于切面类的引入，即告知Spring，你写的切面类放在哪个位置；一般切面类交给Spring管理后，只需要写bean的id就行，@Component注解生成bean的id一般为类名的首字母小写。</li>
</ul>
</li>
</ul>
<pre><code class="hljs xml">注意：<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> /&gt;</span>这个就是配置切入点的标签，该标签中：expression表达式，是指需要为满足该表达式下的方法们进行增强；id属性，是指为这些需要增强的方法名创建一个切面id；

<span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> /&gt;</span>这个就是配置切面类的标签，标签中：ref属性，是指切面类的类名；

<span class="hljs-tag">&lt;<span class="hljs-name">aop:通知类型</span> /&gt;</span>这个就是配置通知类型，标签中：method属性，是指切面类中，具体的增强方法的方法名；pointcut-ref属性，是指给哪些需要增强的方法进行增强，即切入点的id；</code></pre>
</li>
</ul>
</li>
<li><p>AOP开发(注解方式，推荐该方式)：</p>
<ul>
<li><p>编写目标类(也就是需要被增强的类)并在applicationContext.xml中配置，交给Spring管理，即在目标类上添加@Component注解；</p>
</li>
<li><p>编写切面类(即包含增强功能和切入点的类)并在applicationContext.xml中配置，交给Spring管理，即在切面类上添加@Component注解；</p>
</li>
<li><p>在applicationContext.xml中，开启AOP注解开发，使用标签：</p>
<pre><code><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--该标签就表示开启AspectJ的自动代理功能--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span> /&gt;</span></code></pre></code></pre></li>
<li><p>再在切面类上添加切面注解：@Aspect，Spring会自动识别该注解，并将该注解下注明的类认为是切面类；<strong><code>注意：如果有多个切面，有默认的先后执行顺序；但是可以用@Order(num)定义优先级，num越小，也就是数字越小(但不能为负数)，优先级越高。</code></strong></p>
</li>
<li><p>在增强方法上配置通知类型注解：</p>
<pre><code><pre><code class="hljs java"><span class="hljs-meta">@Before</span>(value=<span class="hljs-string">"execution(* com.dyf.CustomerDao.*(..))"</span>)
    <span class="hljs-keyword">public</span> ..... &#123;  <span class="hljs-comment">//这里是增强功能</span>
        ....
    &#125;</code></pre></code></pre></li>
<li><p>另外，还可以提取一个公共切入点，公共切入点的注解格式：</p>
<ul>
<li><p>基本语法格式：</p>
<pre><code><pre><code class="hljs java"><span class="hljs-meta">@Pointcut</span>(value=<span class="hljs-string">"execution(* com.dyf.CustomerDao.*(..)"</span>)
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pointcut</span><span class="hljs-params">()</span></span>&#123;
        ...
    &#125;</code></pre></code></pre></li>
<li><p>而增强方法上注解则变成：@Before(value=”切面类名.切入点名”)，即可；</p>
</li>
<li><p><code>@pointcut</code>注解的实质是：将某一类需要增强的方法们，放在了一个@Pointcut注解标记的方法上；然后，当这类方法需要不同的通知时，只需修改通知上调用的@Pointcut方法即可；</p>
<pre><code><pre><code class="hljs java"><span class="hljs-comment">//这是通知和切点紧密联系在一起</span>
    <span class="hljs-meta">@Before</span>(value = <span class="hljs-string">"execution(* com.dyf.Dao.*(..))"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;
    
        System.out.println(<span class="hljs-string">"我是前置通知！"</span>);
    &#125;
    
    <span class="hljs-comment">//=========================================================</span>
    
    <span class="hljs-comment">//定义切点1</span>
    <span class="hljs-meta">@Pointcut</span>(value = <span class="hljs-string">"execution(* com.dyf.Dao.update())"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyPoint1</span><span class="hljs-params">()</span></span>&#123;&#125;
    
    <span class="hljs-comment">//定义切点2</span>
    <span class="hljs-meta">@Pointcut</span>(value = <span class="hljs-string">"execution(* com.dyf.Dao.delete())"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Mypoint2</span><span class="hljs-params">()</span></span>&#123;&#125;
    
    <span class="hljs-comment">//---------------------------------------------------------</span>
    
    <span class="hljs-comment">//AfterReturning通知有返回值，使用returning来接受返回值</span>
    <span class="hljs-meta">@AfterReturning</span>(value = <span class="hljs-string">"Mypoint2()"</span>,returning = <span class="hljs-string">"element"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">After</span><span class="hljs-params">(Object element)</span></span>&#123;
    
        <span class="hljs-comment">//打印输出了返回值</span>
        System.out.println(<span class="hljs-string">"我删除了"</span>+element);
    &#125;
    
    <span class="hljs-meta">@Around</span>(value=<span class="hljs-string">"MyPoint1()"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span></span>&#123;
    
        Object obj=<span class="hljs-keyword">null</span>;
    
        System.out.println(<span class="hljs-string">"环绕前"</span>);
    
        <span class="hljs-keyword">try</span> &#123;
    
            obj=joinPoint.proceed();
    
        &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;
    
            throwable.printStackTrace();
    
        &#125;
    
        System.out.println(<span class="hljs-string">"环绕后"</span>);
    
        <span class="hljs-keyword">return</span> obj;
    &#125;</code></pre></code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO1-4-Jdbc-Template"><a href="#NO1-4-Jdbc-Template" class="headerlink" title="NO1.4 Jdbc Template"></a>NO1.4 Jdbc Template</h3><p>Jdbc Template其实是Spring框架对JDBC的封装。</p>
<ul>
<li><p>JDBC Template：</p>
<ul>
<li><p>使用Jdbc模板操作数据库：</p>
<ul>
<li><p>创建项目，并导入数据库JAR包或依赖；然后创建连接池(druid连接池、C3P0连接池、JDBC内置连接池均可)，获取连接池对象；一般的，有关连接池之类的属性，我们会放在单独的属性文件中，这时就需要在Spring中引入属性文件；<strong><code>注意：该步骤可以交给Spring管理。</code></strong></p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--使用该标签引用数据库的属性文件--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:jdbc.properties"</span>&gt;</span>
    
//---------------------------------------------    

<span class="hljs-comment">&lt;!--交给Spring管理--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"连接池变量名"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"连接池类的全包名路径"</span>&gt;</span>

    <span class="hljs-comment">&lt;!--在其中注入数据库的四大要素：驱动、url、账号、密码即可--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClassName"</span> </span>
<span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.driverClassName&#125;"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.url&#125;"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.username&#125;"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.password&#125;"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
</li>
<li><p>创建Jdbc模板；<strong><code>注意：该步骤可以交给Spring管理。</code></strong></p>
<pre><code class="hljs xml">原本需要自己写：
JdbcTemplate jdbcTemplate = new JdbcTemplate(连接池对象);

//--------------------------------------------------------------------

<span class="hljs-comment">&lt;!--交给Spring管理--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jdbc模板的变量名"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"jdbc模板类的全包名路径"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"连接池对象名"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"需要注入的真正连接池对象"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
    
注意：这里jdbc模板类的全包名路径一般为：org.springframework.jdbc.core.JdbcTemplate</code></pre>
</li>
<li><p>JdbcTemple中常用方法语句；</p>
<pre><code class="hljs java">增删改：
jdbcTemplate.update(sql语句,可变参数);

如：
String sql = <span class="hljs-string">"insert into emp values(null,?,?,?)"</span>;
jdbcTemplate.update(sql,<span class="hljs-string">"邓先森"</span>,<span class="hljs-number">27</span>,<span class="hljs-string">"男"</span>);

<span class="hljs-comment">//------------------------------------------------------------</span>

查询：
jdbcTemplate.queryForObject(sql语句,RowMapper&lt;T&gt;接口的实现类对象,可变参数);

String sql = <span class="hljs-string">"select eid,ename,age,sex from emp"</span>;

RowMapper&lt;Emp&gt; rowMapper = <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Emp<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

List&lt;Emp&gt; list = jdbcTemplate.update(sql,rowMapper);

<span class="hljs-comment">//遍历list</span>
....

说明：常用查询方法：
一、<span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">queryForObject</span><span class="hljs-params">(String sql, Class&lt;T&gt; requiredType)</span>：执行sql查询语句，返回一个指定类型的数据，即方法中第二个参数就是知道返回值的类型</span>
<span class="hljs-function"></span>
<span class="hljs-function">二、<span class="hljs-keyword">public</span> T <span class="hljs-title">queryForObject</span><span class="hljs-params">(String sql, RowMapper&lt;T&gt; rm, Object... args)</span>：执行查询语句，返回一个指定类型的对象</span>
<span class="hljs-function">    </span>
<span class="hljs-function">三、<span class="hljs-keyword">public</span> List&lt;T&gt; <span class="hljs-title">query</span><span class="hljs-params">(String sql, RowMapper&lt;T&gt; rm, Object... args)</span>：执行查询语句，返回一个集合  </span>
<span class="hljs-function">    </span>
<span class="hljs-function">四、<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">batchUpdate</span><span class="hljs-params">(String sql,List&lt;Object[]&gt; args)</span>：批量操作，一般做批量添加操作较多；第二个参数为批量添加的多个记录数组</span></code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO1-5-事务"><a href="#NO1-5-事务" class="headerlink" title="NO1.5 事务"></a>NO1.5 事务</h3><p>大家所了解的事务(Transaction)，它是一些列严密的操作，要么操作都完成，要么操作都回滚撤销。</p>
<ul>
<li><p>Spring事务：</p>
<ul>
<li><p>定义：就是逻辑上一组操作，要么都成功，要么都失败，不存在一半成功，一半失败。另外Spring的事务管理是基于底层数据库本身的事务处理机制。数据库事务的基础，是掌握Spring事务管理的基础；</p>
</li>
<li><p>事务的ACID四种特性：ACID是Atomic(原子性)、Consistency(一致性)、Isolation(隔离性)和Durability(持久性)的英文缩写；</p>
<ul>
<li><code>原子性(Atomicity)</code>：事务最基本的操作单元，要么全部成功，要么全部失败，不会结束在中间某个环节；事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样；</li>
<li><code>一致性(Consistency)</code>：指的是在一个事务执行之前和执行之后，数据库都必须处于一个正确的状态，什么叫正确的状态呢，就是满足预订的约束就叫做正确的状态。<strong><code>如，如果事务成功地完成，那么系统中所有变化将正确地应用，此时数据库就处于正确的状态；如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态，这时数据库也是正确的状态，也就是说，要么不改变，要么按照开发者的要求进行改变，这就是正确的状态。</code></strong></li>
<li><code>隔离性(Isolation)</code>：指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间；由并发事务所做的修改必须与任何其他并发事务所做的修改隔离；事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据；</li>
<li><code>持久性(Durability)</code>：指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来；即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态；</li>
</ul>
</li>
<li><p>Spring中事务的两种实现方式：</p>
<ul>
<li><p>编程式事务管理(了解)；</p>
<ul>
<li><p>在Spring中配置平台事务管理器；</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"事务管理器的名称"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"事务管理器类全包名路径"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"连接池名"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"连接池bean对象的id"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
</li>
<li><p>配置事务管理的模板类；</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"事务管理模板的名称"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"事务管理模板类的全包名路径"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"事务管理器的名称"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"事务管理器bean对象id"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
</li>
<li><p>在Service层添加事务模板对象，并调用方法：</p>
<pre><code class="hljs java">transactionTemplate.execute(
    <span class="hljs-keyword">new</span> TransactionCallbackWithoutResult()&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInTransactionWithoutResult</span><span class="hljs-params">(TransactionStatus arg0)</span></span>&#123;


        这里放入需要加入事务的代码体；

    &#125;
&#125;);</code></pre>
</li>
</ul>
</li>
<li><p>声明式事务管理(推荐)；</p>
<ul>
<li><p>XML文件形式：</p>
<ul>
<li><p>在Spring中配置平台事务管理器；</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置事务管理器--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"事务管理器的名称"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"事务管理器类全包名路径"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"连接池名"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"连接池bean对象的id"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
</li>
<li><p>添加事务名称空间，然后配置事务的属性；</p>
<pre><code class="hljs xml">//先添加这个
xmlns:tx="http://www.springframework.org/schema/tx

//后添加这个
http://www.springframework.org/schema/tx 
http://www.springframework.org/schema/tx/spring-tx.xsd

//----------------------------------------------

<span class="hljs-comment">&lt;!--配置事务属性--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> </span>
<span class="hljs-tag">	<span class="hljs-attr">id</span>=<span class="hljs-string">"事务的id"</span> </span>
<span class="hljs-tag">	<span class="hljs-attr">transactions-manager</span>=<span class="hljs-string">"事务管理器对象id"</span>&gt;</span>

    <span class="hljs-comment">&lt;!--确定哪些方法需要使用事务功能之后，再用这个标签进一步细分到每一个要使用事务功能的方法上&gt;</span>
<span class="hljs-comment">    &lt;tx:attributes&gt;</span>
<span class="hljs-comment">        &lt;tx:method name="需要使用事务的方法"&gt;</span>
<span class="hljs-comment">    &lt;tx:attributes&gt;</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">&lt;/tx:advice&gt;</span></code></pre>
</li>
<li><p>配置事务的切入点，以及把事务和切入点关联起来；</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置事务切入点，以及把事务切入点和事务关联起来--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>

    <span class="hljs-comment">&lt;!--配置事务切入点，就是告诉Spring哪些方法需要使用事务--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> </span>
<span class="hljs-tag">      <span class="hljs-attr">expression</span>=<span class="hljs-string">"execution(切入点表达式)"</span> </span>
<span class="hljs-tag">      <span class="hljs-attr">id</span>=<span class="hljs-string">"切入点id，自定义"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!--把需要使用事务功能的方法和切入点关联起来，也就是说&lt;aop:pointcut&gt;这个标签下表示大概有哪些方法要用事务，&lt;tx:advice&gt;这个标签则在&lt;aop:pointcut&gt;标签的范围下具体确定哪些方法要使用事务功能，然后把这两者关联起来的意思--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advicor</span> </span>
<span class="hljs-tag">     <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">"&lt;tx:advice&gt;标签的id"</span> </span>
<span class="hljs-tag">     <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">"就上面这个id，意思是把增强的功能放到这个id上的方法里"</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre>
</li>
</ul>
</li>
<li><p>注解形式：</p>
<ul>
<li><p>在Spring中配置平台事务管理器；</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"事务管理器的名称"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"事务管理器类全包名路径"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"连接池名"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"连接池bean对象的id"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
</li>
<li><p>开启注解事务；</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"事务管理器对象"</span>&gt;</span></code></pre>
</li>
<li><p>在Service层上添加@Transactional注解即可开启事务。@Transactional注解解析：<strong><code>注意：如果该注解用在类上，则对类中所有方法都使用事务功能；用在方法上则只对该方法使用事务功能。</code></strong></p>
<ul>
<li><p><code>readOnly</code>：该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false；简单的说，就是设置为true之后，访问数据不会加锁，提高查询效率，但会只允许查询操作；</p>
<pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>(readOnly=<span class="hljs-keyword">true</span>)</code></pre>
</li>
<li><p><code>rollbackFor</code>：该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚；</p>
<pre><code class="hljs java">指定单一异常类：<span class="hljs-meta">@Transactional</span>(rollbackFor=RuntimeException<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>
<span class="hljs-class"></span>
<span class="hljs-class">指定多个异常类：</span>
<span class="hljs-class">@<span class="hljs-title">Transactional</span>(<span class="hljs-title">rollbackFor</span></span>=&#123;RuntimeException<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Exception</span>.<span class="hljs-title">class</span>&#125;)</span></code></pre>
</li>
<li><p><code>rollbackForClassName</code>：该属性用于设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚；</p>
<pre><code class="hljs java">指定单一异常类名称：<span class="hljs-meta">@Transactional</span>(rollbackForClassName=<span class="hljs-string">"RuntimeException"</span>)

指定多个异常类名称：
<span class="hljs-meta">@Transactional</span>(rollbackForClassName=&#123;<span class="hljs-string">"RuntimeException"</span>,<span class="hljs-string">"Exception"</span>&#125;)</code></pre>
</li>
<li><p><code>noRollbackFor</code>：该属性用于设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，不进行事务回滚；</p>
<pre><code class="hljs java">指定单一异常类：<span class="hljs-meta">@Transactional</span>(noRollbackFor=RuntimeException<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>
<span class="hljs-class"></span>
<span class="hljs-class">指定多个异常类：</span>
<span class="hljs-class">@<span class="hljs-title">Transactional</span>(<span class="hljs-title">noRollbackFor</span></span>=&#123;RuntimeException<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Exception</span>.<span class="hljs-title">class</span>&#125;)</span></code></pre>
</li>
<li><p><code>noRollbackForClassName</code>：该属性用于设置不需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，不进行事务回滚；</p>
<pre><code class="hljs java">指定单一异常类名称：<span class="hljs-meta">@Transactional</span>(noRollbackForClassName=<span class="hljs-string">"RuntimeException"</span>)

指定多个异常类名称：<span class="hljs-meta">@Transactional</span>(noRollbackForClassName=&#123;<span class="hljs-string">"RuntimeException"</span>,<span class="hljs-string">"Exception"</span>&#125;)</code></pre>
</li>
<li><p><code>propagation</code>：该属性用于设置事务的传播行为，具体取值可参考下一个小节；</p>
<pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>(propagation=Propagation.NOT_SUPPORTED,
readOnly=<span class="hljs-keyword">true</span>)</code></pre>
</li>
<li><p><code>isolation</code>：该属性用于设置底层数据库的事务隔离级别，事务隔离级别用于处理多事务并发的情况，通常使用数据库的默认隔离级别即可，基本不需要进行设置；</p>
</li>
<li><p><code>timeout</code>：该属性用于设置事务的超时秒数，即如果超过规定时间则进行事务回滚操作；默认值为-1表示永不超时。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Spring事务的传播行为：</p>
<ul>
<li><p>定义：指的就是当一个事务方法去调用另一个事务方法时，当前的事务方法应该如何进行；</p>
</li>
<li><p>Spring定义的七种传播行为：</p>
<ul>
<li><p><code>PROPAGATION_REQUIRED(常用)</code>：是指如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中；这是最常见的选择，也是Spring默认的传播行为；</p>
<pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>(propagation = Propagation.REQUIRED)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;
    
    methodB();

    <span class="hljs-comment">// do something</span>
&#125;

<span class="hljs-comment">// 事务属性为REQUIRED</span>
<span class="hljs-meta">@Transactional</span>(propagation = Propagation.REQUIRED)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span> </span>&#123;

    <span class="hljs-comment">// do something</span>
&#125;

说明：
一、单独调用methodB方法时，因为当前上下文不存在事务，所以会开启一个新的事务；
        
二、调用methodA方法时，因为当前上下文不存在事务，所以会开启一个新的事务；当执行到methodB时，methodB发现当前上下文有事务，因此就加入到当前事务中来。</code></pre>
</li>
<li><p><code>PROPAGATION_REQUIRES_NEW(常用)</code>：是指无论当前是否有事务，开启一个新的事务；如果当前有事务，则先将这个存在的事务挂起；</p>
<pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>(propagation = Propagation.REQUIRED)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;

	doSomeThingA();

	methodB();

	doSomeThingB();

	<span class="hljs-comment">// do something else</span>
&#125;

<span class="hljs-comment">// 事务属性为REQUIRES_NEW</span>
<span class="hljs-meta">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span> </span>&#123;

	<span class="hljs-comment">// do something</span>
&#125;

说明：
一、当单独调用methodB时，会创建新的事务；

二、当调用methodA，执行到methodB时，总是会单独给methodB创建一个新的事务，并挂起methodA的事务；当methodB执行完成后，回到methodA的事务中，无论methodA的事务是否成功，methodB的事务都不会受其影响(即该提交提交，该回滚回滚)，反过来，methodB事务也是一样的，也就是这两者的事务都不会互相干扰。</code></pre>
</li>
<li><p><code>PROPAGATION_SUPPORTS</code>：是指如果当前有事务，就加入当前事务，如果当前没有事务，就以非事务方式执行；</p>
<pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>(propagation = Propagation.REQUIRED)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;

    methodB();

    <span class="hljs-comment">// do something</span>
&#125;


<span class="hljs-comment">//事务属性为SUPPORTS</span>
<span class="hljs-meta">@Transactional</span>(propagation = Propagation.SUPPORTS)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span> </span>&#123;

    <span class="hljs-comment">// do something</span>
&#125;

说明：单纯的调用methodB时，methodB方法是非事务执行的；当调用methdA时，methodB则加入了methodA的事务中；</code></pre>
</li>
<li><p><code>PROPAGATION_NOT_SUPPORTED</code>：是指总是以非事务的方式执行，如果当前有事务，则挂起事务；</p>
<pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>(propagation = Propagation.REQUIRED)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;

    doSomeThingA();

    methodB();

    doSomeThingB();

    <span class="hljs-comment">// do something else</span>

&#125;

<span class="hljs-comment">// 事务属性为NOT_SUPPORTED</span>
<span class="hljs-meta">@Transactional</span>(propagation = Propagation.NOT_SUPPORTED)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span> </span>&#123;

    <span class="hljs-comment">// do something</span>
&#125;

说明：单独调用methodB，以非事务的状态执行；调用methodA，执行到methodB时，methodB以非事务的方式执行，并挂起methodA的事务，当methodB执行完成后，回到methodA中，继续执行methodA的事务</code></pre>
</li>
<li><p><code>PROPAGATION_MANDATORY</code>：是指如果当前有事务，则加入当前事务；如果没有事务，则抛出异常；即该传播行为，必须有事务；</p>
<pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>(propagation = Propagation.REQUIRED)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;

    methodB();

    <span class="hljs-comment">// do something</span>
&#125;


<span class="hljs-comment">// 事务属性为MANDATORY</span>
<span class="hljs-meta">@Transactional</span>(propagation = Propagation.MANDATORY)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span> </span>&#123;

    <span class="hljs-comment">// do something</span>
&#125;

说明：当单独调用methodB时，因为当前没有一个活动的事务，则会抛出异常<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalTransactionStateException，即不合法事务状态异常；当调用methodA时，methodB则加入到methodA的事务中</code></pre>
</li>
<li><p><code>PROPAGATION_NEVER</code>：是指总是以非事务的方式执行，如果当前有事务，则抛出异常；</p>
<pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>(propagation = Propagation.REQUIRED)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;

    methodB();

    <span class="hljs-comment">// do something</span>

&#125;

<span class="hljs-comment">// 事务属性为NEVER</span>
<span class="hljs-meta">@Transactional</span>(propagation = Propagation.NEVER)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span> </span>&#123;

    <span class="hljs-comment">// do something</span>

&#125;

说明：单独调用methodB时，以非事务的方式执行；调用methodA，执行到methodB时，发现当前有事务，则抛出异常；发现没有事务时，则继续执行；总之，就是不支持事务</code></pre>
</li>
<li><p><code>PROPAGATION_NESTED</code>：是指当前有事务，仍然创建事务后，并加入当前事务；没有事务则创建新的事务；但是，加入事务后，子事务失败并回滚，当前事务却不回滚；</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;

    doSomeThingA();

    methodB();

    doSomeThingB();

    <span class="hljs-comment">// do something else</span>

&#125;


<span class="hljs-comment">// 事务属性为NOT_NESTED</span>
<span class="hljs-meta">@Transactional</span>(propagation = Propagation.NESTED)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span> </span>&#123;

    <span class="hljs-comment">// do something</span>
&#125;

说明：单独调用methodB时，创建事务，按照事务的正常流程执行；调用methodA，执行到methodB时，methodB会创建一个事务，成功则提交，失败则回滚；无论methodB事务是哪种结果，都不会影响methodA的事务结果</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>事务的安全性问题与隔离级别：</p>
<ul>
<li><p>安全性问题：</p>
<ul>
<li><p>定义：如果不考虑事务的隔离性，那么将产生安全性问题；</p>
</li>
<li><p>种类：</p>
<ul>
<li><p>脏读：是指一个事务读到另一个事务还没有提交的数据；</p>
<pre><code class="hljs java">事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据；</code></pre>
</li>
<li><p>不可重复读：是指一个事务读到另一个事务已经提交的update数据，导致在当前事务中多次查询的结果不一致；</p>
<pre><code class="hljs java">事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致；</code></pre>
</li>
<li><p>虚读/幻读：是指一个事务读到另一个事务已经提交的insert数据，导致在当前事务中多次查询的结果不一致；</p>
<pre><code class="hljs java">系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读；</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>隔离级别：</p>
<ul>
<li><p>定义：为了解决事务的安全性问题而提出的解决方法；</p>
</li>
<li><p>种类：</p>
<ul>
<li><p><code>READ-UNCOMMITTED(读取未提交)</code>：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读；</p>
</li>
<li><p><code>READ-COMMITTED(读取已提交)</code>：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生；</p>
</li>
<li><p><code>REPEATABLE-READ(可重复读)</code>：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生；</p>
</li>
<li><p><code>SERIALIZABLE(可串行化)</code>：最高的隔离级别，完全服从ACID的隔离级别；所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读；</p>
<p><img src="./Image-ssm5.png" srcset="/img/loading.gif" alt="Image"></p>
<p><code>说明：Y代表可能发生，N代表不会发生。</code></p>
<pre><code class="hljs java">拓展：MySQL和Oracle的事务处理级别
一、MySQL默认的事务处理级别是<span class="hljs-string">'REPEATABLE-READ'</span>,也就是可重复读；

二、Oracle默认系统事务隔离级别是READ COMMITTED,也就是读已提交；Oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别。</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;</p>
<p>&nbsp;</p>
<h2 id="Lesson2-MyBatis框架"><a href="#Lesson2-MyBatis框架" class="headerlink" title="Lesson2 MyBatis框架"></a>Lesson2 MyBatis框架</h2><h3 id="NO2-1-全局配置文件与映射文件"><a href="#NO2-1-全局配置文件与映射文件" class="headerlink" title="NO2.1 全局配置文件与映射文件"></a>NO2.1 全局配置文件与映射文件</h3><p>MyBatis是dao的框架。</p>
<ul>
<li><p>MyBatis框架：</p>
<ul>
<li><p>定义：是持久层的框架，对JDBC操作数据库的过程进行了封装，是一个半自动ORM框架；</p>
</li>
<li><p>核心文件：MyBatis全局配置文件和映射文件；</p>
<ul>
<li><p>MyBatis核心配置文件：自定义名称即可，但一般定义为<code>sqlMapConfig.xml</code>或者<code>mybatis-config.xml</code>。可以用来配置连接数据库的环境，以及配置要使用的POJO类的映射文件；</p>
<ul>
<li><p>创建一个xml文件，并引入MyBatis全局配置文件的文件头；</p>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span>
<span class="hljs-meta">  <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span>
<span class="hljs-meta">  <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
	<span class="hljs-comment">&lt;!--在这里面进行MyBatis框架的配置--&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>
</li>
<li><p>由于MyBatis是持久层的框架，也就是常常与数据库进行交互，所以常常要用到数据库连接池；</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入连接数据库所需要的“xxx.properties”资源配置文件--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"db.properties"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>

说明：
一、resource：该属性是指调用类路径下的资源文件；一般src下就是类路径，所以只有放入src下即可；

二、url：该属性是指调用网络路径下或磁盘路径下进行访问。

//------------------------------------------------------

<span class="hljs-comment">&lt;!--配置连接数据库的环境--&gt;</span>
<span class="hljs-comment">&lt;!--这个environments标签就是用于配置连接数据库的环境，可以配置多个，一般只配置一个；default属性是指，默认使用值为xxx作为连接数据库的环境--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"development"</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!--environment标签用于，配置某一个具体的数据库连接环境；id属性则是指这个配置环境的唯一标识，不能重复，以供environments标签使用--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"development"</span>&gt;</span>

        <span class="hljs-comment">&lt;!--配置事务管理，type属性有两个值：一个是JDBC，是指使用JDBC进行事务管理；二是使用MANAGED，是指谁能够管理事务就让谁来管理--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span> /&gt;</span>

        <span class="hljs-comment">&lt;!-- 配置数据库连接信息，type属性有三个值：POOLED(指使用MyBatis自带的数据库连接池)、UNPOOLED(不使用数据库连接池)、JNDI(使用JNDI实现的数据源，该方式用的比较少) --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.driver&#125;"</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.url&#125;"</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.name&#125;"</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.password&#125;"</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>

    <span class="hljs-comment">&lt;!--第二个连接数据库的环境配置--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"connectB"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span> /&gt;</span>

        <span class="hljs-comment">&lt;!-- 配置数据库连接信息 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.driver&#125;"</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.url&#125;"</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.name&#125;"</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.password&#125;"</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span></code></pre>
</li>
<li><p>映射文件配置；</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入要使用的映射文件，即告诉MyBatis这是一个映射文件--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"即xxxMapper.xml文件"</span>/&gt;</span>

    <span class="hljs-comment">&lt;!--还可以使用package标签集体引入某一个包下的xxxMapper.xml文件，但是要求xxxMapper.xml文件和对应接口文件必须在同一个包下，所以我们一般把放这两个文件的包路径名都设置的是一样的，也就是说，这两种文件可以不需要紧挨在一起，只要包路径名相同即可--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cn.dyf.xxxMapper"</span> /&gt;</span>
     
<span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre>
</li>
<li><p>其他配置标签；</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 该标签用于全局设置某个属性。如，cacheEnabled属性(缓存是否可用)，mapUnderscoreToCamelCase属性(将数据库字段的下划线转换为驼峰命名)等等；</span>
<span class="hljs-comment">     常用的属性，一般配置lazyLoadingEnabled(是否执行懒加载)、aggressiveLazyLoading(是否查询所有数据)，这两个属性一般一起使用；</span>
<span class="hljs-comment"> --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"lazyLoadingEnabled"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"aggressiveLazyLoading"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"false"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 该标签用于为类型设置别名，type属性设置Java类型，如果只设置了type，默认的别名就是类型，且不区分大小写；alias属性就是为type的类型设置一个别名，这样在xml文件中就可以直接填入“u”，而不是“cn.dyf.domain.User”了 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"cn.dyf.domain.User"</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"u"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!--为该包路径下的所有类都设置别名，默认为类名小写，不区分大小写--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cn.dyf.domain"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span></code></pre>
</li>
</ul>
</li>
<li><p>MyBatis映射文件：一般自定义名称为xxxMapper.xml格式；其实映射文件就是Dao层中接口的实现类；另外，映射文件都要在核心配置文件中进行声明，也就是使用<code>&lt;mappers&gt;</code>标签，注册xxxMapper.xml文件，告诉MyBatis，这是映射文件；xxxMapper.xml文件中主要用标签的形式来书写sql语句；</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"这里填入，该映射文件对应的接口的全包名路径"</span>&gt;</span>

    <span class="hljs-comment">&lt;!--这是查询标签--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"接口中对应的方法名"</span> </span>
<span class="hljs-tag">            <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"参数的数据类型"</span> </span>
<span class="hljs-tag">            <span class="hljs-attr">resultType</span>=<span class="hljs-string">"结果的数据类型(如果是POJO类则填类的全包名路径)"</span>&gt;</span>

        这里写sql语句，一般占位符用#&#123;&#125;，特殊情况用$&#123;&#125;(这是连接符，详情看下个小节)

    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>

    <span class="hljs-comment">&lt;!--</span>
<span class="hljs-comment">            如果添加一条数据之后，立马需要查询该条记录的自增主键值，有两种方式：</span>
<span class="hljs-comment">            1.这是Oracle数据库使用，即没有自增主键的数据库使用，可以使用标签：</span>
<span class="hljs-comment">            &lt;selectKey resultType="返回值类型" keyProperty="返回值放入到POJO的哪个属性里" order="只有BEFORE和AFTER，即在sql语句之前获取或sql语句之后获取"&gt;&lt;/selectKey&gt;</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">            2.这是MySQl数据库使用，即有自增主键的数据库使用，直接在&lt;insert&gt;标签中，多添加两个属性即可，就是useGeneratedKeys(是否需要返回该条记录的自增主键值)和keyProperty(将该记录的主键值赋值到传过来的对象参数的哪个属性上)，返回的自增主键值就赋值在了你传过来的对象参数里你设定的某一个属性上，一般都设置为id属性：</span>
<span class="hljs-comment">            &lt;insert id="xxx" useGeneratedKeys="true" keyProperty="xxx"&gt;xxxx&lt;/insert&gt;</span>
<span class="hljs-comment">            </span>
<span class="hljs-comment">     --&gt;</span>

    <span class="hljs-comment">&lt;!--这是添加标签：&lt;insert&gt;内容参考上面的查询和普通sql语句&lt;/insert&gt;--&gt;</span>

    <span class="hljs-comment">&lt;!--这是修改标签：&lt;update&gt;内容参考上面的查询和普通sql语句&lt;/update&gt;--&gt;</span>

    <span class="hljs-comment">&lt;!--这是删除标签：&lt;delete&gt;内容参考上面的查询和普通sql语句&lt;/delete&gt;--&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre>

<ul>
<li><p>测试代码；</p>
<pre><code class="hljs java"><span class="hljs-comment">//获得能够创建sqlSessionFactory的工程师对象</span>
SqlSessionFactoryBuilder builder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();

<span class="hljs-comment">//从全局配置文件sqlMapConfig.xml中获得工厂的图纸</span>
InputStream factoryMap = Resources.getResourceAsStream(<span class="hljs-string">"sqlMapConfig.xml"</span>);

<span class="hljs-comment">//创建sqlSessionFactory工厂</span>
SqlSessionFactory sqlSessionFactoyr = builder.buil(factoryMap);

<span class="hljs-comment">//获得sqlSession对象，openSession()方法还可以多添加一个“true”参数，即自动提交事务    </span>
sqlSession sqlSession = sqlSessionFactory.openSession();

<span class="hljs-comment">//操作语句，根据sqlSession获得接口的代理实现对象；</span>
接口名 mapper = sqlSession.getMapper(需要代理的接口的<span class="hljs-class"><span class="hljs-keyword">class</span>文件，即：<span class="hljs-title">xxx</span>.<span class="hljs-title">class</span>)</span>;

<span class="hljs-comment">//操作方法</span>
mapper.方法();

<span class="hljs-comment">//提交事务</span>
sqlSession.commit();</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>映射文件中sql语句的占位符号：#{}和${}的区别；</p>
<ul>
<li><p><code>#{}</code>：将传入的数据都当成一个字符串，会对传入的数据自动加一个引号。#{}底层是使用的是PreparedStatement对象操作的SQL语句；</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span></span>&#123;
    queryUserById(<span class="hljs-keyword">int</span> id);  <span class="hljs-comment">//当接口参数为一个非对象类型的值时</span>
&#125;

select.... where id = #&#123;xxx&#125; 

说明：
如果传入的值是<span class="hljs-number">111</span>，那么解析成sql时的值为select... where id = <span class="hljs-string">"111"</span>
如果传入的值是abc，则解析成的sql为select... where id = <span class="hljs-string">"abc"</span>

<span class="hljs-comment">//-------------------------------------------------</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span></span>&#123;
    updateUser(User user);  <span class="hljs-comment">//当接口参数为一个对象类型的值时</span>
&#125;

update.... where id = #&#123;yyy&#125;  

说明：
由于接口参数是一个对象类型，而yyy是该对象的一个属性，那么可以直接获取到该对象的yyy属性的值，假设yyy属性是id属性且值为<span class="hljs-number">2</span>，则sql解析为order by <span class="hljs-string">"2"</span>

<span class="hljs-comment">//--------------------------------------</span>
拓展：map作为参数
一、和对象作为参数意义，#&#123;map的key值&#125;就可以直接获取对应key中所存放的值。</code></pre>
</li>
<li><p><code>${}</code>：将传入的数据直接显示在生成的sql中。${}底层是使用的是Statement对象操作的SQL语句；</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span></span>&#123;
    queryUserById(<span class="hljs-keyword">int</span> id);  <span class="hljs-comment">//当接口参数为一个非对象类型的值时</span>
&#125;

select.... where id = $&#123;xxx&#125;

说明：
如果传入的值是<span class="hljs-number">111</span>，只能以$&#123;value&#125;或者$&#123;_parameter&#125;获取值，那么解析成sql时的值为select... where id = <span class="hljs-number">111</span>；
如果传入的值是abc，只能以$&#123;value&#125;或者$&#123;_parameter&#125;获取值，则解析成的sql为select... where id = abc。

<span class="hljs-comment">//-------------------------------------------------</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span></span>&#123;
    updateUser(User user);  <span class="hljs-comment">//当接口参数为一个对象类型的值时</span>
&#125;

update.... where id = $&#123;yyy&#125;  

说明：
由于接口参数是一个对象类型，而yyy是该对象的一个属性，那么可以直接获取到该对象的yyy属性的值；假设yyy属性是id属性且值为<span class="hljs-number">2</span>，则sql解析为order by <span class="hljs-number">2</span>

<span class="hljs-comment">//-------------------------------------------------------------</span>
拓展：#&#123;&#125;和$&#123;&#125;的其他注意点
一、#&#123;&#125;方式能够很大程度防止sql注入，$&#123;&#125;方式无法防止Sql注入，一般能用#&#123;&#125;的就别用$&#123;&#125;；

二、$&#123;&#125;方式一般用于传入数据库的对象。如，传入表名等等；

三、MyBatis排序时使用order by，需要注意，排序的字段用$&#123;&#125;而不是#&#123;&#125;。</code></pre>
</li>
</ul>
</li>
<li><p>映射文件中sql语句的参数：</p>
<ul>
<li><p>当sql语句中只有一个参数时(基本数据类型或引用数据类型)：</p>
<ul>
<li><code>#{}</code>内的参数名称可以是任意名称，符合命名规范就行；</li>
<li><code>${}</code>内的参数名称则只能使用<code>${value}</code>或<code>${_parameter}</code>来获取参数。</li>
</ul>
</li>
<li><p>当sql语句里需要多个参数时：MyBatis默认会将多个参数放入一个Map中；当参数是集合或者数组时，也会默认放到一个Map中，而List的键是list，Array的键则是array；</p>
<ul>
<li><p>一种是根据参数索引0、1、2、3…获取，<code>#{0}</code>、<code>#{1}</code>，这种只有<code>#{}</code>方式可以使用；</p>
</li>
<li><p>另一种则根据param1、param2…获取，<code>${param1}</code>或<code>#{param1}</code>，<code>#{}</code>与<code>${}</code>都可以使用；</p>
</li>
<li><p><code>使用注解@Param(&quot;xxx&quot;)(推荐)</code>：该注解的效果相当于为指定的参数设置一个指定名称的“键”，而值则是该注解后面的参数；该注解不仅提供了名称命名参数的功能，即为参数创建了一个名称，以便在映射文件中方便的使用，而且同时还提供了使用param1，param2…paramN命名参数的功能，也就是说这一个注解同时做了这两件事情，你选择哪一个都可以获取到你想要的参数。<code>#{}</code>和<code>${}</code>都可以使用这种方式，但是<code>${}</code>要注意引号的问题。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span></span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(@Param(<span class="hljs-string">"aaa"</span>)</span><span class="hljs-keyword">int</span> id, </span>
<span class="hljs-function">    		@<span class="hljs-title">Param</span><span class="hljs-params">(<span class="hljs-string">"bbb"</span>)</span>String name)</span>;  

&#125;
说明：<span class="hljs-meta">@Param</span>注解中，分别将两个键值对，一个键为aaa，一个键为bbb，放入了一个Map中，这样映射文件中直接可以根据键名称获取到对应的值了</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>MyBatis中与数据库的交互，使用的是mapper代理形式，即接口+映射文件的形式；开发规范如下：</p>
<ul>
<li>接口的全包名路径要和映射文件的namespace属性值保持一致；</li>
<li>接口的方法名要和映射文件的id属性值保持一致；</li>
<li>接口的参数类型、返回值类型要和映射文件的parameterType、resultType保持一致；</li>
<li>接口和映射文件的名称最好保持一致；</li>
<li>接口和映射文件最好放到同一目录。</li>
</ul>
</li>
<li><p>注解@MapKey(“xxx”)的使用；</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名</span>&#123;

    <span class="hljs-meta">@MapKey</span>(<span class="hljs-string">"xxx"</span>);  <span class="hljs-comment">//该注解的作用是，指定一个字段(也就是括号中的“xxx”)作为Map中的Key；由于获取的是对象类型，所以放入Map中的值位置，而键需要我们指定，但又不能重复，所有我们使用User中的id属性来充当键就行了</span>
    <span class="hljs-function">Map&lt;String, Object&gt; <span class="hljs-title">getAllUser</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//获取所有的User对象，放将数据放入Map中，对象作为值</span>
&#125;</code></pre>
</li>
<li><p><code>&lt;resultMap&gt;</code>标签的高级自定义映射功能：resultType可以把查询结果封装到pojo类型中，但要求pojo类的属性名和查询到的数据库表的字段名一致；如果sql查询到的字段与pojo的属性名不一致，则需要使用resultMap将字段名和属性名对应起来，进行手动配置封装，将结果映射到pojo中；</p>
<pre><code class="hljs xml">//在映射文件中，配置resultMap标签，映射不同的字段和属性名

    <span class="hljs-comment">&lt;!-- resultMap标签，常用于多对一的表关系，作用是将结果映射到pojo上，</span>
<span class="hljs-comment">         type属性就是指定映射到哪一个pojo，</span>
<span class="hljs-comment">         id属性就表示ResultMap的id --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Emp"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"empMap"</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- id标签定义主键，非常重要；如果是多个字段,则定义多个id；</span>
<span class="hljs-comment">             property属性，就是指主键在pojo中的属性名，</span>
<span class="hljs-comment">			 column属性，就是主键在数据库中的列名 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"eid"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"eid"</span> /&gt;</span>

        <span class="hljs-comment">&lt;!-- result标签定义普通属性，</span>
<span class="hljs-comment">			 property属性，普通属性在pojo类中的名称</span>
<span class="hljs-comment">			 column属性则是指，普通属性在数据库的名称--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"ename"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"ename"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"age"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sex"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!--处理某个对象类型的属性，有三种方式--&gt;</span>
    <span class="hljs-comment">&lt;!--第一种方式，直接使用result标签--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Emp"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"empMap"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"eid"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"eid"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"ename"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"ename"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"age"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sex"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"did"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"dept.did"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"dname"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"dept.dname"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>

    <span class="hljs-comment">&lt;!--第二种方式，使用&lt;association&gt;标签</span>
<span class="hljs-comment">        association标签的作用是，处理单一的关联对象或处理单一属性的关联关系；</span>
<span class="hljs-comment">        javaType属性，是指把sql语句查询出的结果集，封装给哪个类的对象；</span>
<span class="hljs-comment">    --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Emp"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"empMap"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"eid"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"eid"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"ename"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"ename"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"age"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sex"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"dept"</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">"xxx.xxx.Dept"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"did"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"did"</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"dname"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"dname"</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>

    <span class="hljs-comment">&lt;!--第三种方式，分步查询</span>
<span class="hljs-comment">        association标签的作用是，处理单一的关联对象或处理单一属性的关联关系；</span>
<span class="hljs-comment">        javaType属性，是指把sql语句查询出的结果集，封装给哪个类的对象；</span>
<span class="hljs-comment">        select属性，是指当使用分步查询(和sql子查询类似)时，你要调用哪一个sql，格式为：namespace.你要调用那一条sql的id；</span>
<span class="hljs-comment">        column属性，是指分步查询时，你要调用的那一条sql，需要参数时，就使用这个属性，该参数的值会从当前的sql语句获取；</span>
<span class="hljs-comment">        property属性，是指你需要将查询出来的结果注入到哪个属性中；</span>
<span class="hljs-comment">    --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Emp"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"empMap"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"eid"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"eid"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"ename"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"ename"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"age"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sex"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"dept"</span> <span class="hljs-attr">select</span>=<span class="hljs-string">"cn.dyf.mapper.DeptMapper.getDeptById"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"did"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>

    <span class="hljs-comment">&lt;!--当出现一对多或者多对多的情况时，则使用&lt;collection&gt;标签，如一个部门有多个职员；ofType属性，是指集合中的元素的类型--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Dept"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"deptMap"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"did"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"did"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"dname"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"dname"</span> /&gt;</span>
        
        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"emps"</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">"Emp"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"eid"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"eid"</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"ename"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"ename"</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"age"</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sex"</span> /&gt;</span>
            
        <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>

    <span class="hljs-comment">&lt;!--同样的，在&lt;collection&gt;标签中也可以使用分步查询，也就是说里面也有select和column属性，且column属性的值可以是一个Map，即放入多个值，如，例中的did=did，前者是键did，后者是值did，分布查询后面的sql语句的参数要和这里的键名称相同，也就是说变成id=did，则分步查询的后一条sql语句的参数一定是#&#123;id&#125;或$&#123;id&#125;；fetchType属性用于指定该条sql语句是否要执行懒加载，该属性只有两个值，lazy或eager--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Dept"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"deptMapStep"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"did"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"did"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"dname"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"dname"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"emps"</span> <span class="hljs-attr">select</span>=<span class="hljs-string">"cn.dyf.mapper.getEmpListByDid"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"&#123;did=did,...&#125;"</span> <span class="hljs-attr">fetchType</span>=<span class="hljs-string">"eager"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>

//---------------------------------------------------------------------------

//先在映射文件中，配置基本的sql语句

<span class="hljs-comment">&lt;!-- resultMap属性，即填入配置的resultMap标签的id值就行 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getAllEmp"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"empMap"</span>&gt;</span>
    SELECT e.eid, e.ename, e.age, e.sex, e.did, d.dname
    FROM emp e
    LEFT JOIN
    dept d
    ON e.did = d.did
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>

<span class="hljs-comment">&lt;!--根据部门id查询职员信息--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getEmpListByDid"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"empMap"</span>&gt;</span>
    SELECT eid, ename, age, sex FROM emp where did = #&#123;did&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>

<span class="hljs-comment">&lt;!--根据id查询部门信息--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getDeptByDid"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"deptMapStep"</span>&gt;</span>
    SELECT did, dname FROM dept where did = #&#123;did&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-2-动态SQL与缓存"><a href="#NO2-2-动态SQL与缓存" class="headerlink" title="NO2.2 动态SQL与缓存"></a>NO2.2 动态SQL与缓存</h3><p>动态sql是为了解决sql语句拼接问题。</p>
<ul>
<li><p>动态sql：</p>
<ul>
<li><p>定义：传统的使用JDBC的方法，相信大家在组合复杂的的sql语句的时候，需要去拼接，稍不注意哪怕少了个空格，都会导致错误；Mybatis的动态sql功能正是为了解决这种问题，其通过if、choose、when、otherwise、trim、where、set、foreach标签，可组合成非常灵活的sql语句，从而提高开发人员的效率；</p>
</li>
<li><p>if和where标签：</p>
<ul>
<li><p><code>where</code>：去除where关键字之后的第一个and或者or，但是不会去除条件后面的AND或者OR；</p>
</li>
<li><p><code>if</code>：判断。该标签里有个test属性，该属性就是用于判断指定的表达式是否成立，成立则if标签中的语句有效，否则就无效；</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"xxx"</span>&gt;</span>
    SELECT * FROM user
    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"username !=null and username !=''"</span>&gt;</span>
            AND username LIKE '%$&#123;username&#125;%'
        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"sex !=null and sex !=''"</span>&gt;</span>
            AND sex = #&#123;sex&#125;
        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"address !=null and address !=''"</span>&gt;</span>
            AND address = #&#123;address&#125;
        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre>
</li>
</ul>
</li>
<li><p>foreach标签：</p>
<ul>
<li><p><code>foreach</code>：用于遍历数组、集合；属性有：</p>
<ul>
<li><p><code>collection</code>：要遍历的数组或集合；</p>
</li>
<li><p><code>item</code>：表示集合中每一个元素进行迭代时的别名；</p>
</li>
<li><p><code>index</code>：用于表示在迭代过程中，每次迭代到的位置；</p>
</li>
<li><p><code>open</code>：表示该语句以什么开始；</p>
</li>
<li><p><code>separator</code>：表示在每次进行迭代之间以什么符号作为分隔符；</p>
</li>
<li><p><code>close</code>：表示以什么结束。</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"xxx"</span>&gt;</span>
    SELECT * FROM user
    WHERE age IN
    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> </span>
<span class="hljs-tag">    	<span class="hljs-attr">collection</span>=<span class="hljs-string">"通过参数传过来的数组"</span> </span>
<span class="hljs-tag">    	<span class="hljs-attr">open</span>=<span class="hljs-string">"("</span> <span class="hljs-attr">close</span>=<span class="hljs-string">")"</span> </span>
<span class="hljs-tag">    	<span class="hljs-attr">separator</span>=<span class="hljs-string">","</span> <span class="hljs-attr">item</span>=<span class="hljs-string">"age"</span> &gt;</span>
        #&#123;age&#125;
    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>

//------------------------------------
拓展：批量修改使用<span class="hljs-tag">&lt;<span class="hljs-name">foreach</span>&gt;</span>标签，需要注意的是，MyBatis的预编译对象不允许一次执行多条sql语句，所以为了解决这个问题，需要在连接地址url的后面添加参数：?allowMultiQueries=true
<span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"xxx"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> </span>
<span class="hljs-tag">    	<span class="hljs-attr">collection</span>=<span class="hljs-string">"array"</span>  </span>
<span class="hljs-tag">    	<span class="hljs-attr">item</span>=<span class="hljs-string">"emp"</span>&gt;</span>
        UPDATE emp SET ename=#&#123;emp.ename&#125;, 
        age=#&#123;emp.age&#125;, 
        sex=#&#123;emp.sex&#125;, 
        where eid=#&#123;emp.eid&#125;
    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>set标签：</p>
<ul>
<li><p><code>set</code>：去除最后一个“,”，即去除最后一个逗号。</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"xxx"</span>&gt;</span>
    UPDATE user
    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"username!=null and username!=''"</span>&gt;</span>
            username = #&#123;username&#125;,
        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"username!=null and username!=''"</span>&gt;</span>
            sex = #&#123;sex&#125;,
        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"username!=null and username!=''"</span>&gt;</span>
            address = #&#123;address&#125;,
        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>
    WHERE id =#&#123;id&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre>
</li>
</ul>
</li>
<li><p>trim标签：</p>
<ul>
<li><p><code>trim</code>：一般用于去除sql语句中多余的and关键字，逗号，或者给sql语句前拼接“where”、“set”以及“values”等后缀(或后缀)，可用于选择性插入、更新、删除或者条件查询等操作。属性有：</p>
<ul>
<li><p><code>prefixOverrides</code>：前缀覆盖，就是去除第一个条件之前的相应内容；</p>
</li>
<li><p><code>suffixOverrides</code>：后缀覆盖，覆盖最后一个条件之后的相应内容；</p>
</li>
<li><p><code>prefix</code>：前缀，在第一个条件之前添加的内容；</p>
</li>
<li><p><code>suffix</code>：后缀，在最后一个条件之后添加的内容。</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"xxx"</span>&gt;</span>
    SELECT * FROM user

    <span class="hljs-comment">&lt;!--这里的suffixOverrides属性为“AND/OR”，表示把多余的AND或者OR都去除掉--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"WHERE"</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">"AND/OR"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"username !=null and username !=''"</span>&gt;</span>
            username LIKE '%$&#123;username&#125;%' AND
        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"sex !=null and sex !=''"</span>&gt;</span>
            sex = #&#123;sex&#125; or
        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"address !=null and address !=''"</span>&gt;</span>
            address = #&#123;address&#125;
        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>choose标签：</p>
<ul>
<li><p><code>choose</code>：按顺序判断其内部when标签中的test条件出否成立，如果有一个成立，则choose结束，也就不会拼接其他条件，只有一个条件会成立；当choose中所有when的条件都不满则时，则执行otherwise中的sql。</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"xxx"</span>&gt;</span>  
    SELECT *  
    FROM user u   
    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span>  
            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"username != null"</span>&gt;</span>  
                u.username LIKE '%$&#123;username&#125;%')  
            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span> &gt;</span>  
            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"sex != null and sex != ''"</span>&gt;</span>  
                AND u.sex = #&#123;sex&#125;  
            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span> &gt;</span>  
            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"birthday != null"</span>&gt;</span>  
                AND u.birthday = #&#123;birthday&#125;  
            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span> &gt;</span>  
            <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span> 
                u.age = #&#123;age&#125; 
            <span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span>  
        <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span>  
    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span>    
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre>
</li>
</ul>
</li>
<li><p>sql标签：</p>
<ul>
<li><p><code>sql</code>：这个标签用于设置一条公用的sql语句，也就是说任意的其他sql都可以使用这条sql语句，只要本身的sql里包含有这条sql语句就行了。</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"empColumn"</span>&gt;</span>SELECT ename,age,sex FROM emp<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"xxx"</span>&gt;</span>  

    <span class="hljs-comment">&lt;!--这里引用了公共的sql语句，所以使用&lt;include&gt;标签来引用公共的sql，而refid属性则是填入这个公共sql的id值就行了--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">"empColumn"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>
    WHERE eid=#&#123;eid&#125;
      
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>MyBatis缓存：</p>
<ul>
<li><p>目的：为了提高查询效率；</p>
</li>
<li><p>MyBatis为我们提供了一级缓存(默认开启)和二级缓存(手动配置开启)：</p>
<p><img src="./Image-ssm7.png" srcset="/img/loading.gif" alt="Image"></p>
<ul>
<li><p><code>一级缓存是SqlSession级别的缓存</code>： 其实指的就是MyBatis中sqlSession对象(该对象类似于JDBC的Connection对象)的缓存，当我们执行查询以后，查询的结果会同时存入到SqlSession为我们提供的一块区域中，该区域的结构是一个Map，当我们再次查询同样的数据(如果查询的数据不同，则不会有缓存)，MyBatis会先去sqlsession中查询是否有，有的话直接拿出来用；不同的sqlSession之间拥有不同的一级缓存；</p>
<ul>
<li><p>一级缓存的销毁：当SqlSession对象消失时，MyBatis的一级缓存也就消失了；</p>
</li>
<li><p>一级缓存失效情况：</p>
<ul>
<li>不同的SqlSession对象，且分别第一次调用某个方法时，一级缓存无效。因为是不同的SqlSession对象，且是第一次查询；</li>
<li>同一个SqlSession对象，同一个查询方法，但查询条件不一样。<code>如，第一次通过id=1去查询，第二次通过id=2去查询，当然也没有缓存</code>；</li>
<li>同一个SqlSession对象，同一个查询方法，调用两次之间，穿插调用了同一个SqlSession的修改、添加、删除等方法(即第一次查询后去执行了增删改方法，而后又以和第一次相同的条件执行查询)，那么一级缓存也会失效；commit(提交)、close(关闭)、</li>
<li>clearCache(手动清空一级缓存)，就会清空一级缓存。</li>
</ul>
</li>
<li><p>底层数据结构： MyBatis内部存储缓存(无论一级缓存还是二级缓存)使用的是一个HashMap，key为hashCode+sqlId+Sql语句，value为从查询出来映射生成的java对象或查询结果的普通数据。</p>
<pre><code class="hljs java"><span class="hljs-comment">//domain类</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-keyword">private</span> String username;
    <span class="hljs-keyword">private</span> Date birthday;
    <span class="hljs-keyword">private</span> String sex;
    <span class="hljs-keyword">private</span> String address;
    
    get和set方法省略.....
&#125;

<span class="hljs-comment">//----------------------------------------------</span>

<span class="hljs-comment">//Dao接口</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;

    <span class="hljs-comment">//查询所有的用户</span>
    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;

    <span class="hljs-comment">//根据Id查询用户</span>
    <span class="hljs-function">User <span class="hljs-title">findById</span><span class="hljs-params">(Integer id)</span></span>;

    <span class="hljs-comment">//更新用户</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(User user)</span></span>;
&#125;

<span class="hljs-comment">//----------------------------------------------</span>

<span class="hljs-comment">//Dao接口对应的Mapper.xml</span>

&lt;mapper namespace=<span class="hljs-string">"cn.dyf.dao.UserDao"</span>&gt;

    &lt;select id=<span class="hljs-string">"findAll"</span> resultType=<span class="hljs-string">"cn.dyf.domain.User"</span>&gt;
        SELECT * FROM USER;
    &lt;/select&gt;

    &lt;select id=<span class="hljs-string">"findById"</span> resultType=<span class="hljs-string">"cn.dyf.domain.User"</span>&gt;
        SELECT * FROM  USER  WHERE ID = #&#123;ID&#125;
    &lt;/select&gt;

    &lt;update id=<span class="hljs-string">"updateUser"</span> parameterType=<span class="hljs-string">"cn.dyf.domain.User"</span>&gt;
        UPDATE USER
        &lt;set&gt;
            &lt;if test="username != null"&gt;username=#&#123;username&#125;,&lt;/if&gt;

            &lt;if test="password != null"&gt;birthday=#&#123;birthday&#125;,&lt;/if&gt;

            &lt;if test="sex != null"&gt;sex=#&#123;sex&#125;,&lt;/if&gt;

            &lt;if test="address != null"&gt;address=#&#123;address&#125;,&lt;/if&gt;
        &lt;/set&gt;
        WHERE id=#&#123;id&#125;
    &lt;/update&gt;

&lt;/mapper&gt;

<span class="hljs-comment">//----------------------------------------------</span>

<span class="hljs-comment">//测试代码</span>

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findByIdTest</span><span class="hljs-params">()</span></span>&#123;

    <span class="hljs-comment">//获得能够创建sqlSessionFactory的工程师对象</span>
    SqlSessionFactoryBuilder builder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();

    <span class="hljs-comment">//从全局配置文件sqlMapConfig.xml中获得工厂的图纸</span>
    InputStream factoryMap = Resources.getResourceAsStream(<span class="hljs-string">"sqlMapConfig.xml"</span>);

    <span class="hljs-comment">//创建sqlSessionFactory工厂</span>
    SqlSessionFactory sqlSessionFactoyr = builder.buil(factoryMap);

    SqlSession session =sqlSessionFactoyr.openSession();
    UserDao userDao = session.getMapper(UserDao<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-comment">//第一次获取该用户</span>
    User user1 = userDao.findById(<span class="hljs-number">45</span>);
    System.out.println(user1);

    第二次获取该用户
    User user2 = userDao.findById(<span class="hljs-number">45</span>);
    System.out.println(user2);

    System.out.println(user1 == user2);
    session.close();
&#125;</code></pre>
</li>
</ul>
</li>
<li><p><code>二级缓存是mapper级别的缓存</code>：多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的；<code>如，UserMapper有一个二级缓存区域(按namespace分)，其它mapper也有自己的二级缓存区域(按namespace分)</code>。每一个namespace的mapper都有一个二级缓存区域，两个mapper的namespace如果相同，这两个mapper执行sql查询到数据将存在相同的二级缓存区域中；通俗的理解就是，二级缓存的配置完成后，可以有多个SqlSession，但是必须操作同一个namespace，并执行查询相同的数据，这样结果数据就会进行缓存；</p>
<pre><code class="hljs java">&lt;!--第一步，让Mybatis框架支持二级缓存(在Mybatis的全局配置文件中进行配置)--&gt;
&lt;setting name=<span class="hljs-string">"cacheEnabled"</span> value=<span class="hljs-string">"true"</span>/&gt;

<span class="hljs-comment">//----------------------------------------------------</span>

&lt;!--第二步，让当前的映射文件支持二级缓存(在xxxMapper.xml映射文件中配置)，只需要写上&lt;cache /&gt;标签，这个mapper就开启了二级缓存--&gt;
&lt;cache /&gt;

<span class="hljs-comment">//----------------------------------------------------</span>

<span class="hljs-comment">//第三步，二级缓存需要查询结果所映射的pojo对象实现java.io.Serializable接口来实现序列化和反序列化操作。注意：如果存在父类、成员pojo都需要实现序列化接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;
    ....
&#125;

说明：二级缓存必须在SqlSession关闭或提交之后才会生效

<span class="hljs-comment">//----------------------------------------------------</span>

<span class="hljs-comment">//测试代码</span>

<span class="hljs-comment">//获取session1</span>
SqlSession session1 = sqlSessionFactory.openSession();
UserMapper userMapper = session1.getMapper(UserMapper<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

<span class="hljs-comment">//使用session1执行第一次查询</span>
User user1 = userMapper.findUserById(<span class="hljs-number">1</span>);
System.out.println(user1);

<span class="hljs-comment">//关闭session1</span>
session1.close();


<span class="hljs-comment">//获取session2</span>
SqlSession session2 = sqlSessionFactory.openSession();
UserMapper userMapper2 = session2.getMapper(UserMapper<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

<span class="hljs-comment">//使用session2执行第二次查询，由于开启了二级缓存这里从缓存中获取数据不再向数据库发出sql</span>
User user2 = userMapper2.findUserById(<span class="hljs-number">1</span>);
System.out.println(user2);

<span class="hljs-comment">//关闭session2</span>
session2.close();

拓展：增删改和查询语句中的useCache属性、flushCache属性
一、select标签语句中：
	<span class="hljs-number">1</span>.都有useCache属性，且默认为<span class="hljs-keyword">true</span>，表示会将本条语句的结果进行二级缓存；
	<span class="hljs-number">2</span>.都有flushCache属性，且默认为<span class="hljs-keyword">false</span>，表示任何时候语句被调用，都不会去清空	   本地(一级)缓存和二级缓存。

二、每条insert、update、delete语句中：
	<span class="hljs-number">1</span>.useCache属性，在以上三个标签语句中没有；
	<span class="hljs-number">2</span>.都有flushCache属性，且默认为<span class="hljs-keyword">true</span>，表示任何时候语句被调用，都会导致本地	  (一级)缓存和二级缓存被清空。

三、sqlSession.clearCache()方法只能清空本地(一级)缓存的。</code></pre>

<p><img src="./Image-ssm8.png" srcset="/img/loading.gif" alt="Image"></p>
<p><code>说明：以上属性是第二步中的&lt;cache&gt;标签中的属性。</code></p>
</li>
<li><p>第三方缓存：为了提高扩展性，MyBatis定义了缓存接口Cache，我们可以通过实现Cache接口来实现自己的缓存逻辑；EhCache是一个分布式缓存框架，EhCache是一个纯Java的进程内缓存框架，是一种广泛使用的开源Java分布式缓存，具有快速、精干等特点，是Hibernate中默认的CacheProvider。要整合EhCache，要准备以下步骤：</p>
<ul>
<li><p>第一步，准备JAR包或者maven依赖；</p>
<pre><code class="hljs css"><span class="hljs-selector-tag">mybatis-ehcache-1</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.3</span><span class="hljs-selector-class">.jar</span>
<span class="hljs-selector-tag">ehcache-core-2</span><span class="hljs-selector-class">.6</span><span class="hljs-selector-class">.8</span><span class="hljs-selector-class">.jar</span>
<span class="hljs-selector-tag">slf4j-api-1</span><span class="hljs-selector-class">.6</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.jar</span>
其中，<span class="hljs-selector-tag">mybatis</span>本身已经带了<span class="hljs-selector-tag">slf4j-api</span>包，所以只需要拷贝前两个<span class="hljs-selector-tag">jar</span>包即可</code></pre>
</li>
<li><p>第二步，在项目的src目录下，新建ehcache.xml文件，文件内容如下：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ehcache</span>&gt;</span>
    <span class="hljs-comment">&lt;!--表示硬盘上保存缓存的位置，默认是临时文件夹--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">diskStore</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"D:\cache"</span>/&gt;</span>

    <span class="hljs-comment">&lt;!--默认缓存配置，如果类没有做特定的设置，则使用这里配置的缓存属性</span>
<span class="hljs-comment">       maxElementsInMemory：设置缓存中允许保存的最大对象(pojo)数量</span>
<span class="hljs-comment">       eternal：设置对象是否永久保存，如果为true，则缓存中的数据永远不销毁，一直保存</span>
<span class="hljs-comment">       timeToIdleSeconds：设置空闲销毁时间。只有eternal为false时才起作用。表示从现在到上次访问时间如果超过这个值，则缓存数据销毁</span>
<span class="hljs-comment">       timeToLiveSeconds：设置活动销毁时间。表示从现在到缓存创建时间如果超过这个值，则缓存自动销毁</span>
<span class="hljs-comment">       overflowToDisk：设置是否在超过保存数量时，将超出的部分保存到硬盘上--&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">defaultCache</span></span>
<span class="hljs-tag">        <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">"1500"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">eternal</span>=<span class="hljs-string">"false"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">"120"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">"300"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">"true"</span>/&gt;</span>

    <span class="hljs-comment">&lt;!-- 也可以通过name设置针对某个类的缓存配置 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cn.sz.po.Emp"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">"1000"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">eternal</span>=<span class="hljs-string">"true"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">"0"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">"0"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">"false"</span></span>
<span class="hljs-tag">        /&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">ehcache</span>&gt;</span></code></pre>
</li>
<li><p>第三步，最后在xxxMapper.xml映射文件中添加一个<cache>标签即可，就相当于用第三方缓存来替代MyBatis的二级缓存；</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"org.mybatis.caches.ehcache.LoggingEhcache"</span> &gt;</span>
    
    <span class="hljs-comment">&lt;!--这下面的内容，是和ehcache.xml文件中的配置差不多，只不过是用于实时配置--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"timeToIdleSeconds"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"3600"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"timeToLiveSeconds"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"3600"</span>/&gt;</span>

    <span class="hljs-comment">&lt;!-- 同ehcache参数maxElementsInMemory--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"maxEntriesLocalHeap"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1000"</span>/&gt;</span>

    <span class="hljs-comment">&lt;!-- 同ehcache参数maxElementsOnDisk --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"maxEntriesLocalDisk"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"10000000"</span>/&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"memoryStoreEvictionPolicy"</span> 			</span>
<span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">"LRU"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">cache</span>&gt;</span></code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="Lesson3-Spring-MVC框架"><a href="#Lesson3-Spring-MVC框架" class="headerlink" title="Lesson3 Spring MVC框架"></a>Lesson3 Spring MVC框架</h2><h3 id="NO3-1-Spring-MVC概述与运行原理"><a href="#NO3-1-Spring-MVC概述与运行原理" class="headerlink" title="NO3.1 Spring MVC概述与运行原理"></a>NO3.1 Spring MVC概述与运行原理</h3><p>Spring MVC是web层的框架</p>
<ul>
<li><p>Spring MVC：</p>
<ul>
<li><p>定义：是一个严格遵循MVC设计模式的框架。说其是一个框架，那么Spring MVC框架中就应该有与Model，View，Controller相对应的组件：分别是Model模型对象，视图解析器，Controller控制器；Spring MVC的请求流程图：</p>
<p><img src="./Image-ssm9.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>优点：</p>
<ul>
<li>支持Restful风格；</li>
<li>采用松散耦合可插拔组件结构，比其他MVC框架更具扩展性和灵活性等等。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO3-2-Spring-MVC框架解析"><a href="#NO3-2-Spring-MVC框架解析" class="headerlink" title="NO3.2 Spring MVC框架解析"></a>NO3.2 Spring MVC框架解析</h3><ul>
<li><p>入门案例：</p>
<ul>
<li><p>创建项目，并导入需要的JAR包或者使用Maven导入需要的依赖；</p>
<p><img src="./Image-ssm10.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-ssm11.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>在web.xml中配置好DispatcherServlet的<code>&lt;servlet&gt;&lt;/servlet&gt;</code>导向后，因为还要创建Spring MVC的配置文件，但该配置文件是默认放在/WEB-INF/下，默认名称是<code>&lt;servlet-name&gt;-servlet.xml</code>，所以需要在<code>&lt;servlet&gt;</code>标签里的<code>&lt;init-param&gt;</code>子标签下修改默认配置文件的位置，我们一般放在固定的config目录下；</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置DispatcherServlet的作用是为了加载配置文件，Spring MVC会加载默认位置的配置文件，但我们一般都会给它修改到config目录下去，这样它就会加载config下的配置文件了--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>
        xxx
    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>
        org.springframework.web.servlet.DispatcherServlet
    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>

    <span class="hljs-comment">&lt;!--这是修改默认的加载配置文件的位置，原本默认加载/WEB-INF/XXX-servlet.xml位置的配置文件，修改成如下 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 原本Servlet是在第一次被访问时，才会被加载，设置了该标签以后则会将Servlet的加载时间提前到项目启动时，标签中写负整数时，相当于没有设置该标签，只有设置0或正整数才能使该标签生效，且值越小，优先级越高，即0&gt;1&gt;2... --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>
        xxx
    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>

    <span class="hljs-comment">&lt;!--该标签表示对哪些指定的请求进行处理，而“/”值，表示只对所有的请求进行拦截处理，页面不会进行拦截处理--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>
        /
    <span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre>
</li>
<li><p>编写并配置Controller类；</p>
<ul>
<li><p>编写一个普通Java类，并在类上添加注解：@Controller，然后创建一个返回值是ModelAndView的方法，在方法上添加注解：@RequestMapping(“/请求的资源名”)；</p>
<pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/xx"</span>)  <span class="hljs-comment">//该标签在类上的作用是，添加一个主路由，意思就是要想访问这个控制层下的方法，必须加上这里的这个路径名，如访问test方法，这里加了个user，所以访问路径就变成了localhost:8080/web01/user/test，而不是原来的localhost:8080/web01/test</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">xxxController</span></span>&#123;

    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/请求的url资源名，不要带后缀，根据资源名会找对应方法去执行"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">XXX</span><span class="hljs-params">(HttpServletRequest request,HttpServletReponse reponse)</span></span>&#123;...&#125;

&#125;</code></pre>

<ul>
<li>注解@RequestMapping解析：<ul>
<li><code>value</code>：就是指定处理某个请求的url，也就是当请求的资源名和这个属性值对应时，DispatcherServlet会调用这个注解下的方法对请求进行处理，有多个值时，必须将value写出来，即value={“aa”,”bb”}；</li>
<li><code>method</code>：该属性用来表示该方法仅仅处理哪些HTTP请求方式，常用的请求方式有GET、POST、DELETE、PUT等等；</li>
<li><code>params</code>：该属性指定，请求中必须包含params属性规定的参数时，才能执行该请求。<code>如，当params=&quot;flag&quot;时，请求中必须包含flag参数，flag参数值不做要求，而当params=&quot;flag=true&quot;时，则参数flag的值也必须为true才能调用方法执行该请求，params=!flag则表示请求中不能包含flag参数</code>；</li>
<li><code>headers</code>：该属性指定，请求中必须包含某些指定的header值，才能够让该方法处理请求。<code>如，headers=&quot;Referer=http://www.xxx.com&quot;，表明请求的header中必须满足，指定的请求头&quot;Referer&quot;和值为&quot;http://www.xxx.com&quot;时，才能执行该请求</code>；</li>
</ul>
</li>
</ul>
</li>
<li><p>将带@Controller注解的类配置到Spring MVC.xml中，也就是开启注解扫描，然后再配置视图解析器，用于解析你要跳转的页面；</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 扫描注解 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"需要扫描的Controller全包名路径"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span>

//--------------------------------------

<span class="hljs-comment">&lt;!-- 视图解析器 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"viewResolver"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 前缀 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/WEB-INF/view"</span>/&gt;</span>
    <span class="hljs-comment">&lt;!-- 后缀 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".jsp"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
</li>
<li><p>获取请求需要的数据后，创建一个ModelAndView，即：</p>
<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/请求的url资源名"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">XXX</span><span class="hljs-params">(HttpServletRequest request,HttpServletReponse reponse)</span></span>&#123;

    <span class="hljs-comment">//创建一个modelAndView</span>
    ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView();

    <span class="hljs-comment">//相当于把数据放入了request域中</span>
    modelAndView.addObject(name,value);

    <span class="hljs-comment">//设置要跳转的页面，即JSP路径即可</span>
    modelAndView.setViewName(viewName);

&#125;</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>Spring MVC请求路径风格：</p>
<ul>
<li><p>Spring MVC支持Ant风格的通配符：其实就是@RequestMapping注解的value值多加一层路径；</p>
<ul>
<li><p><code>?</code>：匹配一个任意字符；</p>
</li>
<li><p><code>*</code>：匹配0或多个任意字符；</p>
</li>
<li><p><code>**</code>：匹配0或多层路径。</p>
<pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AntMaskTest</span> </span>&#123;
    
    <span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/?/test"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">TestAntMask</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;
    &#125;
&#125;

说明：
一、<span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/?/test"</span>)注解使用了Ant风格的匹配符，那么在浏览器中输入的url就变为了：localihost:<span class="hljs-number">8080</span>/项目名/a/test，也可以是localihost:<span class="hljs-number">8080</span>/项目名/v/test，因为使用了?，只能匹配一个任意字符；

二、<span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/*/test"</span>)，则可以输入为localihost:<span class="hljs-number">8080</span>/项目名/aaa/test或localihost:<span class="hljs-number">8080</span>/项目名/test；

三、<span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/**/test"</span>)，则是localihost:<span class="hljs-number">8080</span>/项目名/aaa/bbb/test或localihost:<span class="hljs-number">8080</span>/项目名/test都行。</code></pre>
</li>
</ul>
</li>
<li><p><code>Spring支持的RESTful风格(推荐)</code>：其实这种风格就是把参数写到url后面并用{}括起来，多个参数用“/”隔开；但是该风格需要配合@PathVariable(XXX)注解一起使用</p>
<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user/&#123;id&#125;/&#123;otherParam&#125;"</span>)
<span class="hljs-meta">@ResponseBody</span>  <span class="hljs-comment">//该注解会将返回的对象转换成JSON格式的数据后传给前台</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUser</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id, @<span class="hljs-title">PathVariable</span><span class="hljs-params">(<span class="hljs-string">"otherParam"</span>)</span>String param) </span>&#123;
    User user = <span class="hljs-keyword">new</span> User();
    <span class="hljs-keyword">if</span>(<span class="hljs-string">"123"</span>.equals(id)) &#123;
        user.setUsername(<span class="hljs-string">"nlskyfree"</span>);
    &#125;
    <span class="hljs-keyword">return</span> user;
&#125;

说明：
一、<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user/&#123;id&#125;/&#123;otherParam&#125;"</span>)，通过URL中的&#123;XXX&#125;表示占位符，与<span class="hljs-meta">@PathVariable</span>(XXX)注解配合建立URL路径到参数的绑定关系。</code></pre>

<ul>
<li><p>SpringMVC过滤器HiddenHttpMethodFilter的使用：</p>
<ul>
<li><p>问题：浏览器不支持以PUT、DELETE方式提交请求。一般使用Restful风格的url，都会遇到这个问题：即一般来说，资源操作有新增，删除，更改，查询四种类型，对应HTTP协议中四类请求：<code>POST</code>，<code>DELETE</code>，<code>PUT</code>，<code>GET</code>；未声明情况下浏览器默认使用GET提交请求；需要注意的是，普通浏览器只支持GET，POST方式，其他请求方式，像DELETE或PUT必须通过过滤器的支持才能实现；</p>
</li>
<li><p>解决：Spring自带了一个过滤器HiddenHttpMethodFilter，支持GET、POST、PUT、DELETE请求。HiddenHttpMethodFilter的父类是OncePerRequestFilter，它继承了父类的doFilterInternal方法，工作原理是将jsp页面的form表单的method属性值在doFilterInternal方法中转化为标准的Http方法，即GET、POST、HEAD、OPTIONS、PUT、DELETE、TRACE，然后到Controller中找到对应的方法；</p>
<pre><code class="hljs java"><span class="hljs-comment">//首先，在web.xml中增加过滤器，&lt;filter&gt;标签必须放在&lt;servlet&gt;标签之前</span>

&lt;!-- 增加HiddenHttpMethodFilte过滤器：给普通浏览器增加put或delete请求方式 --&gt;
&lt;filter&gt;
    &lt;filter-name&gt;HiddenHttpMethodFilte&lt;/filter-name&gt;
    &lt;filter-<span class="hljs-class"><span class="hljs-keyword">class</span>&gt;<span class="hljs-title">org</span>.<span class="hljs-title">springframework</span>.<span class="hljs-title">web</span>.<span class="hljs-title">filter</span>.<span class="hljs-title">HiddenHttpMethodFilter</span>&lt;/<span class="hljs-title">filter</span>-<span class="hljs-title">class</span>&gt;</span>
<span class="hljs-class">&lt;/<span class="hljs-title">filter</span>&gt;</span>
<span class="hljs-class">    </span>
<span class="hljs-class">&lt;<span class="hljs-title">filter</span>-<span class="hljs-title">mapping</span>&gt;</span>
<span class="hljs-class">    &lt;<span class="hljs-title">filter</span>-<span class="hljs-title">name</span>&gt;<span class="hljs-title">HiddenHttpMethodFilte</span>&lt;/<span class="hljs-title">filter</span>-<span class="hljs-title">name</span>&gt;</span>
<span class="hljs-class">    &lt;!-- 过滤所有：/*--&gt;</span>
<span class="hljs-class">    &lt;<span class="hljs-title">url</span>-<span class="hljs-title">pattern</span>&gt;/*&lt;/<span class="hljs-title">url</span>-<span class="hljs-title">pattern</span>&gt;</span>
<span class="hljs-class">&lt;/<span class="hljs-title">filter</span>-<span class="hljs-title">mapping</span>&gt;       </span>
<span class="hljs-class"></span>
<span class="hljs-class"></span>
<span class="hljs-class">//----------------------------------</span>
<span class="hljs-class"></span>
<span class="hljs-class">//其次，往<span class="hljs-title">JSP</span>中添加一个隐藏域，然后设置隐藏域的<span class="hljs-title">name</span>属性(值为<span class="hljs-title">_method</span>)和<span class="hljs-title">value</span>值(值为<span class="hljs-title">DELETE</span>或<span class="hljs-title">PUT</span>)</span>
<span class="hljs-class">&lt;<span class="hljs-title">form</span> <span class="hljs-title">action</span></span>=<span class="hljs-string">"/testRest/1234"</span> method=<span class="hljs-string">"post"</span>&gt;
    &lt;input type=<span class="hljs-string">"hidden"</span>  name=<span class="hljs-string">"_method"</span> value=<span class="hljs-string">"DELETE"</span>/&gt;
    &lt;input type=<span class="hljs-string">"submit"</span> value=<span class="hljs-string">"删"</span>&gt;
&lt;/form&gt;

<span class="hljs-comment">//----------------------------------</span>

<span class="hljs-comment">//Controller层</span>
<span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"testRest/&#123;id&#125;"</span>,method=RequestMethod.DELETE)
<span class="hljs-function"><span class="hljs-keyword">public</span> String  <span class="hljs-title">testDelete</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> Integer id) </span>&#123;


    System.out.println(<span class="hljs-string">"delete：删 "</span> +id);
    <span class="hljs-comment">//Service层省略</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span> ;
&#125;

<span class="hljs-comment">//-------------------------------------------</span>

说明：HiddenHttpMethodFilter的实现原理其实就是新建了个HttpMethodRequestWrapper类，覆写了getMethod()方法，也就是将原来本身的HTTP请求方式(POST)给隐藏掉了

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HiddenHttpMethodFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OncePerRequestFilter</span> </span>&#123;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_METHOD_PARAM = <span class="hljs-string">"_method"</span>;

    <span class="hljs-keyword">private</span> String methodParam = DEFAULT_METHOD_PARAM;

    
    <span class="hljs-comment">//这个方法，其实就是Filter中的doFilter(...)方法，也就是请求放行的方法</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;

        <span class="hljs-comment">//获取到"_method"对应的value值</span>
        String paramValue = request.getParameter(<span class="hljs-keyword">this</span>.methodParam);

        <span class="hljs-comment">//如果是POST请求，就将POST请求包装成需要转换的请求</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-string">"POST"</span>.equals(request.getMethod()) &amp;&amp; StringUtils.hasLength(paramValue)) &#123;

            <span class="hljs-comment">//toUpperCase方法是将字符串转换成大写的英文字符串</span>
            String method = paramValue.toUpperCase(Locale.ENGLISH);

            <span class="hljs-comment">//通过调用包装方法将请求以及我们要转换的请求方式一起包装成新的请求</span>
            HttpServletRequest wrapper = <span class="hljs-keyword">new</span> HttpMethodRequestWrapper(request, method);

            <span class="hljs-comment">//转换完成，请求放行</span>
            filterChain.doFilter(wrapper, response);

        &#125;<span class="hljs-keyword">else</span> &#123;

            <span class="hljs-comment">//如果不是POST请求(那就只有GET请求了)，就直接放行</span>
            filterChain.doFilter(request, response);
        &#125;
    &#125;

<span class="hljs-comment">//----------------------------------------------</span>

    <span class="hljs-comment">//该类将重新包装请求，请求的内容并没有变化，只是将POST请求转换成了前端传过来的指定请求类型值</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpMethodRequestWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServletRequestWrapper</span> </span>&#123;

        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String method;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpMethodRequestWrapper</span><span class="hljs-params">(HttpServletRequest request, String method)</span> </span>&#123;
            <span class="hljs-keyword">super</span>(request);
            <span class="hljs-keyword">this</span>.method = method;
        &#125;

        <span class="hljs-comment">//通过覆写了getMethod方法，后期再调用getMethod方法的时候获取到的就是我们转换之后的method</span>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMethod</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.method;
        &#125;
    &#125;
&#125;

<span class="hljs-comment">//-------------------------------------------</span>

说明：
一、使用HiddenHttpMethodFilter对浏览器传来的请求进行处理，也就是转换成PUT或DELETE请求，需要：
	<span class="hljs-number">1</span>.在web.xml中配置HiddenHttpMethodFilter过滤器；
	<span class="hljs-number">1</span>.请求的方式必须是POST；
	<span class="hljs-number">2</span>.请求中必须包含参数<span class="hljs-string">"_method"</span>，且有对应的值为<span class="hljs-string">"PUT"</span>或<span class="hljs-string">"DELETE"</span>；</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>Spring MVC获取前台传递的数据：</p>
<ul>
<li><p>在处理请求的方法声明上，加入形参的时候，只要形参的名称和前台传来的数据的名称相对应，就可以自动赋值；</p>
<ul>
<li>如果处理方法的方法声明上需要的是一个普通类型；</li>
</ul>
<pre><code class="hljs java"><span class="hljs-comment">//JSP页面</span>

&lt;form action=<span class="hljs-string">"/param"</span> method=<span class="hljs-string">"post"</span>&gt;
    用户名：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"username"</span> /&gt;
    密码：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"password"</span> /&gt;
    年龄：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"age"</span> /&gt;
    &lt;input type=<span class="hljs-string">"submit"</span> value=<span class="hljs-string">"提交"</span>&gt;
&lt;/form&gt;

<span class="hljs-comment">//----------------------------------------------------</span>

<span class="hljs-comment">//Controller层</span>

<span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/param"</span>,method=RequestMethod.POST)
<span class="hljs-function"><span class="hljs-keyword">public</span> String  <span class="hljs-title">testParam</span><span class="hljs-params">(String username, String password, Integer age)</span> </span>&#123;  <span class="hljs-comment">//在这个方法声明里，这里的形参名称和前台传来的参数名称一致，所以可以自动赋值</span>

    System.out.println(<span class="hljs-string">"结果为："</span> + username + password + age);

    <span class="hljs-comment">//Service层省略</span>

    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span> ;
&#125;</code></pre>

<ul>
<li><p>如果前台传来的数据是一个pojo对象，那么只需要在处理方法的方法声明上添加这个pojo对象所属类的形参即可，但必须要求pojo类对象的属性名称和前台的页面中的表单元素的name属性一致，且还要注意对象的一些属性可能会是一个对象的情况；<strong><code>注意：当前台传过来的数据是JSON对象时，是无法使用该方式进行获取数据的。</code></strong></p>
<pre><code class="hljs java"><span class="hljs-comment">//JSP页面</span>

&lt;!--表单封装了一个User对象--&gt;
&lt;form action=<span class="hljs-string">"/param"</span> method=<span class="hljs-string">"post"</span>&gt;
    
    用户名：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"username"</span> /&gt;
    密码：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"password"</span> /&gt;
    年龄：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"age"</span> /&gt;

    &lt;!--下面三个属性是User对象中的address属性，而Address又是一个对象，所以需要加上address属性进行限定--&gt;
    所在省：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"address.province"</span> /&gt;
    所在城市：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"address.city"</span> /&gt;
    所在街道：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"address.street"</span> /&gt;
    
    &lt;!--封装成一个list，表示将这两个属性封装成一个对象，然后存入list--&gt;
    aaa：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"list[0].xxx"</span> /&gt;
	bbb：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"list[0].xxx"</span> /&gt;
    
    &lt;!--封装成一个map，表示将key和后面的xxx封装成一个键值对，存入map--&gt;
    aaa：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"map['key'].xxx"</span> /&gt;
	bbb：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"map['key'].xxx"</span> /&gt;
    
    &lt;input type=<span class="hljs-string">"submit"</span> value=<span class="hljs-string">"提交"</span>&gt;
&lt;/form&gt;

<span class="hljs-comment">//----------------------------------------------------</span>

<span class="hljs-comment">//pojo类</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;

    <span class="hljs-keyword">private</span> integer id;
    <span class="hljs-keyword">private</span> String username;
    <span class="hljs-keyword">private</span> String password;
    <span class="hljs-keyword">private</span> integer age;
    <span class="hljs-keyword">private</span> Address address;
    
    ...
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span></span>&#123;

    <span class="hljs-keyword">private</span> String province;
    <span class="hljs-keyword">private</span> String city;
    <span class="hljs-keyword">private</span> String street;
    
    ...
&#125;

<span class="hljs-comment">//------------------------------------------------------</span>

<span class="hljs-comment">//Controller层</span>

<span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/param"</span>,method=RequestMethod.POST)
<span class="hljs-function"><span class="hljs-keyword">public</span> String  <span class="hljs-title">testParam</span><span class="hljs-params">(User user)</span> </span>&#123;  <span class="hljs-comment">//在这个方法声明里，需要一个User对象，传过来的数据名称和User对象属性名称一致的，就会自动赋值，如果名称不一致的，就需要提前在页面中就行限定了</span>

    System.out.println(<span class="hljs-string">"结果为："</span> + user);

    <span class="hljs-comment">//Service层省略</span>

    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span> ;
&#125;</code></pre>
</li>
</ul>
</li>
<li><p>在处理方法的方法声明中使用注解@RequestBody或@RequestParam。</p>
<ul>
<li><p>前端传来的是普通形式的字参数时，则使用@RequestParam注解；</p>
<pre><code class="hljs java"><span class="hljs-comment">//JSP页面</span>

&lt;form action=<span class="hljs-string">"/param"</span> method=<span class="hljs-string">"post"</span>&gt;
    用户名：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"name"</span> /&gt;
    密码：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"password"</span> /&gt;
    年龄：&lt;input type=<span class="hljs-string">"text"</span>  name=<span class="hljs-string">"age"</span> /&gt;
    &lt;input type=<span class="hljs-string">"submit"</span> value=<span class="hljs-string">"提交"</span>&gt;
&lt;/form&gt;

<span class="hljs-comment">//----------------------------------------------------</span>

<span class="hljs-comment">//Controller层</span>

<span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/param"</span>,method=RequestMethod.POST)
<span class="hljs-function"><span class="hljs-keyword">public</span> String  <span class="hljs-title">testParam</span><span class="hljs-params">(@RequestParam(value=<span class="hljs-string">"name"</span>, required=<span class="hljs-keyword">false</span>, defaultValue=<span class="hljs-string">"xxx"</span>)</span> String username) </span>&#123;

    System.out.println(<span class="hljs-string">"结果为："</span> + username + password + age);

    <span class="hljs-comment">//Service层省略</span>

    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span> ;
&#125;</code></pre>

<ul>
<li>@RequestParam注解解析：<ul>
<li><code>value</code>：用于指定前台的某个参数和注解后面的形参进行映射，就是把前台的某个指定名称的参数赋值到该注解后面的形参中去；</li>
<li><code>required</code>：默认为true)是指，value属性指定的参数不是一定要出现在前台传来的数据当中，即不一定要有value属性指定的参数，有就赋值，没有也可以；</li>
<li><code>defaultValue</code>：是指，当value属性指定的参数不存在时，即形参的值为null时，为该注解后面的形参设置一个默认值；</li>
</ul>
</li>
</ul>
</li>
<li><p>前端传来的是JSON格式的数据对象时，那么就需要用到注解@RequestBody了，因为目前前端传对象数据，哪怕是注册用户也好，还是修改用户信息也罢，都会封装成一个JSON对象进行传递，而不是放到form表单中进行传递(form表单中的数据格式并不是一个JSON)。</p>
<pre><code class="hljs java"><span class="hljs-comment">//Controller层</span>

<span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/param"</span>,method=RequestMethod.POST)
<span class="hljs-function"><span class="hljs-keyword">public</span> String  <span class="hljs-title">testParam</span><span class="hljs-params">(@RequestBody User user)</span> </span>&#123;  <span class="hljs-comment">//该注解就会将前端传来的JSON格式的数据，封装成User，前提是传来的参数名称要和User中的属性名称一一对应才行，因为原理是使用的User中Setter方法进行设置值</span>

    System.out.println(<span class="hljs-string">"结果为："</span> + username + password + age);

    <span class="hljs-comment">//Service层省略</span>

    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span> ;
&#125;



拓展：<span class="hljs-meta">@RequestHeader</span>注解与<span class="hljs-meta">@CookieValue</span>注解
与<span class="hljs-meta">@RequestParam</span>()注解类似的，<span class="hljs-meta">@RequestHeader</span>注解是用来获取请求头中的某个参数的值，该注解的属性和<span class="hljs-meta">@RequestParam</span>()注解一样，都有value、required、defaultValue属性，且意思一样，只不过获取参数的区域是从请求头中获取；
    
二、<span class="hljs-meta">@CookieValue</span>注解则是获取Cookie中的参数信息的，也有value、required、defaultValue属性，如JSESSIONID等等；
    
三、<span class="hljs-meta">@ResponseBody</span>注解，用在方法上，将方法的返回值一JSON的形式返回给前台。</code></pre>

<ul>
<li>@RequestBody注解解析：GET方式无请求体，所以使用@RequestBody接收数据时，前端不能使用GET方式提交数据，而是用POST方式进行提交。在后端的同一个接收方法里，@RequestBody与@RequestParam()可以同时使用，@RequestBody最多只能有一个，而@RequestParam()可以有多个。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用Servlet的原生API获取参数；</p>
<pre><code class="hljs java"><span class="hljs-comment">//Controller层</span>

<span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/param"</span>,method=RequestMethod.POST)
<span class="hljs-function"><span class="hljs-keyword">public</span> String  <span class="hljs-title">testParam</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;

    <span class="hljs-comment">//获取前台传过来的参数</span>
    String param = request.getParameter(<span class="hljs-string">"xxxx"</span>);    

    System.out.println(<span class="hljs-string">"结果为："</span> + param);

    <span class="hljs-comment">//Service层省略</span>

    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span> ;
&#125;

拓展：MVC中Handler方法可以接受的ServletAPI类型的参数，说白了就是处理方法中可以直接获取并使用的参数：
一、HttpServletRequest、HttpServletResponse、HttpServletSession

二、java.security.Principal、Locale、InputStream、OutPutStream、Reader、Writer。</code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>乱码问题：</p>
<ul>
<li><p>请求或响应的乱码问题：当前台JSP页面和Java代码中使用了不同的字符集进行编码的时候就会出现表单提交的数据或者上传/下载中文名称文件出现乱码的问题；</p>
</li>
<li><p>解决请求或响应的乱码问题：使用<code>CharacterEncodingFilter(编码过滤器)</code>，是Spring内置过滤器的一种，用来指定请求或者响应的编码格式；</p>
<pre><code class="hljs xml">//在web.xml中配置编码过滤器，一定要在所有的filter的最前面配置该过滤器
<span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>SpringEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>

    <span class="hljs-comment">&lt;!--为CharacterEncodingFilter类中的encoding的属性赋值，该属性的作用是指定request的编码格式--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>

    <span class="hljs-comment">&lt;!--forceEncoding属性则表示，是否强制response的编码格式也是encoding属性值的编码格式--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>SpringEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!--Filter中的“/*”就等于是DispatcherServlet中“/”，也就是对所有请求进行过滤--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>返回数据给前台：使用ModelAndView对象，该对象是往Request作用域中存储处理完后的结果数据，以及返回要显示的视图；</p>
<pre><code class="hljs arduino"><span class="hljs-comment">//Controller层</span>

@RequestMapping(value=<span class="hljs-string">"/test"</span> , method=RequestMethod.POST)
<span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;
    
    <span class="hljs-comment">//创建一个ModelAndView对象</span>
    ModelAndView mav = <span class="hljs-keyword">new</span> ModelAndView();

    <span class="hljs-comment">//省略Service层    </span>

    <span class="hljs-comment">//存储数据，即存储放回的数据结果</span>
    mav.addObject(<span class="hljs-string">"username"</span>, <span class="hljs-string">"root"</span>);
    
    <span class="hljs-comment">//设置一个要返回的视图</span>
    mav.setViewName(<span class="hljs-string">"success"</span>);
    
    <span class="hljs-comment">//如果需要转发请求，或重定向，则</span>
    mav.setViewName(<span class="hljs-string">"forward:/路径"</span>);
    mav.setViewName(<span class="hljs-string">"redirect:/路径"</span>);

    <span class="hljs-keyword">return</span> mav ;
&#125;

拓展：除了使用ModelAndView往Request域中传输数据以外，也可以使用以下三种方式
<span class="hljs-comment">//方式一</span>
@RequestMapping(value=<span class="hljs-string">"/test"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">test</span><span class="hljs-params">(Map&lt;<span class="hljs-keyword">String</span>, Object&gt; <span class="hljs-built_in">map</span>)</span> </span>&#123;
    
    <span class="hljs-comment">//使用一个Map也可以往Request域中传值，但该方式最终仍然会封装成一个ModelAndView方式进行存储数据</span>
    <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">"username"</span>,<span class="hljs-string">"admin"</span>);
    
    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;
&#125;

<span class="hljs-comment">//方式二</span>
@RequestMapping(value=<span class="hljs-string">"/test"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">test</span><span class="hljs-params">(Model model)</span> </span>&#123;
    
    <span class="hljs-comment">//使用一个Model对象也可以往Request域中传值，该方式最终也会转封装成一个ModelAndView方式进行存储数据</span>
    model.addAttribute(<span class="hljs-string">"username"</span>,<span class="hljs-string">"张三"</span>);
    
    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;
&#125;

<span class="hljs-comment">//方式三</span>
@RequestMapping(value=<span class="hljs-string">"/test"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">test</span><span class="hljs-params">(HttpServletRequest req)</span> </span>&#123;
    
    <span class="hljs-comment">//Servlet原生API往Request域中传值</span>
    req.setAttribute(<span class="hljs-string">"username"</span>,<span class="hljs-string">"张三"</span>);
    
    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;
&#125;</code></pre>

</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>Spring MVC三大核心组件：<ul>
<li><code>处理器映射器(即HandlerMapping)</code>：用来帮助我们找到响应的Controller；</li>
<li><code>处理器适配器(即HandlerAdapter)</code>：帮助我们找到请求的资源所对应的方法；</li>
<li><code>视图解析器(即ViewResolver)</code>：获取ModelAndView之后，用视图解析器渲染HTML页面；</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p><code>&lt;mvc:annotation-driven&gt;和&lt;mvc:default-servlet-handler/&gt;</code>标签的作用；</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在SpringMVC.xml中配置标签就可以使用最新的核心组件，当然还有其他重要的功能，暂时不讲--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>


<span class="hljs-comment">&lt;!--</span>
<span class="hljs-comment">    SpringMVC将接收到的所有请求都看作是一个普通的请求，包括对于静态资源的请求；这样一来，所有对于静态资源的请求都会被看作是一个普通的后台控制器请求，导致请求找不到而报404异常错误；对于这个问题SpringMVC在全局配置文件中提供了一个&lt;mvc:default-servlet-handler/&gt;标签；在WEB容器启动的时候会在上下文中定义一个DefaultServletHttpRequestHandler，它会对DispatcherServlet的请求进行处理，如果该请求已经作了映射(就是在Controller层中找到了方法对该请求进行处理)，那么会接着交给后台对应的处理程序，如果没有作映射(也就是说可能是一个对静态资源的请求)，就交给 WEB 应用服务器默认的 Servlet 处理，从而找到对应的静态资源，只有再找不到资源时才会报错</span>
<span class="hljs-comment">--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span></code></pre>

</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>JSON的使用：</p>
<ul>
<li><p>定义：JSON是一种简单的数据交换格式；</p>
</li>
<li><p>种类：JSON中只有两种数据基本结构：</p>
<ul>
<li>一种是MAP(或者叫对象，即常说的JSON对象)；<ul>
<li>JSON对象：类似于java中的Map，标准的格式是“{}”，里面的内容是键值对，即key:value，中间是：号隔开，如果是不同的object，则它们之间用逗号隔开。<code>如，Var user = {name:hujie , age:21}，获取某个值的方式为user.name</code>；</li>
</ul>
</li>
<li>另一种是Array(即常说的JSON数组)。<ul>
<li>JSON数组：标准的格式为“[]”。<code>如，[value1, value2 ,value3...]</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p>Java对象与JSON的转换：</p>
<ul>
<li>Bean和Map都转换为JSON对象。<code>如，Var user = {name:hujie , age:21}</code>；</li>
<li>List转换为JSON数组。<code>如，[value1, value2 ,value3...]</code>；</li>
</ul>
</li>
<li><p>在Spring MVC中使用JSON；</p>
<pre><code class="hljs java"><span class="hljs-comment">//首先，导入Jackson的JAR包或者依赖</span>

&lt;!--对json的支持--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.9.9&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
    &lt;version&gt;2.9.9&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
    &lt;version&gt;2.9.9&lt;/version&gt;
&lt;/dependency&gt;

<span class="hljs-comment">//-----------------------------------------------------</span>

<span class="hljs-comment">//其次，配置SpringMVC对Jackson的支持，在web.xml中配置一个标签就行</span>
&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;

<span class="hljs-comment">//-----------------------------------------------------</span>

三、使用<span class="hljs-meta">@ResponseBody</span>注解

<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/getuser"</span>)
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserById</span><span class="hljs-params">()</span></span>&#123;

    User user = <span class="hljs-keyword">new</span> User();
    <span class="hljs-keyword">return</span> user;
&#125;

说明：<span class="hljs-meta">@responseBody</span>注解的作用是将Controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据；但要注意，在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据</code></pre>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>文件下载：</p>
<ul>
<li><p>了解：Http请求或响应报文其实都是字符串，当请求报文到Java程序会被封装为一个ServletInputStream流，开发人员再读取报文，响应报文则通过ServletOutputStream流，来输出响应报文；从流中只能读取到原始的字符串报文，同样输出流也是；那么在报文到达Spring MVC/SpringBoot和从Spring MVC/SpringBoot出去，都存在一个字符串到Java对象的转化问题；这一过程，在Spring MVC/SpringBoot中，是通过HttpMessageConverter来解决的；</p>
<p><img src="./Image-ssm12.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>Spring MVC实现文件下载的两种方式；</p>
<ul>
<li><p>基于ResponseEntity实现；</p>
<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/testHttpMessageDown"</span>)
<span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-keyword">byte</span>[]&gt; download(HttpServletRequest request) <span class="hljs-keyword">throws</span> IOException &#123;

    File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"E://123.jpg"</span>);

    InputStream is = <span class="hljs-keyword">new</span> FileInputStream(file);

    <span class="hljs-comment">//创建一个字节数组</span>
    <span class="hljs-keyword">byte</span>[] body = <span class="hljs-keyword">null</span>;

    <span class="hljs-comment">//获取所读取的文件所有的字节个数</span>
    body = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[is.available()];

    is.read(body);

    <span class="hljs-comment">//设置响应头信息</span>
    HttpHeaders headers = <span class="hljs-keyword">new</span> HttpHeaders();

    <span class="hljs-comment">//attchement是必须要设置的，告诉浏览器以附件的形式打开，也就是下载啦</span>
    headers.add(<span class="hljs-string">"Content-Disposition"</span>, <span class="hljs-string">"attchement;filename="</span> + file.getName());

    HttpStatus statusCode = HttpStatus.OK;

    ResponseEntity&lt;<span class="hljs-keyword">byte</span>[]&gt; entity = <span class="hljs-keyword">new</span> ResponseEntity&lt;<span class="hljs-keyword">byte</span>[]&gt;(body, headers, statusCode);

    <span class="hljs-keyword">return</span> entity;
&#125;</code></pre>
</li>
<li><p>Java通用下载实现(推荐使用这个)；</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">download</span><span class="hljs-params">(String fileName, String filePath, HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

    <span class="hljs-comment">//声明本次下载状态的记录对象</span>
    DownloadRecord downloadRecord = <span class="hljs-keyword">new</span> DownloadRecord(fileName, filePath, request);

    <span class="hljs-comment">//设置响应头和客户端保存文件名</span>
    response.setCharacterEncoding(<span class="hljs-string">"utf-8"</span>);
    response.setContentType(<span class="hljs-string">"multipart/form-data"</span>);
    response.setHeader(<span class="hljs-string">"Content-Disposition"</span>, <span class="hljs-string">"attachment;fileName="</span> + fileName);

    <span class="hljs-comment">//用于记录已完成的下载的数据量，单位是byte</span>
    <span class="hljs-keyword">long</span> downloadedLength = <span class="hljs-number">0l</span>;

    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">//打开本地文件流</span>
        InputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(filePath);

        <span class="hljs-comment">//根据reponse对象获得一个输出流，激活下载操作</span>
        OutputStream os = response.getOutputStream();

        <span class="hljs-comment">//循环写入输出流</span>
        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2048</span>];
        <span class="hljs-keyword">int</span> length;
        <span class="hljs-keyword">while</span> ((length = inputStream.read(b)) &gt; <span class="hljs-number">0</span>) &#123;
            os.write(b, <span class="hljs-number">0</span>, length);
            downloadedLength += b.length;
        &#125;


        <span class="hljs-comment">// 这里主要关闭。</span>
        os.close();
        inputStream.close();
    &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;
        downloadRecord.setStatus(DownloadRecord.STATUS_ERROR);
        <span class="hljs-keyword">throw</span> e;
    &#125;
    downloadRecord.setStatus(DownloadRecord.STATUS_SUCCESS);
    downloadRecord.setEndTime(<span class="hljs-keyword">new</span> Timestamp(System.currentTimeMillis()));
    downloadRecord.setLength(downloadedLength);
    <span class="hljs-comment">//存储记录</span>
&#125;</code></pre>
</li>
</ul>
</li>
<li><p>Spring MVC实现文件上传的方式；</p>
 <pre><code class="hljs java"><span class="hljs-comment">//一、导入依赖或JAR包，即commons-fileupload和commons-io，但是commons-io可以不用自己导入，maven会自动导入对应版本的JAR</span>

&lt;dependency&gt; 
    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; 
    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; 
    &lt;version&gt;1.3.2&lt;/version&gt; 
&lt;/dependency&gt;

<span class="hljs-comment">//---------------------------------------------------</span>

<span class="hljs-comment">//二、input的type设置为file、form表单的method设为post、form表单的enctype设置为multipart/form-data(意思是以二进制的形式传输数据)</span>

&lt;%@ page language=<span class="hljs-string">"java"</span> contentType=<span class="hljs-string">"text/html; charset=UTF-8"</span>
      pageEncoding=<span class="hljs-string">"UTF-8"</span>%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
  &lt;meta charset=<span class="hljs-string">"ISO-8859-1"</span>&gt;
  &lt;title&gt;Insert title here&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
      &lt;form action=<span class="hljs-string">"/ssm/file/imgUpload"</span> enctype=<span class="hljs-string">"multipart/form-data"</span> method=<span class="hljs-string">"post"</span>&gt;
          图片<span class="hljs-number">1</span>：&lt;input type=<span class="hljs-string">"file"</span> name=<span class="hljs-string">"file"</span>&gt;

          &lt;!--如果有批量上传图片：name属性必须一致
          图片<span class="hljs-number">2</span>：&lt;input type=<span class="hljs-string">"file"</span> name=<span class="hljs-string">"file"</span>&gt;
          图片<span class="hljs-number">3</span>：&lt;input type=<span class="hljs-string">"file"</span> name=<span class="hljs-string">"file"</span>&gt; --&gt;


          &lt;input type=<span class="hljs-string">"submit"</span> value=<span class="hljs-string">"上传"</span>&gt;
      &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;

<span class="hljs-comment">//---------------------------------------------------</span>

<span class="hljs-comment">//三、Springmvc.xml配置CommonsMultipartResolver，该解析器的作用是将用户上传的file文件转换成MultipartFile</span>

&lt;bean id=<span class="hljs-string">"multipartResolver"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;
    &lt;!--上传文件的最大大小，单位为字节 --&gt;
    &lt;property name="maxUploadSize" value="17367648787"&gt;&lt;/property&gt;
     
    &lt;!-- 上传文件的编码 --&gt;
    &lt;property name="defaultEncoding" value="UTF-8"&gt;&lt;/property&gt;
&lt;/bean&gt;

<span class="hljs-comment">//---------------------------------------------------</span>

<span class="hljs-comment">//四、使用MultipartFile对象作为参数，接收前端发送过来的文件，将文件写入本地文件中，就完成了上传操作</span>

<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/upload"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upload</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"file"</span>)</span> MultipartFile file, HttpServletRequest req) <span class="hljs-keyword">throws</span> IllegalStateException, IOException </span>&#123;  <span class="hljs-comment">//接收批量图片，把MultipartFile改成MultipartFile[]就行，然后遍历MultipartFile数组，逐个复制就行了</span>


    <span class="hljs-comment">// 判断文件是否为空，空则返回失败页面</span>
    <span class="hljs-keyword">if</span> (file.isEmpty()) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"failed"</span>;
    &#125;

    <span class="hljs-comment">// 获取文件存储路径（绝对路径）</span>
    String path = req.getServletContext().getRealPath(<span class="hljs-string">"/WEB-INF/file"</span>);

    <span class="hljs-comment">// 获取原文件名</span>
    String fileName = file.getOriginalFilename();

    <span class="hljs-comment">// 创建文件实例</span>
    File filePath = <span class="hljs-keyword">new</span> File(path, fileName);

    <span class="hljs-comment">// 如果文件目录不存在，创建目录</span>
    <span class="hljs-keyword">if</span> (!filePath.getParentFile().exists()) &#123;

        filePath.getParentFile().mkdirs();
        System.out.println(<span class="hljs-string">"创建目录"</span> + filePath);
    &#125;

    <span class="hljs-comment">// 写入文件</span>
    file.transferTo(filePath);

    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;
&#125;</code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>Spring MVC是单例模式的原因；</p>
<ul>
<li><p>原因：Spring MVC默认是单例的，不需要每次请求都要创建对象，因为都是通过Spring管理的，直接通过注入的方式获取对象；Spring MVC变成(Controller)多例的解决方案：</p>
<ul>
<li><p>通过注解<code>@Scope(“prototype”)</code>，将其设置为多例模式(但是这样效率不高，不建议这样做)；</p>
<ul>
<li><p>影响：对于多例情况普通属性是不会共用的，不会产生影响，对于静态属性会去共用这个属性；对于单例情况普通属性和静态属性都会被共用；</p>
<pre><code class="hljs java"><span class="hljs-comment">//Controller多例模式</span>

<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/test"</span>)
<span class="hljs-meta">@Scope</span>(value=<span class="hljs-string">"prototype"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-title">UserController</span><span class="hljs-params">(）&#123;</span></span>
<span class="hljs-function"><span class="hljs-params"></span></span>
<span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;</span></span>
<span class="hljs-function"><span class="hljs-params"></span></span>
<span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> staticIndex = <span class="hljs-number">0</span>;</span></span>
<span class="hljs-function"><span class="hljs-params"></span></span>
<span class="hljs-function"><span class="hljs-params">    System.out.println(<span class="hljs-string">"普通属性："</span>+(index++)</span>+"--------分割线--------"+"静态属性："+<span class="hljs-params">(staticIndex++)</span>)</span>;

    <span class="hljs-comment">//输出结果为</span>
    <span class="hljs-comment">//普通属性：0--------分割线--------静态属性：0</span>

    <span class="hljs-comment">//普通属性：0--------分割线--------静态属性：1</span>

    <span class="hljs-comment">//普通属性：0--------分割线--------静态属性：2</span>

    <span class="hljs-comment">//普通属性：0--------分割线--------静态属性：3</span>
&#125;

<span class="hljs-comment">//-----------------------------------------------------------------</span>

<span class="hljs-comment">//Controller单例模式</span>

<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/test"</span>)
<span class="hljs-meta">@Scope</span>(value=<span class="hljs-string">""</span>singleton)
<span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-title">UserController</span><span class="hljs-params">(）&#123;</span></span>
<span class="hljs-function"><span class="hljs-params"></span></span>
<span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;</span></span>
<span class="hljs-function"><span class="hljs-params"></span></span>
<span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> staticIndex = <span class="hljs-number">0</span>;</span></span>
<span class="hljs-function"><span class="hljs-params"></span></span>
<span class="hljs-function"><span class="hljs-params">    System.out.println(<span class="hljs-string">"普通属性："</span>+(index++)</span>+"--------分割线--------"+"静态属性："+<span class="hljs-params">(staticIndex++)</span>)</span>;

    <span class="hljs-comment">//输出结果为</span>

    <span class="hljs-comment">//普通属性：0--------分割线--------静态属性：0</span>

    <span class="hljs-comment">//普通属性：1--------分割线--------静态属性：1</span>

    <span class="hljs-comment">//普通属性：2--------分割线--------静态属性：2</span>

    <span class="hljs-comment">//普通属性：3--------分割线--------静态属性：3</span>

&#125;
说明：尽量不要在Controller里面去定义属性，如果在特殊情况需要定义属性的时候，那么就在类上面加上注解<span class="hljs-meta">@Scope</span>(<span class="hljs-string">"prototype"</span>)改为多例的模式，但是不建议这么做，因为，一旦Controller中定义了许多属性，那么单例访问就会出现安全问题，所以在Controller中定义了属性，就添加<span class="hljs-meta">@Scope</span>(<span class="hljs-string">"prototype"</span>)注解，使得Controller变成多例</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>Spring MVC的自定义拦截器的使用和理解；</p>
<ul>
<li><p>Spring MVC的拦截器主要作用也是在服务端真正处理请求前后进行一些相关的操作。<code>如，初始化资源，权限监控，会话设置，菜单获取，资源清理等</code>；</p>
<ul>
<li><p>自定义拦截器一般继承自HandlerInterceptorAdapter或者实现HandlerInterceptor接口。</p>
<ul>
<li><p>实现接口需要实现对应的3个方法，也就是preHandle，postHandle，afterCompletion这三个方法，所以我们首先需要编写一个普通类实现上面提到的拦截器接口或者继承拦截器类即可。</p>
</li>
<li><p>继承父类只需要实现需要的方法即可。</p>
<pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.dyf.interceptor

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HandlerInterceptorAdapter</span> </span>&#123;

     <span class="hljs-comment">//preHandle方法是进行处理器拦截用的，顾名思义，该方法将在Controller处理之前进行调用，SpringMVC中的Interceptor拦截器是链式的，可以同时存在多个Interceptor，然后SpringMVC会根据声明的前后顺序一个接一个的执行，而且所有的Interceptor中的preHandle方法都会在Controller方法调用之前调用；SpringMVC的这种Interceptor链式结构也是可以进行中断的，这种中断方式是令preHandle的返回值为false，当preHandle的返回值为false的时候整个请求就结束了；这种方式，如果返回false，一般情况需要重定向或者转发到其他页面，采用request的转发或者response的重定向即可</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;&#125;

     <span class="hljs-comment">//这个方法只会在当前这个Interceptor的preHandle方法返回值为true的时候才会执行；postHandle是进行处理器拦截用的，它的执行时间是在处理器进行处理之后，也就是在Controller的方法调用之后执行，但是它会在DispatcherServlet进行视图的渲染之前执行，也就是说在这个方法中你可以对ModelAndView进行操作；这个方法的链式结构跟正常访问的方向是相反的，也就是说先声明的Interceptor拦截器该方法反而会后调用，这跟Struts2里面的拦截器的执行过程有点像，只是Struts2里面的intercept方法中要手动的调用ActionInvocation的invoke方法，Struts2中调用ActionInvocation的invoke方法就是调用下一个Interceptor或者是调用action，然后要在Interceptor之前调用的内容都写在调用invoke之前，要在Interceptor之后调用的内容都写在调用invoke方法之后</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;&#125;

    <span class="hljs-comment">//该方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行；该方法将在整个请求完成之后，也就是DispatcherServlet渲染了视图执行， 这个方法的主要作用是用于清理资源的</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;&#125;
&#125;

说明：HandlerInterceptor接口的方法(或者说继承自HandlerInterceptorAdapter类需要重写的三个方法)
一、preHandle：在handler方法之前被调用；
	<span class="hljs-number">1</span>.返回值为<span class="hljs-keyword">true</span>：继续调用后续的其他拦截器和目标方法
	<span class="hljs-number">2</span>.返回值为<span class="hljs-keyword">false</span>：不继续调用后续的其他拦截器和目标方法
	<span class="hljs-number">3</span>.使用场景：权限检查、日志、事务。

二、postHandle：调用handler方法之后，渲染视图之前被调用；
	<span class="hljs-number">1</span>.使用场景：修改请求域属性,修改视图

三、afterCompletion：渲染视图之后被调用；
	<span class="hljs-number">1</span>.使用场景：释放资源</code></pre>
</li>
</ul>
</li>
<li><p>在SpringMVC的配置文件中配置自定义好的拦截器后，并声明和添加过滤规则。</p>
<pre><code class="hljs java">&lt;mvc:interceptors&gt;
    &lt;!-- 这种方式表示默认拦截所有请求 --&gt;
    &lt;bean id=<span class="hljs-string">"xxx"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"cn.dyf.interceptor.MyInterceptor"</span>/&gt;

    &lt;!--这种方式也是默认拦截所有请求，但是要求拦截器类上必须要有<span class="hljs-meta">@Component</span>注解，该注解的作用是告诉Spring这是一个普通的组件类，帮我生成对应的bean对象即可，id默认是类名首字母小写。如，MyInterceptor拦截器类的默认生成的bean的id为myInterceptor--&gt;
    &lt;ref bean=<span class="hljs-string">"myInterceptor"</span>&gt;

    &lt;!--设置自定义要拦截的方式--&gt;
    &lt;mvc:interceptor&gt;
        &lt;!--对特定的请求进行拦截--&gt;
        &lt;mvc:mapping path=<span class="hljs-string">"/**"</span> /&gt;

        &lt;!-- 排除拦截的链接 --&gt;
        &lt;mvc:exclude-mapping path=<span class="hljs-string">"/static/**"</span> /&gt;

        &lt;bean <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"要使用的某个指定的拦截器"</span> /&gt;
    &lt;/mvc:interceptor&gt;

&lt;/mvc:interceptors&gt;</code></pre>
</li>
</ul>
</li>
<li><p>多个拦截器的执行流程图；</p>
<p><img src="./Image-ssm13.png" srcset="/img/loading.gif" alt="Image"></p>
<pre><code class="hljs java">说明：
拦截器<span class="hljs-number">1</span>的preHandle方法执行，不符合请求规则的返回<span class="hljs-keyword">false</span>，不走后台去处理，否则就返回<span class="hljs-keyword">true</span>；
拦截器<span class="hljs-number">2</span>的preHandle方法执行，不符合请求规则的返回<span class="hljs-keyword">false</span>，不走后台去处理，否则就返回<span class="hljs-keyword">true</span>；
拦截器<span class="hljs-number">2</span>的preHandle方法为<span class="hljs-keyword">true</span>后，交给后台处理请求，得到响应的数据(此时还没有渲染视图)，调用拦截器<span class="hljs-number">2</span>的postHandle方法；
拦截器<span class="hljs-number">2</span>的postHandle方法调用完毕，再调用拦截器<span class="hljs-number">1</span>的postHandle方法；
调用拦截器<span class="hljs-number">2</span>的afterCompletion方法，最后调用拦截器<span class="hljs-number">1</span>的afterCompletion方法，返回用户想要的响应；</code></pre>
</li>
<li><p>过滤器和拦截器的区别以及各自的执行顺序；</p>
<p><img src="./Image-ssm14.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-ssm15.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-ssm16.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>Spring MVC对异常的处理方式：</p>
<ul>
<li><p>第一种是使用HandlerExceptionResolver接口，并且Spring已经提供默认的实现类SimpleMappingExceptionResolver；我们一般在项目中使用第一种方式；</p>
<pre><code class="hljs java"><span class="hljs-comment">//使用这种方式只需要实现resolveException方法，该方法返回一个ModelAndView对象，在方法内部对异常的类型进行判断，然后返回合适的ModelAndView对象，如果该方法返回了null，则Spring会继续寻找其他的实现了HandlerExceptionResolver接口的Bean；换句话说，Spring会搜索所有注册在其环境中的实现了HandlerExceptionResolver接口的Bean，逐个执行，直到返回了一个ModelAndView对象；</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">xxxExceptionHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerExceptionResolver</span> </span>&#123;  
  
    <span class="hljs-meta">@Override</span>  
    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object object, Exception exception)</span> </span>&#123;  
        <span class="hljs-keyword">if</span>(exception <span class="hljs-keyword">instanceof</span> IOException)&#123;  
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">"ioexp"</span>);  

        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(exception <span class="hljs-keyword">instanceof</span> SQLException)&#123;  
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">"sqlexp"</span>);  
        &#125;  
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;  
    &#125;  
&#125;

<span class="hljs-comment">//------------------------------------------------------------------------</span>

<span class="hljs-comment">//这个类必须声明到Spring配置文件中，或者使用@Component标签，让Spring管理它；同时Spring也提供默认的实现类SimpleMappingExceptionResolver，需要使用时只需要使用注入到Spring配置文件进行声明即可；自定义实现类与默认的实现类，可同时使用</span>

&lt;!-- 自定义的异常实现类注入 --&gt;
&lt;bean id=<span class="hljs-string">"exceptionHandler"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"cn.dyf.exception.xxExceptionHandler"</span>/&gt;

&lt;!-- 默认的异常实现类注入 --&gt;
&lt;bean <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"</span>&gt;  

    &lt;!-- 为所有的异常定义默认的异常处理页面，exceptionMappings未定义的异常使用本默认配置 --&gt;  
    &lt;property name="defaultErrorView" value="error"&gt;&lt;/property&gt;  

    &lt;!-- 定义异常处理页面用来获取异常信息的变量名，也就是你要获取异常信息的时候，需要一个变量名来获取，而这个默认的变量名为exception，也可以自定义 --&gt;  
    &lt;property name="exceptionAttribute" value="ex"&gt;&lt;/property&gt;  

    &lt;!--
　　　　定义需要特殊处理的异常，用类名或完全路径名作为key，异常页文件名作为值，
　　　　将不同的异常映射到不同的页面上。
　　 --&gt;  
    &lt;property name=<span class="hljs-string">"exceptionMappings"</span>&gt;  
        &lt;props&gt;  
            &lt;prop key="IOException"&gt;error/ioexp&lt;/prop&gt;  
            &lt;prop key="java.sql.SQLException"&gt;error/sqlexp&lt;/prop&gt;  
        &lt;/props&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;</code></pre>
</li>
<li><p>另一种使用@ExceptionHandler注解实现异常处理，需每一个controller都继承自该类，但对于代码的侵入性大，一般不用。</p>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="Lesson4-SSM整合"><a href="#Lesson4-SSM整合" class="headerlink" title="Lesson4 SSM整合"></a>Lesson4 SSM整合</h2><h3 id="NO4-1-SSM基本代码整合"><a href="#NO4-1-SSM基本代码整合" class="headerlink" title="NO4.1 SSM基本代码整合"></a>NO4.1 SSM基本代码整合</h3><p>整合SSM框架是必备的知识。</p>
<ul>
<li><p>SSM框架整合：</p>
<ul>
<li><p>首先创建项目；</p>
</li>
<li><p>导入SSM整合的JAR包；</p>
</li>
<li><p>在src下创建com.dyf.mapper(即原Dao)、com.dyf.service(即原Service)、com.dyf.controller(即原Web)的包结构；</p>
</li>
<li><p>在项目下创建Source Folder专门放置配置文件，即：MyBatis的核心配置文件sqlMapConfig.xml和applicationContext-dao.xml(这是整合spring后，分层)、Spring的核心配置文件applicationContext-service.xml、Spring MVC的Spring MVC.xml、日志信息log4j.properties、阿里巴巴德鲁伊连接池配置文件druid.properties；</p>
</li>
<li><p>在Spring整合MyBatis的核心配置文件applicationContext-dao.xml中，管理MyBatis的一些数据；</p>
<ul>
<li><p>加载数据库配置；</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 1.加载数据库的druid.properties配置文件，四要素：驱动、请求资源、数据库账号、数据库密码 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:druid.properties"</span> /&gt;</span>

<span class="hljs-comment">&lt;!-- 1.1配置阿里巴巴的druid连接池 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.alibaba.druid.pool.DruidDataSource"</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">"close"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClassName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;driverClassName&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;url&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;usernames&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;password&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
</li>
<li><p>配置sqlSessionFactory和mapper代理开发；</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 2.这是配置sqlSessionFactory和mapper代理开发 --&gt;</span>
<span class="hljs-comment">&lt;!-- 2.1.1.配置spring管理sqlSessionFactory --&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sqlSessionFactory"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 2.1.2.让spring管理sqlSessionFactory，就需要数据库连接池 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 2.2.1.这是配置mapper代理形式 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"basePackage"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"dyf.mapper"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
</li>
<li><p>在Spring的核心配置文件applicationContext-service.xml中配置；</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 1.只需要配置Service的IOC注解开发的扫描器即可 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"com.dyf.service"</span> /&gt;</span>

<span class="hljs-comment">&lt;!-- 2.配置事务平台管理器 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"transactionManager"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span> /&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 开启注解事务 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span> /&gt;</span>

<span class="hljs-comment">&lt;!--上面和下面二选一，即注解事务，和XML事务二选一--&gt;</span>

<span class="hljs-comment">&lt;!-- 配置事务的属性 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txAdvice"</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- 配置事务的传播行为 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"save*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"insert*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"add*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"create*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"delete*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"update*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> /&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"find*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"SUPPORTS"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"true"</span> /&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"select*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"SUPPORTS"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"true"</span> /&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"get*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"SUPPORTS"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"true"</span> /&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span>


<span class="hljs-comment">&lt;!-- 配置事务的切入点，以及把事务与切入点关联起来 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">"txAdvice"</span> <span class="hljs-attr">pointcut</span>=<span class="hljs-string">"execution(* dyf.*.*(..))"</span> /&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre>
</li>
<li><p>在Spring MVC的Spring MVC.xml中：</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 1.配置SpringMVC的Controller注解扫描 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"dyf.controller"</span> /&gt;</span>

<span class="hljs-comment">&lt;!-- 2.配置使用最新的处理器映射器、处理器适配器 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> /&gt;</span>

<span class="hljs-comment">&lt;!-- 3.配置视图处理器：jsp --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jspViewResolver"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 3.1配置输入资源地址时：直接输入/页面 ，即可 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/WEB-INF/jsp/"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".jsp"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
</li>
<li><p>最后，在web.xml中，配置Spring MVC的前端控制器DispatcherServlet以及监听器(为了在加载Spring工厂时，只生产一个工厂，并将工厂放入servletContext，后面直接获取即可)；</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 1.配置SpringMVC的前端控制器DispatcherServlet --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>SpringMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>

    <span class="hljs-comment">&lt;!--1.1这是修改初始化默认加载配置文件的位置，原本默认加载/WEB-INF/XXX-servlet.xml位置的配置文件，修改成如下 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>SpringMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.action<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 2.配置监听器，加载Spring工厂，是为了只生产一个工厂，并将工厂放入servletContext --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 2.1指定加载的Spring配置文件 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext-*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span></code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/1-%EB%8C%80%ED%95%99%EA%B5%90-%EC%9D%BC-%ED%95%99%EB%85%84/">1.대학교 일 학년</a>
                    
                      <a class="hover-with-bg" href="/categories/1-%EB%8C%80%ED%95%99%EA%B5%90-%EC%9D%BC-%ED%95%99%EB%85%84/03-Java/">03.Java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%A4%A7%E4%B8%80%E8%AF%BE%E7%A8%8B/">大一课程</a>
                    
                      <a class="hover-with-bg" href="/tags/SSM/">SSM</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/07/07/SpringBoot--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">04.SpringBoot--学习笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/07/03/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                        <span class="hidden-mobile">01.前端基础--学习笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "03.SSM框架--学习笔记&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
