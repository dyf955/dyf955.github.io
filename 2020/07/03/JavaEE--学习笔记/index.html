<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="o一行瑠璃o">
  <meta name="keywords" content="学习笔记,Java,C">
  <title>02.JavaEE--学习笔记 - 知晓天空之蓝的人啊</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Hello World</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                目录
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/indexbg/sun.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-07-03 11:19">
      2020年7月3日 上午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.8k 字
    </span>
  

  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="JavaEE–学习笔记-包含JavaEE视频"><a href="#JavaEE–学习笔记-包含JavaEE视频" class="headerlink" title="JavaEE–学习笔记(包含JavaEE视频)"></a>JavaEE–学习笔记(包含JavaEE视频)</h1><h2 id="Lesson1-JavaEE基础"><a href="#Lesson1-JavaEE基础" class="headerlink" title="Lesson1 JavaEE基础"></a>Lesson1 JavaEE基础</h2><h3 id="NO1-1-JDBC与事务"><a href="#NO1-1-JDBC与事务" class="headerlink" title="NO1.1 JDBC与事务"></a>NO1.1 JDBC与事务</h3><p>我们常说的操作数据库，其实指的是操作DBMS，即操作数据库管理系统。</p>
<ul>
<li><p>数据库：</p>
<ul>
<li><p>MySQL数据库细节部分，请参考另一篇博客，这里不做过多叙述。</p>
</li>
<li><p>原生JDBC连接数据库：</p>
<ul>
<li><p>定义：JDBC即Java与数据库的连接，建立连接之后，就可以使用Java与数据库进行交互；</p>
</li>
<li><p>应用：</p>
<ul>
<li><p>首先，熟悉JDBC的核心，即三个接口和一个类；</p>
<ul>
<li>DriverManager：驱动管理类，帮助我们加载驱动；</li>
<li>Connection：数据库连接接口，实现类在驱动中；</li>
<li>Statement：执行SQL语句的接口，实现类在驱动中；</li>
<li>Result：结果集接口，实现类在驱动中；</li>
</ul>
</li>
<li><p>然后，编写原生JDBC开发；</p>
<ul>
<li><p>导入数据库驱动包或Maven导入相应的依赖；</p>
</li>
<li><p>注册驱动：</p>
<pre><code class="hljs java">Class.forName(com.mysql.jdbc.Driver);</code></pre>
</li>
<li><p>获取连接(四大要素：驱动、需要连接的数据库字符串、用户名、密码)，前提是必须注册驱动：</p>
<pre><code class="hljs java">Connection conn = DriverManager.getConnection(<span class="hljs-string">"jdbc:mysql://IP地址:3306/数据库名称"</span>,<span class="hljs-string">"用户名"</span>,<span class="hljs-string">"密码"</span>);</code></pre>
</li>
<li><p>获取sql语句预处理对象：</p>
<pre><code class="hljs java">PreparedStatement pst = conn.prepareStatement(String sql);

pst.setObject(<span class="hljs-string">"占位符序列号"</span>,<span class="hljs-string">"具体的参数值"</span>);

注意：这里设置的是上面sql语句中的占位符?的值，例如select * from userwhere uid = ?</code></pre>
</li>
<li><p>使用sql语句执行对象执行操作，并获取结果集：</p>
<pre><code class="hljs java"><span class="hljs-keyword">int</span> rows = pst.executeUpdate();  <span class="hljs-comment">//增删改操作，返回的是影响的行数，可以根据这个值来判断操作是否成功</span>

ResultSet rs = pst.executeQuery();  <span class="hljs-comment">//查询操作</span></code></pre>
</li>
<li><p>处理结果集(只针对查询操作)，循环遍历操作：</p>
<pre><code class="hljs java">rs.next();  <span class="hljs-comment">//判断是否有下一条记录</span>

结果集对象rs.getObject(<span class="hljs-string">"字段名"</span>)  <span class="hljs-comment">//获取具体的值</span>


拓展：结果集的处理方法
一、结果集第一种处理方法：ArrayHandler，将结果集的第一行存储到对象数组中Object[]；

二、结果集第二种处理方法：ArrayListHandler，将结果集的每一行，封装到对象数组中，出现很多对象数组，对象数组存储到List集合；

三、结果集第三种处理方法：BeanHandler，将结果集的第一行数据，封装成JavaBean对象(常用)；注意：被封装成到JavaBean对象，JavaBean类必须有无参构造；

四、结果集第四种处理方法：BeanListHandler，结果集每一行数据，封装JavaBean对象，多个JavaBean对象，存储到List集合(常用)；

五、结果集第五种处理方法：ColumnListHandler，将指定列的数据，存储到List集合，List&lt;Object&gt; 每个列数据类型不同；

六、结果集第六种处理方法：ScalarHandler，对于查询后，只有<span class="hljs-number">1</span>个结果(常用)；

七、结果集第七种处理方法：MapHandler，将结果集第一行数据，封装到Map集合中，Map&lt;键,值&gt; 键：列名，值：这列的数据；

八、结果集第八种处理方法：MapListHandler，将结果集每一行存储到Map集合，键：列名，值：数据，Map集合过多，存储到List集合；</code></pre>
</li>
<li><p>释放资源：</p>
<pre><code class="hljs java">conn.close();  <span class="hljs-comment">//关闭链接对象</span>
                
pst.close();  <span class="hljs-comment">//关闭SQL语句预处理对象</span>

rs.close();  <span class="hljs-comment">//只针对查询操作</span></code></pre>


</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>-   编写JDBCUtils工具类用于加载驱动和获取连接对象：

    <pre><code class="hljs java"><span class="hljs-comment">/***</span>
<span class="hljs-comment"> * JDBC工具类</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 邓燕飞</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCUtils</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String driverName = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String url = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String username = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String password = <span class="hljs-keyword">null</span>;

    <span class="hljs-comment">// 数据库的驱动没有必要每一次调用都加载，放在static代码块中，只加载一次即可</span>
    <span class="hljs-keyword">static</span> &#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//加载四大要素配置文件</span>
            <span class="hljs-comment">//使用Map集合Properties加载配置文件</span>
            Properties pp = <span class="hljs-keyword">new</span> Properties();
            pp.load(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"jdbc_config.properties"</span>));

            <span class="hljs-comment">//从配置文件对象中获取驱动、需要连接的数据库字符串、数据库账号、数据库密码</span>
            driverName = pp.getProperty(<span class="hljs-string">"driverName"</span>);
            url = pp.getProperty(<span class="hljs-string">"url"</span>);
            username = pp.getProperty(<span class="hljs-string">"username"</span>);
            password = pp.getProperty(<span class="hljs-string">"password"</span>);
            
            <span class="hljs-comment">// 加载驱动</span>
            Class.forName(driverName);

        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            <span class="hljs-comment">// 驱动出错，则后面的代码没必要继续执行，抛出异常，直接终止程序；</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"数据库驱动加载出错..."</span>);
        &#125;
    &#125;


    <span class="hljs-comment">/***</span>
<span class="hljs-comment">     * 这是获取数据库的连接的对象</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回一个连接对象</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-comment">// 获取与数据库的连接</span>
        Connection conn = DriverManager.getConnection(url, username, password);

        <span class="hljs-comment">// 返回连接对象</span>
        <span class="hljs-keyword">return</span> conn;
    &#125;


    <span class="hljs-comment">/***</span>
<span class="hljs-comment">     * 这是关闭连接对象，执行语句对象，结果集对象的方法</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> conn 这是连接对象</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> st 执行语句对象</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rs 结果集对象</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeAll</span><span class="hljs-params">(Connection conn, PreparedStatement ps,ResultSet rs)</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">if</span> (conn != <span class="hljs-keyword">null</span>) &#123;
                conn.close();
            &#125;

            <span class="hljs-keyword">if</span> (ps != <span class="hljs-keyword">null</span>) &#123;
                ps.close();
            &#125;

            <span class="hljs-keyword">if</span> (rs != <span class="hljs-keyword">null</span>) &#123;
                rs.close();
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;
            System.out.println(<span class="hljs-string">"资源关闭出错啦..."</span>);
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>

-   编写C3P0Utils连接池工具类：**`注意：C3P0连接池不需要手动加载配置文件，只需将c3p0-config.xml文件放入src目录下，C3P0连接池会自动去找配置文件并加载里面的配置。`**

    <pre><code class="hljs java">c3p0-config.xml文件

&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;
&lt;c3p0-config&gt;
    &lt;<span class="hljs-keyword">default</span>-config&gt;
        &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt;
        &lt;property name=<span class="hljs-string">"jdbcUrl"</span>&gt;jdbc:mysql:<span class="hljs-comment">//localhost:3306/dbtest&lt;/property&gt;</span>
        &lt;property name="user"&gt;root&lt;/property&gt;
        &lt;property name="password"&gt;Deng521314&lt;/property&gt;
        &lt;property name="initialPoolSize"&gt;10&lt;/property&gt;
    &lt;/default-config&gt;
&lt;/c3p0-config&gt;

<span class="hljs-comment">//--------------------------------------</span>

<span class="hljs-comment">//C3P0Utils连接池工具类；</span>

<span class="hljs-comment">/***</span>
<span class="hljs-comment"> * C3P0也实现了javax.sql.DataSource接口，实现类：ComboPooledDataSource</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C3P0Utils</span> </span>&#123;

    <span class="hljs-comment">//创建C3P0连接池</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ComboPooledDataSource C3P0_dataSource =<span class="hljs-keyword">new</span> ComboPooledDataSource();

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 0.获取C3P0连接池对象的方法getDataSource()</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回一个C3P0连接池对象</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-comment">//供给DBUtils的连接池对象</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataSource <span class="hljs-title">getDataSource</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> C3P0_dataSource;
    &#125;



    <span class="hljs-comment">/***</span>
<span class="hljs-comment">     * 1.获取数据库的连接对象的方法getConnection()</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回一个连接对象</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;
        Connection conn = C3P0_dataSource.getConnection();
        <span class="hljs-keyword">return</span> conn;
    &#125;

     <span class="hljs-comment">/***</span>
<span class="hljs-comment">      * 2.这是关闭连接对象，执行语句对象，结果集对象的方法closeAll()</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> conn 这是连接对象</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> st 执行语句对象</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rs 结果集对象</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeAll</span><span class="hljs-params">(Connection conn, PreparedStatement ps,ResultSet rs)</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">if</span> (conn != <span class="hljs-keyword">null</span>) &#123;
                conn.close();
            &#125;
            <span class="hljs-keyword">if</span> (ps != <span class="hljs-keyword">null</span>) &#123;
                ps.close();
            &#125;
            <span class="hljs-keyword">if</span> (rs != <span class="hljs-keyword">null</span>) &#123;
                rs.close();
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;
            System.out.println(<span class="hljs-string">"资源关闭出错啦..."</span>);
            e.printStackTrace();
        &#125;
    &#125;
&#125;

注意：C3P0连接池不要加载配置文件，只需将c3p0-config.xml文件放入src目录下，C3P0连接池会自动去找配置文件加载里面的配置</code></pre>

-   DBUtils中：

    -   只需要创建QueryRunner类对象；

    -   处理结果集(将获取到的对象封装到JavaBean中，所以domain类的属性要和数据库表中字段名一致)即可。

        <pre><code class="hljs java"><span class="hljs-comment">//不带事务</span>

<span class="hljs-comment">//获取C3P0工具类的C3P0连接池对象</span>
DataSource ds = C3P0Utils.getDataSource();

<span class="hljs-comment">//1.创建QueryRunner类对象，因为没有事务，所以需要传入连接池对象；</span>
<span class="hljs-comment">//2.这样update或query方法内部就调用this.getconnection方法来从这个数据源获得连接对象，操作完后，就关闭conneciton,preparedstatement和resultset对象.</span>
QueryRunner qr = <span class="hljs-keyword">new</span> QueryRunner(ds);

<span class="hljs-comment">//添加操作</span>
<span class="hljs-comment">//qr.update("insert into users (uid,uname,uage) values (?,?,?)", 2,"二哈狗子",2);</span>

<span class="hljs-comment">//查询操作</span>
List&lt;Users&gt; query = qr.query(<span class="hljs-string">"select * from users"</span>,<span class="hljs-keyword">new</span> BeanListHandler&lt;Users&gt;(Users<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;

<span class="hljs-comment">//遍历集合，打印集合元素</span>
<span class="hljs-keyword">for</span> (Users users : query) &#123;
    System.out.println(users);
&#125;

    
<span class="hljs-comment">//------------------------------------------</span>
    
<span class="hljs-comment">//带事务</span>
Connection conn = <span class="hljs-keyword">null</span>;

<span class="hljs-comment">//1.带事务操作，不需要连接池对象，这种情况下，调用update或query方法时，需要传入对应的connection参数</span>
<span class="hljs-comment">//2.DBUtils调用这种带connection参数的方法时，只会关闭preparedstatement和resultset对象，不会关闭conneciton对象，就是为了允许其他方法来使用这个conneciton；</span>
QueryRunner qr = <span class="hljs-keyword">new</span> QueryRunner();

<span class="hljs-keyword">try</span>&#123;
    conn = C3P0Utils.getConnection();

    <span class="hljs-comment">//MySQL是自动提交事务，关闭自动事务提交，即开启手动事务提交</span>
    conn.setAutoCommit(<span class="hljs-keyword">false</span>);

    <span class="hljs-comment">//给小仙女转账</span>
    qr.update(conn, <span class="hljs-string">"update mybank set money=money-? where name=?"</span>,<span class="hljs-number">1000</span>,<span class="hljs-string">"邓先森"</span>);

    <span class="hljs-comment">//模拟转账失败</span>
    <span class="hljs-comment">//System.out.println(1/0);</span>

    <span class="hljs-comment">//小仙女收钱</span>
    qr.update(conn, <span class="hljs-string">"update mybank set money=money+? where name=?"</span>,<span class="hljs-number">1000</span>,<span class="hljs-string">"小仙女"</span>);

    <span class="hljs-comment">//提交事务</span>
    conn.commit();
&#125;<span class="hljs-keyword">catch</span> (SQLException e) &#123;
    e.printStackTrace();
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">//事务回滚</span>
        conn.rollback();
    &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;
        e.printStackTrace();
    &#125;
&#125;<span class="hljs-keyword">finally</span> &#123;
    conn.close();
&#125;</code></pre>

-   `ThreadLocal&lt;T&gt;`：线程局部变量，作用是为每一个线程，提供一个存储数据的空间，`&lt;T&gt;`：泛型是设置值的类型，一般是连接对象类；它有两个方法：

    -   `get()`：获取值的方法，它是以当前线程对象作为键，从map中取值，内部原码：map.get(Thread.currentThread())；

    -   `set(Object obj)`：设置值的方法，以当前线程对象作为键，将obj存储到map中，内部原码：map.set(Thread.currentThread,obj)。

        <pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionManager</span> </span>&#123;
    
        <span class="hljs-comment">//创建一个ThreadLocal集合</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Connection&gt; tl = <span class="hljs-keyword">new</span> ThreadLocal&lt;Connection&gt;();
    
        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 1.获取连接对象的方法</span>
<span class="hljs-comment">         * <span class="hljs-doctag">@return</span> 连接对象</span>
<span class="hljs-comment">         * <span class="hljs-doctag">@throws</span> SQLException</span>
<span class="hljs-comment">         */</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;
    
            <span class="hljs-comment">//第一次获取时，肯定是null</span>
            Connection conn = tl.get();
    
            <span class="hljs-comment">//判断是Service层(第一次)还是Dao(第二次以上)层获取连接对象</span>
            <span class="hljs-keyword">if</span>(conn==<span class="hljs-keyword">null</span>) &#123;
    
                <span class="hljs-comment">//如果是第一次获取，则从连接池获取一个连接对象</span>
                conn = C3P0Utils.getConnection();
                
                <span class="hljs-comment">//放入ThreadLocal集合中</span>
                tl.set(conn);
            &#125;
    
            <span class="hljs-comment">//返回连接对象；如果是第二次以上获取连接对象，则直接返回连接对象即可</span>
            <span class="hljs-keyword">return</span> conn;
        &#125;
    
    
        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 2.开启事务的方法</span>
<span class="hljs-comment">         * <span class="hljs-doctag">@throws</span> SQLException</span>
<span class="hljs-comment">         */</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startTransaction</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;
            ConnectionManager.getConnection().setAutoCommit(<span class="hljs-keyword">false</span>);
        &#125;
    
    
        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 3.提交事务的方法</span>
<span class="hljs-comment">         * <span class="hljs-doctag">@throws</span> SQLException</span>
<span class="hljs-comment">         */</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commitTransaction</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;
            ConnectionManager.getConnection().commit();
        &#125;
    
    
        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 4.回滚事务的方法</span>
<span class="hljs-comment">         * <span class="hljs-doctag">@throws</span> SQLException</span>
<span class="hljs-comment">         */</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rollbackTransaction</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;
            ConnectionManager.getConnection().rollback();
        &#125;
    
    
        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 5.关闭连接的方法</span>
<span class="hljs-comment">         * <span class="hljs-doctag">@throws</span> SQLException</span>
<span class="hljs-comment">         */</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cloesConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;
            ConnectionManager.getConnection().close();
        &#125;
    &#125;
    
    <span class="hljs-comment">//---------------------------------------------------------------------</span>
    
    测试代码：
    
    <span class="hljs-comment">//操作事务</span>
    Connection conn = <span class="hljs-keyword">null</span>;
    
    <span class="hljs-keyword">try</span>&#123;
        QueryRunner qr = <span class="hljs-keyword">new</span> QueryRunner();
        conn = ConnectionManager.getConnection();
    
        <span class="hljs-comment">//关闭自动事务提交，即开启手动事务提交</span>
        ConnectionManager.startTransaction();
        qr.update(<span class="hljs-string">"update mybank set money=money-? where name=?"</span>, <span class="hljs-number">1000</span>,<span class="hljs-string">"邓先森"</span>);
    
        <span class="hljs-comment">//模拟转账失败</span>
        System.out.println(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>);
        qr.update(<span class="hljs-string">"update mybank set money=money+? where name=?"</span>, <span class="hljs-number">1000</span>,<span class="hljs-string">"任仙女"</span>);
    
        <span class="hljs-comment">//提交事务</span>
        ConnectionManager.commitTransaction();
    
    &#125;<span class="hljs-keyword">catch</span> (SQLException e) &#123;
        e.printStackTrace();
    
        System.out.println(<span class="hljs-string">"出现错误..."</span>);
    
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//事务回滚</span>
            ConnectionManager.rollbackTransaction();
        &#125; <span class="hljs-keyword">catch</span> (SQLException e1) &#123;
            e1.printStackTrace();
        &#125;
        
    &#125;<span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-keyword">try</span> &#123;
            ConnectionManager.cloesConnection();
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;</code></pre></code></pre><p>&nbsp;</p>
<ul>
<li><p>事务的安全性问题和隔离级别；</p>
<ul>
<li><p>事务的安全性问题；</p>
<ul>
<li>脏读：是指一个事务读到另一个事务还没有提交的数据；<code>如，事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</code>；<ul>
<li>不可重复读：是指一个事务读到另一个事务已经提交的update数据，导致在当前事务中多次查询的结果不一致；<code>如，事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致</code>；</li>
<li>虚读/幻读：是指一个事务读到另一个事务已经提交的insert数据，导致在当前事务中多次查询的结果不一致；<code>如，系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p>事务的安全性问题的解决办法(Y代表可能发生，N代表不会发生)：</p>
<p><img src="JavaEE--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Image-jee1.png" srcset="/img/loading.gif" alt="Image"></p>
<ul>
<li><p>READ-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读；</p>
</li>
<li><p>READ-COMMITTED(读取已提交)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生；</p>
</li>
<li><p>REPEATABLE-READ(可重复读)：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生；</p>
</li>
<li><p>SERIALIZABLE(可串行化)：最高的隔离级别，完全服从ACID的隔离级别；所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>
<pre><code class="hljs java">拓展：MySQL和Oracle数据库隔离级别
一、MySQL默认的事务处理级别是<span class="hljs-string">'REPEATABLE-READ'</span>,也就是可重复读；

二、Oracle默认系统事务隔离级别是READ COMMITTED,也就是读已提交；Oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别。</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO1-2-Web"><a href="#NO1-2-Web" class="headerlink" title="NO1.2 Web"></a>NO1.2 Web</h3><p>看完了后端数据库，我们来看看Web层的一些操作。</p>
<ul>
<li>HTTP协议：<ul>
<li>定义：所谓协议，就是指双方遵循的规范；HTTP协议，就是浏览器和服务器之间进行“沟通”的一种规范；市面上两种常见的架构：<ul>
<li><code>B/S系统</code>：是指Brower/Server，即浏览器/服务器系统；如网站和服务器系统等；</li>
<li><code>C/S系统</code>：是指Client/Server，即客户端/服务器系统；如电脑软件客户端和服务器系统等；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>web应用服务器：<ul>
<li>定义：供向外部发布web资源的服务器软件；常用的web应用服务器如下：<ul>
<li>weblogic：oracle公司的大型收费web服务器，支持JavaEE规范；</li>
<li>websphere：IBM公司的的大型收费web服务器，支持JavaEE规范；</li>
<li>Tomcat：Apache开源组织下的，开源的，免费的小型web服务器，支持JavaEE中的Servlet和JSP规范。</li>
</ul>
</li>
<li>web资源：存在于web应用服务器并可供外界访问的资源就是web资源。</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>Servlet：</p>
<ul>
<li><p>定义：是运行在服务端的Java小程序，是sun公司提供的一套规范(接口)，用来处理请求和发送响应数据；但Servlet的实质就是Java代码，通过Java的API动态的向客户端输出内容；</p>
</li>
<li><p>基本语法格式：</p>
<ul>
<li>创建一个Servlet：<ul>
<li>创建一个Java类并实现Servlet接口；</li>
<li>实现主要方法：service()方法；</li>
<li>在web.xml进行servlet的配置；</li>
</ul>
</li>
</ul>
</li>
<li><p>Servlet的API：</p>
<ul>
<li><code>init()方法</code>：Servlet对象创建的时候执行；</li>
<li><code>service()方法</code>：每次请求都会执行；</li>
<li><code>destroy()方法</code>：Servlet对象销毁的时候执行；</li>
</ul>
</li>
<li><p>Servlet的生命周期；</p>
<ul>
<li><code>Servlet何时创建</code>：默认第一次访问Servlet时，创建该对象；</li>
<li><code>Servlet何时销毁</code>：服务器关闭，Servlet就销毁了；</li>
</ul>
</li>
<li><p>Servlet在web.xml的配置；</p>
<pre><code class="hljs java">&lt;servlet&gt;
            <span class="hljs-comment">//3.这里取什么名字无所谓，作用是让下方的&lt;servlet-name&gt;名称找到这里，并指引找到响应资源的Servlet</span>
            &lt;servlet-name&gt;servletTest&lt;/servlet-name&gt;
        
        
            <span class="hljs-comment">//4.Servlet的全限定类名，也就是Servlet的位置，由上面的&lt;servlet-name&gt;指引而来</span>
            &lt;servlet-<span class="hljs-class"><span class="hljs-keyword">class</span>&gt;<span class="hljs-title">com</span>.<span class="hljs-title">action</span>.<span class="hljs-title">ServletTest</span>&lt;/<span class="hljs-title">servlet</span>-<span class="hljs-title">class</span>&gt;</span>
<span class="hljs-class">        &lt;/<span class="hljs-title">servlet</span>&gt;</span>
<span class="hljs-class">        &lt;<span class="hljs-title">servlet</span>-<span class="hljs-title">mapping</span>&gt;</span>
<span class="hljs-class">            //2.这里的名称必须要和上方的&lt;<span class="hljs-title">servlet</span>-<span class="hljs-title">name</span>&gt;名称相同；</span>
<span class="hljs-class">            &lt;<span class="hljs-title">servlet</span>-<span class="hljs-title">name</span>&gt;<span class="hljs-title">servletTest</span>&lt;/<span class="hljs-title">servlet</span>-<span class="hljs-title">name</span>&gt;</span>
<span class="hljs-class">        </span>
<span class="hljs-class">        </span>
            //1.通过浏览器地址请求的资源名找到这里，注意："/"一定要写，相当于项目名称
            &lt;url-pattern&gt;/servletTest&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;</code></pre>
</li>
<li><p>为什么eclipse创建的Servlet没有service()方法，只有doGet()和doPost()却仍然能够实现接收请求和反馈响应呢？</p>
<pre><code class="hljs java">要想接收请求和反馈响应，就必须实现Servlet接口，而eclipse创建的Servlet继承自HttpServlet，但是HttpServlet中却没有找到实现Serverlet接口，所以继续找HttpServlet的父类，之后发现其父类GenericServlet，实现了Servlet接口，也就是说HttpServlet间接的实现了Servlet接口；之后因为又发现父类GenericServlet没有实现service()方法，只是继承了该方法，该方法仍然是抽象方法，所以去找子类HttpServlet，而在HttpServlet中，找到了被重写的service()方法，但参数却是ServletRequest和ServletResponse，也就是说，这就是普通的一个类间接实现了Servlet接口，重写service()方法，然后HttpServlet中将原生的Servlet参数ServletRequest和ServletResponse强制转成了带Http协议的HttpServletRequest和HttpServletResponse，之后又调用了HttpServlet本类中重载的方法(即方法名相同，参数不同的)service()方法，根据请求中发送数据的方法get和post，分别调用我们看到doGet()和doPost()方法。</code></pre>
</li>
<li><p>ServletContext：</p>
<ul>
<li>定义：是指web应用项目上下文对象，一个web应用项目只有一个ServletContext，但可以有多个Servlet对象；</li>
</ul>
</li>
<li><p>ServletContext生命周期；</p>
<pre><code>-   创建：该web应用项目被加载(即服务器启动或发布web应用)；
-   销毁：web应用被卸载(服务器关闭或移除该web应用)。</code></pre><ul>
<li>基本语法格式：通过getServletContext()直接获得ServletContext对象；</li>
<li>ServletContext的三个主要的作用：<ul>
<li>获得初始化参数(一般写框架的时候才会用到，平常不用)；</li>
<li>获得web应用中任何资源的绝对路径(重要)：String getRealPath(path); path是某个文件，返回该文件所在的绝对路径；<ul>
<li>Tomcat服务器中的项目名称，对应的是eclipse中的WebContent目录；即在Tomcat中的daydayup0011项目，对应在eclipse中的目录为：daydayup0011下的WebContent，WebContent才是真实目录；</li>
</ul>
</li>
<li>ServletContext是一个域对象：<ul>
<li>域对象就是存储数据的区域；</li>
<li>作用范围：整个web应用，即该web应用所有的web资源都可以随意向ServletContext域中存取数据，意思就是数据共享；</li>
<li>域对象通用的方法：<ul>
<li><code>setAtrribute(String name,Object obj)</code>：向ServletContext域中存数据；</li>
<li><code>getAtrribute(String name)</code>：根据名称向ServletContext域中取数据；</li>
<li><code>removeAtrribute(String name)</code>：根据名称删除ServletContext域中的数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>Request：</p>
<ul>
<li><p>定义：就是用户指定访问某个资源，会发送一个访问许可的请求，这个请求就是request；</p>
</li>
<li><p>Request中包含的表单，其提交方式：</p>
<ul>
<li>表单以”get”方式提交，请求参数会在url后面，以?隔开，以&amp;方式连接不同的参数，且长度有限，安全性低；</li>
<li>表单以”post”方式提交，则请求参数会封装在request中的请求体中，长度较大，安全性高。</li>
</ul>
</li>
<li><p>Request的常用API：</p>
<ul>
<li><code>String getContextPath()</code>：获得web应用的名称；</li>
<li><code>String getHeader(String name)</code>：获得请求头中某个指定的键所对应的值；</li>
<li><code>String getParameter(String name)</code>：根据指定的单个参数名获得对应的值；</li>
<li><code>String[] getParameterValues(String name)</code>：根据指定的单个参数名获得对应的多个值(用于获取表单中复选框的值)；</li>
<li><code>Map&lt;String,String[]&gt; getParameterMap()</code>：该方法的返回值只能读，不能改；</li>
</ul>
</li>
<li><p>Request也是一个域对象；</p>
<ul>
<li>作用范围：Request域对象的作用范围只能是在同一次请求当中；</li>
<li><code>setAtrribute(String name,Object obj)</code>：向request域中存数据；</li>
<li><code>getAtrribute(String name)</code>：根据名称向request域中取数据；</li>
<li><code>removeAtrribute(String name)</code>：根据名称删除request域中的数据；</li>
</ul>
</li>
<li><p>Request解决获取的参数乱码问题；</p>
<ul>
<li><p>Post提交方式：<code>request.setCharacterEncoding(&quot;UTF-8&quot;)</code>，设置request中接收的参数用UTF-8编码；</p>
</li>
<li><p>Get提交方式：<code>new String(target.getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;)</code>；</p>
<pre><code class="hljs java">拓展：乱码形成
一、乱码形成：中文---&gt;自动用UTF-<span class="hljs-number">8</span>编码转成程序能看的字节---&gt;开发工具(这里是eclipse)用ISO-<span class="hljs-number">8859</span>-<span class="hljs-number">1</span>解码---&gt;我们看到的乱码

二、解决乱码：乱码---&gt;先用ISO-<span class="hljs-number">8859</span>-<span class="hljs-number">1</span>编码转成程序看的字节---&gt;再用UTF-<span class="hljs-number">8</span>解码---&gt;解成我们想要看的中文</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>Response：</p>
<ul>
<li><p>定义：就是用户请求指定的资源后，服务端给予客户端的一种反馈形式就被成为响应；</p>
</li>
<li><p>Response的常用API：</p>
<ul>
<li><p><code>setStatus(int sc)</code>：该方法用于设置响应行中的状态码；</p>
<pre><code class="hljs java"><span class="hljs-number">2</span>XX：成功
<span class="hljs-number">3</span>XX：重定向
<span class="hljs-number">4</span>XX：请求资源错误
<span class="hljs-number">5</span>XX：服务器错误</code></pre>
</li>
<li><p><code>addHeader(String name,String value)</code>：以键值对的形式，添加一个响应头信息；如果键相同，则值会添加到上一个值的后面，用,隔开；</p>
<pre><code class="hljs java">response.addHeader(<span class="hljs-string">"name"</span>,<span class="hljs-string">"zhangsan"</span>);  <span class="hljs-comment">//以键值对的形式添加一个响应头的信息</span>
            
            response.addHeader(<span class="hljs-string">"name"</span>,<span class="hljs-string">"lisi"</span>);  <span class="hljs-comment">//再次以键值对的形式添加一个响应头的信息，但是键相同结果在浏览器抓包响应时显示：name="zhangsan,lisi"</span></code></pre>
</li>
<li><p><code>setHeader(String name,String value)</code>：以键值对的形式，设置一个响应头信息；如果有键相同，则值会覆盖；</p>
<pre><code class="hljs java">response.addHeader(<span class="hljs-string">"name"</span>,<span class="hljs-string">"zhangsan"</span>);  <span class="hljs-comment">//以键值对的形式添加一个响应头的信息</span>
            
            response.addHeader(<span class="hljs-string">"name"</span>,<span class="hljs-string">"lisi"</span>);  <span class="hljs-comment">//再次以键值对的形式添加一个响应头的信息，但是键相同结果在浏览器抓包响应时显示：name="lisi";</span></code></pre>
</li>
<li><p><code>getOutputStream()</code>：获得一个字节输出流，实际就是一个IO流，用于传输字节数据，如下载图片，视频等，浏览器能够直接解析并获取；下载图片等文件：</p>
<ul>
<li><code>response.setContentType(getServletCOntext().getMimeType(文件名的字符串))</code>：获取文件的MIME类型，即程序区分文件类型是使用MIME类型去区分的，是为了下载传输数据做准备；</li>
<li><code>response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+文件名的字符串)</code>：这个时候程序已经拿到某个文件的MIME类型，该方法是告知浏览器这个文件用附件形式打开，即不会直接解析，因为直接解析会在浏览器端直接打开文件，不是我们想要的方式，也就不是文件下载了；<ul>
<li><code>filename = new String(filename.getBytes(&quot;本地字符集&quot;),&quot;UTF-8&quot;)</code>：解决文件名是中文乱码</li>
</ul>
</li>
</ul>
</li>
<li><p>Response解决中文乱码；</p>
<ul>
<li>response.setContentType(“text/html;charset=字符集”)：即告知浏览器，让浏览器用指定字符集去解析信息；(该方法也隐含了让response用指定的字符集编码)。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>重定向和请求转发的区别：</p>
<ul>
<li><p>重定向是在客户端发生的，速度慢；请求转发是在服务端发生的，速度快；</p>
</li>
<li><p>重定向是两次请求，地址栏有变化；请求转发是一次请求，地址栏没有变化；</p>
</li>
<li><p>重定向的方法为：<code>response.sendRedirect(String location)</code>；</p>
<p>请求转发的方法为：<code>request.getRequestDispatcher(String path).forward(request, response)</code>。</p>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>Cookie和Session：</p>
<ul>
<li><p>定义：即会话技术，是指从打开一个浏览器访问某个站点，到关闭这个浏览器的整个过程，称为一次会话；而会话技术就是记录这次会话中客户端的状态与数据的；</p>
</li>
<li><p>会话技术分为：</p>
<ul>
<li><p>Cookie；</p>
<ul>
<li><p>定义：数据存储在客户端本地，减少了服务器端的数据存储压力，但安全性不好，客户端可以清除Cookie；</p>
</li>
<li><p>Cookie的发送和接收：</p>
<ul>
<li><p>创建Cookie：</p>
<pre><code class="hljs java"><span class="hljs-comment">//以键值对的形式创建一个Cookie</span>
Cookie cookie = <span class="hljs-keyword">new</span> Cookie(String key,String value);

<span class="hljs-comment">//将cookie发送给客户端即可</span>
response.addCookie(cookie);

注意：Cookie不能存储中文</code></pre>
</li>
<li><p>设置Cookie的持久化时间(即存在时间)：</p>
<pre><code class="hljs java"><span class="hljs-comment">//参数是秒，一般的默认都是会话级别的Cookie，在会话结束后就消失；持久化Cookie需要使用该方法设置持久化时间，但时间过了也会消失</span>
cookie.setMaxAge(<span class="hljs-keyword">int</span> seconds);</code></pre>
</li>
<li><p>设置Cookie的携带路径(即访问哪一些资源需要携带Cookie，哪一些不需要)；</p>
<pre><code class="hljs java"><span class="hljs-comment">//参数是路径名，即访问path资源需要携带Cookie，除此之外，不携带cookie</span>
cookie.setPath(String path);

如：
web01/aaa/bbb/testservlet：该路径下产生了Cookie；则，web01/aaa/bbb路径下的所有资源都会携带Cookie

注意：如果不设置该方法，则只默认访问，在产生该Cookie的路径下都会携带Cookie，即除开路径<span class="hljs-string">"/"</span>最后一部分，前面的路径下的资源都会携带Cookie</code></pre>
</li>
<li><p><code>Cookie[] request.getCookies()</code>：该方法返回的是一个Cookie数组，通过遍历数组和想要找的键的比对，找到想要的Cookie值；</p>
</li>
<li><p>删除Cookie，只需创建一个同名同路径Cookie，且该Cookie的持久化时间为0的即可。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Session；</p>
<ul>
<li><p>定义：Session会话技术是将数据存储在服务器端的技术，会为每个客户端都创建一块内存空间存储客户的数据，但是客户端需要每次都携带一个标识ID去服务器中寻找自己的内存空间；所以说Session的实现是基于Cookie，Session需要借助于Cookie存储客户的唯一性标识JSESSIONID；另外数据存储在服务器端，增加了服务器端的数据存储压力，但安全性好；</p>
</li>
<li><p>Session的发送和接收：</p>
<ul>
<li><p>创建Session；</p>
<pre><code class="hljs java"><span class="hljs-comment">//该方法会自动判断访问的客户端是否已经在服务端有Session区域，没有则创建，否则就返回原先拥有的Session区域；</span>
HttpSession session = request.getSession();</code></pre>
</li>
</ul>
</li>
<li><p>Session也是一个域对象：</p>
<ul>
<li>范围：Session域对象的作用范围只能是在同一次会话当中，即浏览器只要不关闭或重新开启，都是一次会话；</li>
<li>setAtrribute(String name,Object obj)：向Session域中存数据；</li>
<li>getAtrribute(String name)：根据名称向Session域中取数据；</li>
<li>removeAtrribute(String name)：根据名称删除Session域中的数据。</li>
</ul>
</li>
<li><p>Session的生命周期；</p>
<ul>
<li><p>创建：第一次执行request.getSession();时创建Session；</p>
</li>
<li><p>销毁：服务器(非正常)关闭时，Session销毁。</p>
<pre><code class="hljs java">拓展：Session过期时间
一、Session过期，一般Session有效时间<span class="hljs-number">30</span>分钟，从最后一次不操作服务器端资源开始计算；手动销毁Session.invalidate();</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>JSP：</p>
<ul>
<li><p>定义：JPS是一种动态网页开发技术，它使用JSP标签在HTML网页中插入Java代码；标签通常以&lt;% %&gt;开头和结束；JSP是简化的Servlet；</p>
</li>
<li><p>JSP脚本：</p>
<ul>
<li>&lt;%这里写Java代码%&gt;，内部的Java代码会被翻译到service内部；</li>
<li>&lt;%=Java变量或表达式%&gt;，内部的Java代码会被翻译到service内部；</li>
<li>&lt;%!这里写Java代码%&gt;，内部的Java代码会被翻译到service成员位置。</li>
</ul>
</li>
<li><p>JSP指令：</p>
<ul>
<li>taglib指令：在JSP页面中引入标签库；格式：&lt;%@ taglib uri=”标签库地址” prefix=”前缀”%&gt;。</li>
</ul>
</li>
<li><p>JSP内置对象(9个)：即这些对象不需要我们生产，直接使用即可；</p>
<ul>
<li>out：用于页面输出；</li>
<li>request：用于得到用户请求；</li>
<li>response：用于服务端向客户端的响应；</li>
<li>config：服务器配置，可以取得初始化参数；</li>
<li>session：用来保存用户信息；</li>
<li>application：所有用户的共享信息(即ServletContext)；</li>
<li>page：指当前页面转换后的Servlet类的实例对象，就是this；</li>
<li>pageContext：JSP的页面容器；</li>
<li>exception：表示JSP页面所引发的异常，在错误页面中才起作用。</li>
</ul>
</li>
<li><p>pageContext也是一个域对象；</p>
<ul>
<li><p>范围：pageContext域对象的作用范围只能是当前JSP页面当中；</p>
</li>
<li><p>setAtrribute(String name,Object obj)：向pageContext域中存数据；</p>
</li>
<li><p>getAtrribute(String name)：根据名称向pageContext域中取数据；</p>
</li>
<li><p>removeAtrribute(String name)：根据名称删除pageContext域中的数据；</p>
</li>
<li><p>findAttribute(String name)：依次(从小到大)从pageContext域、request域、Session域、Application域中查找指定名称的数据。</p>
</li>
<li><p>pageContext可以获得其他八个内置对象，通过get对象名()方法；</p>
<pre><code class="hljs java">拓展：对域对象进行操作
一、setAtrribute(String name,Object obj,<span class="hljs-keyword">int</span> scope)：向指定scope域中存数据；

二、getAtrribute(String name,<span class="hljs-keyword">int</span> scope)：根据名称向指定scope域中取数据；

三、removeAtrribute(String name,<span class="hljs-keyword">int</span> scope)：根据名称删除指定scope域中的数据；</code></pre>
</li>
</ul>
</li>
<li><p>静态包含与动态包含的区别？</p>
<ul>
<li>静态包含会将被包含的JSP页面合并到一起，即两个页面合成一个页面；也就只有一个.class文件；</li>
<li>动态包含则是编译运行主页面后，在主页面引入被包含的页面，之后再去编译运行被包含的页面；有两个.class文件；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>EL表达式</p>
<ul>
<li><p>定义：是指可以嵌入在JSP页面的内部，减少JSP脚本(即Java代码)编写的表达式；EL的出现就是为了替代JSP页面中脚本的编写；</p>
</li>
<li><p>基本语法格式：</p>
<ul>
<li><p>EL从域中取出数据：格式为<code>${EL表达式}</code>；用的最多的是：<code>${key}</code>，即传入一个key，让其自动到四个域对象中去找(范围从小到大)；</p>
</li>
<li><p>EL的内置对象有11个，常用的有(1个)：pageContext，作用是获取其他8个内置对象，常用于获取web应用名称，即<code>${pageContext.request.ContextPath}</code>；</p>
</li>
<li><p>EL还可以执行表达式运算；</p>
<pre><code class="hljs html">$&#123;1+1&#125;
            $&#123;xxx==null?true:false&#125;
            $&#123;empty xxx&#125;
            
            说明：上面的empty用于判断后面的xxx是否为空</code></pre>
</li>
<li><p>EL表达式中，若需要和字符串作拼接，则需要使用<code>concat(&quot;需要拼接的字符串&quot;)</code>方法。<code>如，${user.uname.concat(&quot;是小可爱&quot;)}，结果为：XXX是小可爱</code>；</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>JSTL</p>
<ul>
<li><p>定义：是指JSP的标准标签库，可以嵌入JSP页面中使用标签的形式完成业务逻辑等功能；也是为了替代JSP中的脚本而出现的；</p>
</li>
<li><p>JSTL有5个子库，但只有1个常用：Core库，即核心库，前缀为”c”；核心库的常用标签有：</p>
<ul>
<li><p><code>&lt;c:if test=&quot;&quot;&gt;</code>：test是返回boolean的条件；</p>
</li>
<li><p><code>&lt;c:forEach&gt;</code>：就是循环；</p>
<ul>
<li><p>基本遍历；</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">c:forEach</span> <span class="hljs-attr">begin</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">end</span>=<span class="hljs-string">"5"</span> <span class="hljs-attr">var</span>=<span class="hljs-string">"i"</span>&gt;</span>
	$&#123;i&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">c:forEach</span>&gt;</span>

说明：从0开始，到5(包括5)为止，将值赋给变量i，用EL输出</code></pre>
</li>
<li><p>数组或集合遍历</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">c:forEach</span> <span class="hljs-attr">items</span>=<span class="hljs-string">"这里放集合或数组"</span> <span class="hljs-attr">var</span>=<span class="hljs-string">"j"</span>&gt;</span>
	$&#123;j&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">c:forEach</span>&gt;</span>

说明：从集合中，取出元素，赋给变量j，并输出(推荐此方法，因为是增强for遍历的方)</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>MVC模式：<ul>
<li>M：Model—模型，即JavaBean，封装数据；</li>
<li>V：View—视图，即JSP等，仅页面显示；</li>
<li>C：Controller—控制体，即Servlet等，处理请求(获取数据)和响应(传递数据)。</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>AJax：</p>
<ul>
<li><p>定义：是指异步的JavaScript和XML或者HTML；</p>
</li>
<li><p>同步和异步：</p>
<ul>
<li><code>同步现象</code>：是指客户端发送请求到服务端，在服务端返回响应之前，客户端都处于等待卡死状态；通俗的说，同步就是同一段时间内，只能做一件事情，跟单线程类似；</li>
<li><code>异步现象</code>：是指客户端发送请求到服务端，无论服务端是否返回响应，客户端都可以做其他事情，不会被卡死；通俗的说，异步就是同一段时间内，能做多件事情，跟多线程类似；</li>
</ul>
</li>
<li><p>Js的原生Ajax步骤；</p>
<pre><code class="hljs js">#创建Ajax引擎对象(所有操作都是通过Ajax引擎对象实现的)；
<span class="hljs-keyword">var</span> xmlHttp = <span class="hljs-keyword">new</span> XMLHttpRequest();

#绑定监听(即监听服务器是否已经返回相应的数据)；
xmlHttp.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;

    #未返回数据则不走这里；
    #返回数据后机就会走这里：
    <span class="hljs-keyword">var</span> result = xmlHttp.responseText;
&#125;

#绑定地址(boolean参数表示，是否异步，true为异步，否则为同步)；
xmlHttp.open(<span class="hljs-string">"提交方式"</span>,<span class="hljs-string">"资源访问路径"</span>,<span class="hljs-literal">true</span>);

#发送请求：xmlHttp.send();</code></pre>
</li>
<li><p>Json：</p>
<ul>
<li>定义：是一种数据交互的格式，用于Ajax进行前后台的数据交互；</li>
<li>Json有两种格式：<ul>
<li><code>对象格式</code>：<code>{&quot;key1&quot;:obj, &quot;key2&quot;:obj, &quot;key3&quot;:obj}</code>，key是字符串，value是Object；</li>
<li><code>数组格式</code>：<code>[obj,obj,obj...]</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p>JQuery的Ajax步骤；</p>
<ul>
<li><p>Get方式；</p>
<pre><code class="hljs js">$.get&#123;  #该方法乱码问题解决：参考get方式提交参数，解决乱码的方法

    "xxx/xxx",  #这是请求的资源地址，即uri
    &#123;"key1":obj, "key2":obj&#125;,  #这是请求所携带的参数
    function(data)&#123;  #执行成功后回调的函数，即响应后走这里,data是响应回来的数据

        执行操作...  #操作时，data响应信息已经被解析成了jason格式的字符串对象，可以用该对象获取属性值等
    &#125;,
    "json"   #指定返回的响应里面信息的格式，一般用json和text
&#125;</code></pre>
</li>
<li><p>Post方式；</p>
<pre><code class="hljs js">$.post&#123;  #该方法乱码问题解决：不用管，或参考post提交参数，解决乱码的方法

    "xxx/xxx",  #这是请求的资源地址，即uri
    &#123;"key1":obj, "key2":obj&#125;,  #这是请求所携带的参数
    function(data)&#123;  #执行成功后回调的函数，即响应后走这里,data是响应回来的数据
        执行操作...  #操作时，data响应信息已经被解析成了jason格式的字符串对象，可以用该对象获取属性值等
    &#125;,
    "json"   #指定返回的响应里面信息的格式，一般用json和text
&#125;</code></pre>
</li>
<li><p>常用形式；</p>
<pre><code class="hljs js">$.ajax(&#123;
    url:"xxx/xxx",  #请求的资源地址
    async:true,  #是否异步，默认为true，即默认异步
    type:"POST",  #数据提交方式POST和GET
    data:&#123;"xx":xx,"xx":xx&#125;,  #请求参数
    success:function(data)&#123;  #请求成功后回调的函数，data是响应的数据
        执行操作...
    &#125;,
    dataType:"json"  #返回的响应信息的格式，一般用json和text
&#125;);</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>监听器</p>
<ul>
<li><p>定义：即Listener，就是监听Web服务器的运行，当发生特定事件时，采取预先设定的处理措施的组件；</p>
</li>
<li><p>监听服务：</p>
<ul>
<li>监听器一般是监听这三个域对象：即Request、Session、servletContext；</li>
<li>监听的内容：一般是监听上面提到的三个域对象的创建与销毁、属性的变化这两种内容；<ul>
<li>监听ServletContext域对象：<ul>
<li>ServletContextListener(主要用于监听ServletContext即Servlet容器的创建与销毁)；</li>
<li>ServletContextAttributeListener(主要用于监听ServletContext作用域中属性的变化，即增删改属性的变化)。</li>
</ul>
</li>
<li>监听Session域对象：<ul>
<li>HttpSessionListener(用于监听session对象的创建与销毁)；</li>
<li>HttpSessionAttributeListener(用户监听session作用域中属性的变化)。</li>
</ul>
</li>
<li>监听Request域对象：<ul>
<li>ServletRequestListener(主要用于监听request对象的创建与销毁)；</li>
<li>ServletRequestAttributeListener(主要用于监听request作用域中属性的变化)。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>监听器的编写步骤：</p>
<ul>
<li><p>编写一个监听器类(普通定义的一个类)去实现监听器Listener接口；</p>
</li>
<li><p>重写监听器的方法(可以根据方法中的参数获得所监听的对象)；</p>
</li>
<li><p>需要在web.xml中进行配置，即注册监听器；</p>
<pre><code class="hljs java">&lt;listener&gt;监听器类的全包名路径&lt;/listener&gt;</code></pre>
</li>
</ul>
</li>
<li><p>绑定与解绑监听器：</p>
<ul>
<li>HttpSessionBindingListenner，作用：该接口用于实体类，让其对象知道绑定与解绑的状态，绑定与解绑，决定于该类对象是否被存入或删除于Session域中；</li>
</ul>
</li>
<li><p>钝化与活化监听器：</p>
<ul>
<li>HttpSessionActivationListenner，作用：该接口用于实体类，让其对象知道钝化与活化的状态，如果存入Session域中的该类对象被保存到了磁盘中就是钝化，相反，从磁盘上再次恢复到Session内存中，则是活化；</li>
</ul>
</li>
<li><p>要想将数据序列化(保存到)磁盘上，必须实现<code>Serializable</code>接口，该接口下没有任何需要实现的方法，只需实现该接口即可；</p>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>过滤器：</p>
<ul>
<li><p>定义：即Filter，JavaWeb中的过滤器可以拦截所有访问web资源的请求或响应操作；</p>
</li>
<li><p>过滤器的编写步骤；</p>
<ul>
<li><p>编写一个过滤器类实现Filter接口；</p>
</li>
<li><p>实现接口中未实现的方法(主要是doFilter方法)；</p>
<ul>
<li><p>doFilter()方法中，当过滤了请求后，一定要记得放行，即让请求通过，调用chain对象的doFilter()方法；</p>
<pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> class MyFilter implements <span class="hljs-title">Filter</span><span class="hljs-params">()</span></span>&#123;
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException</span>&#123;
                    &#125;
                
                    <span class="hljs-comment">//这是主要的过滤的方法</span>
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletReponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException,ServletException</span>&#123;
                        <span class="hljs-comment">//请求放行的方法</span>
                        chain.doFilter(request,response);
                    &#125;
                
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span></span>&#123;
                    &#125;
                &#125;</code></pre>
</li>
</ul>
</li>
<li><p>在web.xml中进行配置(主要配置过滤的条件)；</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>
        	<span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>过滤器名称<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
        	<span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>过滤器类的全包名路径<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>
        
        <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>过滤器名称(要和上面的一致)<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>//这里设置过滤的条件
        <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre>
</li>
</ul>
</li>
<li><p>Filter的主要作用：</p>
<ul>
<li>对公共代码的提取；</li>
</ul>
</li>
<li><p>可以对request和response中的方法进行增强(装饰者模式)；</p>
<ul>
<li>进行权限的控制；</li>
</ul>
</li>
</ul>
</li>
</ul>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/1-%EB%8C%80%ED%95%99%EA%B5%90-%EC%9D%BC-%ED%95%99%EB%85%84/">1.대학교 일 학년</a>
                    
                      <a class="hover-with-bg" href="/categories/1-%EB%8C%80%ED%95%99%EA%B5%90-%EC%9D%BC-%ED%95%99%EB%85%84/03-Java/">03.Java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%A4%A7%E4%B8%80%E8%AF%BE%E7%A8%8B/">大一课程</a>
                    
                      <a class="hover-with-bg" href="/tags/JavaEE/">JavaEE</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/07/03/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">01.前端基础--学习笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/06/29/JavaSE--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                        <span class="hidden-mobile">01.JavaSE--学习笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "02.JavaEE--学习笔记&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
