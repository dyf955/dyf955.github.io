<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="o一行瑠璃o">
  <meta name="keywords" content="学习笔记,Java,C">
  <title>04.SpringBoot--学习笔记 - 知晓天空之蓝的人啊</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Hello World</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                目录
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/indexbg/sun.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-07-07 21:22">
      2020年7月7日 晚上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      35.6k 字
    </span>
  

  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="SpringBoot–学习笔记-包含SpringBoot视频"><a href="#SpringBoot–学习笔记-包含SpringBoot视频" class="headerlink" title="SpringBoot–学习笔记(包含SpringBoot视频)"></a>SpringBoot–学习笔记(包含SpringBoot视频)</h1><h2 id="Lesson1-SpringBoot概述"><a href="#Lesson1-SpringBoot概述" class="headerlink" title="Lesson1 SpringBoot概述"></a>Lesson1 SpringBoot概述</h2><h3 id="NO1-1-SpringBoot简介与入门"><a href="#NO1-1-SpringBoot简介与入门" class="headerlink" title="NO1.1 SpringBoot简介与入门"></a>NO1.1 SpringBoot简介与入门</h3><p>SpringBoot用于快速开发单个微服务项目。</p>
<ul>
<li>SpringBoot：<ul>
<li>定义：SpringBoot是简化了Spring应用开发的一个框架；是整个Spring技术栈的一个大整合，J2EE开发的一站式解决方案(SpringCloud则是分布式整体解决方案)；</li>
<li>优点：<ul>
<li>快速创建独立运行的Spring项目以及与主流框架集成；</li>
<li>使用嵌入式的Servlet容器，应用无需打成WAR包；</li>
<li>starters(启动器)自动依赖与版本控制；</li>
<li>大量的自动配置，简化开发，也可修改默认值；</li>
<li>无需配置XML，无代码生成，开箱即用；</li>
<li>与云计算的天然集成等等。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>两种方式创建SpringBoot工程：</p>
<ul>
<li><p>普通方式创建SpringBoot工程：</p>
<ul>
<li><p>创建普通的Maven项目，在pom.xml中继承父工程依赖；</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    
说明：
一.groupid和artifactId被统称为“坐标”，是为了保证项目唯一性而提出的；groupId一般分为多个段，这里只说两段，第一段为域，第二段为公司名称；域又分为org、com、cn等等许多，其中org为非营利组织，com为商业组织，cn为中国；如，apache公司的
tomcat项目，这个项目的groupId是org.apache，它的域是org(因为tomcat是非营利项目)，公司名称是apache，artigactId是tomcat；

二.在使用Maven创建基于SpringBoot的项目后，如果父工程中SpringBoot版本为1开头的，则JDK版本最高为JDK7，尽量使用JDK7，所以需要在pom.xml中修改JDK的版本，修改为1.7；如果父工程中SpringBoot版本为2开头的，则JDK版本最低为JDK8，尽量使用JDK8；导入2开头的版本时，已经自动修改了JDK为JDK8，不需要我们手动修改JDK；但是要添加一个属性 <span class="hljs-tag">&lt;<span class="hljs-name">maven-jar-plugin.version</span>&gt;</span>，如下所示；然后右键项目，选择Maven选项，选择Update Project，更新项目(IDEA中选择Reimport就行了)，SpringBoot项目基本创建成功；
<span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">maven-jar-plugin.version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">maven-jar-plugin.version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>

三、父项目spring-boot-starter-parent往上找，发现这个父项目还依赖另一个父项目spring-boot-starter-dependencies，而这个父项目中的<span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>标签中则管理了大量的依赖版本，这也是为什么我们导入依赖之后，不需要指定版本号的原因。</code></pre>
</li>
<li><p>导入Web的依赖(其实就是管理好的JAR包)，该依赖的作用是导入了Web模块正常运行所依赖的组件，并且使得启动项目之后会挂起而不会启动后就立马将项目关闭；</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Web依赖 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre>
</li>
<li><p>编写启动类；</p>
<pre><code class="hljs java"><span class="hljs-comment">//这是SpringBoot的启动类，从这里启动SpringBoot</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(app<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;
    &#125;
&#125;

注意：
一、启动类一定要加注解：<span class="hljs-meta">@SpringBootApplication</span>，因为<span class="hljs-meta">@SpringBootApplication</span>是SprnigBoot项目的核心注解，目的是开启自动配置，并注明SpringBoot的启动类；

二、main方法体里的“SpringApplication.run(启动类<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;”，启动类<span class="hljs-class">.<span class="hljs-keyword">class</span>中的启动类指的是当前类名，如例子中的启动类.<span class="hljs-title">class</span>则为<span class="hljs-title">app</span>.<span class="hljs-title">class</span>；</span>
<span class="hljs-class"></span>
三、当Maven项目中的某一个JAR包报错出异常时，只需要到Maven的本地仓库(我的仓库是E:\repository)下，找到报错的JAR包所对应的上一级文件夹，把整个对应的文件夹删除，然后右键项目，选择Maven选项，选择Update Project，更新项目(IDEA中选择Reimport就行了)，就会自动下载缺失的JAR包了。</code></pre>

<p><strong><code>注意：启动类不能直接放在main/java下。启动类所在的包是最顶部的包，也就是说你创建好包的总路径之后，第一个创建的就是SpringBoot启动类，且启动类和controller、service、domain等等这些包必须是同一级别的，而不能放入前面说的任意一个包之中。</code></strong></p>
<p><img src="./Image-sb1.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb2.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
<li><p>在IDEA中使用Maven创建SpringBoot工程(推荐)；</p>
<ul>
<li><p>点击菜单栏中的file，选择new，选择project或在项目启动的时候选择new create a new project；出现如下对话框；</p>
<p><img src="./Image-sb3.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>设置工程信息；</p>
<p><img src="./Image-sb4.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>选择要导入的依赖；</p>
<p><img src="./Image-sb5.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>完成创建；</p>
<p><img src="./Image-sb6.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>工程创建后的目录结构；</p>
<p><img src="./Image-sb7.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb8.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>@RestController注解和@Controller注解的区别；<ul>
<li>@RestController注解：相当于@Controller+@ResponseBody两个注解的结合，将结果封装成json格式的数据然后再返回，且不需要在方法前面加@ResponseBody注解了，但使用@RestController这个注解，就不能返回jsp、html页面；</li>
<li>@Controller注解：想要返回json数据，可以跟@ResponseBody注解一起使用；想要进行视图的跳转，则返回字符串路径；</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="Lesson2-SpringBoot基础"><a href="#Lesson2-SpringBoot基础" class="headerlink" title="Lesson2 SpringBoot基础"></a>Lesson2 SpringBoot基础</h2><h3 id="NO2-1-SpringBoot的配置文件"><a href="#NO2-1-SpringBoot的配置文件" class="headerlink" title="NO2.1 SpringBoot的配置文件"></a>NO2.1 SpringBoot的配置文件</h3><p>SpringBoot的配置文件常用的主要有两种：一种是properties文件，另一种则是yml(或者yaml)文件。</p>
<ul>
<li><p>SpringBoot中允许的配置文件形式：properties配置文件、yml(或者yaml)配置文件，也就是说文件结尾分别为<code>.properties</code>和<code>.yml(或.yaml)</code>。</p>
<ul>
<li><p>properties配置文件：主要以键值对的形式进行配置；</p>
<pre><code class="hljs properties"><span class="hljs-attr">name</span>=<span class="hljs-string">dengyanfei</span></code></pre>
</li>
<li><p>yml配置文件(或yaml配置文件)：主要以缩进的形式来表示层级关系。</p>
<ul>
<li><p>优点：</p>
<ul>
<li>yml中解决了中文乱码问题，也不需要我们去特别的注意；</li>
<li>支持<code>${}</code>形式的随机数获取、配置文件里的某个属性的值获取等等。<code>如，${random.int}、${random.uuid}，${person.name:aaa}，这表示如果没有获取到person.name的值，就使用aaa作为内容替代进去</code>。</li>
</ul>
</li>
<li><p>基本语法格式：<code>参数名:空格 参数值</code>，即冒号后面紧跟空格，空格后再跟参数值；</p>
<pre><code class="hljs yaml"><span class="hljs-comment">#普通数据形式：</span>
<span class="hljs-attr">name:</span> <span class="hljs-string">ddd</span>

<span class="hljs-comment">#注意：</span>
<span class="hljs-string">一、字符串不用加引号。</span>

<span class="hljs-string">二、如果要使用引号，双引号中如果有特殊字符，则不会转义该特殊字符，特殊字符会发生作用；单引号则相反，单引号会转义特殊字符，使得特殊字符作为内容的一部分输出</span>

<span class="hljs-string">//----------------------------------------</span>

<span class="hljs-comment">#对象数据形式：分为行内写法和yml写法两种可选</span>
<span class="hljs-comment">#行内写法</span>
<span class="hljs-attr">person:</span> <span class="hljs-string">&#123;name:</span> <span class="hljs-string">dyf,</span> <span class="hljs-attr">sex:</span> <span class="hljs-string">男&#125;</span>  

<span class="hljs-comment">#yml写法</span>
<span class="hljs-attr">person:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">dyf</span>
  <span class="hljs-attr">sex:</span> <span class="hljs-string">男</span>

<span class="hljs-string">//----------------------------------------</span>

<span class="hljs-comment">#数组形式：空格之后，用-表示数组的每一个元素，同样也分为行内写法和yml写法</span>
<span class="hljs-comment">#行内写法</span>
<span class="hljs-attr">pets:</span> <span class="hljs-string">[cat,pig,dog]</span>

<span class="hljs-comment">#yml写法</span>
<span class="hljs-attr">pets:</span>  
  <span class="hljs-string">-cat</span>
  <span class="hljs-string">-pig</span>
  <span class="hljs-string">-dog</span>

<span class="hljs-string">//----------------------------------------</span>

<span class="hljs-comment">#~表示null</span>
<span class="hljs-attr">student:</span> <span class="hljs-string">~</span> 

<span class="hljs-string">//----------------------------------------</span>

<span class="hljs-comment">#使用yml文件也可以给Dog对象赋值</span>

<span class="hljs-attr">dog:</span>
<span class="hljs-comment">#这里使用了松散绑定，意思就是这里写的last-name，与Dog类中的lastName进行了绑定，即last-name中的-后面的字母变成了大写，这就是松散绑定</span>
  <span class="hljs-attr">last-name:</span> <span class="hljs-string">wangcai</span>
  <span class="hljs-attr">age:</span> <span class="hljs-number">6</span>

<span class="hljs-comment">#创建Dog类，并在类上使用@Component注解和@ConfigurationProperties(prefix = "dog")，前者注解的作用是告诉SpringBoot这是一个组件，扫描这个类并生成bean对象，后者注解的作用是将配置文件中的值赋值到这个注解下的类所生成的对象中去，简单说就是赋值的作用，prefix属性，用来匹配配置文件中指定的值的，即prefix属性后面的值，配置文件中必须要出现，否则会赋值失败</span>

<span class="hljs-string">@Component</span>
<span class="hljs-string">@ConfigurationProperties(prefix</span> <span class="hljs-string">=</span> <span class="hljs-string">"dog"</span><span class="hljs-string">)</span>  <span class="hljs-string">//将配置文件中dog的配置，绑定到这个这个类所产生的对象中去，简单的说就是赋值</span>
<span class="hljs-string">public</span> <span class="hljs-string">class</span> <span class="hljs-string">Dog</span> <span class="hljs-string">&#123;</span>

    <span class="hljs-string">private</span> <span class="hljs-string">String</span> <span class="hljs-string">lastName;</span>

    <span class="hljs-string">private</span> <span class="hljs-string">Integer</span> <span class="hljs-string">age;</span>

    <span class="hljs-string">....get、set、toString方法....</span>
<span class="hljs-string">&#125;</span>

<span class="hljs-string">注意：</span>
<span class="hljs-string">一、如果application.properties全局配置文件中，没有dog类需要的对象，则使用@PropertySource注解用于加载指定的配置文件(如，dog.properties文件)，将需要的dog对象赋值到Dog类中去；</span>

<span class="hljs-string">二、@Import注解用来导入@Configuration注解的配置类、声明@Bean注解的bean方法、导入ImportSelector的实现类或导入ImportBeanDefinitionRegistrar的实现类，也就是为它们创建Bean对象以便容器引入；@ImportResource是引入spring配置文件.xml。</span></code></pre>

<p><img src="./Image-sb9.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>SpringBoot配置文件的位置：SpringBoot启动会扫描以下位置的application.yml或者 application.properties文件作为SpringBoot的默认配置文件。<strong><code>注意：配置文件的有优先级，高优先级的配置会覆盖低优先级的配置，所有的配置会形成互补配置(意思就是，除了都有的配置部分，高优先级里没配置的，恰好低优先级里又配置了的，则也会使用低优先级里的配置，这就是互补配置)。</code></strong></p>
<ul>
<li><p>项目内的配置文件位置(配置文件的读取优先级按顺序从高到低)；</p>
<ul>
<li><code>file:./config/</code>：即根目录下的config目录下。这个位置的配置文件会最先读取；</li>
<li><code>file:./</code>：即根目录下；</li>
<li><code>classpath:/config/</code>：即classpath路径下的config目录下，也就是在resources目录下创建的config目录里；</li>
<li><code>classpath:/</code>：即classpath路径下，也就是我们常说的resources目录里。最后读取这里的配置文件。</li>
</ul>
</li>
<li><p>多环境切换配置文件；</p>
<pre><code class="hljs yaml"><span class="hljs-comment">#我们开发中，有时候会在SpringBoot项目中放入多个配置文件。如，application.properties、application-test.properties、application-dev.properties，这个时候SpringBoot会默认启动名称为application.properties的配置文件，但是我想使用别的配置文件怎么办呢？只需要在application.properties配置文件中写入如下代码即可启用别的配置文件了，但是要创建三个不同配置文件</span>

<span class="hljs-comment">#这个表示在application.properties中启用别的配置文件</span>
<span class="hljs-string">spring.profiles.active=test</span>  

<span class="hljs-string">//-----------------------------------------------------------</span>

<span class="hljs-comment">#在yml配置文件中极大简化了以上配置，只需要创建一个ymal配置文件即可</span>

<span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span>

<span class="hljs-comment">#使用spring.profiles.active指定生效的环境配置</span>
<span class="hljs-attr">spring:</span> 
  <span class="hljs-attr">profiles:</span> 
    <span class="hljs-attr">active:</span> <span class="hljs-string">test</span>

<span class="hljs-comment">#这里的---表示分割了一个文档模块，即---之下的是一个模块，---之上又是一个模块</span>
<span class="hljs-meta">---</span>
<span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8082</span>

<span class="hljs-comment">#spring.profiles就是环境标识，即给这个环境起个名称，以供别的配置文件调用</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">profiles:</span> <span class="hljs-string">test</span>

<span class="hljs-meta">---</span>
<span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8083</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span></code></pre>

<p><img src="./Image-sb12.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb13.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb14.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>spring-boot-starter-parent的作用与SpringBoot自动配置源码解析；</p>
<ul>
<li><p>spring-boot-starter-parent的作用；</p>
<pre><code class="hljs xml">//发现每个新建的SpringBoot项目都有一个父依赖
<span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>x.x.x.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>


说明：
一、spring-boot-starter-parent是一个SpringBoot项目，是所有SpringBoot项目的父工程，它定义了很多当前项目的规范：
    1.定义了Java编译版本为1.8；
    2.使用UTF-8格式编码；
    3.继承自spring-boot-dependencies，这个里边定义了大量的依赖的版本号，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号；
    4.执行打包操作的配置；
    5.自动化的资源过滤；
    6.自动化的插件配置；
    7.针对application.properties和application.yml的资源过滤，包括通过profile定义的不同环境的配置文件，如，application-dev.properties 和 application-dev.yml；

//------------------------------------------------------

//每个SpringBoot项目中web依赖的作用
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

说明：
一、web依赖中，包含了一个内置的Tomcat容器</code></pre>
</li>
<li><p>SpringBoot自动配置源码解析(重要)；</p>
<pre><code class="hljs java"><span class="hljs-comment">//1.我们可以发现，在使用main()方法启动SpringBoot的时候，只有一个注解@SpringBootApplication</span>

<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span></span>&#123;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
      SpringApplication.run(App<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;
   &#125;
&#125;

<span class="hljs-comment">//2.我们可以点击进去@SpringBootApplication注解中看看，可以发现有三个注解是比较重要的</span>

<span class="hljs-meta">@Target</span>(ElementType.TYPE)
<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="hljs-meta">@Documented</span>
<span class="hljs-meta">@Inherited</span>
<span class="hljs-meta">@SpringBootConfiguration</span>  <span class="hljs-comment">//我们点进去以后可以发现底层是Configuration注解，说白了这个注解的作用就是支持JavaConfig的方式来进行配置(也就是写一个类，在类上使用@Configuration注解来告诉容器这是一个配置类，帮我生成bean对象，而使用Configuration配置类等同于XML文件中的&lt;bean&gt;标签的使用)</span>
<span class="hljs-meta">@EnableAutoConfiguration</span>  <span class="hljs-comment">//该注解的作用是开启自动配置功能</span>
<span class="hljs-meta">@ComponentScan</span>(excludeFilters = &#123; <span class="hljs-meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>),</span>
<span class="hljs-class">      @<span class="hljs-title">Filter</span>(<span class="hljs-title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>) &#125;)  //这个注解的作用就是扫描注解，默认是扫描当前类下的<span class="hljs-title">package</span>，将@<span class="hljs-title">Controller</span>/@<span class="hljs-title">Service</span>/@<span class="hljs-title">Component</span>/@<span class="hljs-title">Repository</span>等注解加载到<span class="hljs-title">IOC</span>容器中</span>
<span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">SpringBootApplication</span> </span>&#123;
    ....
&#125;

<span class="hljs-comment">//3.我们知道SpringBoot可以帮我们减少很多的配置，也肯定听过“约定大于配置”这么一句话，那SpringBoot是怎么做的呢？其实靠的就是@EnableAutoConfiguration注解；简单来说，这个注解可以帮助我们自动载入应用程序所需要的所有默认配置，我们点进去看一下，发现有两个比较重要的注解</span>

<span class="hljs-meta">@Target</span>(ElementType.TYPE)
<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="hljs-meta">@Documented</span>
<span class="hljs-meta">@Inherited</span>
<span class="hljs-meta">@AutoConfigurationPackage</span>  <span class="hljs-comment">//这个注解的作用是自动配置包，在默认的情况下就是将：主配置类(@SpringBootApplication)的所在包及其子包里边的组件扫描到Spring容器中</span>
<span class="hljs-meta">@Import</span>(AutoConfigurationImportSelector<span class="hljs-class">.<span class="hljs-keyword">class</span>)  //@<span class="hljs-title">Import</span>通过快速导入的方式实现把需要的实例加入<span class="hljs-title">spring</span>的<span class="hljs-title">IOC</span>容器中，但@<span class="hljs-title">Import</span>只能用在类上</span>
<span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">EnableAutoConfiguration</span> </span>&#123;

    <span class="hljs-comment">//自动配置的开关，当我们程序使用了@EnableAutoConfiguration，如果想要关掉自动配置，只需在application.properties文件中加上，spring.boot.enableautoconfiguration = false 或者spring.boot.enable-auto-configuration = false</span>
    String ENABLED_OVERRIDE_PROPERTY = <span class="hljs-string">"spring.boot.enableautoconfiguration"</span>;

    <span class="hljs-comment">//想要排除哪些自动配置类</span>
    Class&lt;?&gt;[] exclude() <span class="hljs-keyword">default</span> &#123;&#125;;

    <span class="hljs-comment">//同上，只不过使用类的完全限定名</span>
    String[] excludeName() <span class="hljs-keyword">default</span> &#123;&#125;;
&#125;

<span class="hljs-comment">//4.我们回到@Import(AutoConfigurationImportSelector.class)这句代码上，再点进去AutoConfigurationImportSelector.class看看具体的实现是什么</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoConfigurationImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DeferredImportSelector</span>, <span class="hljs-title">BeanClassLoaderAware</span>,</span>
<span class="hljs-class">      <span class="hljs-title">ResourceLoaderAware</span>, <span class="hljs-title">BeanFactoryAware</span>, <span class="hljs-title">EnvironmentAware</span>, <span class="hljs-title">Ordered</span> </span>&#123;


    ....这里省略了成员变量....


    <span class="hljs-comment">//这个方法的作用是表明哪些自动配置类是要加入到容器中</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;

        <span class="hljs-comment">//判断spring.boot.enable-auto-configuration属性值</span>
        <span class="hljs-keyword">if</span> (!isEnabled(annotationMetadata)) &#123;
        
            <span class="hljs-comment">//返回一个空数组，不选择任何一个自动配置类，即关闭自动配置</span>
            <span class="hljs-keyword">return</span> NO_IMPORTS;
        &#125;

        AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(<span class="hljs-keyword">this</span>.beanClassLoader);

        <span class="hljs-comment">//这里的方法是重点</span>
        AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);

        <span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
    &#125;


    <span class="hljs-function"><span class="hljs-keyword">protected</span> AutoConfigurationEntry <span class="hljs-title">getAutoConfigurationEntry</span><span class="hljs-params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> </span>&#123;

        <span class="hljs-keyword">if</span> (!isEnabled(annotationMetadata)) &#123;
            <span class="hljs-keyword">return</span> EMPTY_ENTRY;
        &#125;
        AnnotationAttributes attributes = getAttributes(annotationMetadata);

        <span class="hljs-comment">//这个方法的作用是，获取META-INF/spring.factories文件中，org.springframework.boot.autoconfigure.EnableAutoConfiguration属性值，也就是得到了要进行自动配置的类的名称所组成的这么一个集合，这个方法在该类的下面</span>
        List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);
        
        <span class="hljs-comment">//移除重复自动配置类</span>
        configurations = removeDuplicates(configurations);

        <span class="hljs-comment">//获取exclude属性以及excludeName属性指定的类，将这些自动配置类跳过</span>
        Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);

        <span class="hljs-comment">//校验这些排除类</span>
        checkExcludedClasses(configurations, exclusions);

        <span class="hljs-comment">//从自动配置类集合中移除排除的类</span>
        configurations.removeAll(exclusions);

        <span class="hljs-comment">//对剩下的自动配置类做一个过滤，具体不展开了</span>
        configurations = filter(configurations, autoConfigurationMetadata);

        fireAutoConfigurationImportEvents(configurations, exclusions);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AutoConfigurationEntry(configurations, exclusions);
    &#125;
    
    ....省略了一些其他内容

<span class="hljs-comment">//-----------------------------------------------------</span>

    <span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title">getCandidateConfigurations</span><span class="hljs-params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;

        <span class="hljs-comment">//点开方法 getCandidateConfigurations()，其中核心方法是这个</span>
        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());

        Assert.notEmpty(configurations, <span class="hljs-string">"No auto configuration classes found in META-INF/spring.factories. If you "</span>+ <span class="hljs-string">"are using a custom packaging, make sure that file is             correct."</span>);

        <span class="hljs-keyword">return</span> configurations;
    &#125;

    <span class="hljs-keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;
       <span class="hljs-keyword">return</span> EnableAutoConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;
    &#125;
&#125;

<span class="hljs-comment">//-----------------------------------------------------</span>

<span class="hljs-comment">//点击上面的loadFactoryNames方法后跳转到这个类里面的方法里</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringFactoriesLoader</span> </span>&#123;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="hljs-string">"META-INF/spring.factories"</span>;

    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader)</span> </span>&#123;
        String factoryTypeName = factoryType.getName();
        <span class="hljs-keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader) &#123;

        MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);
        <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span> result;
        &#125;


        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//加载的实际是这里，而FACTORIES_RESOURCE_LOCATION的值是META-INF/spring.factories，Spring启动的时候会扫描所有jar路径下的META-INF/spring.factories，将其文件包装成Properties对象，从这个Properties对象获取到key值为EnableAutoConfiguration的数据，然后添加到容器里边</span>
            Enumeration&lt;URL&gt; urls = (classLoader != <span class="hljs-keyword">null</span> ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION 
                                              : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));

            result = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();

            <span class="hljs-keyword">while</span> (urls.hasMoreElements()) &#123;
                URL url = urls.nextElement();
                UrlResource resource = <span class="hljs-keyword">new</span> UrlResource(url);
                
                Properties properties = PropertiesLoaderUtils.loadProperties(resource);
                   <span class="hljs-keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;
                    String factoryTypeName = ((String) entry.getKey()).trim();
                    <span class="hljs-keyword">for</span> (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;
                        result.add(factoryTypeName, factoryImplementationName.trim());
                    &#125;
                &#125;
            &#125;

            cache.put(classLoader, result);
            <span class="hljs-keyword">return</span> result;

            &#125;<span class="hljs-keyword">catch</span> (IOException ex) &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Unable to load factories from location ["</span> + FACTORIES_RESOURCE_LOCATION + <span class="hljs-string">"]"</span>, ex);
        &#125;
    &#125;

<span class="hljs-comment">//5.查看一下spring.factories里面配置的所有EnableAutoConfiguration的值，以上的操作，将EnableAutoConfiguration的值加入到了容器中，spring.factories文件在org.springframework.boot:spring-boot-autoconfigure:x.x.x RELEASE这个JAR包下</span>
# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\
org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\
org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\
org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\
org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\
org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\
org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\
org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\
org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveRestClientAutoConfiguration,\
org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\
org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\
org.springframework.boot.autoconfigure.elasticsearch.rest.RestClientAutoConfiguration,\
org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\
org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\
org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\
org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\
org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\
org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\
org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\
org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\
org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\
org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\
org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\
org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\
org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\
org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\
org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\
org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\
org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\
org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\
org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\
org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\
org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\
org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\
org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\
org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\
org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\
org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\
org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\
org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\
org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\
org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\
org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\
org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\
org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\
org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\
org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\
org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\
org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\
org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\
org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\
org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\
org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\
org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\
org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\
org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\
org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\
org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\
org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\
org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\
org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\
org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\
org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\
org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\
org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration

<span class="hljs-comment">//6.总结：@SpringBootApplication等同于下面三个注解：@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan；其中@EnableAutoConfiguration是关键(启用自动配置)，内部实际上就去加载META-INF/spring.factories文件的信息，然后筛选出以EnableAutoConfiguration为key的数据，加载到IOC容器中，实现自动配置功能</span>

<span class="hljs-comment">//7.以HttpEncodingAutoConfiguration(springmvc自动配置)，来解释xxxAutoConfiguration类是如何进行自动配置, 和SpringBoot中的默认值是以什么样的方式给予他默认值的</span>

<span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span>
<span class="hljs-meta">@EnableConfigurationProperties</span>(HttpEncodingProperties<span class="hljs-class">.<span class="hljs-keyword">class</span>)  //启动指定类的@<span class="hljs-title">ConfigurationProperties</span>注解的功能，也就是将全局配置文件中对应的用户设置的属性值和<span class="hljs-title">HttpEncodingProperties</span>绑定起来，并把<span class="hljs-title">HttpEncodingProperties</span>加入到<span class="hljs-title">IOC</span>容器中，也就是生成这个类的<span class="hljs-title">bean</span>对象；因为如果一个配置类只配置@<span class="hljs-title">ConfigurationProperties</span>注解，而没有使用@<span class="hljs-title">Component</span>，那么在<span class="hljs-title">IOC</span>容器中是获取不到<span class="hljs-title">properties</span>配置文件生成的<span class="hljs-title">bean</span>对象的；说白了@<span class="hljs-title">EnableConfigurationProperties</span>相当于把使用@<span class="hljs-title">ConfigurationProperties</span>注解的类进行了一次注入，也就是生成<span class="hljs-title">bean</span>对象的意思</span>
<span class="hljs-class">@<span class="hljs-title">ConditionalOnWebApplication</span>(<span class="hljs-title">type</span> </span>= ConditionalOnWebApplication.Type.SERVLET)  <span class="hljs-comment">//Spring底层@Conditional注解，根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效</span>
<span class="hljs-meta">@ConditionalOnClass</span>(CharacterEncodingFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)  //判断应用中有没有这个类<span class="hljs-title">CharacterEncodingFilter</span>，如果有，当前配置类生效</span>
<span class="hljs-class">@<span class="hljs-title">ConditionalOnProperty</span>(<span class="hljs-title">prefix</span> </span>= <span class="hljs-string">"spring.http.encoding"</span>, value = <span class="hljs-string">"enabled"</span>, matchIfMissing = <span class="hljs-keyword">true</span>)  <span class="hljs-comment">//判断在配置文件中年是否存在配置spring.http.encoding，如果不存在，则判断成立，使用默认的属性spring.http.encoding.enabled = true</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span> </span>&#123;

    <span class="hljs-comment">//注入HttpEncodingProperties的</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HttpEncodingProperties properties; 


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span><span class="hljs-params">(HttpEncodingProperties properties)</span> </span>&#123;

        <span class="hljs-comment">//参数的值从容器中取出</span>
        <span class="hljs-keyword">this</span>.properties = properties;
    &#125;


    <span class="hljs-meta">@Bean</span>  <span class="hljs-comment">//容器中添加组件，组件的某些值要从properties获取</span>
    <span class="hljs-meta">@ConditionalOnMissingBean</span>  <span class="hljs-comment">//判断有误这个组件CharacterEncodingFilter</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CharacterEncodingFilter <span class="hljs-title">characterEncodingFilter</span><span class="hljs-params">()</span> </span>&#123;

        CharacterEncodingFilter filter = <span class="hljs-keyword">new</span> OrderedCharacterEncodingFilter();
        filter.setEncoding(<span class="hljs-keyword">this</span>.properties.getCharset().name());
        filter.setForceRequestEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(Type.REQUEST));
        filter.setForceResponseEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(Type.RESPONSE));
        <span class="hljs-keyword">return</span> filter;
    &#125;

    ....省略其他一些配置
&#125;</code></pre>

<p><strong><code>注意：下图是常用的@Conditional注解的派生类。</code></strong></p>
<p><img src="./Image-sb15.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb16.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-2-SpringBoot的日志"><a href="#NO2-2-SpringBoot的日志" class="headerlink" title="NO2.2 SpringBoot的日志"></a>NO2.2 SpringBoot的日志</h3><p>Java日志框架众多，常用的有<code>java.util.logging(即JUL)</code>、<code>log4j</code>、<code>logback</code>、<code>commons-logging</code>等等。</p>
<ul>
<li><p>SpringBoot采用了<code>slf4j+logback</code>的组合形式，且SpringBoot也提供对JUL、log4j2、Logback提供了默认配置；常用日志框架，如下图所示。</p>
<p><img src="./Image-sb17.png" srcset="/img/loading.gif" alt="Image"></p>
<ul>
<li><p>SpringBoot的默认日志配置；如果要修改默认的日志配置，则需要在全局配置文件application.properties中进行修改；</p>
<pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)  //该注解的作用就是一个运行器，让测试运行于<span class="hljs-title">Spring</span>测试环境，即能够获得<span class="hljs-title">Spring</span>容器并使用它</span>
<span class="hljs-class">@<span class="hljs-title">SpringBootTest</span></span>
<span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">SpringBootLoggerTest</span></span>&#123;

    <span class="hljs-comment">//这是日志记录器对象，由日志记录器对象工厂得来</span>
    Logger logger = LoggerFactory.getLogger(getClass());

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testLogger</span><span class="hljs-params">()</span> </span>&#123;

        logger.trace(<span class="hljs-string">"这是trace日志..."</span>);
        logger.debug(<span class="hljs-string">"这是debug日志..."</span>);

        logger.info(<span class="hljs-string">"这是info日志..."</span>);
        logger.warn(<span class="hljs-string">"这是warn日志..."</span>);
        logger.error(<span class="hljs-string">"这是error日志..."</span>);
    &#125;

&#125;

说明：
一、<span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)和@<span class="hljs-title">RunWith</span>(<span class="hljs-title">SpringJUnit4ClassRunner</span>.<span class="hljs-title">class</span>)，这两这的区别是，<span class="hljs-title">SpringRunner</span>继承了<span class="hljs-title">SpringJUnit4ClassRunner</span>，没有扩展任何功能；使用前者，名字简短而已；</span>
<span class="hljs-class"></span>
<span class="hljs-class">二、日志的级别：由低到高为，<span class="hljs-title">trace</span> &lt; <span class="hljs-title">debug</span> &lt; <span class="hljs-title">info</span> &lt; <span class="hljs-title">warn</span> &lt; <span class="hljs-title">error</span>，可以调整输出的日志级别，这样就会输出某个级别之后的日志信息，如<span class="hljs-title">info</span>级别，则只会输出<span class="hljs-title">info</span>级别往上的级别的信息，<span class="hljs-title">trace</span>和<span class="hljs-title">debug</span>信息就不会输出了；</span>
<span class="hljs-class"></span>
<span class="hljs-class">三、还可以在全局配置文件中，即<span class="hljs-title">application</span>.<span class="hljs-title">properties</span>中配置指定包的日志级别，<span class="hljs-title">logging</span>.<span class="hljs-title">level</span>.指定包的全路径包名</span>=日志级别，如，logging.level.cn.dyf=trace，这样就将cn.dyf包下的所有类的日志级别设置为了trace；

四、SpringBoot默认给我们使用的是info级别的，如果我们没有指定级别的话就用SpringBoot默认规定的级别：root级别，其实这个root级别就是info级别，只是称呼不一样，也可以在全局配置文件中设置root级别，使用logging.level.root=日志级别；

五、配置日志输出的路径或文件名称：logging.file.path或logging.file.name，前者配置日志文件的输出路径(就是把这个日志文件放到哪里去，而SpringBoot默认的日志文件名称是spring.log)，后者配置的则是输出的日志信息文件的名称，但是这两个只能配置其中一个，因为官网说明只能生效一个；

六、配置日志信息的格式，使用logging.pattern.console=日志格式，这是指定控制台输出的日志信息格式；使用logging.pattern.file=日志格式，这是指定向文件中输出的日志信息格式；而日志输出格式：%d表示日期时间；%thread表示线程名；%-<span class="hljs-number">5l</span>evel表示级别从左显示<span class="hljs-number">5</span>个字符宽度；%logger&#123;<span class="hljs-number">50</span>&#125;表示logger名字最长<span class="hljs-number">50</span>个字符，否则按照句点分割；%msg：日志消息；%n是换行符，如，%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-<span class="hljs-number">5l</span>evel %logger&#123;<span class="hljs-number">50</span>&#125; - %msg%n。</code></pre>
</li>
<li><p>指定日志配置；<strong><code>注意：指定日志的配置需要在类路径(就是Resources文件夹下)的logback.xml(不同的日志框架用不同的配置文件名称就行了)中进行配置自己想要定义的配置。</code></strong></p>
<p><img src="./Image-sb18.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb19.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-3-SpringBoot的Web开发"><a href="#NO2-3-SpringBoot的Web开发" class="headerlink" title="NO2.3 SpringBoot的Web开发"></a>NO2.3 SpringBoot的Web开发</h3><p>SpringBoot中也提供了用于web层开发使用的一些技术栈，但web毕竟不是我们Java该干的主要事情，所以只介绍几个。</p>
<ul>
<li><p>SpringBoot对静态资源的映射，也就是对图片、js、css等资源的访问，提供了一套默认配置，一般该默认配置就足够开发使用。</p>
<pre><code class="hljs java"><span class="hljs-comment">//SpringBoot默认将对“/**”所有访问映射到以下目录</span>

classpath:/<span class="hljs-keyword">static</span>，其实就是Maven工程里的resources文件夹下的<span class="hljs-keyword">static</span>文件夹

classpath:/<span class="hljs-keyword">public</span>，其实就是Maven工程里的resources文件夹下的<span class="hljs-keyword">public</span>文件夹

classpath:/resources，其实就是Maven工程里的resources文件夹下的resources文件夹

classpath:/META-INF/resources，其实就是Maven工程里的resources文件夹下的META-INF文件夹下边的resources文件夹下

说明：
一、classpath在maven项目中指的就是resources文件夹，在不是maven的项目中指的是WEB-INF/classes；

二、还可以自定义静态资源的文件夹，也就是你来定义哪个或哪些文件夹用来存放静态资源，但是这样会修改SpringBoot默认对静态资源的映射，也就是上面所提到的那些路径将不再生效，而是采用你定义的文件夹存放静态资源，使用spring.resources.<span class="hljs-keyword">static</span>-locations=classpath:/aaa,classpath:/ddd，这样就表示类路径下的aaa和ddd文件夹才是存放静态资源的文件夹了；

三、所有对“/webjars<span class="hljs-comment">/**”的请求，都会去classpath:META-INF/resources/webjars文件夹下找资源；如js、css资源等等，webjars是指以JAR包的方式引入静态资源；</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">四、SpringBoot访问静态资源，默认有两个默认目录,一个是classpath/static目录(src/mian/resource)，一个是ServletContext根目录下(src/main/webapp)。</span></code></pre>

</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>SpringBoot中使用模板引擎Thymeleaf。</p>
<ul>
<li><p>介绍：简单的说，Thymeleaf是一个跟 Velocity、FreeMarker类似的模板引擎，它可以完全替代JSP；SpringBoot中默认的模板映射路径是：<code>src/main/resources/templates</code>，也就是说静态页面是放在这里的；</p>
</li>
<li><p>基本步骤：</p>
<ul>
<li><p>导入Thymeleaf的依赖；</p>
<pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
</li>
<li><p>把要展示的html页面放入到classpath:/templates文件夹下(也就是放入Maven工程里的resources下的templates里面，没有templates这个文件夹的话，创建一个就可以了)；</p>
</li>
<li><p>在html页面中导入Thymeleaf的命名空间；</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span></code></pre>
</li>
<li><p>最后使用Thymeleaf的语法渲染页面即可，Thymeleaf的语法前缀是：<code>th</code>；<strong><code>并且；注意：th:任意html属性，使用这种形式可以替换原生属性的值。如&lt;div id=&quot;xx&quot;&gt;，可以写成&lt;div th:id=&quot;xxx&quot;&gt;。</code></strong></p>
<ul>
<li><p>基本语法格式：</p>
<ul>
<li><p><code>th:text</code>：这个语法的基本作用就是显示文本，也可以用于一些简单的运算(加减乘除)，用于HTML标签的内部；</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;msg&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    
    如果需要对取出的值作字符串的拼接操作，在值前面多添加一个''就行了，也就是添加一个空字符串，如：<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"'' + $&#123;msg&#125; + '123'"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre>
</li>
<li><p><code>th:value</code>：这个语法用于给value属性赋值；</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">"$&#123;user.name&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span> 
    等价于 
<span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"xxx"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></code></pre>
</li>
<li><p><code>th:if</code>：这个标签用于判断是否满足条件，还可以多条件 and，or(二元操作符)，!，not非(一元操作符)；</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"$&#123;msg&#125; == '男'"</span>&gt;</span>性别：男<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre>
</li>
<li><p><code>th:switch和th:case搭配</code>：这个标签用于多选一，即符合哪个条件就走哪里；</p>
<pre><code class="hljs html">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:switch</span>=<span class="hljs-string">"$&#123;msg&#125;"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">"男"</span>&gt;</span>我是男的<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">"女"</span>&gt;</span>我是女的<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
</li>
<li><p><code>th:each</code>：该标签用于循环遍历数组，集合；<code>格式：th:each=&quot;自定义变量名,自定义状态变量名:${被遍历的数组或集合}&quot;</code>；<strong><code>注意：该语法用在哪个标签里，那么这个标签每次遍历都会新生成一次。</code></strong></p>
<pre><code class="hljs html">    <span class="hljs-comment">&lt;!-- 遍历普通集合 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"user,status:$&#123;userList&#125;"</span>&gt;</span>
    
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;user.userId&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;user.userName&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;user.userAge&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    
        <span class="hljs-comment">&lt;!-- 以下都是自定义状态变量status的属性 --&gt;</span>
    
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;status.index&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  ---当前迭代对象的index，即索引值(从0开始计算)
    
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;status.count&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  ---当前迭代对象的个数，即第几个(从1开始计算)
    
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;status.size&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  ---被迭代的数组或集合的长度
    
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;status.even&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  ---当前迭代的对象是否是第偶数个(从0开始计算)
    
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;status.odd&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  ---当前迭代的对象是否是第奇数个(从0开始计算)
    
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;status.first&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  ---当前迭代的对象是否是第一个
    
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;status.last&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  ---当前迭代的对象是否是最后一个
    
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;status.current&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  ---当前迭代的对象，就是该对象的内存地址值：包名+类名@地址值；
    
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    
    //----------------------------------------------------------
    
    
    <span class="hljs-comment">&lt;!-- 遍历Map集合 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"userEntrySet:$&#123;userMap&#125;"</span>&gt;</span>
    
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"husbandKey:$&#123;userEntrySet&#125;"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;husbandKey.key&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"wifeValue:$&#123;userEntrySet&#125;"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;wifeValue.value.userId&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"wifeValue:$&#123;userEntrySet&#125;"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;wifeValue.value.userName&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"wifeValue:$&#123;userEntrySet&#125;"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;wifeValue.value.userAge&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    
    注意：Map形式的集合，获取到的是一个Key-Value的元素集合，所以需要再一次遍历这个元素集合，就可以分别获得key和value</code></pre>
</li>
<li><p><code>th:object</code>：该标签用于表单数据对象绑定，将表单绑定到后台Controller的一个JavaBean参数，常与<code>th:field</code>一起使用进行表单数据绑定；选择表达式<code>*{...}</code>一般跟在th:object后，直接取object中的属性；</p>
</li>
</ul>
</li>
<li><p>Thymeleaf的表达式；</p>
<ul>
<li><p><code>${...}</code>：该表达式为变量表达式，它的作用是从Thymeleaf上下文获取指定变量的值；Thymeleaf提供了一些预定义变量param、session和application，使用<code>${}</code>可以方便地获取这些变量的值；</p>
<pre><code class="hljs html">获取当前Request中名称为x的参数：
$&#123;param.x&#125;

获取当前Request域中名称为x的属性：
$&#123;#httpServletRequest.getAttribute('x')&#125;

获取当前session中名称为x的属性：
$&#123;session.x&#125;

获取当前ServletContext中名称为x的属性：
$&#123;application.x&#125;

<span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;welcome&#125;"</span>&gt;</span>这是欢迎问候<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
结果：如果当前上下文存在一个welcome变量的话，就显示这个值，否则显示默认的内容：这是欢迎问候；</code></pre>
</li>
<li><p><code>@{...}</code>：该表达式为URL表达式，它的作用相当于<code>&lt;a&gt;&lt;/a&gt;</code>标签的href属性，如果有参数，则在URL后面加个()，参数直接用,隔开即可；</p>
<pre><code class="hljs html">无参的URL：
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@&#123;/order/list&#125;"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>

带参数的URL：
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@&#123;/order/details(id=$&#123;xxx&#125;,type=$&#123;xxx&#125;)&#125;"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>

相对地址：<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@&#123;../documents/report&#125;"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
绝对地址：<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@&#123;http://www.baidu.com&#125;"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre>
</li>
<li><p><code>*{...}</code>：该表达式为选择表达式，选择表达式一般跟在th:object后，直接选择object中的属性；<code>*{...}</code>表达式的值是在选定的对象；也就是说，如果没有选定的对象，<code>*{...}</code>和<code>${...}</code>没有区别；</p>
</li>
</ul>
</li>
<li><p>Thymeleaf中的常用内置对象；</p>
<ul>
<li><p><code>#dates</code>：日期格式化内置对象，具体方法可以参照java.util.Date；</p>
<ul>
<li><p>格式化日期；</p>
<pre><code class="hljs html">$&#123;#dates.format(XXX)&#125;，如果没有设置日期格式，默认使用浏览器默认的语言进行格式化日期

$&#123;#dates.format(XXX,'yyyy年MM月dd日 HH时mm分ss秒')&#125;，指定日期格式进行格式化日期</code></pre>
</li>
</ul>
</li>
<li><p><code>#calendars</code>：类似于<code>#dates</code>，但却是java.util.Calendar类的方法；</p>
</li>
<li><p><code>#numbers</code>：数字格式化；</p>
</li>
<li><p><code>#strings</code>：字符串格式化，具体方法可以参照java.lang.String，如startsWith、contains等；</p>
<pre><code class="hljs smalltalk"><span class="hljs-string">$&#123;</span><span class="hljs-symbol">#strings</span>.isEmpty(<span class="hljs-type">XXX</span>)&#125;：用于判断字符串是否为空，是就返回<span class="hljs-keyword">true</span>，否则返回<span class="hljs-keyword">false</span>；
<span class="hljs-string">$&#123;</span><span class="hljs-symbol">#strings</span>.contains(<span class="hljs-type">XXX</span>,<span class="hljs-string">'x'</span>)&#125;：用于判断字符串是否包含指定子字符串，包含就返回<span class="hljs-keyword">true</span>，否则返回<span class="hljs-keyword">false</span>；
<span class="hljs-string">$&#123;</span><span class="hljs-symbol">#strings</span>.startsWith(<span class="hljs-type">XXX</span>,<span class="hljs-string">'x'</span>)&#125;：用于判断字符串是否以子字符串开头，是就返回<span class="hljs-keyword">true</span>，否则返回<span class="hljs-keyword">false</span>；
<span class="hljs-string">$&#123;</span><span class="hljs-symbol">#strings</span>.endsWith(<span class="hljs-type">XXX</span>,<span class="hljs-string">'x'</span>)&#125;：用于判断字符串是否以子字符串结尾，是就返回<span class="hljs-keyword">true</span>，否则返回<span class="hljs-keyword">false</span>；
<span class="hljs-string">$&#123;</span><span class="hljs-symbol">#strings</span>.length(<span class="hljs-type">XXX</span>)&#125;：用于获取字符串的长度；
<span class="hljs-string">$&#123;</span><span class="hljs-symbol">#strings</span>.indexOf(<span class="hljs-type">XXX</span>,<span class="hljs-string">'x'</span>)&#125;：用于获取字符串中指定子字符串的索引，没有就返回<span class="hljs-number">-1</span>；</code></pre>
</li>
<li><p><code>#objects</code>：参照java.lang.Object；</p>
</li>
<li><p><code>#bools</code>：判断boolean类型的工具；</p>
</li>
<li><p><code>#arrays</code>：数组操作的工具；</p>
</li>
<li><p><code>#lists</code>：列表操作的工具，参照java.util.List；</p>
</li>
<li><p><code>#sets</code>：Set操作工具，参照java.util.Set；</p>
</li>
<li><p><code>#maps</code>：Map操作工具，参照java.util.Map；</p>
</li>
<li><p><code>#aggregates</code>：操作数组或集合的工具；</p>
</li>
<li><p><code>#messages</code>：操作消息的工具；</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>SpringBoot中使用JSP。</p>
<ul>
<li><p>基本步骤：</p>
<ul>
<li><p>需要使用的依赖；</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- JSTL依赖 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-comment">&lt;!-- JSP引擎：JASPER依赖 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
</li>
<li><p>在Maven项目的src/main/resource目录下创建application.properties文件，用于配置JSP的前缀和后缀，作用和SpringMVC的视图解析器配置一样。</p>
<pre><code class="hljs xml">spring.mvc.view.prefix=/WEB-INF/jsp/
spring.mvc.view.suffix=.jsp</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>SpringBoot中使用FreeMarker。</p>
<ul>
<li><p>介绍：SpringBoot要求模板形式的视图层技术的文件必须要放到src/main/resources目录下的一个名称为templates的包下；</p>
</li>
<li><p>FreeMarker的构成：<code>由文本+插值+FTL标签+注释组成</code>；<strong><code>注意：谨记一点，就是插值只能放在文本中，不能放在FTL标签中，不然渲染模板的时候会报错。</code></strong></p>
<ul>
<li><p>文本：HTML原来的内容；</p>
</li>
<li><p>插值：<code>${}</code>或<code>#{}</code>代表的就是插值，一般来说就是后台传过来的值显示在前台用<code>${}</code>或<code>#{}</code>表示；</p>
</li>
<li><p>FTL标签：以标签中含有#的标签。<strong><code>如，&lt;#list&gt;&lt;/#list&gt;，不会显示在界面上，和html标签类似，只不过用#予以区分。</code></strong></p>
</li>
<li><p>注释：<code>&lt;#-- 注释 --&gt;</code>。</p>
<pre><code class="hljs html">正确的示范：
<span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>$&#123;user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>

错误的示范：
<span class="hljs-tag">&lt;<span class="hljs-name">#if</span> $&#123;<span class="hljs-attr">user.name</span>&#125; == <span class="hljs-string">"augus"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span>

注意：在FTL标签中，直接user.name即可，也就是对象.属性名称就行，不用插值(即不使用$&#123;&#125;)；实际上，使用标签时前面的#符号也可能变成@，如果该指令是一个用户指令而不是系统内建指令时，应将#符号改为@符号</code></pre>
</li>
</ul>
</li>
<li><p>定义变量；</p>
<ul>
<li><code>&lt;#assign var = value &gt;</code>：定义变量并初始化；</li>
<li><code>&lt;#assign str = &quot;hello world&quot; &gt;</code>：定义字符串类型；</li>
<li><code>&lt;#assign num = 13.2 &gt;</code>：定义数字类型；</li>
<li><code>&lt;#assign flag = true &gt;</code>：定义布尔类型；</li>
<li><code>&lt;#assign arr = [&quot;foo&quot;, &quot;boo&quot;, &quot;get&quot;]/&gt;</code>：定义数组；</li>
<li><code>&lt;#assign map={&quot;name&quot;:&quot;augus&quot;, &quot;age&quot;:&quot;16&quot;}&gt;</code>：定义map；</li>
</ul>
</li>
<li><p>标签的使用：</p>
<ul>
<li><p>if标签、比较运算符、!空值操作符；</p>
<pre><code class="hljs html">//if标签

<span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">condition</span>&gt;</span>
    if条件成立则输出这里的内容xxx

<span class="hljs-tag">&lt;<span class="hljs-name">#elseif</span> <span class="hljs-attr">condition</span>&gt;</span>
    elseif条件成立则输出这里的内容yyy

<span class="hljs-tag">&lt;<span class="hljs-name">#else</span>&gt;</span>
    上面两种都不符合，就会输出这里的内容
<span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span>

//-----------------------------------------

//比较运算符

x == y (等于)

x != y(不等于)

x gt y(大于)

x gte y (大于等于)

x lt y(小于)

x lte y(小于等于)

//------------------------------------------

//!空值操作符，即FreeMarker针对防止null有特定的操作符，也就是说当获取的变量为null时，所采取的措施

<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>$&#123;"name:" + name!&#125;<span class="hljs-tag">&lt;<span class="hljs-name">p</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>$&#123;(maxNumber!) + 1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

输出：
name:
1

说明：在页面中并未存在name和maxNumber的，通过加!可以处理null值的存在，如果上述例子不加!操作符，模板加载时会报错 “The following has evaluated to null or missing:”

//------------------------------------------

//创建一个数值变量
<span class="hljs-tag">&lt;<span class="hljs-name">#assign</span> <span class="hljs-attr">num</span> = <span class="hljs-string">13.2</span> &gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">num</span> <span class="hljs-attr">gt</span> <span class="hljs-attr">16</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>num大于16<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">#elseif</span> <span class="hljs-attr">num</span> <span class="hljs-attr">lt</span> <span class="hljs-attr">12</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>num小于12<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">#else</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>num在12~16的范围中<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span>

输出：num在12~16的范围中</code></pre>
</li>
<li><p>FreeMarker的list标签和循环；</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">#list</span> 需要被遍历的目标 <span class="hljs-attr">as</span> 一个自定义变量名称&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span>；

<span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">userlist</span> <span class="hljs-attr">as</span> <span class="hljs-attr">user</span> &gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.userId&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.userName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.userAge&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span>

说明：其中userlist是后台传输给前台的数据，即需要被遍历的对象，user是userlist中的遍历的每一个元素变量</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-4-SpringBoot的异常处理机制"><a href="#NO2-4-SpringBoot的异常处理机制" class="headerlink" title="NO2.4 SpringBoot的异常处理机制"></a>NO2.4 SpringBoot的异常处理机制</h3><p>SpringBoot对于异常处理提供了一些处理机制。</p>
<ul>
<li><p>SpringBoot对于处理异常，提供了五种的方式：</p>
<ul>
<li><p>自定义错误异常页面。但该方式的缺点是，无论是什么异常都会走这个error.html页面，显得不那么灵活；</p>
<ul>
<li>SpringBoot默认处理异常的机制：SpringBoot默认的已经提供了一套处理异常的机制，即一旦程序中出现了异常，SpringBoot会向RequestMappint(“/error”)的url发送请求；在SpringBoot中提供了一个叫BasicExceptionController来处理该请求，然后跳转到默认显示异常的页面来展示异常信息，但该方式通常不是我们所常用的；</li>
<li>一般我们所使用的就是自定义的异常页面：在src/main/resources/templates下创建一个名称必须为error.html的页面；然后对于错误页面进行一些简单的用户体验设计即可；</li>
</ul>
</li>
<li><p>使用@ExceptionHandler注解处理异常。但该方式的缺点是，当其他包下的Controller里也有同类型的异常时，只能使用本包下定义的@ExceptionHandler，无法使用其他包下Controller里的@ExceptionHandler，即该注解无法跨Controller，必须在本Controller中定义一个@ExceptionHandler才能解决；</p>
<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/testException"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testException</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">int</span> v = <span class="hljs-number">5</span>/<span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;
&#125;

<span class="hljs-comment">//-----------------------------------------------------------------</span>

<span class="hljs-meta">@ExceptionHandler</span>(value= &#123;java.lang.ArithmeticException<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;)</span>
<span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">ModelAndView</span> <span class="hljs-title">getException</span>(<span class="hljs-title">Exception</span> <span class="hljs-title">e</span>) </span>&#123;
    ModelAndView mav = <span class="hljs-keyword">new</span> ModelAndView();
    
    <span class="hljs-comment">//存储错误信息和跳转跳转视图</span>
    mav.addObject(<span class="hljs-string">"errorMsg"</span>, e.toString());
    mav.setViewName(<span class="hljs-string">"error"</span>);
    <span class="hljs-keyword">return</span> mav;
&#125;

说明：访问<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/testException"</span>)时，会触发除数为<span class="hljs-number">0</span>的异常；在捕获异常的方法上添加<span class="hljs-meta">@ExceptionHandler</span>(value=&#123;&#125;)，value的值是一个<span class="hljs-class"><span class="hljs-keyword">class</span>数组，即可以处理多个异常，并且该方法返回了一个<span class="hljs-title">ModelAndView</span>对象，作用是封装异常信息以及设置跳转的视图。</span></code></pre>
</li>
<li><p>使用@ControllerAdvice+@ExceptionHandler注解处理异常。但是该方式的缺点是异常越多，需要添加的捕获异常的方法也就越多；</p>
<pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionController</span> </span>&#123;

    <span class="hljs-meta">@ExceptionHandler</span>(value= &#123;java.lang.ArithmeticException<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;)</span>
<span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">ModelAndView</span> <span class="hljs-title">getException</span>(<span class="hljs-title">Exception</span> <span class="hljs-title">e</span>) </span>&#123;
        ModelAndView mav = <span class="hljs-keyword">new</span> ModelAndView();
        mav.addObject(<span class="hljs-string">"errorMsg"</span>, e.toString());
        mav.setViewName(<span class="hljs-string">"error2"</span>);
        <span class="hljs-keyword">return</span> mav;
    &#125;
&#125;


说明：<span class="hljs-meta">@ControllerAdvice</span>+<span class="hljs-meta">@ExceptionHandler</span>注解处理异常，需要创建一个能够处理异常的全局异常类，即该注解的作用就是将类定义为全局异常处理类；在该类上需要添加<span class="hljs-meta">@ControllerAdvice</span> 注解，对应捕获异常的方法上添加<span class="hljs-meta">@ExceptionHandler</span>注解，这样就可以跨Controller捕获异常了。</code></pre>
</li>
<li><p>配置SimpleMappingExceptionResolver处理异常。但是该方式的缺点是无法传递异常信息；</p>
<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionController</span> </span>&#123;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> SimpleMappingExceptionResolver <span class="hljs-title">getException</span><span class="hljs-params">()</span> </span>&#123;

        SimpleMappingExceptionResolver resolver = <span class="hljs-keyword">new</span> SimpleMappingExceptionResolver();
        Properties pp = <span class="hljs-keyword">new</span> Properties();
        pp.put(<span class="hljs-string">"java.lang.ArithmeticException"</span>,<span class="hljs-string">"error1"</span>);
        pp.put(<span class="hljs-string">"java.lang.NullPointerException"</span>,<span class="hljs-string">"error2"</span>);
        resolver.setExceptionMappings(pp);
        <span class="hljs-keyword">return</span> resolver;
    &#125;
&#125;

说明：<span class="hljs-meta">@Configuration</span>注解的类和<span class="hljs-meta">@Bean</span>注解的方法，是告诉SpringBoot在启动的时候对该类进行初始化；配置SimpleMappingExceptionResolver处理异常，必须使用<span class="hljs-meta">@Configuration</span>注解类、<span class="hljs-meta">@Bean</span>注解方法；<span class="hljs-meta">@Bean</span>注解的方法必须有返回值：SimpleMappingExceptionResolver，然后创建Properties，设置参数，参数一：异常的类型，注意必须是异常类型的全名；参数二： 视图名称。</code></pre>
</li>
<li><p>自定义HandlerExceptionResolver接口实现类来处理异常，这个比较常用(推荐)。</p>
<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerExceptionResolver</span></span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse reponse, Object object,Exception ex)</span> </span>&#123;

        ModelAndView mav = <span class="hljs-keyword">new</span> ModelAndView();

        <span class="hljs-keyword">if</span>(ex <span class="hljs-keyword">instanceof</span> ArithmeticException) &#123;
            mav.addObject(<span class="hljs-string">"error1"</span>, ex.toString());
            mav.setViewName(<span class="hljs-string">"error1"</span>);
        &#125;
        
        <span class="hljs-keyword">if</span>(ex <span class="hljs-keyword">instanceof</span> NullPointerException) &#123;
            mav.addObject(<span class="hljs-string">"error2"</span>, ex.toString());
            mav.setViewName(<span class="hljs-string">"error2"</span>);
        &#125;
        <span class="hljs-keyword">return</span> mav;
    &#125;
&#125;

说明：创建一个全局异常处理类实现HandlerExceptionResolver接口，重写resolveException()方法，并在全局异常处理类上使用<span class="hljs-meta">@Configuration</span>注解，resolveException()方法中的Exception ex就是异常对象，可以获得异常信息；使用ex <span class="hljs-keyword">instanceof</span> 异常种类，与异常种类进行匹配，然后进行不同页面的跳转即可。</code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-5-SpringBoot注册Servlet"><a href="#NO2-5-SpringBoot注册Servlet" class="headerlink" title="NO2.5 SpringBoot注册Servlet"></a>NO2.5 SpringBoot注册Servlet</h3><p>SpringBoot中也提供了Servlet注册方式。</p>
<ul>
<li><p>SpringBoot注册Servlet，有两种方式可用：</p>
<ul>
<li><p>注解式完成Servlet的注册；</p>
<pre><code class="hljs java"><span class="hljs-meta">@WebServlet</span>(name=<span class="hljs-string">"HelloWorld"</span>,urlPatterns=<span class="hljs-string">"/helloWorld"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
        System.out.println(<span class="hljs-string">"注解注册Serlvet..."</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
        doGet(request, response);
    &#125;
&#125;

说明：一定要配置<span class="hljs-meta">@WebServlet</span>(name=<span class="hljs-string">"HelloWorld"</span>,urlPatterns=<span class="hljs-string">"/helloWorld"</span>)注解，其中，name属性是以前&lt;servlet&gt;标签中的&lt;servlet-name&gt;，urlPatterns属性则是以前&lt;servlet&gt;标签中的&lt;url-pattern&gt;

------------------------------------------------以上是Servlet的部分

<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@ServletComponentScan</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(App<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;
    &#125;
&#125;

说明：<span class="hljs-meta">@SpringBootApplication</span>，该注解是表明该类是SpringBoot的启动类；<span class="hljs-meta">@ServletComponentScan</span>，该注解则是表明SpringBoot在启动时，会自动去扫描带<span class="hljs-meta">@WebServlet</span>注解的类。

------------------------------------------------以上是SpringBoot启动器的部分</code></pre>
</li>
<li><p>在配置类中配置Servlet的注册；</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
        System.out.println(<span class="hljs-string">"非注解注册Serlvet..."</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
        doGet(request, response);
    &#125;
&#125;

------------------------------------------------以上是Servlet的部分

<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfiguration</span></span>&#123;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">getSRB</span><span class="hljs-params">()</span> </span>&#123;

        ServletRegistrationBean srb = <span class="hljs-keyword">new</span> ServletRegistrationBean(<span class="hljs-keyword">new</span> HelloWorld());

        srb.addUrlMappings(<span class="hljs-string">"/helloWorld"</span>);

        <span class="hljs-keyword">return</span> srb;
    &#125;
&#125;

注意：<span class="hljs-meta">@Bean</span>的作用就是执行注册Servlet的getSRB()方法，方法名可以自定义；但是返回值一定要是：ServletRegistrationBean类型</code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-6-SpringBoot注册Filter"><a href="#NO2-6-SpringBoot注册Filter" class="headerlink" title="NO2.6 SpringBoot注册Filter"></a>NO2.6 SpringBoot注册Filter</h3><p>SpringBoot中也提供了Filter注册方式。</p>
<ul>
<li><p>SpringBoot中注册Filter，有两种方式可用：</p>
<ul>
<li><p>注解式完成Filter的注册；</p>
<pre><code class="hljs java"><span class="hljs-meta">@WebFilter</span>(filterName=<span class="hljs-string">"SBFilter"</span>,urlPatterns=<span class="hljs-string">"/helloWorld"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SBFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest arg0, ServletResponse arg1, FilterChain chain)</span><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;
        System.out.println(<span class="hljs-string">"注解式请求前经过过滤....."</span>);
        chain.doFilter(arg0, arg1);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig arg0)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;
    &#125;
&#125;

说明：<span class="hljs-meta">@WebFilter</span>的作用就是过滤对应的请求；urlPatterns是一个字符串数组，即可以同时过滤多种请求。如：urlPatterns=&#123;<span class="hljs-string">"*.do"</span>,<span class="hljs-string">"*.action"</span>&#125;。

------------------------------------------------以上是Filter部分

<span class="hljs-meta">@WebServlet</span>(name=<span class="hljs-string">"HelloWorld"</span>,urlPatterns=<span class="hljs-string">"/helloWorld"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
        System.out.println(<span class="hljs-string">"注解式Filter和Servlet..."</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
        doGet(request, response);
    &#125;
&#125;

------------------------------------------------以上是Servlet部分

<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@ServletComponentScan</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(App<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;
    &#125;
&#125;

------------------------------------------------以上是SpringBoot启动器的部分</code></pre>
</li>
<li><p>在配置类中配置Filter的注册；</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SBFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest arg0, ServletResponse arg1, FilterChain chain)</span><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;
        System.out.println(<span class="hljs-string">"非注解式请求前经过拦截....."</span>);
        chain.doFilter(arg0, arg1);
        
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig arg0)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;
    &#125;
&#125;

------------------------------------------------以上是Filter部分

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
        System.out.println(<span class="hljs-string">"非注解式Filter和Servlet..."</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
        doGet(request, response);
    &#125;
&#125;

------------------------------------------------以上是Servlet部分，请求的资源

<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfiguration</span></span>&#123;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">getSRB</span><span class="hljs-params">()</span> </span>&#123;

        ServletRegistrationBean srb = <span class="hljs-keyword">new</span> ServletRegistrationBean(<span class="hljs-keyword">new</span> HelloWorld());
        srb.addUrlMappings(<span class="hljs-string">"/helloWorld"</span>);
        <span class="hljs-keyword">return</span> srb;
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">getFRB</span><span class="hljs-params">()</span> </span>&#123;

        FilterRegistrationBean frb = <span class="hljs-keyword">new</span> FilterRegistrationBean(<span class="hljs-keyword">new</span> SBFilter());
        frb.addUrlPatterns(<span class="hljs-string">"/helloWorld"</span>);
        <span class="hljs-keyword">return</span> frb;
    &#125;
&#125;

说明：<span class="hljs-meta">@Bean</span>的作用就是执行注册对应的方法；ServletRegistrationBean注册Servlet需要使用的类；FilterRegistrationBean注册Filter需要使用的类。</code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-7-SpringBoot注册Listener"><a href="#NO2-7-SpringBoot注册Listener" class="headerlink" title="NO2.7 SpringBoot注册Listener"></a>NO2.7 SpringBoot注册Listener</h3><p>SpringBoot中也提供了Listener注册方式。</p>
<ul>
<li><p>SpringBoot中注册Listener，有两种方式：</p>
<ul>
<li><p>注解式注册Listener；</p>
<pre><code class="hljs java"><span class="hljs-meta">@WebListener</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SCListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContextListener</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextDestroyed</span><span class="hljs-params">(ServletContextEvent arg0)</span> </span>&#123;
        System.out.println(<span class="hljs-string">"监听到销毁了一个ServletContextEvent"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextInitialized</span><span class="hljs-params">(ServletContextEvent arg0)</span> </span>&#123;
        System.out.println(<span class="hljs-string">"监听到创建了一个ServletContextEvent"</span>);
    &#125;
&#125;

说明：主要需要添加一个<span class="hljs-meta">@WebListener</span>即可，因为以往的Listener配置也只是添加一个&lt;listener-<span class="hljs-class"><span class="hljs-keyword">class</span>&gt;，所以只需@<span class="hljs-title">WebListener</span>就行。</span>
<span class="hljs-class"></span>
<span class="hljs-class">------------------------------------------------以上是<span class="hljs-title">Listener</span>部分</span>
<span class="hljs-class"></span>
<span class="hljs-class">@<span class="hljs-title">SpringBootApplication</span></span>
<span class="hljs-class">@<span class="hljs-title">ServletComponentScan</span></span>
<span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">App</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(App<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;
    &#125;
&#125;
------------------------------------------------以上是SpringBoot启动器的部分</code></pre>
</li>
<li><p>配置类中配置Listener的注册；</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SCListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContextListener</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextDestroyed</span><span class="hljs-params">(ServletContextEvent arg0)</span> </span>&#123;
        System.out.println(<span class="hljs-string">"监听到销毁了一个ServletContextEvent"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextInitialized</span><span class="hljs-params">(ServletContextEvent arg0)</span> </span>&#123;
        System.out.println(<span class="hljs-string">"监听到创建了一个ServletContextEvent"</span>);
    &#125;
&#125;
------------------------------------------------以上是Listener部分

<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfiguration</span> </span>&#123;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletListenerRegistrationBean <span class="hljs-title">getSLRB</span><span class="hljs-params">()</span> </span>&#123;
        ServletListenerRegistrationBean&lt;SCListener&gt; slrb = <span class="hljs-keyword">new</span> ServletListenerRegistrationBean&lt;SCListener&gt;(<span class="hljs-keyword">new</span> SCListener());
        <span class="hljs-keyword">return</span> slrb;
    &#125;
&#125;

说明：和非注解式注册Servlet、Filter一样，在配置类中添加注册Listener方法进行注册即可；返回值必须是ServletListenerRegistrationBean。</code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-8-SpringBoot的其他容器配置"><a href="#NO2-8-SpringBoot的其他容器配置" class="headerlink" title="NO2.8 SpringBoot的其他容器配置"></a>NO2.8 SpringBoot的其他容器配置</h3><p>SpringBoot中默认支持三种嵌入式Servlet容器。</p>
<ul>
<li><p>SpringBoot中使用其他的嵌入式Servlet容器；SpringBoot中默认支持三种Servlet容器，分别为Tomcat(默认使用的是这个，因为每个项目都会使用web依赖，而引入该依赖就是默认使用的Tomcat容器作为Servlet容器的)，Jetty(用于长连接)，Undertow(该容器不支持JSP)；</p>
<ul>
<li><p>Jetty容器的配置：只需要排除掉Tomcat容器，然后引入Jetty容器的依赖即可，SpringBoot自动使用该容器了；</p>
<p><img src="./Image-sb20.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>Undertow容器的配置：只需要排除掉Tomcat容器，然后引入Undertow容器的依赖即可，SpringBoot自动使用该容器了；</p>
<p><img src="./Image-sb21.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-9-SpringBoot与数据访问"><a href="#NO2-9-SpringBoot与数据访问" class="headerlink" title="NO2.9 SpringBoot与数据访问"></a>NO2.9 SpringBoot与数据访问</h3><p>数据访问就是与数据库进行交互式操作。</p>
<ul>
<li><p>SpringBoot中常用与数据库进行交互的技术栈：</p>
<ul>
<li><p>SpringBoot中使用JDBC进行数据访问；</p>
<ul>
<li><p>基本步骤：</p>
<ul>
<li><p>创建基于SpringBoot的Maven工程，导入web依赖、MySQL依赖(连接数据库的驱动等等)、jdbc依赖；</p>
<p><img src="./Image-sb22.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb23.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>在application.xml或者application.yaml中配置连接数据库的一些属性就行了；</p>
<pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">datasource:</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">xxxx</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://ip地址:3306/指定数据库名称</span>
    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span></code></pre>

<p><strong><code>注意：SpringBoot默认可以支持的数据源类型有：org.apache.tomcat.jdbc.Datasource(推荐)、HikariDataSource、BasicDatasource；也支持自定义的数据源，如下图所示。</code></strong></p>
<p><img src="./Image-sb24.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>使用Druid连接池；</p>
<ul>
<li><p>导入Druid连接池的依赖；</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>LATEST<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
</li>
<li><p>在全局配置文件中指定连接池的类型；</p>
<pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">datasource:</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">xxxx</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://ip地址:3306/指定数据库名称</span>
    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span></code></pre>
</li>
<li><p>如果还想要配置Druid的其他参数，则可以使用如下几种方式(前提是已经引入了Druid的依赖)；</p>
<ul>
<li><p>基于配置文件的方式对Druid的属性进行配置；</p>
<pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-comment"># 数据源配置</span>
  <span class="hljs-attr">datasource:</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>
　　 <span class="hljs-comment"># MYSQL 5 驱动：com.mysql.jdbc.Driver，MYSQL 6+ 驱动：com.mysql.cj.jdbc.Driver</span>
    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/test?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=CONVERT_TO_NULL&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>
    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>

    <span class="hljs-comment"># 连接池配置</span>
    <span class="hljs-attr">druid:</span>
      <span class="hljs-comment"># 初始化大小，最小，最大</span>
      <span class="hljs-attr">initial-size:</span> <span class="hljs-number">5</span>
      <span class="hljs-attr">min-idle:</span> <span class="hljs-number">5</span>
      <span class="hljs-attr">max-active:</span> <span class="hljs-number">20</span>
      <span class="hljs-comment"># 配置获取连接等待超时的时间</span>
      <span class="hljs-attr">max-wait:</span> <span class="hljs-number">60000</span>
      <span class="hljs-comment"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位毫秒</span>
      <span class="hljs-attr">time-between-eviction-runs-millis:</span> <span class="hljs-number">60000</span>
      <span class="hljs-comment"># 配置一个连接在池中最小生存时间</span>
      <span class="hljs-attr">min-evictable-idle-time-millis:</span> <span class="hljs-number">300000</span>
      <span class="hljs-attr">validation-query:</span> <span class="hljs-string">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-string">FROM</span> <span class="hljs-string">sys_user</span>
      <span class="hljs-attr">test-while-idle:</span> <span class="hljs-literal">true</span>
      <span class="hljs-attr">test-on-borrow:</span> <span class="hljs-literal">false</span>
      <span class="hljs-attr">test-on-return:</span> <span class="hljs-literal">false</span>
      <span class="hljs-comment"># 打开 PSCache，并且指定每个连接上 PSCache 的大小</span>
      <span class="hljs-attr">pool-prepared-statements:</span> <span class="hljs-literal">true</span>
      <span class="hljs-attr">max-pool-prepared-statement-per-connection-size:</span> <span class="hljs-number">20</span>

      <span class="hljs-comment"># 配置监控统计拦截的 Filter，去掉后监控界面 SQL 无法统计，wall 用于防火墙</span>
      <span class="hljs-attr">filters:</span> <span class="hljs-string">stat,wall,log4j</span>

      <span class="hljs-comment"># 通过 connection-properties 属性打开 mergeSql 功能；慢 SQL 记录</span>
      <span class="hljs-attr">connection-properties:</span> <span class="hljs-string">druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000</span>

      <span class="hljs-comment"># 配置 DruidStatFilter</span>
      <span class="hljs-attr">web-stat-filter:</span>
        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>
        <span class="hljs-attr">url-pattern:</span> <span class="hljs-string">/*</span>
        <span class="hljs-attr">exclusions:</span> <span class="hljs-string">.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*</span>

      <span class="hljs-comment"># 配置 DruidStatViewServlet</span>
      <span class="hljs-attr">stat-view-servlet:</span>
        <span class="hljs-attr">url-pattern:</span> <span class="hljs-string">/druid/*</span>
        <span class="hljs-comment"># IP 白名单，没有配置或者为空，则允许所有访问</span>
        <span class="hljs-attr">allow:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>
        <span class="hljs-comment"># IP 黑名单，若白名单也存在，则优先使用</span>
        <span class="hljs-attr">deny:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.31</span><span class="hljs-number">.253</span>
        <span class="hljs-comment"># 禁用 HTML 中 Reset All 按钮</span>
        <span class="hljs-attr">reset-enable:</span> <span class="hljs-literal">false</span>
        <span class="hljs-comment"># 登录用户名/密码</span>
        <span class="hljs-attr">login-username:</span> <span class="hljs-string">root</span>
        <span class="hljs-attr">login-password:</span> <span class="hljs-number">123</span></code></pre>
</li>
<li><p>基于Java方式对Druid的属性进行配置；</p>
<pre><code class="hljs java">spring:
  datasource:
    username: root
    password: xxxx
    url: jdbc:mysql:<span class="hljs-comment">//ip地址:3306/指定数据库名称</span>
    driver-class-name: com.mysql.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource

    #数据源的其他配置
    initialSize: <span class="hljs-number">5</span>
    minIdle: <span class="hljs-number">5</span>
    maxActive: <span class="hljs-number">20</span>
    maxWait: <span class="hljs-number">60000</span>
    timeBetweenEvictionRunsMillis: <span class="hljs-number">60000</span>
    minEvictableIdleTimeMillis: <span class="hljs-number">300000</span>
    validationQuery: SELECT <span class="hljs-number">1</span> FROM DUAL
    testWhileIdle: <span class="hljs-keyword">true</span>
    testOnBorrow: <span class="hljs-keyword">false</span>
    testOnReturn: <span class="hljs-keyword">false</span>
    poolPreparedStatements: <span class="hljs-keyword">true</span>


    # 配置监控统计拦截的 filters，去掉后监控界面 sql 无法统计，'wall'用于防火墙
    filters: stat,wall,log4j
    maxPoolPreparedStatementPerConnectionSize: <span class="hljs-number">20</span>
    useGlobalDataSourceStat: <span class="hljs-keyword">true</span>
    connectionProperties: druid.stat.mergeSql=<span class="hljs-keyword">true</span>;druid.stat.slowSqlMillis=<span class="hljs-number">500</span>

<span class="hljs-comment">//--------------------------------------------------------------以上是application.yml配置文件</span>

<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidConfig</span> </span>&#123;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.datasource"</span>)  <span class="hljs-comment">//将所有前缀为spring.datasource下的配置项都加载DataSource中</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">druidDataSource</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DruidDataSource();
    &#125;

    <span class="hljs-comment">//Druid监控的配置</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean&lt;Servlet&gt; <span class="hljs-title">druidServlet</span><span class="hljs-params">()</span> </span>&#123;

        ServletRegistrationBean&lt;Servlet&gt; srb = <span class="hljs-keyword">new</span> ServletRegistrationBean&lt;&gt;(<span class="hljs-keyword">new</span> StatViewServlet(), <span class="hljs-string">"/druid/**"</span>);

        <span class="hljs-comment">// 白名单</span>
        srb.addInitParameter(<span class="hljs-string">"allow"</span>, <span class="hljs-string">"127.0.0.1"</span>);

        <span class="hljs-comment">// 黑名单</span>
        srb.addInitParameter(<span class="hljs-string">"deny"</span>, <span class="hljs-string">"192.168.31.253"</span>);

        <span class="hljs-comment">// 用户名</span>
        srb.addInitParameter(<span class="hljs-string">"loginUsername"</span>, <span class="hljs-string">"root"</span>);

        <span class="hljs-comment">// 密码</span>
        srb.addInitParameter(<span class="hljs-string">"loginPassword"</span>, <span class="hljs-string">"root"</span>);

        <span class="hljs-comment">// 是否可以重置数据源</span>
        srb.addInitParameter(<span class="hljs-string">"resetEnable"</span>, <span class="hljs-string">"false"</span>);

        <span class="hljs-keyword">return</span> srb;
    &#125;
    
    <span class="hljs-comment">//Web监控的Filter配置</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean&lt;Filter&gt; <span class="hljs-title">filterRegistrationBean</span><span class="hljs-params">()</span> </span>&#123;

        FilterRegistrationBean&lt;Filter&gt; frb = <span class="hljs-keyword">new</span> FilterRegistrationBean&lt;&gt;();

        frb.setFilter(<span class="hljs-keyword">new</span> WebStatFilter());

        <span class="hljs-comment">// 所有请求进行监控处理</span>
        frb.addUrlPatterns(<span class="hljs-string">"/*"</span>);

        <span class="hljs-comment">// 排除名单</span>
        frb.addInitParameter(<span class="hljs-string">"exclusions"</span>, <span class="hljs-string">"*.js,*.gif,*.jpg,*.css,/druid/*"</span>);

        <span class="hljs-keyword">return</span> frb;
    &#125;
&#125;

<span class="hljs-comment">//最后，启动SpringBoot项目访问地址http://localhost:8080/druid/login.html进行查看登录</span></code></pre>
</li>
<li><p>基于注解的方式对Druid的属性进行配置；</p>
<pre><code class="hljs java">spring:
  datasource:
    username: root
    password: xxxx
    url: jdbc:mysql:<span class="hljs-comment">//ip地址:3306/指定数据库名称</span>
    driver-class-name: com.mysql.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource

    #数据源的其他配置
    initialSize: <span class="hljs-number">5</span>
    minIdle: <span class="hljs-number">5</span>
    maxActive: <span class="hljs-number">20</span>
    maxWait: <span class="hljs-number">60000</span>
    timeBetweenEvictionRunsMillis: <span class="hljs-number">60000</span>
    minEvictableIdleTimeMillis: <span class="hljs-number">300000</span>
    validationQuery: SELECT <span class="hljs-number">1</span> FROM DUAL
    testWhileIdle: <span class="hljs-keyword">true</span>
    testOnBorrow: <span class="hljs-keyword">false</span>
    testOnReturn: <span class="hljs-keyword">false</span>
    poolPreparedStatements: <span class="hljs-keyword">true</span>

    # 配置监控统计拦截的 filters，去掉后监控界面 sql 无法统计，'wall'用于防火墙
    filters: stat,wall,log4j
    maxPoolPreparedStatementPerConnectionSize: <span class="hljs-number">20</span>
    useGlobalDataSourceStat: <span class="hljs-keyword">true</span>
    connectionProperties: druid.stat.mergeSql=<span class="hljs-keyword">true</span>;druid.stat.slowSqlMillis=<span class="hljs-number">500</span>

<span class="hljs-comment">//------------------------------------------------------------------------------------以上是application.yml配置文件</span>

<span class="hljs-comment">//配置WebServlet</span>

<span class="hljs-meta">@WebServlet</span>(urlPatterns = <span class="hljs-string">"/druid/*"</span>, 
            initParams=&#123;
            <span class="hljs-meta">@WebInitParam</span>(name=<span class="hljs-string">"allow"</span>,value=<span class="hljs-string">"192.168.16.110,127.0.0.1"</span>),  <span class="hljs-comment">//IP白名单(没有配置或者为空，则允许所有访问)</span>
            <span class="hljs-meta">@WebInitParam</span>(name=<span class="hljs-string">"deny"</span>,value=<span class="hljs-string">"192.168.16.111"</span>),  <span class="hljs-comment">//IP黑名单(存在共同时，deny优先于allow)</span>
            <span class="hljs-meta">@WebInitParam</span>(name=<span class="hljs-string">"loginUsername"</span>,value=<span class="hljs-string">"admin"</span>),  <span class="hljs-comment">//用户名</span>
            <span class="hljs-meta">@WebInitParam</span>(name=<span class="hljs-string">"loginPassword"</span>,value=<span class="hljs-string">"admin"</span>),  <span class="hljs-comment">//密码</span>
            <span class="hljs-meta">@WebInitParam</span>(name=<span class="hljs-string">"resetEnable"</span>,value=<span class="hljs-string">"false"</span>)  <span class="hljs-comment">//禁用HTML页面上的“Reset All”功能</span>
            &#125;)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatViewServlet</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;
&#125;

<span class="hljs-comment">//------------------------------------------------------------------------------------</span>

<span class="hljs-comment">//配置WebFilter</span>

<span class="hljs-meta">@WebFilter</span>(filterName=<span class="hljs-string">"druidWebStatFilter"</span>,urlPatterns=<span class="hljs-string">"/*"</span>, 
           initParams=&#123;
           <span class="hljs-meta">@WebInitParam</span>(name=<span class="hljs-string">"exclusions"</span>,value=<span class="hljs-string">"*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*"</span>)  <span class="hljs-comment">//忽略资源</span>
           &#125;)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebStatFilter</span> </span>&#123;
&#125;

<span class="hljs-comment">//------------------------------------------------------------------------------------</span>

<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@ServletComponentScan</span>(<span class="hljs-string">"com.uy.servlet"</span>)  <span class="hljs-comment">//扫描我们配置Servlet类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootApplication</span></span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(SpringBootApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>; &#125; 
&#125;

<span class="hljs-comment">//最后，启动SpringBoot项目访问地址http://localhost:8080/druid/login.html进行查看登录</span>

说明：一、<span class="hljs-meta">@Component</span>注解表明一个类会作为组件类，并告知Spring要为这个类创建bean

二、<span class="hljs-meta">@Bean</span>注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean，通常方法体中包含了最终产生bean实例的逻辑

三、两者的目的是一样的，都是注册bean到Spring容器中，<span class="hljs-meta">@Component</span>（<span class="hljs-meta">@Controller</span>、<span class="hljs-meta">@Service</span>、<span class="hljs-meta">@Repository</span>）通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中，而<span class="hljs-meta">@Bean</span>注解通常是我们在标有该注解的方法中定义产生这个bean的逻辑</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>SpringBoot中使用MyBatis进行数据访问；</p>
<ul>
<li><p>基本步骤：</p>
<ul>
<li><p>导入需要的Web依赖、MySQL依赖(数据库驱动)、JDBC依赖(自动配置数据源)、以及MyBatis依赖；</p>
<p><img src="./Image-sb25.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb26.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>在全局配置文件中配置连接数据库的基本属性；</p>
<pre><code class="hljs java">&lt;!--在pom.xml中引入Druid的依赖，并使用Druid连接池--&gt;

&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;LATEST&lt;/version&gt;
&lt;/dependency&gt;

<span class="hljs-comment">//-------------------------------------------------------------</span>

spring:
  datasource:
    username: root
    password: xxxx
    url: jdbc:mysql:<span class="hljs-comment">//ip地址:3306/指定数据库名称</span>
    driver-class-name: com.mysql.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource

    #数据源的其他配置
    initialSize: <span class="hljs-number">5</span>
    minIdle: <span class="hljs-number">5</span>
    maxActive: <span class="hljs-number">20</span>
    maxWait: <span class="hljs-number">60000</span>
    timeBetweenEvictionRunsMillis: <span class="hljs-number">60000</span>
    minEvictableIdleTimeMillis: <span class="hljs-number">300000</span>
    validationQuery: SELECT <span class="hljs-number">1</span> FROM DUAL
    testWhileIdle: <span class="hljs-keyword">true</span>
    testOnBorrow: <span class="hljs-keyword">false</span>
    testOnReturn: <span class="hljs-keyword">false</span>
    poolPreparedStatements: <span class="hljs-keyword">true</span>

    # 配置监控统计拦截的 filters，去掉后监控界面 sql 无法统计，'wall'用于防火墙
    filters: stat,wall,log4j
    maxPoolPreparedStatementPerConnectionSize: <span class="hljs-number">20</span>
    useGlobalDataSourceStat: <span class="hljs-keyword">true</span>
    connectionProperties: druid.stat.mergeSql=<span class="hljs-keyword">true</span>;druid.stat.slowSqlMillis=<span class="hljs-number">500</span>

<span class="hljs-comment">//----------------------------------------------------</span>

<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidConfig</span> </span>&#123;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.datasource"</span>)  <span class="hljs-comment">//将所有前缀为spring.datasource下的配置项都加载DataSource中</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">druidDataSource</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DruidDataSource();
    &#125;

    <span class="hljs-comment">//Druid监控的配置</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean&lt;Servlet&gt; <span class="hljs-title">druidServlet</span><span class="hljs-params">()</span> </span>&#123;

        ServletRegistrationBean&lt;Servlet&gt; srb = <span class="hljs-keyword">new</span> ServletRegistrationBean&lt;&gt;(<span class="hljs-keyword">new</span> StatViewServlet(), <span class="hljs-string">"/druid/**"</span>);

        <span class="hljs-comment">// 白名单</span>
        srb.addInitParameter(<span class="hljs-string">"allow"</span>, <span class="hljs-string">"127.0.0.1"</span>);

        <span class="hljs-comment">// 黑名单</span>
        srb.addInitParameter(<span class="hljs-string">"deny"</span>, <span class="hljs-string">"192.168.31.253"</span>);

        <span class="hljs-comment">// 用户名</span>
        srb.addInitParameter(<span class="hljs-string">"loginUsername"</span>, <span class="hljs-string">"root"</span>);

        <span class="hljs-comment">// 密码</span>
        srb.addInitParameter(<span class="hljs-string">"loginPassword"</span>, <span class="hljs-string">"root"</span>);

        <span class="hljs-comment">// 是否可以重置数据源</span>
        srb.addInitParameter(<span class="hljs-string">"resetEnable"</span>, <span class="hljs-string">"false"</span>);

        <span class="hljs-keyword">return</span> srb;
    &#125;
    
    <span class="hljs-comment">//Web监控的Filter配置</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean&lt;Filter&gt; <span class="hljs-title">filterRegistrationBean</span><span class="hljs-params">()</span> </span>&#123;

        FilterRegistrationBean&lt;Filter&gt; frb = <span class="hljs-keyword">new</span> FilterRegistrationBean&lt;&gt;();

        frb.setFilter(<span class="hljs-keyword">new</span> WebStatFilter());

        <span class="hljs-comment">// 所有请求进行监控处理</span>
        frb.addUrlPatterns(<span class="hljs-string">"/*"</span>);

        <span class="hljs-comment">// 排除名单</span>
        frb.addInitParameter(<span class="hljs-string">"exclusions"</span>, <span class="hljs-string">"*.js,*.gif,*.jpg,*.css,/druid/*"</span>);

        <span class="hljs-keyword">return</span> frb;
    &#125;
&#125;

<span class="hljs-comment">//最后，启动SpringBoot项目访问地址http://localhost:8080/druid/login.html进行查看登录</span></code></pre>
</li>
<li><p>最后使用xxxMapper和xxxMapper.xml对数据库的表进行增删改查的操作即可；</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>SpringBoot中使用JPA进行数据访问；</p>
<ul>
<li><p>介绍：SpringDataJPA，基于JPA的标准对数据进行操作；简化持久层的代码，只需要编写接口即可；</p>
</li>
<li><p>基本步骤：</p>
<ul>
<li><p>导入需要的Web依赖、JPA依赖、MySQL依赖、JDBC依赖(数据源也可以使用Druid连接池)；</p>
<p><img src="./image-sb27.png" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p>在全局配置文件中配置连接数据库的基本属性；</p>
<pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">datasource:</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">xxxx</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://ip地址:3306/指定数据库名称</span>
    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span>
    
    <span class="hljs-comment">#如果使用了Druid连接池就使用这个</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>


  <span class="hljs-string">jpa</span>
    <span class="hljs-attr">hibernate:</span>
      <span class="hljs-attr">ddl-auto:</span> <span class="hljs-string">update</span>
    <span class="hljs-attr">show-sql:</span> <span class="hljs-literal">true</span>

<span class="hljs-string">说明：</span>
<span class="hljs-string">一、spring-boot工程中，jpa下hibernate的ddl-auto的各种属性：</span>
	<span class="hljs-string">ddl-auto:create：每次运行该程序，没有表格会新建表格，表内有数据会清空；</span>
    <span class="hljs-string">ddl-auto:create-drop：每次程序结束的时候会清空表；</span>
    <span class="hljs-string">ddl-auto:update：每次运行程序，没有表格会新建表格，表内有数据不会清空，只会更新；</span>
    <span class="hljs-string">ddl-auto:validate：运行程序会校验数据与数据库的字段类型是否相同，不同会报错。</span></code></pre>
</li>
<li><p>创建pojo类；</p>
<pre><code class="hljs java"><span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table</span>(name=<span class="hljs-string">"t_user"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;

    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue</span>(strategy=GenerationType.IDENTITY)
    <span class="hljs-meta">@Column</span>(name=<span class="hljs-string">"id"</span>)
    <span class="hljs-keyword">private</span> Integer id ;

    <span class="hljs-meta">@Column</span>(name=<span class="hljs-string">"name"</span>)
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-meta">@Column</span>(name=<span class="hljs-string">"age"</span>)
    <span class="hljs-keyword">private</span> Integer age;

    <span class="hljs-meta">@Column</span>(name=<span class="hljs-string">"adress"</span>)
    <span class="hljs-keyword">private</span> String adress;

    get方法和set方法....

&#125;

说明：
一、<span class="hljs-meta">@Entity</span>，标识这个实体类是一个JPA实体，告诉JPA在程序运行的时候记得生成这个实体类所对应的表；
    
二、<span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"自定义的表名"</span>)，自定义设置这个实体类在数据库所对应的表名；

三、<span class="hljs-meta">@Id</span>，把这个类里面所在的变量设置为主键Id；    
    
四、<span class="hljs-meta">@GeneratedValue</span>，设置主键的生成策略，这种方式依赖于具体的数据库，如果数据库不支持自增主键，那么这个类型是没法用的

五、<span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"自定义对应的表的字段名"</span>，length = <span class="hljs-string">"自定义长度"</span>，nullable = <span class="hljs-string">"是否可以空"</span>，unique = <span class="hljs-string">"是否唯一"</span>，columnDefinition = <span class="hljs-string">"自定义该字段的类型和长度"</span>)，表示对这个变量所对应的表字段名进行一些个性化的设置，例如表字段的名字，表字段的长度，是否为空和是否唯一等等设置</code></pre>
</li>
<li><p>编写一个Dao层的接口继承JpaRepository，JpaRepository只是一个标记接口，里面没有任何方法，若我们编写的接口继承了JpaRepository，则该接口会被IOC容器识别为一个JpaRepository Bean纳入到IOC容器中，进而可以在该接口中定义满足一定规范的方法；</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;
&#125;

说明：JPA提供的父接口是标记型接口，没有任何方法，&lt;T, ID&gt;中，即父接口后面的泛型分别为：前者是持久层管理的主要实体类型，即POJO类；后者是实体类的主ID(也就是对应表的主键)</code></pre>
</li>
<li><p>编写测试类进行测试即可；</p>
<pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(value=SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>
<span class="hljs-class">@<span class="hljs-title">SpringBootTest</span>(<span class="hljs-title">classes</span></span>= &#123;Starter<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;)</span>
<span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">JPATest</span> </span>&#123;

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> UserRepository userRepository;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span>&#123;

        User user = <span class="hljs-keyword">new</span> User();
        user.setName(<span class="hljs-string">"邓先森"</span>);
        user.setAge(<span class="hljs-number">26</span>);
        user.setAdress(<span class="hljs-string">"银河系地球村"</span>);
        userRepository.save(user);
    &#125;
&#125;</code></pre>
</li>
</ul>
</li>
<li><p>SpringData JPA提供的核心接口有以下几种；</p>
<ul>
<li><p>Repository：JPA的根接口；</p>
<ul>
<li><p>提供了根据方法名称去查询的方式：方法的名称要遵循findBy + 属性名(首字母大写)+ 查询条件(首字母大写)；<strong><code>注意：查询条件不写，默认是做相等判断。</code></strong></p>
<pre><code class="hljs java">findByNameLike(String name);

findByAge(Integer age);</code></pre>
</li>
<li><p>基于@Query注解的查询和更新，SpringData JPA使用的是JPQL语句，该语句与HQL语法极其相似；</p>
<pre><code class="hljs java"><span class="hljs-meta">@Query</span>(<span class="hljs-string">"from User where name = ?1"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">queryByNameUseHQL</span><span class="hljs-params">(String name)</span></span>;

<span class="hljs-meta">@Query</span>(value=<span class="hljs-string">"select * from t_user where name=?1 and age=?2"</span>,nativeQuery=<span class="hljs-keyword">true</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">queryByNameAndAge</span><span class="hljs-params">(String name,Integer age)</span></span>;

<span class="hljs-meta">@Query</span>(value=<span class="hljs-string">"update t_user set name=?1 where id=?2"</span>,nativeQuery=<span class="hljs-keyword">true</span>)
<span class="hljs-meta">@Modifying</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateUserById</span><span class="hljs-params">(String name,Integer id)</span></span>;

说明：
一、<span class="hljs-meta">@Query</span>使用JPQL语句进行查询，nativeQuery(是否不用转换成标准SQL语句)属性默认是<span class="hljs-keyword">false</span>，即需要转成标准的SQL语句；如果使用该方式进行数据访问，一定要在占位符?后面添加对应的索引，即?<span class="hljs-number">1</span>,?<span class="hljs-number">2</span>，否则不需要添加对应的索引

二、<span class="hljs-meta">@Query</span>注解下使用SQL语句时，需要使用nativeQuery=<span class="hljs-keyword">true</span>属性，即告诉JPA这是SQL语句，不需要转成标准的SQL语句；如果使用该方式进行数据访问，也一定要在占位符?后面添加对应的索引，即?<span class="hljs-number">1</span>,?<span class="hljs-number">2</span>，否则不需要添加对应的索引

三、做更新操作时，有更新或者删除操作时，必须要加上<span class="hljs-meta">@Modifying</span>注解才能生效，且这两项操作需要使用事务，测试类或者业务层添加<span class="hljs-meta">@Transactional</span>即可，否则报异常</code></pre>
</li>
</ul>
</li>
<li><p>CrudRepository：该接口主要完成对增删改查的操作，且该接口继承了Repository；该接口中的方法：</p>
<ul>
<li><p>save(entity)：添加一条数据；</p>
</li>
<li><p>save(entities)：添加多条数据，entities为集合，由于JDK中的集合都继承了Iterable接口，所以直接添加List即可；</p>
</li>
<li><p>findByID(id)：根据id查询一条数据；</p>
</li>
<li><p>findAll(entities)：查询全部数据；</p>
</li>
<li><p>existsById(id)：判断id是否存在；</p>
</li>
<li><p>delete(id)：根据id删除数据；</p>
</li>
<li><p>delete(entity)：根据一条数据的信息删除数据；</p>
</li>
<li><p>delete(entities)：根据多条数据的信息删除数据；</p>
</li>
<li><p>deleteAll()：删除全部信息；</p>
<pre><code class="hljs java">User target = test2.findById(<span class="hljs-number">6</span>).orElse(<span class="hljs-keyword">null</span>);

<span class="hljs-keyword">if</span>(target!=<span class="hljs-keyword">null</span>) &#123;
    System.out.println(target);
&#125;

<span class="hljs-comment">//-------------------------------------------------</span>

test2.save(User);

说明：
一、findByID(id)方法返回的是Optional类型的对象，该对象有一个orElse(Object)方法，意思是：判断findByID(id)得到的结果是否为<span class="hljs-keyword">null</span>，不是就直接返回原本的值，否则返回orElse(Object)方法中的Object，而Object一般我们写成<span class="hljs-keyword">null</span>

二、save方法既是添加，也是更新，在添加之前去数据库查看是否有相同的对象，没有则添加，有则更新；entity是对象；entities是一个集合，即元素是对象的集合</code></pre>
</li>
</ul>
</li>
<li><p>PagingAndSortingRepository：该接口主要提供分页和排序，该接口继承了CrudRepository。特殊方法：</p>
<ul>
<li><p>findAll(Sort sort)：这是排序；</p>
<pre><code class="hljs java"><span class="hljs-comment">//Sort对象的构造器里有两个参数：Direction和Properties，前者排序规则，后者是做排序的属性；</span>
还可以使用Sort sort = <span class="hljs-keyword">new</span> Sort(Order order...)构造器，即放入多个Order进行多次排序，
Order order = <span class="hljs-keyword">new</span> Order(Sort.Direction.DESC,<span class="hljs-string">"id"</span>)、
Order order = <span class="hljs-keyword">new</span> Order(Sort.Direction.ASC,<span class="hljs-string">"name"</span>)
....

<span class="hljs-comment">//单次排序</span>
Sort sort = <span class="hljs-keyword">new</span> Sort(Sort.Direction.DESC,<span class="hljs-string">"id"</span>);

List&lt;User&gt; targetList = (List&lt;User&gt;) test3.findAll(sort);

<span class="hljs-keyword">for</span> (User user : targetList) &#123;
    System.out.println(user);
&#125;

<span class="hljs-comment">//---------------------------------------------------</span>

<span class="hljs-comment">//多次排序</span>
Order order = <span class="hljs-keyword">new</span> Order(Direction.DESC, <span class="hljs-string">"id"</span>);
Order order2 = <span class="hljs-keyword">new</span> Order(Direction.DESC, <span class="hljs-string">"age"</span>);
Order order3 = <span class="hljs-keyword">new</span> Order(Direction.ASC, <span class="hljs-string">"salary"</span>);

ArrayList&lt;Order&gt; list = <span class="hljs-keyword">new</span> ArrayList()&lt;&gt;;

Sort sort1 = <span class="hljs-keyword">new</span> Sort(list);

说明：findAll(Sort sort)，该方法需要的是一个排序的规则对象，所以创建Sort对象即可，放入findAll(Sort sort)方法中去</code></pre>
</li>
<li><p>findAll(Pageable page)：这是分页；</p>
<pre><code class="hljs java">Pageable pageable = <span class="hljs-keyword">new</span> PageRequest(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);

Page&lt;User&gt; page = test3.findAll(pageable);

<span class="hljs-keyword">for</span> (User user : page) &#123;
    System.out.println(user);
&#125;

说明：findAll(Pageable page)，该方法需要一个分页的基本条件，即跨过前面xx页并开始，每页显示的记录数；所以创建实现了Pageable接口的PageRequest的对象即可，然后放入findAll(Pageable page)方法中；该方法返回的结果是Page类型的对象，该对象中封装了关于页面的信息；如：
当前页数：page.getNumber()+<span class="hljs-number">1</span>，因为当前页是从<span class="hljs-number">0</span>开始，所以需要+<span class="hljs-number">1</span>，即当前页是第一页或n+<span class="hljs-number">1</span>页；
当前页的记录数：page.getNumberOfElements()
每页记录数：page.getSize()
总记录数：page.getTotalElements()
总页数：page.getTotalPages()
当前查询的记录结果集：page.getContent()</code></pre>
</li>
<li><p>分页和排序结合；</p>
<pre><code class="hljs java"><span class="hljs-comment">//排序</span>
Sort sort = <span class="hljs-keyword">new</span> Sort(Sort.Direction.DESC,<span class="hljs-string">"id"</span>);

<span class="hljs-comment">//分页</span>
Pageable pageable = <span class="hljs-keyword">new</span> PageRequest(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, sort);

Page&lt;User&gt; target = test.findAll(pageable);

List&lt;User&gt; content = target.getContent();

<span class="hljs-keyword">for</span> (User user : content) &#123;
    System.out.println(user);
&#125;


说明：只需要在创建Pageable的实现类对象时，使用带有sort排序参数的构造方法即可</code></pre>
</li>
</ul>
</li>
<li><p>JpaRepository：该接口继承了PagingAndSortingRepository接口，推荐使用该接口，因为这个接口包含了之前三个接口的所有方法，并对方法的返回值进行了适配(即返回值都是以<code>List&lt;T&gt;</code>形式返回的)；</p>
</li>
<li><p>JpaSpecificationExecutor，该接口主要是提供多条件查询的支持，并且可以在查询中添加分页和删除，该接口是独立的接口，该接口要和其他接口一起使用，无法单独使用；为什么该接口无法单独使用呢？因为JpaSpecificationExecutor接口是一个单独的接口，并没有继承其他接口，而在真正使用的时候，注入的却是根据SimpleJpaRepository类动态代理产生的代理对象，而要产生该类的代理对象，就必须继承Repository接口，而JpaSpecificationExecutor接口没有继承Repository，所以无法生成动态代理类的代理对象，也就无法使用；</p>
<pre><code class="hljs java">Specification&lt;User&gt; spec = <span class="hljs-keyword">new</span> Specification&lt;User&gt;() &#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Predicate <span class="hljs-title">toPredicate</span><span class="hljs-params">(Root&lt;User&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb)</span> </span>&#123;

        <span class="hljs-comment">//这是单条件查询</span>
        <span class="hljs-comment">//Predicate pre = cb.equal(root.get("name"), "邓燕飞");</span>

        <span class="hljs-comment">//这是多条件查询</span>
        List&lt;Predicate&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

        list.add(cb.equal(root.get(<span class="hljs-string">"name"</span>), <span class="hljs-string">"邓燕飞"</span>));

        list.add(cb.equal(root.get(<span class="hljs-string">"age"</span>), <span class="hljs-number">27</span>));

        Predicate[] pre = <span class="hljs-keyword">new</span> Predicate[list.size()];

        <span class="hljs-keyword">return</span> cb.and(list.toArray(pre));

        <span class="hljs-comment">//以上条件可以写成这样：</span>
        <span class="hljs-comment">//return cb.and(cb.equal(root.get("name"), "邓燕飞"), cb.equal(root.get("age"), 27));</span>
    &#125;
&#125;;

List&lt;User&gt; target = test.findAll(spec);
<span class="hljs-keyword">for</span> (User user : target) &#123;
    System.out.println(user);
&#125;
       
注意：Predicate：定义了查询条件，即根据对应属性和属性值去查询；Root&lt;User&gt; root：根对象；封装了查询条件的对象；CriteriaQuery&lt;?&gt; query：定义了一个基本的查询，一般不使用；CriteriaBuilder cb：创建一个查询条件；如，如下便是添加了排序和分页的查询

Specification&lt;User&gt; spec = <span class="hljs-keyword">new</span> Specification&lt;User&gt;() &#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Predicate <span class="hljs-title">toPredicate</span><span class="hljs-params">(Root&lt;User&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb)</span> </span>&#123;
        return cb.like(root.get("name").as(String.class), "邓%");
    &#125;
&#125;;

<span class="hljs-comment">//排序</span>
Sort sort = <span class="hljs-keyword">new</span> Sort(Sort.Direction.DESC,<span class="hljs-string">"id"</span>);

<span class="hljs-comment">//分页</span>
Pageable page = <span class="hljs-keyword">new</span> PageRequest(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>,sort);
Page&lt;User&gt; target = test4.findAll(spec,page);

List&lt;User&gt; content = target.getContent();

<span class="hljs-keyword">for</span> (User user : content) &#123;
    System.out.println(user);
&#125;</code></pre>
</li>
</ul>
</li>
<li><p>SpringData JPA一对多和多对多表关系的建立与操作；</p>
<ul>
<li><p>SpringData JPA建立双向一对多关系映射；</p>
<ul>
<li><p>首先：</p>
<ul>
<li><p>在多的一方里：在实体类中添加一的一方的属性；</p>
</li>
<li><p>在一的一方里：在实体类中添加多的一方的属性；</p>
<pre><code class="hljs java"><span class="hljs-comment">//用户和角色，用户是多的一方，角色是一的一方</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    
    ...其他成员变量

    <span class="hljs-keyword">private</span> Role role;

    ...get和set方法

&#125;

<span class="hljs-comment">//--------------------------------------------------</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> </span>&#123;
    
    ...其他成员变量

    <span class="hljs-keyword">private</span> Set&lt;User&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;User&gt;();

    ...get和set方法
&#125;</code></pre>
</li>
</ul>
</li>
<li><p>其次：</p>
<ul>
<li><p>在多的一方：在实体类中一的一方的属性上添加注解@ManyToOne(cascade=CascadeType.PERSIST)、cascade属性是指在操作当前POJO的对象时，也关联操作当前对象所维护的另一方的对象；@JoinColumn(name=”自定义外键名称”)，该注解放在主控方，一般该注解所在的一方能够改变关联关系，也就是说用户选择了别的角色，那么role就会变化，所以User是主控方，也就是能改变关联关系的一方；</p>
</li>
<li><p>在一的一方：在实体类中多的一方的属性上添加注解@OneToMany(mappedBy=”放入在多的一方里对应的一的一方的对象名称”)，一方设置mappedBy属性，则另一方必须添加为JoinColumn，mappedBy可以理解为一个标志，拥有mappedBy属性的POJO类就是去匹配拥有这个标志的另一个POJO类，而这个标志其实就是另一个POJO类的对象或者集合对象，且mappedBy这方不用管关联关系，关联关系交给另一方处理；</p>
<pre><code class="hljs java"><span class="hljs-comment">//用户和角色，用户是多的一方，角色是一的一方</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    
    ...其他成员变量

    <span class="hljs-meta">@ManyToOne</span>(cascade=CascadeType.PERSIST)
    <span class="hljs-meta">@JoinColumn</span>(name=<span class="hljs-string">"role_id"</span>)       
    <span class="hljs-keyword">private</span> Role role;

    ...get和set方法

&#125;

<span class="hljs-comment">//--------------------------------------------------------</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> </span>&#123;
    
    ...其他成员变量

    <span class="hljs-meta">@OneToMany</span>(mappedBy=<span class="hljs-string">"role"</span>)
    <span class="hljs-keyword">private</span> Set&lt;User&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;User&gt;();

    ...get和set方法

&#125;

说明：
一、<span class="hljs-meta">@ManyToOne</span>(cascade=CascadeType.PERSIST)，cascade的属性是指级联操作，例如保存客户，也保存该客户所对应的订单信息等待级联信息；

二、只有OneToOne，OneToMany，ManyToMany上才有mappedBy属性，ManyToOne不存在该属性；mappedBy标签一定是定义在被拥有方的，他指向拥有方；mappedBy的含义，应该理解为，拥有方能够自动维护跟被拥有方的关系，当然，如果从被拥有方，通过手工强行来维护拥有方的关系也是可以做到的；mappedBy跟joinColumn/JoinTable总是处于互斥的一方，可以理解为正是由于拥有方的关联被拥有方的字段存在，拥有方才拥有了被拥有方；mappedBy这方定义JoinColumn/JoinTable总是失效的，不会建立对应的字段或者表；mappedBy表示声明自己不是一对多的关系维护端，由对方来维护，是在一的一方进行声明的；mappedBy的值应该为一的一方的某个对应的名称</code></pre>
</li>
</ul>
</li>
<li><p>最后，测试操作；</p>
<pre><code class="hljs java"><span class="hljs-comment">//创建一个User</span>
User user = <span class="hljs-keyword">new</span> User();
user.setName(<span class="hljs-string">"邓GM"</span>);
user.setAge(<span class="hljs-number">26</span>);
user.setAdress(<span class="hljs-string">"太阳系"</span>);

<span class="hljs-comment">//创建一个Roler</span>
Role role = <span class="hljs-keyword">new</span> Role();
role.setRolename(<span class="hljs-string">"游戏创建者"</span>);

<span class="hljs-comment">//互相关联操作，其实就是在各自的对象中，添加相应的属性即可；</span>
user.setRole(role);

Set&lt;User&gt; userSet = role.getUserSet();
userSet.add(user);

userRepository.save(user);</code></pre>
</li>
</ul>
</li>
<li><p>SpringDataJPA建立双向多对多关系映射；</p>
<ul>
<li><p>在A方：在实体类中添加B的一方的对象集合，并加上对应的注解即可；在B方：在实体类中添加A的一方的对象集合，并加上对应的注解即可；</p>
<pre><code class="hljs java"><span class="hljs-comment">//菜单和角色</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> </span>&#123;

    ...其他成员变量

    <span class="hljs-meta">@ManyToMany</span>(cascade=CascadeType.PERSIST, fectch=FetchType.EAGER)
    <span class="hljs-meta">@JoinTable</span>(name=<span class="hljs-string">"t_role_menu"</span>, joinColumns=<span class="hljs-meta">@JoinColumn</span>(name=<span class="hljs-string">"roles_id"</span>), inverseJoinColumns=<span class="hljs-meta">@JoinColumn</span>(name=<span class="hljs-string">"menu_id"</span>))
    <span class="hljs-keyword">private</span> Set&lt;Menu&gt; menuSet = <span class="hljs-keyword">new</span> HashSet&lt;Menu&gt;();

    ...get和set方法
&#125;

<span class="hljs-comment">//--------------------------------------------------------------------------------</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Menu</span> </span>&#123;

    ...其他成员变量

    <span class="hljs-meta">@ManyToMany</span>(mappedBy=<span class="hljs-string">"menuSet"</span>)
    <span class="hljs-keyword">private</span> Set&lt;Role&gt; roleSet = <span class="hljs-keyword">new</span> HashSet&lt;Role&gt;();

    ...get和set方法
&#125;


说明：在多对多关系映射中，两边都要添加<span class="hljs-meta">@ManyToMany</span>()注解；<span class="hljs-meta">@JoinTable</span>是指创建一个中间表，属性name=<span class="hljs-string">"XXX"</span>是设置中间表的名称，属性joinColumns=<span class="hljs-meta">@JoinColumn</span>(name=<span class="hljs-string">"XXX"</span>)是设置当前表主键在中间表的外键的名称，属性inverseJoinColumns=<span class="hljs-meta">@JoinColumn</span>(name=<span class="hljs-string">"XXX"</span>)是设置中间表中，另一个外键的名称，即另一个实体类的主键在中间表的外键名称；<span class="hljs-meta">@JoinTable</span>可以在任意一方的实体类中添加，因为都是多对多；另一方只需设置<span class="hljs-meta">@ManyToMany</span>(mappedBy=<span class="hljs-string">"XXX"</span>)即可，属性mappedBy是指要放入的另一方的对象集合即可；fectch属性是设置放弃延迟加载而改用立即加载，因为级联查询会需要Session去查询级联信息，该属性默认会使用延迟加载，这样级联信息就查询不到了</code></pre>
</li>
<li><p>代码测试；</p>
<pre><code class="hljs java">Menu menu = <span class="hljs-keyword">new</span> Menu();
menu.setMenuname(<span class="hljs-string">"角色信息"</span>);
menu.setMenuurl(<span class="hljs-string">"www.jianling.com"</span>);
menu.setFatherid(<span class="hljs-number">66</span>);

Role role = <span class="hljs-keyword">new</span> Role();
role.setRolename(<span class="hljs-string">"开发者"</span>);

menu.getRoleSet().add(role);
role.getMenuSet().add(menu);

Role target = Repository.findById(<span class="hljs-number">2</span>).orElse(<span class="hljs-keyword">null</span>);

<span class="hljs-keyword">if</span>(target!=<span class="hljs-keyword">null</span>) &#123;
    System.out.println(target);
    <span class="hljs-keyword">for</span> (Menu me: target.getMenuSet()) &#123;
        System.out.println(me);
    &#125;
&#125;</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-10-SpringBoot整合SpringMVC、MyBatis"><a href="#NO2-10-SpringBoot整合SpringMVC、MyBatis" class="headerlink" title="NO2.10 SpringBoot整合SpringMVC、MyBatis"></a>NO2.10 SpringBoot整合SpringMVC、MyBatis</h3><p>这三个框架的整合，开发中我们也会经常遇到。</p>
<ul>
<li><p>基本步骤：</p>
<ul>
<li><p>创建基于SpringBoot的Maven工程，导入Web和MyBatis的依赖、数据库驱动依赖等等；<strong><code>注意：Web依赖里面包含有SpringMVC的JAR包，所以不需要添加额外的依赖。</code></strong></p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Web依赖 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-comment">&lt;!-- Thymeleaf依赖 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-comment">&lt;!-- MyBatis依赖 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 数据库驱动依赖 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 连接池依赖 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
</li>
<li><p>在src/main/resources下创建包templates存放静态资源、创建SpringBoot全局配置文件application.properties配置数据库；</p>
<pre><code class="hljs properties"><span class="hljs-comment">#配置链接数据库的四大要素</span>
<span class="hljs-meta">spring.datasource.driverClassName</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span>
<span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/数据库名称?serverTimezone=UTC</span>
<span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">Deng521314</span>

<span class="hljs-comment">#配置德鲁伊数据源</span>
<span class="hljs-meta">spring.datasource.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>

<span class="hljs-comment">#配置别名，即在Mapper.xml中，参数或返回值类型，不需要再写全包名路径</span>
<span class="hljs-meta">mybatis.type-aliases-package</span>=<span class="hljs-string">com.dyf.pojo</span></code></pre>
</li>
<li><p>在Controller中，尽量使用RESTful风格进行开发；</p>
<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/&#123;page&#125;"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">showPage</span><span class="hljs-params">(@PathVariable String page)</span> </span>&#123;
    <span class="hljs-keyword">return</span> page;
&#125;

注意：直接输入页面名称即可</code></pre>
</li>
<li><p>记得要在启动器类里，再配置一个扫描器，用于扫描MyBatis的Mapper接口；</p>
<pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@MapperScan</span>(<span class="hljs-string">"com.dyf.mapper"</span>)  <span class="hljs-comment">//该注解用于扫描MyBatis的Mapper接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(App<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;
    &#125;
&#125;

说明：
一、<span class="hljs-meta">@Mapper</span>一般我们用在接口上，代码如下：
<span class="hljs-meta">@Mapper</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;

    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from user where name = #&#123;name&#125;"</span>)
    <span class="hljs-function">User <span class="hljs-title">find</span><span class="hljs-params">(String name)</span></span>;

    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from user where name = #&#123;name&#125; and pwd = #&#123;pwd&#125;"</span>)  <span class="hljs-comment">//对于多个参数来说，每个参数之前都要加上@Param注解，要不然会找不到对应的参数进而报错</span>
    <span class="hljs-function">User <span class="hljs-title">login</span><span class="hljs-params">(@Param(<span class="hljs-string">"name"</span>)</span>String name, @<span class="hljs-title">Param</span><span class="hljs-params">(<span class="hljs-string">"pwd"</span>)</span>String pwd)</span>;
&#125;

使用 <span class="hljs-meta">@Mapper</span>，最终MyBatis会有一个拦截器，会自动的把<span class="hljs-meta">@Mapper</span>注解的接口生成动态代理类；这点可以在 MapperRegistry 类中的源代码中查看；<span class="hljs-meta">@Mapper</span>注解针对的是一个一个的类，相当于是一个一个Mapper.xml 文件；而一个接口一个接口的使用 <span class="hljs-meta">@Mapper</span>，太麻烦了，于是<span class="hljs-meta">@MapperScan</span>就应用而生了；

二、<span class="hljs-meta">@MapperScan</span>配置一个或多个包路径，自动的扫描这些包路径下的类，自动的为它们生成代理类；代码如下：

<span class="hljs-meta">@SpringBootApplication</span>  
<span class="hljs-meta">@MapperScan</span>(&#123;<span class="hljs-string">"cn.dyf.mapper"</span>,<span class="hljs-string">"com.dxe.dao"</span>&#125;)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XttblogApp</span> </span>&#123;  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  
       SpringApplication.run(XttblogApp<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;  
    &#125;  
&#125;

当使用了<span class="hljs-meta">@MapperScan</span>注解，将会生成MapperFactoryBean，如果没有标注<span class="hljs-meta">@MapperScan</span>也就是没有MapperFactoryBean的实例，就走<span class="hljs-meta">@Import</span>里面的配置，具体可以在AutoConfiguredMapperScannerRegistrar和 MybatisAutoConfiguration类中查看源代码进行分析；由此可见，动态代理和AOP知识非常的重要，各种框架都在大量的使用

三、SpringBoot默认的上传文件的大小为：<span class="hljs-number">10</span>M，要修改该限制，只需要在application.properties全局配置文件中配置即可；配置如下内容：
spring.http.multipart.maxFileSize=设置单个文件的大小.MB
spring.http.multipart.maxRequestSize = 设置单次请求的文件的总大小.MB
    
注意：一定要写单位的全称，即MB，GB等等，如果是想要不限制文件上传的大小，那么就把两个值都设置为-<span class="hljs-number">1</span></code></pre>
</li>
<li><p>其他的整合思路，与SpringMVC+Spring+MyBatis的思路相差无几；</p>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-11-SpringBoot的启动器原理"><a href="#NO2-11-SpringBoot的启动器原理" class="headerlink" title="NO2.11 SpringBoot的启动器原理"></a>NO2.11 SpringBoot的启动器原理</h3><ul>
<li><p>SpringBoot的启动器原理解析；</p>
<pre><code class="hljs java"><span class="hljs-comment">//1.这是SpringBoot的入口类</span>

<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(App<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;
    &#125;
&#125;


<span class="hljs-comment">//2.点击SpringBoot入口类中的run()方法，进入到下面</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt; primarySource, String... args)</span> </span>&#123;
   <span class="hljs-keyword">return</span> run(<span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123; primarySource &#125;, args);
&#125;


<span class="hljs-comment">//3.再进入返回值中“return run(new Class&lt;?&gt;[] &#123; primarySource &#125;, args);”的run()方法，进入到下面；也就是说运行到这里，启动SpringBoot的入口类后，new了个SpringApplication对象，并调用了run()方法</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SpringApplication(primarySources).run(args);
&#125;


<span class="hljs-comment">//4.我们先看看new SpringApplication()方法中，做了哪些事情，点击SpringApplication()方法，进入到下面</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(Class&lt;?&gt;... primarySources)</span> </span>&#123;
   <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, primarySources);
&#125;


<span class="hljs-comment">//5.再点击“this()构造方法”，进入到下面</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;
    
    <span class="hljs-keyword">this</span>.resourceLoader = resourceLoader;
    Assert.notNull(primarySources, <span class="hljs-string">"PrimarySources must not be null"</span>);

    <span class="hljs-comment">//保存主配置类</span>
    <span class="hljs-keyword">this</span>.primarySources = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));

    <span class="hljs-comment">//调用deduceFromClasspath()方法，检测当前环境是否为Web环境</span>
    <span class="hljs-keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();

    <span class="hljs-comment">//也就是说，通过getSpringFactoriesInstances(ApplicationContextInitializer.class)方法可以知道，其实该方法就是找到类路径下的META-INF/spring.factories文件中配置了的所有ApplicationContextInitializer，然后保存起来</span>
    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;

    <span class="hljs-comment">//同理getSpringFactoriesInstances(ApplicationListener.class)方法可以知道，其实该方法就是找到类路径下的META-INF/spring.factories文件中配置了的所有ApplicationListener，然后保存起来</span>
    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;

    <span class="hljs-comment">//这个方法则是能够检测出那个配置类中有“main”方法的标志，则哪个类是主程序的入口</span>
    <span class="hljs-keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();
&#125;

<span class="hljs-comment">//5.1.这是deduceFromClasspath()方法</span>

<span class="hljs-function"><span class="hljs-keyword">static</span> WebApplicationType <span class="hljs-title">deduceFromClasspath</span><span class="hljs-params">()</span> </span>&#123;
   <span class="hljs-keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="hljs-keyword">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="hljs-keyword">null</span>)
         &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="hljs-keyword">null</span>)) &#123;
      <span class="hljs-keyword">return</span> WebApplicationType.REACTIVE;
   &#125;
   <span class="hljs-keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;
      <span class="hljs-keyword">if</span> (!ClassUtils.isPresent(className, <span class="hljs-keyword">null</span>)) &#123;
         <span class="hljs-keyword">return</span> WebApplicationType.NONE;
      &#125;
   &#125;
   <span class="hljs-keyword">return</span> WebApplicationType.SERVLET;
&#125;


<span class="hljs-comment">//5.2.这是getSpringFactoriesInstances()方法</span>

<span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">Collection&lt;T&gt; <span class="hljs-title">getSpringFactoriesInstances</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>&#123;
   <span class="hljs-keyword">return</span> getSpringFactoriesInstances(type, <span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123;&#125;);
&#125;


<span class="hljs-comment">//5.3.这是getSpringFactoriesInstances()方法</span>

<span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">Collection&lt;T&gt; <span class="hljs-title">getSpringFactoriesInstances</span><span class="hljs-params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;
   ClassLoader classLoader = getClassLoader();
   <span class="hljs-comment">// Use names and ensure unique to protect against duplicates</span>
   Set&lt;String&gt; names = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));
   List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);
   AnnotationAwareOrderComparator.sort(instances);
   <span class="hljs-keyword">return</span> instances;
&#125;


<span class="hljs-comment">//5.4.这是loadFactoryNames()方法</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader)</span> </span>&#123;
   String factoryTypeName = factoryType.getName();
   <span class="hljs-keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());
&#125;


<span class="hljs-comment">//5.5.这是loadSpringFactories()方法</span>

<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader) &#123;
   MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);
   <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> result;
   &#125;

   <span class="hljs-keyword">try</span> &#123;
      Enumeration&lt;URL&gt; urls = (classLoader != <span class="hljs-keyword">null</span> ?

            <span class="hljs-comment">//这个变量的值其实就是META-INF/spring.factories，因为该类中的成员变量FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";</span>
            classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :
            ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));
      result = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();
      <span class="hljs-keyword">while</span> (urls.hasMoreElements()) &#123;
         URL url = urls.nextElement();
         UrlResource resource = <span class="hljs-keyword">new</span> UrlResource(url);
         Properties properties = PropertiesLoaderUtils.loadProperties(resource);
         <span class="hljs-keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;
            String factoryTypeName = ((String) entry.getKey()).trim();
            <span class="hljs-keyword">for</span> (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;
               result.add(factoryTypeName, factoryImplementationName.trim());
            &#125;
         &#125;
      &#125;
      cache.put(classLoader, result);
      <span class="hljs-keyword">return</span> result;
   &#125;
   <span class="hljs-keyword">catch</span> (IOException ex) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Unable to load factories from location ["</span> +
            FACTORIES_RESOURCE_LOCATION + <span class="hljs-string">"]"</span>, ex);
   &#125;
&#125;


<span class="hljs-comment">//5.6.这是deduceMainApplicationClass()方法</span>

<span class="hljs-keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;
   <span class="hljs-keyword">try</span> &#123;
      StackTraceElement[] stackTrace = <span class="hljs-keyword">new</span> RuntimeException().getStackTrace();
      <span class="hljs-keyword">for</span> (StackTraceElement stackTraceElement : stackTrace) &#123;
         <span class="hljs-keyword">if</span> (<span class="hljs-string">"main"</span>.equals(stackTraceElement.getMethodName())) &#123;
            <span class="hljs-keyword">return</span> Class.forName(stackTraceElement.getClassName());
         &#125;
      &#125;
   &#125;
   <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;
      <span class="hljs-comment">// Swallow and continue</span>
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;


<span class="hljs-comment">//6.接下来，退回到第3步，再来看看run()方法中做了哪些事情</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SpringApplication(primarySources).run(args);
&#125;


<span class="hljs-comment">//7.点击run()方法，进入后，发现下面</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> </span>&#123;

   StopWatch stopWatch = <span class="hljs-keyword">new</span> StopWatch();
   stopWatch.start();
   ConfigurableApplicationContext context = <span class="hljs-keyword">null</span>;
   Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
   configureHeadlessProperty();

   <span class="hljs-comment">//获取SpringApplicationRunListeners，怎么获取的呢？点击getRunListeners()方法</span>
   SpringApplicationRunListeners listeners = getRunListeners(args);

   <span class="hljs-comment">//回调所有获取到的SpringApplicationRunListeners的starting()方法</span>
   listeners.starting();
   <span class="hljs-keyword">try</span> &#123;
      <span class="hljs-comment">//封装命令行参数</span>
      ApplicationArguments applicationArguments = <span class="hljs-keyword">new</span> DefaultApplicationArguments(args);

      <span class="hljs-comment">//准备环境，在创建环境完成后回调SpringApplicationRunListeners.environmentPrepared()方法，这个方法就表示环境准备完成了的意思</span>
      ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);
      configureIgnoreBeanInfo(environment);
      Banner printedBanner = printBanner(environment);

      <span class="hljs-comment">//创建ApplicationContext，也就是IOC容器，该方法会判断生成哪一种环境，是Web的IOC环境还是普通的IOC环境</span>
      context = createApplicationContext();
      exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span>
            new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);

      <span class="hljs-comment">//准备上下文环境，将Environment保存到IOC中，并回调之前保存的ApplicationContextInitializers的initializer()方法和SpringApplicationRunListener的contextPrepared()方法；最后该方法执行完成后会回调SpringApplicationRunListeners的contextLoaded()方法</span>
      prepareContext(context, environment, listeners, applicationArguments, printedBanner);

      <span class="hljs-comment">//刷新容器，初始化IOC容器(如果是Web应用还好创建嵌入式的Tomcat)，该方法执行完成后，IOC容器初始化完成</span>
      refreshContext(context);

      afterRefresh(context, applicationArguments);
      stopWatch.stop();
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;
         <span class="hljs-keyword">new</span> StartupInfoLogger(<span class="hljs-keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
      &#125;
      listeners.started(context);

      <span class="hljs-comment">//点击查看该方法，发现该方法从IOC容器中获取所有的ApplicationRunner(先调用)和CommandLineRunner(后调用)进行回调</span>
      callRunners(context, applicationArguments);
   &#125;
   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;
      handleRunFailure(context, ex, exceptionReporters, listeners);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);
   &#125;


   <span class="hljs-keyword">try</span> &#123;
      listeners.running(context);
   &#125;
   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;
      handleRunFailure(context, ex, exceptionReporters, <span class="hljs-keyword">null</span>);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);
   &#125;
   <span class="hljs-keyword">return</span> context;
&#125;


<span class="hljs-comment">//7.1.这是getRunListeners()方法，发现调用了也是从getSpringFactoriesInstances()方法中获取的，也就说从类路径下的META-INF/spring.factories里获取的</span>

<span class="hljs-function"><span class="hljs-keyword">private</span> SpringApplicationRunListeners <span class="hljs-title">getRunListeners</span><span class="hljs-params">(String[] args)</span> </span>&#123;
   Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SpringApplicationRunListeners(logger, getSpringFactoriesInstances(SpringApplicationRunListener<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">types</span>, <span class="hljs-title">this</span>, <span class="hljs-title">args</span>))</span>;
&#125;


<span class="hljs-comment">//7.2.这是prepareEnvironment()方法</span>

<span class="hljs-function"><span class="hljs-keyword">private</span> ConfigurableEnvironment <span class="hljs-title">prepareEnvironment</span><span class="hljs-params">(SpringApplicationRunListeners listeners,</span></span>
<span class="hljs-function"><span class="hljs-params">      ApplicationArguments applicationArguments)</span> </span>&#123;
   
   <span class="hljs-comment">//创建或者配置(在拥有环境的前提下)一个环境</span>
   ConfigurableEnvironment environment = getOrCreateEnvironment();
   configureEnvironment(environment, applicationArguments.getSourceArgs());
   ConfigurationPropertySources.attach(environment);
   listeners.environmentPrepared(environment);
   bindToSpringApplication(environment);
   <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isCustomEnvironment) &#123;
      environment = <span class="hljs-keyword">new</span> EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,
            deduceEnvironmentClass());
   &#125;
   ConfigurationPropertySources.attach(environment);
   <span class="hljs-keyword">return</span> environment;
&#125;


<span class="hljs-comment">//7.3.这是createApplicationContext()方法</span>

<span class="hljs-function"><span class="hljs-keyword">protected</span> ConfigurableApplicationContext <span class="hljs-title">createApplicationContext</span><span class="hljs-params">()</span> </span>&#123;
   Class&lt;?&gt; contextClass = <span class="hljs-keyword">this</span>.applicationContextClass;
   <span class="hljs-keyword">if</span> (contextClass == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">try</span> &#123;
         <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.webApplicationType) &#123;
         <span class="hljs-keyword">case</span> SERVLET:
            contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);
            <span class="hljs-keyword">break</span>;
         <span class="hljs-keyword">case</span> REACTIVE:
            contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);
            <span class="hljs-keyword">break</span>;
         <span class="hljs-keyword">default</span>:
            contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);
         &#125;
      &#125;
      <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;
         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(
               <span class="hljs-string">"Unable create a default ApplicationContext, please specify an ApplicationContextClass"</span>, ex);
      &#125;
   &#125;
   <span class="hljs-comment">//利用工具和反射创建IOC环境</span>
   <span class="hljs-keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);
&#125;


<span class="hljs-comment">//7.4.这是prepareContext()方法</span>

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareContext</span><span class="hljs-params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span>
<span class="hljs-function"><span class="hljs-params">      SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;
   context.setEnvironment(environment);
   postProcessApplicationContext(context);
    
   <span class="hljs-comment">//点进去查看这个方法发现，这个方法主要是回调了之前保存的ApplicationContextInitializer的initializer()方法</span>
   applyInitializers(context);

   <span class="hljs-comment">//点击这个方法发现，这个方法也是回调了之前保存的SpringApplicationRunListener的contextPrepared()方法</span>
   listeners.contextPrepared(context);
   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;
      logStartupInfo(context.getParent() == <span class="hljs-keyword">null</span>);
      logStartupProfileInfo(context);
   &#125;
   <span class="hljs-comment">// Add boot specific singleton beans</span>
   ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
   beanFactory.registerSingleton(<span class="hljs-string">"springApplicationArguments"</span>, applicationArguments);
   <span class="hljs-keyword">if</span> (printedBanner != <span class="hljs-keyword">null</span>) &#123;
      beanFactory.registerSingleton(<span class="hljs-string">"springBootBanner"</span>, printedBanner);
   &#125;
   <span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> DefaultListableBeanFactory) &#123;
      ((DefaultListableBeanFactory) beanFactory)
            .setAllowBeanDefinitionOverriding(<span class="hljs-keyword">this</span>.allowBeanDefinitionOverriding);
   &#125;
   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lazyInitialization) &#123;
      context.addBeanFactoryPostProcessor(<span class="hljs-keyword">new</span> LazyInitializationBeanFactoryPostProcessor());
   &#125;
   <span class="hljs-comment">// Load the sources</span>
   Set&lt;Object&gt; sources = getAllSources();
   Assert.notEmpty(sources, <span class="hljs-string">"Sources must not be empty"</span>);
   load(context, sources.toArray(<span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>]));
   listeners.contextLoaded(context);
&#125;


<span class="hljs-comment">//7.5.这是applyInitializers()方法</span>

<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyInitializers</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> </span>&#123;
   <span class="hljs-keyword">for</span> (ApplicationContextInitializer initializer : getInitializers()) &#123;
      Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),
            ApplicationContextInitializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
      Assert.isInstanceOf(requiredType, context, <span class="hljs-string">"Unable to call initializer."</span>);
      initializer.initialize(context);
   &#125;
&#125;


<span class="hljs-comment">//7.6.这是contextPrepared()方法</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextPrepared</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> </span>&#123;
   <span class="hljs-keyword">for</span> (SpringApplicationRunListener listener : <span class="hljs-keyword">this</span>.listeners) &#123;
      listener.contextPrepared(context);
   &#125;
&#125;

<span class="hljs-comment">//7.7.这是callRunners()方法</span>

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callRunners</span><span class="hljs-params">(ApplicationContext context, ApplicationArguments args)</span> </span>&#123;
   List&lt;Object&gt; runners = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
   runners.addAll(context.getBeansOfType(ApplicationRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">values</span>())</span>;
   runners.addAll(context.getBeansOfType(CommandLineRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">values</span>())</span>;
   AnnotationAwareOrderComparator.sort(runners);
   <span class="hljs-keyword">for</span> (Object runner : <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(runners)) &#123;
      <span class="hljs-keyword">if</span> (runner <span class="hljs-keyword">instanceof</span> ApplicationRunner) &#123;
         callRunner((ApplicationRunner) runner, args);
      &#125;
      <span class="hljs-keyword">if</span> (runner <span class="hljs-keyword">instanceof</span> CommandLineRunner) &#123;
         callRunner((CommandLineRunner) runner, args);
      &#125;
   &#125;
&#125;</code></pre>

</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>SpringBoot自定义Starter；</p>
<ul>
<li><p>Starter的原理；Spring Boot Starter的工作原理如下；</p>
<ul>
<li>Spring Boot 在启动时扫描项目所依赖的JAR包，寻找包含spring.factories文件的JAR；</li>
<li>根据spring.factories配置加载AutoConfigure类；</li>
<li>根据 @Conditional注解的条件，进行自动配置并将Bean注入Spring Context；</li>
</ul>
</li>
<li><p>自定义Starter；一个完整的SpringBootStarter可能包含以下组件：即starter模块(提供对autoconfigure模块的依赖，以及一些其它的依赖)和autoconfigure模块(包含自动配置的代码)；</p>
<ul>
<li><p>命名：模块名称不能以spring-boot开头，如，你为“mystarter”创建了一个starter，那么你的auto-configure模块可以命名为mystarter-spring-boot-autoconfigure，starter模块可以命名为mystarter-spring-boot-starter；如果你只有一个模块包含这两部分，那么你可以命名为acme-spring-boot-starter；</p>
</li>
<li><p>starter模块：事实上，starter是一个空jar；它唯一的目的是提供这个库所必须的依赖；你的starter必须直接或间接引用核心的SpringBoot的starter(即spring-boot-starter)；</p>
</li>
<li><p>autoconfigure模块：建议在autoconfigure模块中包含下列依赖；</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
</li>
<li><p>编写自定义的MyStarter；</p>
<ul>
<li><p>新建一个Maven项目，选择Empty Project，并命名为SpringBoot-createmystarter；mystarter-spring-boot-starter；</p>
<p><img src="./Image-sb28.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb29.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>在打开的Empty Project中，分别创建两个模块，即starter模块和autoconfigure模块，我们先创建前者，再创建后者；注意：Project Structure对话框在创建Empty Project后会自动打开；</p>
<p><img src="./Image-sb30.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb31.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb32.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb33.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb34.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb35.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb36.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb37.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>在starter模块的pom.xml中引入autoconfigure模块；</p>
<p><img src="./Image-sb38.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>删除autoconfigure模块中多余的启动器，和全局配置文件；并在autoconfigure</p>
<p><img src="./Image-sb39.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb40.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>首先编写三个文件，MyStarterService，MyStarterProperties，MyStarterAutoConfiguration；</p>
<pre><code class="hljs java"><span class="hljs-comment">//这是MyStarterService类，这个类主要调用Properties类里面的方法或属性</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStarterService</span> </span>&#123;

    <span class="hljs-comment">//注入MyStarterProperties</span>
    MyStarterProperties myStarterProperties;

    <span class="hljs-function"><span class="hljs-keyword">public</span> MyStarterProperties <span class="hljs-title">getMyStarterProperties</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> myStarterProperties;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMyStarterProperties</span><span class="hljs-params">(MyStarterProperties myStarterProperties)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.myStarterProperties = myStarterProperties;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">helloMyStarter</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> myStarterProperties.getName()+<span class="hljs-string">"-左边名称，右边描述-"</span>+myStarterProperties.getDesc();
    &#125;
&#125;

<span class="hljs-comment">//-------------------------------------------------------</span>

<span class="hljs-comment">//这是MyStarterProperties类，也就是配置类，当用户在application.properties或application.yaml全局配置文件中，使用this.is.mystarter的前缀给属性进行配置时，其实实际上是在给MyStarterProperties的属性赋值，而其赋值原理是使用了Setter方法</span>

<span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"this.is.mystarter"</span>)  <span class="hljs-comment">//该注解会将用户在全局配置文件中配置的属性，赋值到该类中</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStarterProperties</span> </span>&#123;

    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-keyword">private</span> String desc;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDesc</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> desc;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDesc</span><span class="hljs-params">(String desc)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.desc = desc;
    &#125;
&#125;

<span class="hljs-comment">//-------------------------------------------------------</span>

<span class="hljs-comment">//这是MyStarterAutoConfiguration类，也就是自动配置类，该类的主要作用是对MyStarterService和MyStarterProperties两个类进行注册，也就是生成bean对象</span>

<span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">//告知Spring这是一个配置类</span>
<span class="hljs-meta">@ConditionalOnWebApplication</span>  <span class="hljs-comment">//判断当前是否是web环境，如果不是，那么该自动配置类就不会生效</span>
<span class="hljs-meta">@EnableConfigurationProperties</span>(MyStarterProperties<span class="hljs-class">.<span class="hljs-keyword">class</span>)  //该注解使得<span class="hljs-title">MyStarterProperties</span>类生效，也就是生成<span class="hljs-title">bean</span>对象，放入到容器中</span>
<span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">MyStarterAutoConfiguration</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    MyStarterProperties myStarterProperties;

    <span class="hljs-meta">@Bean</span>  <span class="hljs-comment">//注册Bean对象</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> MyStarterService <span class="hljs-title">myStarterService</span><span class="hljs-params">()</span></span>&#123;

        MyStarterService service = <span class="hljs-keyword">new</span> MyStarterService();

        service.setMyStarterProperties(myStarterProperties);

        <span class="hljs-keyword">return</span> service;
    &#125;
&#125;</code></pre>
</li>
<li><p>当完成上面的步骤后，需要在类路径下(也就是Resources文件夹下)创建一个文件夹，名为META-INF，并在该文件夹下创建一个文件，名为spring.factories，并在该文件中将我们自动配置类的全包名路径放入即可，这样基本的Starter我们就自定义完成了，接下来只要使用Maven进行部署并测试就行了；</p>
<pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span>.EnableAutoConfiguration=\
xx<span class="hljs-selector-class">.xx</span><span class="hljs-selector-class">.xx</span>.xxxxAutoConfiguration</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-12-SpringBoot与缓存"><a href="#NO2-12-SpringBoot与缓存" class="headerlink" title="NO2.12 SpringBoot与缓存"></a>NO2.12 SpringBoot与缓存</h3><p>SpringBoot中也整合了缓存。</p>
<ul>
<li><p>SpringBoot的缓存；</p>
<ul>
<li><p>JavaCache(简称JCache)，它定义了供开发人员使用的标准Java缓存API和供实现者使用的标准SPI(“服务提供者接口”)，并为Java提供了通用的方法来创建，访问，更新和删除缓存中的条目(entries)；JCache主要定义了5个接口来规范缓存的生命周期；</p>
<ul>
<li><code>CacheingProvider</code>：管理多个CacheManager，制定建立，配置，请求机制；</li>
<li><code>CacheManager</code>：管理多个Cache，制定建立，配置，请求机制，只有一个对应的CacheProvider；</li>
<li><code>Cache</code>：对缓存操作，是一个像Map一样的数据结构，它允许基于Key的临时存储；只有一个对应的CacheManager；</li>
<li><code>Cache.Entry</code>：是被Cache存储的单个key-value对；Cache接口的内部接口，真正的存储实体；</li>
<li><code>ExpiryPolicy</code>：控制缓存的过期时间；</li>
</ul>
</li>
<li><p>Spring的缓存抽象：</p>
<ul>
<li><p>定义：缓存抽象，也就是，每次调用目标方法时，抽象都会去缓存中查看是否有同样的查询；如果有，则返回缓存的结果，而不必执行实际的方法；如果没有，则执行方法，缓存结果并返回给用户，以便在下次调用方法时返回缓存的结果；这样，对于给定的一组参数，方法只能执行一次，并且结果可以重用，而不必实际再次执行该方法；</p>
</li>
<li><p>核心：抽象的核心是将缓存应用于Java方法，从而减少了基于缓存中可用信息的执行次数；</p>
</li>
<li><p>抽象实现：就像Spring里Framework中的其他服务一样，缓存服务是一种抽象(不是缓存实现)，需要使用实际存储来存储缓存数据，也就是说，抽象使开发人员不必编写缓存逻辑，但抽象不提供实际的存储；这种抽象由org.springframework.cache.Cache和org.springframework.cache.CacheManager这两个接口实现；这个抽象的一些实现可以直接使用：基于JDK java.util.concurrent.ConcurrentMap的缓存(即默认的缓存是基于JVM的ConcurrentMap)、Ehcache 2.x、Gemfire缓存、符合Caffeine和JSR-107的缓存(如，Ehcache 3.x)；对于缓存声明，抽象提供了一组Java注释，如下所示；</p>
</li>
<li><p>Spring缓存抽象中的几个重要概念和缓存注解；</p>
<ul>
<li><p><code>Cache</code>：指缓存接口，定义缓存操作，实现有：RedisCache、EhCache、ConcurrentMapCache等；</p>
</li>
<li><p><code>CacheManage</code>：指缓存管理器，用于管理各种缓存(Cache)组件；</p>
</li>
<li><p><code>@Cacheable</code>：就是指将该数据存储于缓存中，主要针对方法配置，能够根据方法的请求参数对其结果进行缓存；<strong><code>注意：@Cacheable不能用#result，且该注解会先去查询缓存再去运行方法。</code></strong></p>
<ul>
<li><p><code>cacheNames/value</code>：该属性值必须提供，指定缓存组件(也就是Cache)的名字，将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存。<code>如：cacheNames = &quot;product&quot;或者cacheNames = {&quot;product1&quot;,&quot;product2&quot;}</code>；</p>
</li>
<li><p><code>key</code>：缓存数据使用的key，不指定key则默认使用的是方法参数的值，该属性值支持SpEL表达式。<strong><code>注意：当我们要使用root对象的属性作为key时我们也可以将“#root”省略，因为Spring默认使用的就是root对象的属性。如，@Cacheable(key = &quot;targetClass + methodName + #p0&quot;)</code></strong>；使用方法参数时我们可以直接使用<code>#参数名</code>或者<code>#p参数的索引值(或者#a参数的索引值)</code>；<code>如，@Cacheable(value=&quot;users&quot;, key=&quot;#id&quot;)、@Cacheable(value=&quot;users&quot;, key=&quot;#p0&quot;)</code>；</p>
<p><img src="./Image-sb41.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p><code>cacheManager</code>：指定缓存管理器；或者cacheResolver指定获取解析器；</p>
</li>
<li><p><code>condition</code>：指定符合条件的情况下才缓存；<code>如，@Cacheable(condition = &quot;#id&gt;0&quot;)，表示当id大于0时，才进行缓存</code>；</p>
</li>
<li><p><code>unless</code>：否定缓存；当unless指定的条件为true，方法的返回值就不会被缓存；可以在获取到结果后进行判断，<code>unless = &quot;#result == null&quot;</code>，也可以，<code>unless = &quot;#a0==2&quot;</code>：如果第一个参数的值是2，结果不缓存；</p>
</li>
<li><p><code>sync</code>：是否使用异步模式；默认是为false，即使用同步模式，也就是说得到方法的结果之后，才会进行缓存；但是当该属性设置为true时，unless就不会生效；</p>
</li>
</ul>
</li>
<li><p><code>@CacheEvict</code>：指清空缓存；</p>
</li>
<li><p><code>@CachePut</code>：指保证方法被调用，又希望结果被缓存，相当于缓存的修改操作，该注解先执行方法，后更新缓存；<strong><code>注意：查询方法上缓存用的key要和修改方法上缓存所使用的key要相同。</code></strong></p>
<pre><code class="hljs java"><span class="hljs-meta">@Cacheable</span>(cacheNames=<span class="hljs-string">"xxx"</span> key=<span class="hljs-string">"#id"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUserById</span><span class="hljs-params">(Integer id)</span></span>&#123;
    ....
&#125;

<span class="hljs-meta">@CachPut</span>(cacheNames=<span class="hljs-string">"xxx"</span> key=<span class="hljs-string">"#user.id"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">updateUser</span><span class="hljs-params">(User user)</span></span>&#123;
    ....
    <span class="hljs-keyword">return</span> user;
&#125;</code></pre>
</li>
<li><p><code>@EnableCaching</code>：指开启基于注解的缓存，一般在启动类中进行添加；</p>
</li>
<li><p><code>@Caching</code>：重新组合要在方法上应用的多个缓存操作，也就是说你可以同时组合使用多个缓存的注解；</p>
<p><img src="./Image-sb42.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb43.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p><code>@CacheConfig</code>：在类级别共享一些常见的缓存相关设置；</p>
<p><img src="./Image-sb44.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p><code>keyGenerator</code>：指缓存时key的生成策略，可以自定义key的生成策略(也就是生成Cache中的Key值，用于缓存获取值使用)，可作为@Cacheable、@CachePut、@CacheConfig注解的属性；一般key和keyGenerator属性二选一即可；</p>
<pre><code class="hljs java"><span class="hljs-comment">//自定义Key的生成策略</span>

<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCacheConfig</span> </span>&#123;

    <span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"myKeyGenerator"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> KeyGenerator <span class="hljs-title">keyGenerator</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> KeyGenerator() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">generate</span><span class="hljs-params">(Object target, Method method, Object... params)</span> </span>&#123;
                <span class="hljs-keyword">return</span> method.getName()+<span class="hljs-string">"["</span>+Arrays.asList(params).toString() +<span class="hljs-string">"]"</span>;
            &#125;
        &#125;;
    &#125;
&#125;


<span class="hljs-comment">//在使用缓存的方法声明上，使用自己的key生成策略即可，也就是keyGenerator的值等于@Bean注解生成Bean对象的id就行了 </span>
<span class="hljs-meta">@Cacheable</span>(cacheNames = <span class="hljs-string">"users"</span>,keyGenerator = <span class="hljs-string">"myKeyGenerator"</span>)</code></pre>
</li>
<li><p><code>serialize</code>：指缓存数据时value序列化策略，可作为@Cacheable、@CachePut、@CacheConfig注解的属性；</p>
<p><img src="./Image-sb45.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
<li><p>创建基于SpringBoot的Maven工程后(一定要导入Cache的依赖)，只需要在启动类上使用@EnableCaching注解就表示开启了缓存，以及在需要使用缓存的方法上添加@Cacheable注解表示对该方法的结果进行缓存处理；</p>
<p><img src="./Image-sb46.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb47.png" srcset="/img/loading.gif" alt=""></p>
</li>
</ul>
</li>
<li><p>缓存工作原理，以及@Cacheable注解的运行流程；</p>
<ul>
<li><p>缓存工作原理；</p>
<ul>
<li><p>SpringBoot加载缓存的自动配置类：CacheAutoConfiguration；该自动配置类中主要是导入了<code>CacheConfigurationImportSelector</code>，这个类的作用是给容器中导入一些缓存的配置组件；</p>
<p><img src="./Image-sb48.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>CacheConfigurationImportSelector导入的缓存的配置类主要如下所示；通过在全局配置文件中添加debug=true(可以查看默认导入了哪些自动配置)，可以发现默认生效的是SimpleCacheConfiguration缓存配置类；这个默认生效的SimpleCacheConfiguration的作用其实就是给容器注册了一个CacheManager：ConcurrentMapCacheManager；最后在ConcurrentMapCacheManager中，根据方法获取或创建ConcurrentMapCache类型的缓存组件，它的作用是将数据保存在ConcurrentMap中；</p>
<pre><code class="hljs java">org.springframework.boot.autoconfigure.cache.GenericCacheConfiguration
org.springframework.boot.autoconfigure.cache.JCacheCacheConfiguration
org.springframework.boot.autoconfigure.cache.EhCacheCacheConfiguration
org.springframework.boot.autoconfigure.cache.HazelcastCacheConfiguration
org.springframework.boot.autoconfigure.cache.InfinispanCacheConfiguration
org.springframework.boot.autoconfigure.cache.CouchbaseCacheConfiguration
org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration
org.springframework.boot.autoconfigure.cache.CaffeineCacheConfiguration
org.springframework.boot.autoconfigure.cache.GuavaCacheConfiguration
org.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration(默认加载的是这个缓存配置类)
org.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration

<span class="hljs-comment">//-----------------------------------------------------------------------</span>

<span class="hljs-comment">//1.这是默认生效的SimpleCacheConfiguration缓存配置类</span>

<span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)
<span class="hljs-meta">@ConditionalOnMissingBean</span>(CacheManager<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>
<span class="hljs-class">@<span class="hljs-title">Conditional</span>(<span class="hljs-title">CacheCondition</span>.<span class="hljs-title">class</span>)</span>
<span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">SimpleCacheConfiguration</span> </span>&#123;

   <span class="hljs-meta">@Bean</span>
   <span class="hljs-function">ConcurrentMapCacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">(CacheProperties cacheProperties,</span></span>
<span class="hljs-function"><span class="hljs-params">         CacheManagerCustomizers cacheManagerCustomizers)</span> </span>&#123;
      ConcurrentMapCacheManager cacheManager = <span class="hljs-keyword">new</span> ConcurrentMapCacheManager();
      List&lt;String&gt; cacheNames = cacheProperties.getCacheNames();
      <span class="hljs-keyword">if</span> (!cacheNames.isEmpty()) &#123;
         cacheManager.setCacheNames(cacheNames);
      &#125;
      <span class="hljs-keyword">return</span> cacheManagerCustomizers.customize(cacheManager);
   &#125;
&#125;

<span class="hljs-comment">//------------------------------------------------------------------------</span>

<span class="hljs-comment">//2.ConcurrentMapCacheManager类实现了CacheManager接口</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentMapCacheManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CacheManager</span>, <span class="hljs-title">BeanClassLoaderAware</span> </span>&#123;

    ....这里省略了一些代码....

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;String, Cache&gt; cacheMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">16</span>);

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> dynamic = <span class="hljs-keyword">true</span>;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-meta">@Nullable</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Cache <span class="hljs-title">getCache</span><span class="hljs-params">(String name)</span> </span>&#123;

        Cache cache = <span class="hljs-keyword">this</span>.cacheMap.get(name);

        <span class="hljs-keyword">if</span> (cache == <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.dynamic) &#123;
            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.cacheMap) &#123;
                cache = <span class="hljs-keyword">this</span>.cacheMap.get(name);
                <span class="hljs-keyword">if</span> (cache == <span class="hljs-keyword">null</span>) &#123;
                    cache = createConcurrentMapCache(name);
                    <span class="hljs-keyword">this</span>.cacheMap.put(name, cache);
                &#125;
            &#125;
        &#125;
           <span class="hljs-keyword">return</span> cache;
    &#125;

    <span class="hljs-comment">//这是createConcurrentMapCache方法()，作用是生成了一个ConcurrentMapCache组件</span>

    <span class="hljs-function"><span class="hljs-keyword">protected</span> Cache <span class="hljs-title">createConcurrentMapCache</span><span class="hljs-params">(String name)</span> </span>&#123;

        SerializationDelegate actualSerialization = (isStoreByValue() ? <span class="hljs-keyword">this</span>.serialization : <span class="hljs-keyword">null</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcurrentMapCache(name, <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">256</span>), isAllowNullValues(), actualSerialization);
    &#125;
&#125;

<span class="hljs-comment">//2.1.CacheManager接口中的方法有两个，一个是getCache()方法，返回值是一个Cache组件(该组件的值可以为null)，另一个getCacheNames()方法这是获取此CacheManager中已知的缓存的名称的集合</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CacheManager</span> </span>&#123;

    <span class="hljs-meta">@Nullable</span>
    <span class="hljs-function">Cache <span class="hljs-title">getCache</span><span class="hljs-params">(String var1)</span></span>;

    <span class="hljs-function">Collection&lt;String&gt; <span class="hljs-title">getCacheNames</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-comment">//2.2.这是ConcurrentMapCache类</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentMapCache</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractValueAdaptingCache</span> </span>&#123;


   ....这里省略了一些代码....

    <span class="hljs-comment">//实际new的是子类ConcurrentHashMap</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;Object, Object&gt; store;  

    <span class="hljs-comment">//这个是查询的方法，也就是从成员变量ConcurrentMap中根据key获取值</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-meta">@Nullable</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">lookup</span><span class="hljs-params">(Object key)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.store.get(key);
    &#125;

    <span class="hljs-comment">//这个方法是保存缓存数据的</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Object key, @Nullable Object value)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.store.put(key, toStoreValue(value));
    &#125;

    <span class="hljs-comment">//这个方法是删除指定键的缓存</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">evict</span><span class="hljs-params">(Object key)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.store.remove(key);
    &#125;

    <span class="hljs-comment">//这个方法是清空缓存</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.store.clear();
    &#125;
&#125;

说明：这个默认生效的SimpleCacheConfiguration类中的方法，最终返回了一个ConcurrentMapCacheManager，也就是说这个默认生效的缓存配置类，主要的作用就是注册了一个ConcurrentMapCacheManager，并放到了容器中；而在ConcurrentMapCacheManager中，最主要的作用就是获取(根据Cache名称获取，有就获取)或者创建一个ConcurrentMapCache类型的Cache组件，该ConcurrentMapCache就是增删以及清空缓存的主要对象</code></pre>
</li>
</ul>
</li>
<li><p>运行流程如下；</p>
<ul>
<li>添加了@Cacheable注解的方法，在方法运行之前，会先去缓存里查询，按照cacheNames指定的名字获取，也就是CacheManager先获取相应的缓存；第一次获取缓存，如果没有Cache组件，会自动创建；</li>
<li>然后去Cache中查找缓存的内容，使用一个key，这个key默认就是方法的参数，key是按照某种策略生成的，默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key；说明：SimpleKeyGenerator生成key的默认策略：如果没有参数：key=new SimpleKey()；如果有一个参数：key=参数的值；如果有多个参数：key=new SimpleKey(params)；</li>
<li>没有查到缓存就调用目标方法；</li>
<li>将目标方法返回的结果，放进缓存中；</li>
<li>总结：@Cacheable标注的方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存，如果没有就运行方法并将结果放入缓存，以后再来调用就可以直接使用缓存中的数据；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>SpringBoot中整合Redis缓存；</p>
<ul>
<li><p>基本步骤：</p>
<ul>
<li><p>安装虚拟机，并在虚拟机中安装Redis以及Redis可视化界面程序：Redis-desktop-Manager，或者也可以使用Windows版本的redis，这样就不用安装虚拟机；</p>
</li>
<li><p>在SpringBoot中添加Redis依赖；</p>
<pre><code class="hljs xml">    <span class="hljs-comment">&lt;!-- Redis的依赖 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!-- jackson序列化 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
</li>
<li><p>将Redis的属性配置编写到SpringBoot的全局配置文件Application.properties当中；</p>
<pre><code class="hljs properties">    <span class="hljs-meta">spring.redis.pools.min-idle</span>=<span class="hljs-string">5</span>
    <span class="hljs-meta">spring.redis.pools.max-idle</span>=<span class="hljs-string">10</span>
    <span class="hljs-meta">spring.redis.pools.max-total</span>=<span class="hljs-string">20</span>
    <span class="hljs-meta">spring.redis.hostName</span>=<span class="hljs-string">127.0.0.1</span>
<span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span></code></pre>
</li>
<li><p>编写测试类进行测试；</p>
<pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>
<span class="hljs-class">@<span class="hljs-title">SpringBootTest</span>(<span class="hljs-title">classes</span></span>=App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>
<span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">Test</span> </span>&#123;

    <span class="hljs-comment">//导入RedisTemplate对象进行对缓存操作即可</span>
    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> RedisTemplate&lt;String,Object&gt; rt;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;

        <span class="hljs-comment">//存储</span>
        rt.opsForValue().set(<span class="hljs-string">"dyf"</span>, <span class="hljs-string">"邓燕飞"</span>);
        
        <span class="hljs-comment">//获取</span>
        Object obj = rt.opsForValue().get(<span class="hljs-string">"dyf"</span>);

        System.out.println(obj.toString());
    &#125;
&#125;
注意：以上示例是存入一个键值对到Redis缓存中，以及根据Key从Redis取出对应的值</code></pre>
</li>
<li><p>在SpringBoot中使用Redis来存取对象，就需要在实体类上添加Serializable序列化接口，然后在进行存取值时，SpringBoot会默认使用JDK的对象序列化器，即new JdkSerializationRedisSerializer()，但是该序列化的缺点是，显示的数据是以Hex形式显示(就是<code>\xxxx\xxx\xxx</code>这样的形式)，且会浪费较多存储空间；由于JDK本身的序列化器比较占用空间且数据形式不直观，所以，我们把序列化器换成了<code>new Jackson2JsonRedisSerializer&lt;&gt;(实体类.class)</code>去替代上面的序列化器即可；</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;
          ......
&#125;

<span class="hljs-comment">//---------------------------------------------------</span>

<span class="hljs-comment">//这是SpringBoot2.0版本中使用Jackson2序列化器的配置方法</span>

<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> CacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;

    <span class="hljs-comment">//初始化一个RedisCacheWriter</span>
    RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(connectionFactory);

    Jackson2JsonRedisSerializer serializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    RedisSerializationContext.SerializationPair&lt;Object&gt; pair = RedisSerializationContext.SerializationPair.fromSerializer(serializer);

    RedisCacheConfiguration defaultCacheConfig=RedisCacheConfiguration.defaultCacheConfig().serializeValuesWith(pair);

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RedisCacheManager(redisCacheWriter, defaultCacheConfig);
&#125;

<span class="hljs-comment">//---------------------------------------------------</span>

<span class="hljs-meta">@Resource</span>
<span class="hljs-keyword">private</span> RedisTemplate&lt;String,Object&gt; rt;

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;

    User user = <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">"邓先森"</span>, <span class="hljs-number">26</span>);

    rt.opsForValue().set(<span class="hljs-string">"testUser"</span>, user);

    User obj = (User)rt.opsForValue().get(<span class="hljs-string">"testUser"</span>);
    System.out.println(obj);
&#125;

注意：一定要在需要序列化的实体类上实现Serializable接口</code></pre>


</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>SpringBoot与Ehcache缓存；</p>
<ul>
<li><p>基本步骤：</p>
<ul>
<li><p>添加Ehcache依赖；</p>
<pre><code class="hljs xml">    <span class="hljs-comment">&lt;!-- SpringBoot缓存依赖 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
           
    <span class="hljs-comment">&lt;!-- Ehcache缓存依赖 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.sf.ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
</li>
<li><p>在src/main/resources下创建Ehcache的配置文件，配置文件名称为：ehcache.xml；</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ehcache</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag">          <span class="hljs-attr">xsi:noNamespaceSchemaLocation</span>=<span class="hljs-string">"../config/ehcache.xsd"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">diskStore</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"java.io.tmpdir"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">defaultCache</span> <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">"10000"</span> <span class="hljs-attr">eternal</span>=<span class="hljs-string">"false"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">"120"</span> <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">"120"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">maxElementsOnDisk</span>=<span class="hljs-string">"10000000"</span> <span class="hljs-attr">diskExpiryThreadIntervalSeconds</span>=<span class="hljs-string">"120"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">memoryStoreEvictionPolicy</span>=<span class="hljs-string">"LRU"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">persistence</span> <span class="hljs-attr">strategy</span>=<span class="hljs-string">"localTempSwap"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">defaultCache</span>&gt;</span>
       
    <span class="hljs-comment">&lt;!-- 自定义缓存策略 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">"10000"</span> <span class="hljs-attr">eternal</span>=<span class="hljs-string">"false"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">"120"</span> <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">"120"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">maxElementsOnDisk</span>=<span class="hljs-string">"10000000"</span> <span class="hljs-attr">diskExpiryThreadIntervalSeconds</span>=<span class="hljs-string">"120"</span></span>
<span class="hljs-tag">        <span class="hljs-attr">memoryStoreEvictionPolicy</span>=<span class="hljs-string">"LRU"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">persistence</span> <span class="hljs-attr">strategy</span>=<span class="hljs-string">"localTempSwap"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">cache</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ehcache</span>&gt;</span>


注意：可以自定义缓存策略</code></pre>
</li>
<li><p>在application.properties配置文件中，配置缓存信息，让SpringBoot在启动的时候方便找到缓存配置文件并解析；</p>
<pre><code class="hljs properties"><span class="hljs-meta">spring.cache.ehcache.config</span>=<span class="hljs-string">classpath:ehcache.xml</span></code></pre>
</li>
<li><p>在启动类上添加一个注解；</p>
<pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableCaching</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 启动类</span>&#123;
    ...
&#125;</code></pre>
</li>
<li><p>编写Service层和ServiceImpl实现类，编写测试类并进行测试缓存，在ServiceImpl实现类中对需要使用缓存的方法添加<code>@Cacheable(value=&quot;自定义的缓存策略名称&quot;)</code>注解，该注解就是开启缓存；</p>
<pre><code class="hljs java">......ServiceImpl实现类
     
    <span class="hljs-meta">@Override</span>
    <span class="hljs-meta">@Cacheable</span>(value=<span class="hljs-string">"user"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">findUserById</span><span class="hljs-params">(Integer id)</span> </span>&#123;
    User user = userRepository.findById(id).orElse(<span class="hljs-keyword">null</span>);
    <span class="hljs-keyword">return</span> user;


<span class="hljs-comment">//--------------------------------------------------------------</span>

......测试类

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cacheTest</span><span class="hljs-params">()</span> </span>&#123;

        User target1 = userService.findUserById(<span class="hljs-number">1</span>);
        System.out.println(target1);
        User target2 = userService.findUserById(<span class="hljs-number">1</span>);
        System.out.println(target2);
    &#125;


&#125;

注意：一般来说，查询两次，会出现两条SQL语句，使用缓存后，只会出现一条SQL语句，即开启缓存后，会将返回值存入缓存当中，下次查询根据缓存中是否有相同的key，决定是否直接从缓存中获取，有相同的key则从缓存中去值，没有则去数据库查询；测试后发现会报错NotSerializableException，即查询的对象实体类没有实现Serializable接口，因为被缓存的对象可以存储到本地文件当中(其实就是序列化)，所以只需要实体类实现Serializable接口即可；

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;
    ....
&#125;

必须指定value属性，即将返回值存储到value定义的这个缓存当中</code></pre>

<ul>
<li><p>@Cacheable和@CacheEvict的区别；</p>
<ul>
<li><p>@Cacheable注解：</p>
<ul>
<li><p>是开启缓存的注解，可以写在方法上，即对该方法开启缓存；也可以写在类上，即对该类下所有方法都开启缓存；</p>
</li>
<li><p>该注解中的value属性必须要设置，即开启缓存必须指定将值存入一个缓存中；</p>
</li>
<li><p>缓存方法的返回值是以键值对进行缓存的，该注解中的key属性，就是用来指定缓存方法的返回结果时对应的key的；key的属性有两种定义方式：</p>
<ul>
<li>一是自定义；<code>如，使用方法参数就用&quot;#参数名&quot;</code>；</li>
<li>二是使用默认的root对象的属性；<code>如，使用当前方法参数组成的数组#root.args[0]等</code>。</li>
</ul>
</li>
<li><p>condition属性指定缓存发生的条件，即当满足condition属性设置的条件时(为true时)，才会触发缓存，否则不触发缓存；</p>
<pre><code class="hljs java"><span class="hljs-comment">//当id是偶数时才触发缓存</span>
<span class="hljs-meta">@Cacheable</span>(value=&#123;<span class="hljs-string">"user"</span>&#125;, key=<span class="hljs-string">"#user.id"</span>, condition=<span class="hljs-string">"#user.id%2==0"</span>)</code></pre>
</li>
</ul>
</li>
<li><p>@CacheEvict注解：</p>
<ul>
<li><p>是清除缓存的注解，写在方法上则清除该方法的缓存，写在类上则该类下所有方法的都会执行清除缓存操作；</p>
</li>
<li><p>value属性和key属性和@Cacheable相似，只是清除指定缓存下指定key所对应的缓存；</p>
</li>
<li><p>allEntries：该属性表示是否清除缓存中所有元素，默认是false；在使用了缓存之后，一定要记得清除缓存，否则会有数据库与缓存不同步的状况发生；</p>
<pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-meta">@Cacheable</span>(value=<span class="hljs-string">"user"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">findUserAll</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> userRepository.findAll();
&#125;

注意：该方法使用了缓存

<span class="hljs-comment">//------------------------------------------------------------</span>

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cacheTest</span><span class="hljs-params">()</span> </span>&#123;
    
    List&lt;User&gt; target = userService.findUserAll();
    System.out.println(target.size());
    User user = <span class="hljs-keyword">new</span> User();
    user.setName(<span class="hljs-string">"小呜呜"</span>);
    user.setAge(<span class="hljs-number">23</span>);
    user.setAdress(<span class="hljs-string">"黄土高坡"</span>);
    userService.saveUser(user);
    
    List&lt;User&gt; target2 = userService.findUserAll();
    System.out.println(target2.size());
&#125;



注意：这里出现了数据库与缓存不同步的问题，即两次调用findUserAll()，得到的结果都是相同的，但由于我们中间添加了一条记录，所以，数据库中的数据是要比缓存中多一条数据，但测试后得到结果都相同，所以两者不同步；解决方法如下


<span class="hljs-meta">@Override</span>
<span class="hljs-meta">@CacheEvict</span>(value=<span class="hljs-string">"user"</span>,allEntries=<span class="hljs-keyword">true</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveUser</span><span class="hljs-params">(User user)</span> </span>&#123;
    userRepository.save(user);
&#125;

解决：在saveUser()方法上添加<span class="hljs-meta">@CacheEvict</span>(value=<span class="hljs-string">"user"</span>,allEntries=<span class="hljs-keyword">true</span>)注解，并设置value和allEntries属性即可


测试后，成功解决不同步的情况；解决思想：因为当方法开启缓存后，每次查询都会去缓存里查询是否有对应的值缓存，当添加新的记录时，由于添加方法增加了清除缓存的操作，所以再次调用查询方法时，发现没有缓存了，就只能去数据库获取数据，之后再次将查询结果放入缓存中，就解决了缓存与数据库不同步的问题</code></pre>


</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-13-SpringBoot与消息"><a href="#NO2-13-SpringBoot与消息" class="headerlink" title="NO2.13 SpringBoot与消息"></a>NO2.13 SpringBoot与消息</h3><p>SpringBoot中也有与消息中间件的整合。</p>
<ul>
<li><p>消息中间件；</p>
<ul>
<li><p>定义：什么是消息中间件？其实就是关注于数据的发送和接收，利用高效可靠的异步消息传递机制集成分布式系统；常用于异步处理、应用的解耦、流量的削峰、日志处理、以及纯粹的消息通信等等；</p>
</li>
<li><p>优点：</p>
<ul>
<li><p>异步通信：有些业务不想也不需要立即处理消息，消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它；想要往队列中放入多少消息就放多少，然后在需要的时候再去处理它们；</p>
</li>
<li><p>解耦：降低工程间的强依赖程度，针对异构系统进行适配；在项目启动之初来预测将来项目会碰到什么需求，是极其困难的；通过消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，当应用发生变化时，可以独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束；</p>
</li>
<li><p>冗余：有些情况下，处理数据的过程会失败，除非数据被持久化，否则将造成丢失；消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险；许多消息队列所采用的“插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕；</p>
</li>
<li><p>扩展性：因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可；不需要改变代码、不需要调节参数，便于分布式扩容；</p>
</li>
<li><p>过载保护：在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量无法提取预知；如果以为了能处理这类瞬间峰值访问为标准来投入资源随时待命无疑是巨大的浪费；使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃；</p>
</li>
<li><p>可恢复性：系统的一部分组件失效时，不会影响到整个系统；消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理；</p>
</li>
<li><p>顺序保证；在大多使用场景下，数据处理的顺序都很重要；大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理；</p>
</li>
<li><p>缓冲：在任何重要的系统中，都会有需要不同的处理时间的元素；消息队列通过一个缓冲层来帮助任务最高效率的执行，该缓冲有助于控制和优化数据流经过系统的速度，以调节系统响应时间；</p>
</li>
<li><p>数据流处理：分布式系统产生的海量数据流，如，业务日志、监控数据、用户行为等，针对这些数据流进行实时或批量采集汇总，然后进行大数据分析是当前互联网的必备技术，通过消息队列完成此类数据收集是最好的选择；</p>
<p><img src="./Image-sb49.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb50.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb51.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
<li><p>消息服务中心有两个重要的概念：消息代理(message broker)和目的地(destination)。意思就是说，当消息发送者发送消息后，消息将由消息代理接管，消息代理保证消息传递到目的地；消息代理主要有两种形式的目的地：队列(queue)和主题(topic)；</p>
<ul>
<li>点对点式：即点对点式消息通信；<ul>
<li>消息发送者发布消息，消息代理将其放入一个队列，消息接收者从队列中获取消息，消息被读取后则移除消息队列中的消息；</li>
<li>消息只有唯一的发送者和接受者，但并不是只有唯一的接收者。<strong><code>如，A是消息发送者，而B是实际接受者，但是消息其实也可以被B、C、D、E所接受，只是最后实际接收消息的是B</code></strong>；</li>
</ul>
</li>
<li>发布订阅式：即发布和订阅消息通信；<ul>
<li>发布者发送消息到主题，如果多个接受者(订阅者)监听(订阅)这个主题，那么所有接受者会在消息到达时同时接到消息。</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是JMS？指的是Java消息服务(Java Message Service)，基于JVM的消息代理规范，是一个Java平台中关于面向消息中间件的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信；ActiveMQ、HornetMQ都是JMS的实现；</p>
</li>
<li><p>什么是AMQP？AMQP(advanced message queuing protocol)，即高级消息队列协议，兼容JMS，是应用层协议的一个开放标准，为面向消息的中间件设计；消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然；RabbitMQ是AMQP的实现；</p>
<p><img src="./Image-sb52.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb53.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>SpringBoot整合RabbitMQ消息中间件：</p>
<ul>
<li><p>介绍：RabbitMQ是一个开源的消息代理和队列服务器，RabbitMQ是使用Erlang语言来编写的，基于AMQP协议在完全不同的应用之间共享数据(RabbitMQ能够实现跨语言跨平台的机制)，本身支持很多的协议：AMQP、XMPP、SMTP、STOMP，也正是如此，使的它变的非常重量级，同时也实现了Broker架构，核心思想是生产者不会将消息直接发送给队列，消息在发送给客户端时先在中心队列排队；对路由(Routing)，负载均衡(Load balance)、数据持久化都有很好的支持，多用于进行企业级的ESB整合，以及用于在分布式系统中存储转发消息；</p>
</li>
<li><p>RabbitMQ的核心概念：</p>
<ul>
<li><code>Server</code>：又称为Broker，接收客户端的连接，实现AMQP实体服务，简单来说就是消息队列服务器实体；</li>
<li><code>Connection</code>：连接，应用程序与broker的网络连接；</li>
<li><code>Channel</code>：消息通道，几乎所有的操作都在Chanel中进行，Channel是进行消息读写的通道；客户端可建立多个Channel，每个Channel代表一个会话任务；</li>
<li><code>Message</code>：消息，服务器和应用程序之间传送的数据，由Properties和Body组成；Properties可以对消息进行修饰，比如消息的优先级，延迟等高级特性；而Body就是消息体内容；</li>
<li><code>Virtual host</code>：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离和逻辑隔离，是最上层的消息路由；一个vhost里面可以有若干个Exchange和Queue，同一个vhost里面不能有相同名称的exchange或queue(用于隔离不同的项目和应用的);</li>
<li><code>Exchange</code>：消息交换机，它指定消息按什么规则，路由到哪个队列；Exchange有多种类型，类型不同，Message的分发机制不同，主要有以下几种类型；<ul>
<li><code>fanout</code>：广播模式，这种类型的Exchange会将Message分发到绑定了该Exchange的所有Queue，所以写不写Routingkey绑定Queue都可以，因为是广播模式，只要绑定了广播模式的交换器，那么这些队列都可以接受到消息；</li>
<li><code>direct</code>：单播模式，这种类型的Exchange会根据Routing key(点对点精确匹配，将Message分发到指定的Queue)，默认使用该机制；</li>
<li><code>Topic</code>：主题模式，这种类型的Exchange会根据Routing key(模糊匹配，将Message分发到合适的Queue)；能够识别两个通配符：<code>符号“#”</code>和<code>符号“*”</code>，其中<code>#</code>匹配0个或多个单词，<code>*</code>匹配一个单词；</li>
<li><code>headers</code>：与主题交换机有点相似，但是不同于主题交换机的路由是基于路由键，头交换机的路由值基于消息的header数据；主题交换机路由键只有是字符串，而头交换机可以是整型和哈希值，该方式不常用；</li>
</ul>
</li>
<li><code>Binding</code>：绑定，它的作用就是把exchange和queue按照路由规则绑定起来；</li>
<li><code>Routing key</code>：路由关键字，exchange根据这个关键字进行消息投递；</li>
<li><code>Queue</code>：消息队列载体，每个消息都会被投入到一个或多个队列，保存消息并将它们转发给消费者，消费者直接监听队列就能收到消息了；<ul>
<li><code>name</code>：队列名称；</li>
<li><code>durable</code>：持久化消息队列，rabbitmq重启的时候不需要创建新的队列，默认true；</li>
<li><code>auto-delete</code>：表示消息队列没有在使用时将被自动删除，默认是false；</li>
<li><code>exclusive</code>：表示该消息队列是否只在当前connection生效，默认是false；</li>
</ul>
</li>
<li><code>producer</code>：消息生产者，就是投递消息的程序；</li>
<li><code>consumer</code>：消息消费者，就是接受消息的程序；</li>
</ul>
</li>
<li><p>基本步骤：</p>
<ul>
<li><p>分别安装Erlang语言(因为这个RabbitMQ是基于这个语言写的，需要Erlang的语言库，就像JAVA需要JVM一样)和RabbitMQ；</p>
<ul>
<li><p>下载并安装Erlang语言；</p>
<p><img src="./Image-sb54.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>下载并安装RabbitMQ；</p>
<p><img src="./Image-sb55.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>安装管理界面(插件)，进入RabbitMQ的安装目录的sbin目录；</p>
<p><img src="./Image-sb56.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>在地址栏输入cmd打开命令窗口，输入命令：rabbitmq-plugins enable rabbitmq_management，并回车；</p>
<p><img src="./Image-sb57.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>出现如下界面后，重启RabbitMQ服务；如果不行，则再次执行一次rabbitmq-plugins enable rabbitmq_management命令后，重启RabbitMQ服务；</p>
<p><img src="./Image-sb58.png" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p>打开浏览器，输入地址+端口，查看RabbitMQ管理界面<code>http://localhost:15672/</code>，进行登录，用户名：guest，密码：guest，登录成功后可看到如下界面；至此RabbitMQ已经全部安装完成；</p>
<p><img src="./Image-sb59.png" srcset="/img/loading.gif" alt=""></p>
</li>
</ul>
</li>
<li><p>创建一个基于SpringBoot的Maven项目，并导入RabbitMQ所需要的依赖，然后在测试中导入RabbitTemplate模板(这个模板是操作消息的发送与接收的)进行测试即可；</p>
<ul>
<li><p>工程创建完成后，导入RabbitMQ的依赖，为了测试方便，也可以引入Web依赖；</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
</li>
<li><p>由于在RabbitAutoConfiguration自动配置类中，许多需要的组件都已经被配置好了，像CachingConnectionFactory(用于连接到RabbitMQ的连接对象)、RabbitTemplate(用于给RabbitMQ发送和接收消息)、AmqpAdmin(RabbitMQ系统管理功能组件)等等，且RabbitProperties封装了RabbitMQ配置，在application.properties(或xxx.ymal)中配置RabbitMQ基本连接信息就可以了；</p>
<pre><code class="hljs properties"><span class="hljs-comment">#配置RabbitMQ的主机地址，不配置的话就默认是本机地址，也就是localhost</span>
<span class="hljs-meta">spring.rabbitmq.host</span>=<span class="hljs-string">xxx.xxx.xxx.xxx</span>
<span class="hljs-meta">spring.rabbitmq.port</span>=<span class="hljs-string">15672</span>
<span class="hljs-meta">spring.rabbitmq.username</span>=<span class="hljs-string">wang</span>
<span class="hljs-meta">spring.rabbitmq.password</span>=<span class="hljs-string">123</span></code></pre>

<p><img src="./Image-sb60.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb61.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb62.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>在测试类中可以直接使用RabbitTemplate进行测试收发消息(前提已经配置好了RabbitMQ)；</p>
<pre><code class="hljs java"><span class="hljs-comment">//这是发送消息</span>

<span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootCacheApplicationTests</span> </span>&#123;

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> RabbitTemplate rt;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span> </span>&#123;

        <span class="hljs-comment">//该方法用的比较少，因为创建message这个对象比较麻烦，</span>
        rt.send(exchange,routingKey,message);

        <span class="hljs-comment">//我们一般常用这个方法，参数从左到右依次是交换器，路由键，消息对象</span>
        rt.convertAndSend(exchange,routingKey,Object);
    &#125;
&#125;

<span class="hljs-comment">//-------------------------------------------------------------------</span>

<span class="hljs-comment">//我们也可以自己配置一个消息序列化器，让消息可视化，一般使用Jackson2JsonMessageConverter序列化器</span>

<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAMQPConfig</span></span>&#123;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title">messageConverter</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Jackson2JsonMessageConverter();
    &#125;
&#125;


<span class="hljs-comment">//---------------------------------------------------------------------</span>

<span class="hljs-comment">//这是接收消息</span>

<span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootCacheApplicationTests</span> </span>&#123;

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> RabbitTemplate rt;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">receiveMessage</span><span class="hljs-params">()</span> </span>&#123;

        <span class="hljs-comment">//我们一般常用这个方法接收某个指定队列里的消息</span>
        rt.reciveAndConver(queueName);
    &#125;
&#125;

说明：上述发送消息的方法中的message参数，也就是需要发送的消息内容，其中创建该Message类的对象，需要封装两个参数，一是需要发送的内容，将其转为一个字节数组，二是MessageProperties对象，这个对象是用来设置消息的一些属性，如，消息的优先级等等，所以我们一般很少用这个方法，常用的是converAndSend()方法，一般用带三个参数的方法，分别是交换器名称，路由键，消息内容即可，但要注意的是，该方法发送消息会自动序列化消息内容，默认使用的是SimpleMessageConverter，也就是在消息队列里查看消息的话，是一串我们看不懂的数据，所以我们也可以自己编写一个配置类，然后设置序列化器，；而在接收消息的方法里，也就是reciveAndConver()方法，只需要填入需要接收的消息队列的名称就行了</code></pre>

<p><img src="./Image-sb63.png" srcset="/img/loading.gif" alt=""></p>
</li>
</ul>
</li>
<li><p>还可以在Java中直接配置Exchange、Queue、Routingkey，这样就会在RabbitMQ的Broker中，生成你配置的这些组件，这与你在Broker设置并生成的组件是一样的；</p>
<pre><code class="hljs java">#配置要连接的RabbitMQ服务器的账号和密码；
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest

#host属性不配置，默认是本机，也就是localhost；
#spring.rabbitmq.host=localhost

#port属性，默认配置的是5672，也就是RabbitMQ的端口
#spring.rabbitmq.port=5672

<span class="hljs-comment">//-----------------------------------------------------------</span>

<span class="hljs-comment">//这是基于Java进行配置Exchange、Queue、Binding</span>

<span class="hljs-keyword">import</span> org.springframework.amqp.core.Binding;
<span class="hljs-keyword">import</span> org.springframework.amqp.core.BindingBuilder;
<span class="hljs-keyword">import</span> org.springframework.amqp.core.DirectExchange;
<span class="hljs-keyword">import</span> org.springframework.amqp.core.Queue;
<span class="hljs-keyword">import</span> org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
<span class="hljs-keyword">import</span> org.springframework.amqp.support.converter.MessageConverter;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;


<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRabbitConfig</span> </span>&#123;


    <span class="hljs-comment">//创建一个Json的序列化器，这样发送和接收的消息就会是一个Json字符串</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title">myMessageConverter</span><span class="hljs-params">()</span></span>&#123;

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Jackson2JsonMessageConverter();
    &#125;

    <span class="hljs-comment">//创建一个Queue</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">myQueue</span><span class="hljs-params">()</span></span>&#123;

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">"dyfQueue"</span>,<span class="hljs-keyword">true</span>);
    &#125;

    <span class="hljs-comment">//创建一个Direct类型的Exchange</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">myDirectExchange</span><span class="hljs-params">()</span></span>&#123;

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(<span class="hljs-string">"dyfExchange"</span>);
    &#125;


    <span class="hljs-comment">//创建一个Binding，并绑定到Queue和Exchange</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">myBinding</span><span class="hljs-params">()</span></span>&#123;

        <span class="hljs-keyword">return</span> BindingBuilder.bind(myQueue()).to(myDirectExchange()).with(<span class="hljs-string">"dyf"</span>);
    &#125;
&#125;

<span class="hljs-comment">//----------------------------------------------------------------</span>

<span class="hljs-comment">//测试发送数据</span>

<span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitmqApplicationTests</span> </span>&#123;

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> RabbitTemplate rt;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;

        rt.convertAndSend(<span class="hljs-string">"dyfExchange"</span>,<span class="hljs-string">"dyf"</span>,<span class="hljs-string">"你好啊，RabbitMQ！"</span>);
    &#125;
&#125;

<span class="hljs-comment">//测试从Queue中接收数据</span>
<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;

    Object msg = rt.receiveAndConvert(<span class="hljs-string">"dyfQueue"</span>);
    System.out.println(msg);
&#125;

控制台成功输出：你好啊，RabbitMQ！</code></pre>
</li>
<li><p>使用监听器进行监听队列，当队列收到消息时，则会进行某些操作，监听机制需要使用注解@RabbitListener和@RabbitHandler搭配使用，但是要注意的是，监听队列的方法也会消费消息，也就是说，也相当于一个消息消费者；</p>
<ul>
<li><p>@RabbitListener注解可以标注在类上面，需配合@RabbitHandler注解一起使用。当@RabbitListener标注在类上面，表示当有收到消息的时候，就交给@RabbitHandler的方法处理，具体使用哪个方法处理，根据MessageConverter转换后的参数类型；</p>
<pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListener</span> </span>&#123;

    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"dyfQueue"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenQueue</span><span class="hljs-params">()</span></span>&#123;
        System.out.println(<span class="hljs-string">"监听到消息了..."</span>);

    &#125;
&#125;

<span class="hljs-comment">//--------------------------------------------------</span>

<span class="hljs-meta">@EnableRabbit</span>  <span class="hljs-comment">//该注解的作用就是开启基于注解RabbitMQ模式</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitmqApplication</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(RabbitmqApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;
    &#125;
&#125;

说明：
一、<span class="hljs-meta">@RabbitListener</span>注解的queues属性是一个数组，可以写多个需要监听队列名称；

二、要使用监听机制监听消息，必须在启动类上添加注解<span class="hljs-meta">@EnableRabbit</span>，该注解的作用就是开启基于注解的RabbitMQ模式。</code></pre>
</li>
</ul>
</li>
<li><p>AmqpAdmin对象的使用：这个对象是用于管理RabbitMQ中的组件的，也就是创建Exchange、Queue、Binding等等；</p>
<pre><code class="hljs java"><span class="hljs-comment">//declare方法里面是创建一些组件,相反的有一些remove方法和delete方法，用来删除</span>

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;

    ad.declareExchange(<span class="hljs-keyword">new</span> FanoutExchange(<span class="hljs-string">"selfExchange"</span>));

    ad.declareQueue(<span class="hljs-keyword">new</span> Queue(<span class="hljs-string">"selfQueue"</span>,<span class="hljs-keyword">true</span>));

    ad.declareBinding(
            <span class="hljs-keyword">new</span> Binding(<span class="hljs-string">"selfQueue"</span>, Binding.DestinationType.QUEUE,
                    <span class="hljs-string">"selfExchange"</span>,
                    <span class="hljs-string">"#.dec"</span>,
                    <span class="hljs-keyword">null</span>)
    );

    System.out.println(<span class="hljs-string">"创建成功啦"</span>);
&#125;</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-14-SpringBoot与检索"><a href="#NO2-14-SpringBoot与检索" class="headerlink" title="NO2.14 SpringBoot与检索"></a>NO2.14 SpringBoot与检索</h3><p>你知道我们常用的百度搜索等搜索引擎，到底使用的什么搜索吗？其实是ElasticSearch。</p>
<ul>
<li><p>ElasticSearch：</p>
<ul>
<li><p>介绍：Elasticsearch是一个开源的分布式、RESTful风格的搜索和数据分析引擎，它的底层是开源库Apache Lucene；Lucene可以说是当下最先进、高性能、全功能的搜索引擎库——无论是开源还是私有，但它也仅仅只是一个库；为了充分发挥其功能，你需要使用Java并将Lucene直接集成到应用程序中；为了解决Lucene使用时的繁复性，于是ElasticSearch便应运而生；它使用Java编写，内部采用Lucene做索引与搜索，但是它的目标是使全文检索变得更简单，简单来说，就是对Lucene做了一层封装，它提供了一套简单一致的RESTful风格的API来帮助我们实现存储和检索；当然，Elasticsearch不仅仅是Lucene，并且也不仅仅只是一个全文搜索引擎，它可以被这样准确地形容：一个分布式的实时文档存储，每个字段可以被索引与搜索；一个分布式实时分析搜索引擎；能胜任上百个服务节点的扩展，并支持PB级别的结构化或者非结构化数据；由于Elasticsearch的功能强大和使用简单，维基百科、卫报、StackOverflow、GitHub等都纷纷采用它来做搜索。现在，Elasticsearch已成为全文搜索领域的主流软件之一；</p>
</li>
<li><p>ElasticSearch的安装；</p>
<ul>
<li><p>到官网根据系统下载ES的zip包即可；</p>
<p><img src="./Image-sb64.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>解压到自定义的指定目录下(注意目录的路径不要有中文)；</p>
</li>
<li><p>进入ES的bin目录，双击elasticsearch.bat启动服务，默认端口是9200；</p>
<p><img src="./Image-sb65.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>启动完成之后，在浏览器中访问<code>http://localhost:9200/</code>，出现如下图所示内容表明ES启动成功；</p>
<p><img src="./Image-sb66.png" srcset="/img/loading.gif" alt=""></p>
</li>
</ul>
</li>
<li><p>ES的核心概念；</p>
<ul>
<li><code>节点&amp;集群(Node&amp;Cluster)</code>：ES本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个ES实例；单个ES实例称为一个节点(Node)，一组节点构成一个集群(Cluster)；</li>
<li><code>索引(Index)</code>：ES数据管理的顶层单位就叫做Index，相当于关系型数据库里的数据库的概念；另外，每个Index的名字必须是小写；</li>
<li><code>类型(Type)</code>：Document可以分组；如，employee这个Index里面，可以按部门分组，也可以按职级分组，这种分组就叫做Type，它是虚拟的逻辑分组，用来过滤Document，类似关系型数据库中的数据表；不同的 Type应该有相似的结构(Schema)，性质完全不同的数据(如，products和logs)应该存成两个Index，而不是一个Index里面的两个Type(虽然可以做到)；</li>
<li><code>文档(Document)</code>：Index里面单条的记录称为Document(相当于数据库里表的记录)；许多条Document构成了一个Index；Document使用JSON格式表示；同一个Index里面的Document，不要求有相同的结构(scheme)，但是最好保持相同，这样有利于提高搜索效率；</li>
<li><code>字段(Fields)</code>：每个Document都类似一个JSON结构，它包含了许多字段，每个字段都有其对应的值，多个字段组成了一个Document，可以类比关系型数据库数据表中的字段；</li>
<li><code>文档元数据(Document metadata)</code>：文档元数据为<code>_index</code>、<code>_type</code>、<code>_id</code>，这三者可以唯一表示一个文档，<code>_index</code>表示文档在哪存放，<code>_type</code>表示文档的对象类别，<code>_id</code>为文档的唯一标识；</li>
</ul>
</li>
<li><p>SpringBoot整合ElasticSearch；</p>
<ul>
<li><p>Java存在三种ES的客户端；造成这种混乱的原因是ES开始是没有Java版的客户端，但Java自己是可以简单的支持ES的API，所以有了第一种客户端(Transport Client)；后来官方推出了第二种版本(Java Low Level Rest Client)，但缺点也是显而易见的，因为从第一种版本迁移到第二版本工作量是比较的大的，官方还特意出一堆文档来提供参考；而第三种版本的客户端是兼容两种客户端的优点，他是在第二种版本的基础上进行了封装，也让代码迁移变得更方便，但依然存在缺点，小的版本更新频繁，经常出现莫名其妙的错误，我们尽量保持客户端和服务器相同的版本；</p>
<ul>
<li>Transport Client；</li>
<li>Java Low Level Rest Client；</li>
<li>Java High Level Rest Client；</li>
</ul>
</li>
<li><p>创建基于SpringBoot的Maven工程后，引入ES依赖，然后创建EsConfig配置类；</p>
<pre><code class="hljs java">&lt;!--ES引入--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;
    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;
    &lt;version&gt;6.6.2&lt;/version&gt;
&lt;/dependency&gt;

<span class="hljs-comment">//-----------------------------------------------------------</span>

<span class="hljs-keyword">import</span> org.apache.http.HttpHost;
<span class="hljs-keyword">import</span> org.elasticsearch.client.RestClient;
<span class="hljs-keyword">import</span> org.elasticsearch.client.RestHighLevelClient;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;


<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EsConfig</span> </span>&#123;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> RestHighLevelClient <span class="hljs-title">restHighLevelClient</span><span class="hljs-params">()</span></span>&#123;
        RestHighLevelClient client = <span class="hljs-keyword">new</span> RestHighLevelClient(
                RestClient.builder(<span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"10.105.9.119"</span>, <span class="hljs-number">9200</span>, <span class="hljs-string">"http"</span>))
        );

        <span class="hljs-keyword">return</span> client;
    &#125;
&#125;</code></pre>
</li>
<li><p>执行增删改查；</p>
<ul>
<li><p>查询；</p>
<p><img src="./Image-sb67.png" srcset="/img/loading.gif" alt="Image"></p>
<pre><code class="hljs java"><span class="hljs-comment">//查询id为1的记录</span>

<span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">private</span> RestHighLevelClient client;


<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/teacher"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">get</span><span class="hljs-params">(@RequestParam(value = <span class="hljs-string">"id"</span>,defaultValue = <span class="hljs-string">""</span>)</span> String id) <span class="hljs-keyword">throws</span> IOException </span>&#123;
    
    <span class="hljs-keyword">try</span> &#123;

        <span class="hljs-keyword">if</span> (id.isEmpty())&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity(HttpStatus.NOT_FOUND);
        &#125;

        <span class="hljs-comment">//封装具体的查询条件</span>
        GetRequest request = <span class="hljs-keyword">new</span> GetRequest(<span class="hljs-string">"user"</span>,<span class="hljs-string">"teacher"</span>,id);

        GetResponse result = client.get(request, RequestOptions.DEFAULT);

        <span class="hljs-keyword">if</span> (!result.isExists())&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity(HttpStatus.NOT_FOUND);
        &#125;
            
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity(result.getSource(),HttpStatus.OK);

        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;
            e.printStackTrace();
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;</code></pre>

<p><img src="./Image-sb68.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>增加；</p>
<pre><code class="hljs java"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/add"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">add</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">            @RequestParam String name,</span></span>
<span class="hljs-function"><span class="hljs-params">            @RequestParam String gender,</span></span>
<span class="hljs-function"><span class="hljs-params">            @RequestParam <span class="hljs-keyword">int</span> age,</span></span>
<span class="hljs-function"><span class="hljs-params">            @RequestParam String country,</span></span>
<span class="hljs-function"><span class="hljs-params">            @RequestParam String date )</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    
    XContentBuilder xContentBuilder = XContentFactory.jsonBuilder()
                .startObject()
                .field(<span class="hljs-string">"name"</span>,name)
                .field(<span class="hljs-string">"gender"</span>,gender)
                .field(<span class="hljs-string">"age"</span>,age)
                .field(<span class="hljs-string">"country"</span>,country)
                .field(<span class="hljs-string">"date"</span>,date)
                .endObject();

    IndexRequest indexRequest = <span class="hljs-keyword">new</span> IndexRequest(<span class="hljs-string">"user"</span>,<span class="hljs-string">"teacher"</span>);
    indexRequest.source(xContentBuilder);
    IndexResponse response = client.index(indexRequest,RequestOptions.DEFAULT);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity(response.getId(),HttpStatus.OK);
&#125;</code></pre>

<p><img src="./Image-sb69.png" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p>修改；</p>
<pre><code class="hljs java"><span class="hljs-meta">@PutMapping</span>(<span class="hljs-string">"/update/teacher"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">update</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">            @RequestParam(name = <span class="hljs-string">"id"</span>)</span> String id,</span>
<span class="hljs-function">            @<span class="hljs-title">RequestParam</span><span class="hljs-params">(name = <span class="hljs-string">"name"</span>,required = <span class="hljs-keyword">false</span>)</span> String name,</span>
<span class="hljs-function">            @<span class="hljs-title">RequestParam</span><span class="hljs-params">(name = <span class="hljs-string">"gender"</span>,required = <span class="hljs-keyword">false</span>)</span> String gender ) <span class="hljs-keyword">throws</span> IOException </span>&#123;

    UpdateRequest updateRequest = <span class="hljs-keyword">new</span> UpdateRequest(<span class="hljs-string">"user"</span>,<span class="hljs-string">"teacher"</span>,id);

    XContentBuilder xContentBuilder = XContentFactory.jsonBuilder()
                .startObject()
                .field(<span class="hljs-string">"name"</span>,name)
                .field(<span class="hljs-string">"gender"</span>,gender)
                .endObject();

    updateRequest.doc(xContentBuilder);

    UpdateResponse result = client.update(updateRequest,RequestOptions.DEFAULT);

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity(result.getId(),HttpStatus.OK);
&#125;</code></pre>

<p><img src="./Image-sb70.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>删除；</p>
<pre><code class="hljs java"><span class="hljs-meta">@DeleteMapping</span>(<span class="hljs-string">"/delete/teacher"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">delete</span><span class="hljs-params">(@RequestParam(name = <span class="hljs-string">"id"</span>)</span> String id) <span class="hljs-keyword">throws</span> IOException </span>&#123;

    DeleteRequest deleteRequest = <span class="hljs-keyword">new</span> DeleteRequest(<span class="hljs-string">"user"</span>,<span class="hljs-string">"teacher"</span>,id);

    DeleteResponse deleteResponse = client.delete(deleteRequest,RequestOptions.DEFAULT);

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity(deleteResponse.status(),HttpStatus.OK);

&#125;</code></pre>

<p><img src="./Image-sb71.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-15-SpringBoot与任务"><a href="#NO2-15-SpringBoot与任务" class="headerlink" title="NO2.15 SpringBoot与任务"></a>NO2.15 SpringBoot与任务</h3><p>SpringBoot中的有异步、定时任务的配置；</p>
<ul>
<li><p>SpringBoot中的异步任务；</p>
<ul>
<li><p>同步和异步：</p>
<ul>
<li>同步：就是整个处理过程顺序执行，当各个过程都执行完毕，并返回结果；</li>
<li>异步：异步调用则是只是发送了调用的指令，调用者无需等待被调用的方法完全执行完毕，而是继续执行下面的流程；基于@Async标注的方法，称之为异步方法；这些方法将在执行的时候，将会在独立的线程中被执行，调用者无需等待它的完成，即可继续其他的操作。</li>
</ul>
</li>
<li><p>SpringBoot中的异步任务的使用：</p>
<ul>
<li><p>在SpringBoot中使用异步任务，需要先开启异步任务(使用的是Spring中自带的)，使用注解@EnableAsync表示支持异步任务，也就是开启异步任务，将该注解用在SpringBoot的启动类上就行了；SpringBoot对于异步、定时、缓存、切面等的配置都是通过在启动类上加@EnableXXX来配置的；</p>
<pre><code class="hljs java"><span class="hljs-meta">@EnableAsync</span>  <span class="hljs-comment">//表示开启异步任务</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;
    &#125;

&#125;

注意：有两种方式开启异步任务，如下所示：
一、基于Java配置的启用方式；
<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableAsync</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringAsyncConfig</span> </span>&#123; ... &#125;

二、基于XML配置文件的启用方式，配置如下；

&lt;task:executor id=<span class="hljs-string">"myexecutor"</span> pool-size=<span class="hljs-string">"5"</span>  /&gt;
&lt;task:annotation-driven executor=<span class="hljs-string">"myexecutor"</span>/&gt;</code></pre>
</li>
<li><p>需要使用异步的方法添加@Async注解，这表示该方法会异步执行，也就是说主线程会直接跳过该方法，而是使用线程池中的线程来执行该方法；@Async注解使用条件：</p>
<ul>
<li><p>@Async注解一般用在类的方法上，如果用在类上，那么这个类所有的方法都是异步执行的；</p>
</li>
<li><p>使用@Async注解的方法所在的类的对象应该是Spring容器管理的bean对象；</p>
</li>
<li><p>调用异步方法类上需要配置上注解@EnableAsync</p>
<pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.scheduling.annotation.Async;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;


<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Async</span>  <span class="hljs-comment">//用在了类上，表示该类下的所有方法都是需要异步执行的</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncTask</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">task1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();
        Thread.sleep(<span class="hljs-number">3000</span>);
        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();
        System.out.println(<span class="hljs-string">"当前线程："</span> + Thread.currentThread().getName() + <span class="hljs-string">"，"</span> + <span class="hljs-string">"任务一耗时："</span> + (end - start) + <span class="hljs-string">"ms"</span>);
    &#125;


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">task2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();
        Thread.sleep(<span class="hljs-number">3000</span>);
        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();
        System.out.println(<span class="hljs-string">"当前线程："</span> + Thread.currentThread().getName()  + <span class="hljs-string">"，"</span> + <span class="hljs-string">"任务二耗时："</span> + (end - start) + <span class="hljs-string">"ms"</span>);
    &#125;


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">task3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();
        Thread.sleep(<span class="hljs-number">3000</span>);
        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();
        System.out.println(<span class="hljs-string">"当前线程："</span> + Thread.currentThread().getName() + <span class="hljs-string">"，"</span> + <span class="hljs-string">"任务三耗时："</span> + (end - start) + <span class="hljs-string">"ms"</span>);
    &#125;
&#125;</code></pre>
</li>
</ul>
</li>
<li><p>调用异步任务，以及测试结果；</p>
<pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskService</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> AsyncTask asyncTask;

    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/taskService"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doTask</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;

        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();
        asyncTask.task1();
        asyncTask.task2();
        asyncTask.task3();
        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();
        System.out.println(<span class="hljs-string">"任务总耗时："</span> + (end - start) + <span class="hljs-string">"ms"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">"任务总耗时："</span> + (end - start) + <span class="hljs-string">"ms"</span>;
    &#125;
&#125;

拓展：SpringBoot异步任务默认使用的线程池为SimpleAsyncTaskExecutor，其特点如下：
一、默认定义多少异步任务，创建多少线程(创建线程数量太多，占用内存过大，会造成OutOfMemoryError)；
二、SimpleAsyncTaskExecutor不提供拒绝策略机制；
三、SimpleAsyncTaskExecutor可通过设置参数concurrencyLimit(值为大于或等于<span class="hljs-number">0</span>的整数)，指定启用的线程数目，默认concurrencyLimit取值为-<span class="hljs-number">1</span>，即不启用资源，目的为了节流；</code></pre>

<p><img src="./Image-sb72.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>SpringBoot中的定时任务(Spring中自带的Scheduled)；</p>
<ul>
<li><p>Scheduled只适合处理简单的计划任务，不能处理分布式计划任务；</p>
<ul>
<li>优势：是spring框架提供的计划任务，开发简单，执行效率比较高；</li>
<li>劣势：且在计划任务数量太多的时候，可能出现阻塞，崩溃，延迟启动等问题。</li>
</ul>
</li>
<li><p>基本步骤：</p>
<ul>
<li><p>要启用Scheduled定时任务，则需要在启动类上增加注解@EnableScheduling，代表启用Scheduled定时任务机制；</p>
<pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableScheduling</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppStarter</span> </span>&#123;

　　<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
　　　　SpringApplication.run(AppStarter<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;
　　&#125;
&#125;</code></pre>
</li>
<li><p>Scheduled定时任务的核心在于注解@Scheduled，这个注解的核心属性是cron，代表定时任务的触发计划表达式；这个表达式的格式为：</p>
<ul>
<li><p>第一种：@Scheduled(cron=”seconds minutes hours day month week”)；</p>
</li>
<li><p>第二种：@Scheduled(cron=”seconds minutes hours day month week year”)。推荐使用第一种表达式形式，因为在很多其他技术中都有不同的定时任务机制，其中用于设置触发计划的表达式都是第一种cron表达式，第二种表达式不能说是Spring Scheduled特有的，也是只有少数技术支持的；cron表达式解析：</p>
<p><img src="./Image-sb73.png" srcset="/img/loading.gif" alt="Image"></p>
<pre><code class="hljs java">说明：
一、符号说明
    <span class="hljs-number">1</span>.逗号(,)：表达一个列表值。如，在星期字段中使用“MON,WED,FRI”，则表示星期一，星期三和星期五；
    <span class="hljs-number">2</span>.减号(-)：表达一个范围。如，在小时字段中使用“<span class="hljs-number">10</span>-<span class="hljs-number">12</span>”，则表示从<span class="hljs-number">10</span>到<span class="hljs-number">12</span>点，即<span class="hljs-number">10</span>，<span class="hljs-number">11</span>，<span class="hljs-number">12</span>；
    <span class="hljs-number">3</span>.星号(*)：可用在所有字段中，表示对应时间域的每一个时刻。例如，*在分钟字段时，表示“每分钟”；
    <span class="hljs-number">4</span>.斜杠(/)：x/y表达一个等步长序列，x为起始值，y为增量步长值。如，在秒数字段中使用<span class="hljs-number">0</span>/<span class="hljs-number">15</span>，则表示为<span class="hljs-number">0</span>、<span class="hljs-number">15</span>、<span class="hljs-number">30</span>和<span class="hljs-number">45</span>秒，而<span class="hljs-number">5</span>/<span class="hljs-number">15</span>在分钟字段中表示<span class="hljs-number">5</span>、<span class="hljs-number">20</span>、<span class="hljs-number">35</span>、<span class="hljs-number">50</span>，你也可以使用*/y，它等同于<span class="hljs-number">0</span>/y；
    <span class="hljs-number">5</span>.问号(?)：该字符只在day和week字段中使用，它通常指定为“无意义的值”，相当于占位符。

二、特殊说明
<span class="hljs-number">1</span>.L：该字符只在day和week字段中使用，代表“Last”的意思，但它在两个字段中意思不同；L在日期字段中，表示这个月份的最后一天，如一月的<span class="hljs-number">31</span>号，非闰年二月的<span class="hljs-number">28</span>号；如果L用在星期中，则表示星期六，等同于<span class="hljs-number">7</span>；但是，如果L出现在星期字段里，而且在前面有一个数值X，则表示“这个月的最后X天”，如，<span class="hljs-number">6L</span>表示该月的最后星期五
<span class="hljs-number">2</span>.W：该字符只能出现在day字段里，是对前导日期的修饰，表示离该日期最近的工作日；如，<span class="hljs-number">15</span>W表示离该月<span class="hljs-number">15</span>号最近的工作日，如果该月<span class="hljs-number">15</span>号是星期六，则匹配<span class="hljs-number">14</span>号星期五；如果<span class="hljs-number">15</span>日是星期日，则匹配<span class="hljs-number">16</span>号星期一；如果<span class="hljs-number">15</span>号是星期二，那结果就是<span class="hljs-number">15</span>号星期二；但必须注意关联的匹配日期不能够跨月，如，你指定<span class="hljs-number">1</span>W，如果<span class="hljs-number">1</span>号是星期六，结果匹配的是<span class="hljs-number">3</span>号星期一，而非上个月最后的那天；W字符串只能指定单一日期，而不能指定日期范围
<span class="hljs-number">3</span>.LW组合：在日期字段可以组合使用LW，它的意思是当月的最后一个工作日
4.井号(#)：该字符只能在week字段中使用，表示当月的第几个周几；如，6#3表示当月的第三个星期五(6表示星期五，#3表示当前的第三个)，而4#5表示当月的第五个星期三，假设当月没有第五个星期三，忽略不触发
<span class="hljs-number">5</span>.C：该字符只在日期和星期字段中使用，代表“Calendar”的意思；它的意思是计划所关联的日期，如果日期没有被关联，则相当于日历中所有日期。例如<span class="hljs-number">5</span>C在日期字段中就相当于日历<span class="hljs-number">5</span>日以后的第一天。<span class="hljs-number">1</span>C在星期字段中相当于星期日后的第一天

三、Cron表达式对特殊字符的大小写不敏感，对代表星期的缩写英文大小写也不敏感

四、示例
每隔<span class="hljs-number">5</span>秒执行一次：*/<span class="hljs-number">5</span> * * * * ?
每隔<span class="hljs-number">1</span>分钟执行一次：<span class="hljs-number">0</span> */<span class="hljs-number">1</span> * * * ?
每天<span class="hljs-number">23</span>点执行一次：<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">23</span> * * ?
每天凌晨<span class="hljs-number">1</span>点执行一次：<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> * * ?
每月<span class="hljs-number">1</span>号凌晨<span class="hljs-number">1</span>点执行一次：<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> * ?
每月最后一天<span class="hljs-number">23</span>点执行一次：<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">23</span> L * ?
每周星期六凌晨<span class="hljs-number">1</span>点实行一次：<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> ? * L
在<span class="hljs-number">26</span>分、<span class="hljs-number">29</span>分、<span class="hljs-number">33</span>分执行一次：<span class="hljs-number">0</span> <span class="hljs-number">26</span>,<span class="hljs-number">29</span>,<span class="hljs-number">33</span> * * * ?
每天的<span class="hljs-number">0</span>点、<span class="hljs-number">13</span>点、<span class="hljs-number">18</span>点、<span class="hljs-number">21</span>点都执行一次：<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>,<span class="hljs-number">13</span>,<span class="hljs-number">18</span>,<span class="hljs-number">21</span> * * ?

如：
<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Controller</span> </span>&#123;

        <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/test"</span>)
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doTask</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;

            test2();
        &#125;


        <span class="hljs-comment">//添加定时任务，每五秒触发一次</span>
        <span class="hljs-meta">@Scheduled</span>(cron = <span class="hljs-string">"0/5 * * * * ?"</span>)
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;
            System.out.println(<span class="hljs-string">"执行静态定时任务时间: "</span> + LocalDateTime.now());
        &#125;
&#125;</code></pre>

<p><img src="./Image-sb74.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>SpringBoot中使用邮件服务；</p>
<ul>
<li><p>首先是引入邮件服务的依赖；</p>
<pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
</li>
<li><p>在邮箱中开启POP3/SMTP/IMAP服务后，点击生产一个授权码，这个授权码，等一会在配置文件中需要使用；</p>
<p><img src="./Image-sb75.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb76.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>配置application.properties；</p>
<pre><code class="hljs properties"><span class="hljs-comment">    #发件人邮箱</span>
    <span class="hljs-meta">spring.mail.username</span>=<span class="hljs-string">xxxxxxx@qq.com</span>
    
<span class="hljs-comment">    #生成的授权码，就是开启POP3/SMTP/IMAP服务后，点击生成授权码产生的一串字符，相当于我们登录邮箱使用的密码</span>
    <span class="hljs-meta">spring.mail.password</span>=<span class="hljs-string">lojwzgpnrpzmifgg</span>
    
<span class="hljs-comment">    #QQ的SMIP地址，用不同的邮箱发送，SMIP地址也会不一样</span>
    <span class="hljs-meta">spring.mail.host</span>=<span class="hljs-string">smtp.qq.com</span>
    
<span class="hljs-comment">    #配置安全连接，如果不配置，会报错</span>
<span class="hljs-meta">spring.mail.properties.mail.smtp.ssl.enable</span>=<span class="hljs-string">true</span></code></pre>
</li>
<li><p>测试发送邮件；</p>
<pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>
<span class="hljs-class">@<span class="hljs-title">SpringBootTest</span></span>
<span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">Tests</span> </span>&#123;

　　<span class="hljs-comment">//注入邮件发送器　</span>
    <span class="hljs-meta">@Autowired</span>
    JavaMailSenderImpl mailSender;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMail</span><span class="hljs-params">()</span></span>&#123;

　　　　 <span class="hljs-comment">//发送简单的邮件</span>
        SimpleMailMessage message=<span class="hljs-keyword">new</span> SimpleMailMessage();

　　　　 <span class="hljs-comment">//邮件的一些设置</span>
　　　　 <span class="hljs-comment">//标题</span>
        message.setSubject(<span class="hljs-string">"注意"</span>);

　　　　 <span class="hljs-comment">//内容</span>
        message.setText(<span class="hljs-string">"有内鬼，终止交易"</span>);

　　　　 <span class="hljs-comment">//发送人</span>
        message.setFrom(<span class="hljs-string">"xxxxx@qq.com"</span>);

　　　　 <span class="hljs-comment">//收件人</span>
        message.setTo(<span class="hljs-string">"xxxxxx@gmail.com"</span>);

        mailSender.send(message);
    &#125;
　　

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tesr01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;

　　　　 <span class="hljs-comment">//复杂邮件发送</span>
        MimeMessage mimeMessage=mailSender.createMimeMessage();

　　　　 <span class="hljs-comment">//使用helper上传文件，后面的true参数就是表示要上传文件</span>
        MimeMessageHelper helper=<span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage,<span class="hljs-keyword">true</span>);

        helper.setSubject(<span class="hljs-string">"注意"</span>);

　　　　 <span class="hljs-comment">//可以HTML样式，后面的true参数表示，我发送的这段内容是html，你要帮我解析</span>
        helper.setText(<span class="hljs-string">"&lt;b style='color:blue'&gt;有内鬼，终止交易&lt;/b&gt;"</span>,<span class="hljs-keyword">true</span>);

　　　　 <span class="hljs-comment">//上传文件，可以上传多个</span>
        helper.addAttachment(<span class="hljs-string">"1.jpg"</span>,<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\Jump\\Pictures\\1.jpg"</span>));

        helper.setFrom(<span class="hljs-string">"xxxxx@qq.com"</span>);

        helper.setTo(<span class="hljs-string">"xxxxxx@qq.com"</span>);

        mailSender.send(mimeMessage);
    &#125;
&#125;</code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-16-SpringBoot与安全"><a href="#NO2-16-SpringBoot与安全" class="headerlink" title="NO2.16 SpringBoot与安全"></a>NO2.16 SpringBoot与安全</h3><ul>
<li><p>SpringBoot中的安全机制；</p>
<ul>
<li><p>介绍：常用的安全框架，一个是Shiro，一个就是Spring Security：Shiro安全框架在另一篇笔记中有详细的介绍与使用，这里主要介绍Spring Security在SpringBoot中的使用；Spring Security是一种基于SpringAOP和Servlet过滤器的安全框架，它可以在web请求级别和方法调用级别处理身份和授权，它是基于AspectJ的切面进行配置的；</p>
</li>
<li><p>Spring Security的核心功能主要包括：认证(你是谁)、授权(你能干什么)、攻击防护(防止伪造身份)；其核心就是一组过滤器链，项目启动后将会自动配置；最核心的就是Basic Authentication Filter，是用来认证用户的身份的；<strong><code>注意：绿色的过滤器可以配置是否生效，其他的都不能控制。</code></strong></p>
<p><img src="./Image-sb77.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>SpringBoot中使用Spring Security；</p>
<ul>
<li><p>创建基于SpringBoot的Maven工程后，引入Spring Security；</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
</li>
<li><p>使用类来配置最简单的安全性配置，所以我们需要编写一个配置类；当我们需要指定Web的安全细节，则需要重写WebSecurityConfigurationAdapter的一些方法。<code>如，configure方法，其中configure(WebSecurity)配置Security的filter链、configure(HttpSecurity)配置哪些请求需要验证，哪些请求不需要验证，以及需要的权限、configure(AuthenticationManagerBuilder)配置user-detail服务</code>；</p>
<pre><code class="hljs java"><span class="hljs-meta">@EnableWebSecurity</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;  
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <span class="hljs-comment">//该方法用来配置登录验证的逻辑，简单地说，就是哪些请求你要拦截，哪些请求不拦截</span>
        http.authorizeRequests()
                .antMatchers(<span class="hljs-string">"/"</span>, <span class="hljs-string">"/home"</span>).permitAll()  <span class="hljs-comment">//这里的“/”和“/home”路径被配置为不需要任何身份验证，所有其他路径必须经过身份验证</span>
                .anyRequest().authenticated()  <span class="hljs-comment">//其他任何请求都需要认证，也就是登录后才可以进行操作</span>
                .and()
            .formLogin()  <span class="hljs-comment">//开启自动配置的登录功能，即如果没有登录、没有权限时就会来到登录页面</span>
                .loginPage(<span class="hljs-string">"/aaa"</span>).permitAll()  <span class="hljs-comment">//用户未登录时，访问任何资源都转跳到该路径，即自定义的登录页面“/aaa”，且访问登录页面时不需要验证，否则就会死循环</span>
                .and()
            .logout().logoutSuccessUrl(<span class="hljs-string">"xxx"</span>);  <span class="hljs-comment">//开启自动配置的注销功能，访问“/logout”，表示用户注销，即清空Session，后面的logoutSuccessUrl()则表示，退出后，跳转到那个页面去</span>

            .rememberMe();  <span class="hljs-comment">//开启记住我功能，其原理其实就是服务端根据来访的客户端，分别给它们创建一个SessionID，</span>
    &#125;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureGlobal</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        auth
            .inMemoryAuthentication()
                .withUser(<span class="hljs-string">"user"</span>).password(<span class="hljs-string">"password"</span>).roles(<span class="hljs-string">"USER"</span>);  <span class="hljs-comment">//将单个用户设置在内存中，该用户的用户名为“user”，密码为“password”，角色为“USER”</span>
    &#125;
&#125;

说明：
一、<span class="hljs-meta">@EnableWebSecurity</span>注解，用在实现了接口WebSecurityConfigurer或者继承自WebSecurityConfigurerAdapter的Web安全配置类上，该注解有两个作用，一是加载了WebSecurityConfiguration配置类，配置安全认证策略；二是加载了AuthenticationConfiguration，配置了认证信息；说白了，就是启用Web安全，也就是启用了Spring Security

二、上面需要注意的是.loginPage(<span class="hljs-string">"/aaa"</span>)方法中，表示的是跳转到自定义的登录页面去，但是，如果要发登录请求，会默认以post形式访问“/aaa”这个url进行登录验证，也就是说，在前端的登录页面中，提交登录请求的url也要写成“/aaa”，只不过提交方法变成了post形式而已；如果你想自定义登录验证的url，也就是你来指定让登录请求去访问哪个接口，还可以使用方法loginProcessingUrl(<span class="hljs-string">"xxx"</span>)；并且在这里还可以设置两个方法，也就是usernameParameter(<span class="hljs-string">"xxx"</span>)和passwordParameter(<span class="hljs-string">"xxx"</span>)，指定提交过来的账号和密码是两个什么样的参数名；</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>JSR303校验：</p>
<ul>
<li><p>定义：JSR是Java Specification Requests的缩写，意思是Java规范提案，是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。任何人都可以提交JSR，以向Java平台增添新的API和服务；JSR已成为Java界的一个重要标准；</p>
<p><img src="./Image-sb10.png" srcset="/img/loading.gif" alt="Image"></p>
<p><img src="./Image-sb11.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;

    <span class="hljs-meta">@Email</span>  <span class="hljs-comment">//这个就是JSR303校验所使用的注释，被标注的元素必须是电子邮箱格式，否则会抛出异常</span>
    <span class="hljs-meta">@value</span>(<span class="hljs-string">"dyf"</span>)
    <span class="hljs-keyword">private</span> String lastName;

    ....get、set、toString方法.... 
&#125;</code></pre>

</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>SpringBoot与hibernate-validator参数校验；</p>
<ul>
<li><p>SpringBoot默认集成了hibernate-validator，因为在Web依赖中就已经包含了它，且默认是生效的，可以直接使用；</p>
<ul>
<li><p>使用hibernate-validator主要分为两大步骤；</p>
<ul>
<li><p>.在对象型参数的POJO类里的属性上添加校验注解。<code>如，@NotBlank等</code>；</p>
</li>
<li><p>使用@Valid，去注解Controller方法里需要校验的对象型参数；</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    
    <span class="hljs-meta">@NotBlank</span>(message=<span class="hljs-string">"用户名不允许为空！"</span>)
    <span class="hljs-keyword">private</span> String username;

    <span class="hljs-meta">@NotBlank</span>(message=<span class="hljs-string">"密码不允许为空！"</span>)
    <span class="hljs-keyword">private</span> String password;

    <span class="hljs-meta">@NotNull</span>
    <span class="hljs-meta">@Range</span>(min=<span class="hljs-number">0</span>,max=<span class="hljs-number">120</span>)
    <span class="hljs-keyword">private</span> Integer age;

    <span class="hljs-comment">//下面是对应的get()和set()方法...</span>
&#125;


<span class="hljs-comment">//------------------------------------------------------------------------</span>


<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/insertUser"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">insertUser</span><span class="hljs-params">(@Valid User user)</span> </span>&#123;
    System.out.println(user);
    <span class="hljs-keyword">return</span> <span class="hljs-string">"ok"</span>;
&#125;

注意：在JavaBean中的对应的属性上添加校验的注解类型即可，如上所示；在Controller里自定义处理参数的对应方法声明上，要添加一个<span class="hljs-meta">@Valid</span>注解，即开启该对象的字段校验</code></pre>
</li>
</ul>
</li>
<li><p>当校验出现不符合规则的数据时，需要一个对象去收集错误信息，并作出相应的提示信息，这个对象就是BindingResult；</p>
<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/insertUser"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">insertUser</span><span class="hljs-params">(@Valid User user, BindingResult result)</span> </span>&#123;

    <span class="hljs-comment">//判断收集错误信息的对象是否有接收到异常信息</span>
    <span class="hljs-keyword">if</span>(result.hasErrors()) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"insertUserPage"</span>;
    &#125;

    <span class="hljs-keyword">return</span> <span class="hljs-string">"ok"</span>;
&#125;


说明：
一、<span class="hljs-meta">@Validated</span>：是Spring validator里的注解，可以用在类型、方法和方法参数上，但是不能用在成员属性上；<span class="hljs-meta">@Valid</span>：是Hibernate validation里的注解，可以用在方法、构造函数、方法参数和成员属性上；这两者并没有使用上的差别
      
(<span class="hljs-number">2</span>).BindingResult，就是获取校验信息的对象，如果没有写这个对象的话，一旦校验出有数据是有问题的，那么服务器会直接抛异常MethodArgumentNotValidException，写上该对象的话则会将错误信息收集，然后交给调用者自己处理；hasErrors()方法就是判断是否有校验出错的信息；当某个字段出现不符合校验规则的情况时，会创建一个与该字段名称一样的同名属性伪变量，并将错误信息作为值，存储到伪变量中；然后，ModelAndView会创建一个与被校验的对象一模一样的同名伪对象，存入Attribute中，传到前端并展示；以上所述：即当被校验的user对象中的name属性不符合校验规则时，会创建一个同名的name变量，错误信息作为值，再创建一个与被校验的对象一模一样的伪对象user，将name属性存入user中，用于在前端展示</code></pre>
</li>
<li><p>前端使用th:errors进行获取错误的校验信息即可；</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">"@&#123;/insertUser&#125;"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>
          用户名：
          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"red"</span> <span class="hljs-attr">th:errors</span>=<span class="hljs-string">"$&#123;user.username&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span>

        

         
          密码：
          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"red"</span> <span class="hljs-attr">th:errors</span>=<span class="hljs-string">"$&#123;user.password&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span>

          

         
          年龄：
          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"red"</span> <span class="hljs-attr">th:errors</span>=<span class="hljs-string">"$&#123;user.age&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span>

          

         
          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"保存"</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>

注意：th:errors="$&#123;user.username&#125;"中的user并不是被校验的user对象，而是由于本体user对象属性校验出错，ModelAndView重新创建的一个与被校验的对象同名的伪对象；同理，username也不是本体user的username属性，而是用来存储校验错误信息的伪同名属性，将该伪同名属性存入上面的伪对象中，用于在前端反馈错误信息；但是，当第一次访问页面时，并没有user对象，因为没有产生校验的错误信息，也就获取不到相应的各种校验错误的信息；针对这种情况，可以按照下面的方式解决；

      @RequestMapping("/insertUserPage")
      public String insertUserPage(User user) &#123;
          return "insertUserPage";
      &#125;

在跳转页面后，一定要注入一个User user，因为当出现不符合校验规则的情况出现时，需要一个伪对象user去获取错误信息并展示出来，在跳转页面时，如果没有注入一个User user，则会出现异常，因为Attribute中并没有user这个对象，也就无法获取对应的校验属性的信息</code></pre>
</li>
<li><p>hibernate-validator中常用的校验注解；</p>
<p><img src="./Image-sb78.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>区分@NotNull，@NotEmpty，@NotBlank，3个注解的区别；</p>
<ul>
<li>@NotNull：不能为null，但可以为空格字符串和empty(即可以是空字符串)；</li>
<li>@NotEmpty：不能为null、空字符串，而且长度必须大于0，但可以是空格符串；</li>
<li>@NotBlank：只能用于字符串，不能为null，并且字符串trim()以后length要大于0，即不允许空字符串和空格字符串；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/1-%EB%8C%80%ED%95%99%EA%B5%90-%EC%9D%BC-%ED%95%99%EB%85%84/">1.대학교 일 학년</a>
                    
                      <a class="hover-with-bg" href="/categories/1-%EB%8C%80%ED%95%99%EA%B5%90-%EC%9D%BC-%ED%95%99%EB%85%84/03-Java/">03.Java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%A4%A7%E4%B8%80%E8%AF%BE%E7%A8%8B/">大一课程</a>
                    
                      <a class="hover-with-bg" href="/tags/SpringBoot/">SpringBoot</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/07/09/MySql--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">02.MySql--学习笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/07/03/SSM%E6%A1%86%E6%9E%B6--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                        <span class="hidden-mobile">03.SSM框架--学习笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "04.SpringBoot--学习笔记&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
