<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="o一行瑠璃o">
  <meta name="keywords" content="学习笔记,Java,C">
  <title>Docker--学习笔记 - 知晓天空之蓝的人啊</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Hello World</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                目录
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/indexbg/sun.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-06-28 10:51">
      2020年6月28日 上午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.8k 字
    </span>
  

  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：2020年6月28日 上午
                
              </p>
            
            <article class="markdown-body">
              <h1 id="Docker–学习笔记-包含Docker视频"><a href="#Docker–学习笔记-包含Docker视频" class="headerlink" title="Docker–学习笔记(包含Docker视频)"></a>Docker–学习笔记(包含Docker视频)</h1><h2 id="Lesson1-Docker概述"><a href="#Lesson1-Docker概述" class="headerlink" title="Lesson1 Docker概述"></a>Lesson1 Docker概述</h2><h3 id="NO1-1-Docker简介"><a href="#NO1-1-Docker简介" class="headerlink" title="NO1.1 Docker简介"></a>NO1.1 Docker简介</h3><p>Docker是一个开源的应用容器平台，通俗的讲Docker就如同它的那个鲸鱼Logo一样，只要下载了Docker这个容器平台，那么那些打包好了的“集装箱”就能在安装了Docker的电脑上使用。</p>
<ul>
<li>Docker：<ul>
<li>出现原因：软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在哪些机器上跑起来？用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。所以说，环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。由此，虚拟技术应运而生，先是LXC容器技术，然后再是Docker；</li>
<li>背景介绍：Docker是一个开源项目，诞生于2013年初，最初是dotCloud公司内部的一个业余项目，基于Google公司的Go语言实现，项目后来加入Linux基金会，遵从Apache2.0协议，项目代码在Github上维护；</li>
<li>定义：Docker是一个开源的应用容器引擎，通俗的讲Docker就如同它的那个鲸鱼Logo一样，只要下载了Docker这个容器引擎，那么那些打包好了的“集装箱”就能在安装了Docker的电脑上使用；</li>
<li>目标：实现轻量级的操作系统虚拟化解决方案。Docker的基础是Linux容器(Linux Containers，缩写为LXC)等技术，在LXC基础上Docker做了进一步的封装，让用户不需要关心容器的管理，使得操作更为简便。用户操作Docker容器就像操作一个快速轻量级的虚拟机一样简单；</li>
<li>作用：<ul>
<li>提供一次性的环境。<code>如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境</code>；</li>
<li>提供弹性的云服务。因为Docker容器可以随开随关，很适合动态扩容和缩容；</li>
<li>组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>Docker和虚拟机的区别：<ul>
<li>表面区别：<ul>
<li>内存占用：容器占用体积小，虚拟机占用体积大；</li>
<li>隔离性：容器提供了基于进程的隔离，而虚拟机提供了资源的完全隔离；</li>
<li>启动速度：虚拟机可能需要一分钟来启动，而容器只需要一秒钟或更短；</li>
<li>容器使用宿主操作系统的内核，而虚拟机使用独立的内核。Docker的局限性之一是，它只能用在64位的操作系统上。</li>
</ul>
</li>
<li>本质区别：<ul>
<li>容器是被隔离的进程。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO1-2-Docker三大核心组件"><a href="#NO1-2-Docker三大核心组件" class="headerlink" title="NO1.2 Docker三大核心组件"></a>NO1.2 Docker三大核心组件</h3><p>Docker的核心组件有三个。</p>
<ul>
<li>Docker核心组件：<ul>
<li>Docker仓库(registeries)：用来保存镜像的仓库。Docker仓库分为公开仓库和私有仓库；最大的公开仓库是Docker Hub，但是这个太慢，所以一般用的都是阿里云或网易云的镜像公开仓库；</li>
<li>Docker镜像(images)：就是一个只读的模板。镜像可以用来创建Docker容器，一个镜像可以创建多个容器；就跟Java的类一样，一个类可以创建出许多个对象一样；</li>
<li>Docker容器(containers)：就是Docker镜像运行的一个或多个实例。</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO1-3-Docker架构"><a href="#NO1-3-Docker架构" class="headerlink" title="NO1.3 Docker架构"></a>NO1.3 Docker架构</h3><p>Docker使用C/S架构，Client通过接口与Server进程通信实现容器的构建，运行和发布。</p>
<p><img src="./Image-do1.png" srcset="/img/loading.gif" alt="Image"></p>
<p>&nbsp;</p>
<ul>
<li><p>Docker架构包括三个部分：</p>
<ul>
<li><p>Host(Docker 宿主机)：即安装了Docker程序，并运行了Docker daemon的主机。包括：</p>
<ul>
<li>Docker daemon(Docker 守护进程)：运行在宿主机上，Docker守护进程，用户通过Docker client(Docker命令)与Docker daemon进行交互；</li>
<li>Images(镜像)：将软件和软件运行所需要的环境打包好的模板，用来创建容器的，一个镜像可以创建多个容器；</li>
<li>Containers(容器)：Docker的运行组件，启动一个镜像就是一个容器，容器与容器之间相互隔离，并且互不影响；简单讲容器其实就相当于一个超迷你型的CentOS，里面安装了你想要使用的软件和运行软件的环境，只不过这个CentOS没有那么多东西，所以轻量便捷。</li>
</ul>
</li>
<li><p>Docker Client(Docker 客户端)：Docker命令行工具，用户使用Docker Clients与Docker daemon进行通信并返回结果给用户。也可以使用其他工具通过Docker Api与Docker daemon通信。</p>
</li>
<li><p>Registry(仓库服务注册器)：经常会和仓库(Repository)混为一谈，实际上Registry上可以有多个仓库，每个仓库可以看成是一个用户， 一个用户的仓库放了多个镜像。仓库分为了公开仓库(Public Repository)和私有仓库(Private Repository)，最大的公开仓库是官方的Docker Hub，国内也有如阿里云、时速云等，可以给国内用户提供稳定快速的服务。用户也可以在本地网络内创建一个私有仓库。当用户创建了自己的镜像之后就可以使用push命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上pull下来就可以了。</p>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO1-4-Docker安装"><a href="#NO1-4-Docker安装" class="headerlink" title="NO1.4 Docker安装"></a>NO1.4 Docker安装</h3><p>要想使用Docker，必须先安装Docker，但是Docker只支持CentOS6.5以上的版本，因为我这里安装的是CentOS7.x，所以只以这个版本为例。</p>
<ul>
<li><p>CentOS7.x的安装：</p>
<ul>
<li><p>首先，要安装Docker的一些依赖包(如果已经安装了的，会自动更新到最新)：</p>
<ul>
<li>安装命令：<ul>
<li><code>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code>，其中sudo是指允许已验证的用户以其他用户的身份来运行命令，简单讲就是提升权限的意思。然而，大部分时候我们用它来以提升的权限来运行命令。如果已经在root用户下就可以不用加sudo；</li>
<li><code>yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code>，设置阿里云镜像，意思就是从阿里云的服务器下载docker等一些需要的安装包。</li>
</ul>
</li>
</ul>
</li>
<li><p>依赖包安装完毕后，就可以安装Docker了：</p>
<ul>
<li><p>安装命令：</p>
<ul>
<li><p><code>sudo yum install docker-ce</code>，这是安装docker的命令；</p>
</li>
<li><p><code>docker version</code>，出现如图1.4.1docker版本信息，说明就安装成功了。</p>
<p>  <img src="./Image-do2.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <code>图1.4.1</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO1-5-Docker启动"><a href="#NO1-5-Docker启动" class="headerlink" title="NO1.5 Docker启动"></a>NO1.5 Docker启动</h3><p>安装完成了Docker，现在就可以启动Dicker服务了。</p>
<ul>
<li>安装完Docker之后，启动Docker：<ul>
<li>启动命令：<ul>
<li><code>sudo systemctl enable docker</code>，这是开机自启的命令；</li>
<li><code>sudo systemctl start docker</code>，这是启动docker服务。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>安装好Docker以后，我们就可以从Docker Hub上下载镜像到本地，然后运行镜像，生成容器了，但是连接到国外的网址会很慢很慢，所以就需要配置连接到阿里云或网易云的镜像仓库(阿里云或网易云的的镜像仓库都是从国外整个搬运的)；找到Linux中的/etc/docker，如果没有docker目录，创建即可，然后再在该目录下创建daemon.json文件并进行配置，镜像加速配置如下：</p>
<p>例如：</p>
<pre><code class="hljs java"><span class="hljs-comment">//加速器地址：阿里云控制台搜索容器镜像服务，进入容器镜像服务，左侧最下方容器镜像服务中复制加速器地址</span>
&#123;
  <span class="hljs-string">"registry-mirrors"</span>: [<span class="hljs-string">"你的加速器地址"</span>]
&#125;

<span class="hljs-comment">//然后使用命令，并在文件中输入上面的加速器地址即可</span>
vim /etc/docker/daemon.json  <span class="hljs-comment">//创建并编辑darmon.json文件</span>

<span class="hljs-comment">//重新加载darmon进程，然后重启docker</span>
sudo systemctl daemon-reload
sudo systemctl restart docker

<span class="hljs-comment">//查看重启后的docker服务是否成功配置了镜像加速配置</span>

如：
vim /etc/docker/daemon.json

&#123;
  <span class="hljs-string">"registry-mirrors"</span>: [<span class="hljs-string">"https://mcokls22.mirror.aliyuncs.com"</span>]
&#125;

sudo systemctl daemon-reload
sudo systemctl restart docker</code></pre>

</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>检查自己配置的镜像加速配置是否生效。</p>
<ul>
<li><p>输入命令：</p>
<ul>
<li><p><code>docker info</code>，找到如图1.4.2，与你之前配置的镜像加速代码是否一致，一致说明镜像加速配置是生效的。</p>
<p><img src="./Image-do3.png" srcset="/img/loading.gif" alt="Image"></p>
<p><code>图1.4.2</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>使用拉取命令测试docker是否能够使用：</p>
<ul>
<li><p>输入命令：</p>
<ul>
<li><p><code>docker run hello-world</code>，出现如图1.4.3就表示docker能够成功拉取镜像，并生成容器使用了。</p>
<p><img src="./Image-do4.png" srcset="/img/loading.gif" alt="Image"></p>
<p><code>图1.4.3</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr>
<h2 id="Lesson2-Docker基础"><a href="#Lesson2-Docker基础" class="headerlink" title="Lesson2 Docker基础"></a>Lesson2 Docker基础</h2><h3 id="NO2-1-Docker常用命令"><a href="#NO2-1-Docker常用命令" class="headerlink" title="NO2.1 Docker常用命令"></a>NO2.1 Docker常用命令</h3><p>我们使用Docker Client来与安装了Docker的主机进行交互。</p>
<ul>
<li>帮助命令：<ul>
<li><code>docker version</code>：查看docker容器平台的版本；</li>
<li><code>docker info</code>：查看docker容器平台信息：；</li>
<li><code>docker --help</code>：查看docker容器帮助。</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>镜像命令：</p>
<ul>
<li><p>镜像构建：</p>
<ul>
<li><code>docker build [选项] .</code>：构建一个镜像。选项如下；<strong><code>注意：构建镜像的格式最后面有个“ .”，即一个空格和一个点。</code></strong><ul>
<li><code>-f</code>：指定要使用的Dockerfile文件的路径；</li>
<li><code>-t</code>：镜像的名称；</li>
<li><code>-tag</code>：镜像的版本号。</li>
</ul>
</li>
</ul>
</li>
<li><p>镜像查看：</p>
<ul>
<li><p><code>docker images [选项]</code>：列出本地的所有镜像。选项如下：</p>
<ul>
<li><p><code>-a</code>：列出本地所以镜像，包含中间映像层；</p>
</li>
<li><p><code>-q</code>：只显示本地所有镜像的ID；</p>
</li>
<li><p><code>-qa</code>：显示本地所有的包含中间映像层的镜像的ID；</p>
</li>
<li><p><code>-digests</code>：显示本地所有镜像的摘要信息(包含DIGEST列，只是多了这一个列，和-a功能差不多)；</p>
</li>
<li><p><code>-no-trunc</code>：显示本地所有镜像的完整信息(其实就是镜像ID列的完整展示)；</p>
<p>  <img src="./Image-do5.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>镜像搜索：</p>
<ul>
<li><p><code>docker search [选项] 镜像名</code>：在仓库中查找指定名称的镜像。选项如下：</p>
<ul>
<li><p><code>--filter=stars=数值</code>：查找并列出“stars数 &gt;= 数值”的镜像；</p>
</li>
<li><p><code>--no-trunc</code>：显示要查找的镜像中其完整描述，就是DESCRIPTION列的完整显示；</p>
</li>
<li><p><code>--automated</code>：只列出AUTOMATED=OK的镜像。</p>
<p>  <img src="./Image-do6.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>镜像下载：</p>
<ul>
<li><code>docker pull 镜像名</code>：下载指定名称的镜像。如果不指定镜像的版本，则默认下载latest版本。即最新版本；</li>
</ul>
</li>
<li><p>镜像删除：</p>
<ul>
<li><code>docker rmi [选项] 镜像名/镜像ID</code>：删除指定名称或镜像ID的镜像。如果不指定镜像的版本，则默认删除latest版本。选项如下：<ul>
<li>-f：表示强制删除(因为删除时，该镜像可能有正在运行的容器)；</li>
<li>镜像名 空格 镜像名：表示删除多个指定的镜像。如，docker rmi aaa bbb ccc，就表示删除了aaa、bbb、ccc三个镜像，且都是latest版本；</li>
<li>&amp;(docker images -qa)：删除本地所有的镜像，因为docker images -qa命令就是获得所有的镜像的ID，再加上前面的删除命令，就是删除所有镜像的命令了。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>容器命令：</p>
<ul>
<li><p>容器启动：</p>
<ul>
<li><p><code>docker run [选项] 镜像名</code>：根据指定名称的镜像创建一个容器并运行该容器，该方式也是进入容器的方式。选项如下：</p>
<ul>
<li><p><code>-i</code>：以交互模式运行容器，通常与-t一起使用；如，我新建并运行了一个MySQL容器，那么我要肯定要进入这个MySQL容器去进行操作，而-i和-t则分别提供了可以交互的功能和我能够给这个MySQL下命令的终端功能；</p>
</li>
<li><p><code>-d</code>：以守护方式启动容器，就是以后台方式运行；</p>
</li>
<li><p><code>-t</code>：为容器重新分配一个伪输入终端，通常与-i一起使用；</p>
</li>
<li><p><code>--name</code>：为容器指定一个名称，相当于取个别名，方便辨认；如果没有添加该选项，则系统会为容器随机取一个名称；</p>
</li>
<li><p><code>-p 外部主机端口:docker容器端口</code>：将外部主机端口映射到docker容器的端口，这样外部就可以访问docker中的容器了；</p>
</li>
<li><p><code>-P 随机分配端口</code>：此时Docker会随机映射一个49000~49900的端口到内部容器开放的网络端口。</p>
<p>  <img src="./Image-do7.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>容器查看：</p>
<ul>
<li><p><code>docker ps [选项]</code>：查看当前正在运行的容器。选项如下：</p>
<ul>
<li><p><code>-q</code>：查看正在运行的容器的ID；</p>
</li>
<li><p><code>-a</code>：查看当前正在运行的、以及历史运行过的容器；</p>
</li>
<li><p><code>-s</code>：显示运行容器总文件大小；</p>
</li>
<li><p><code>--no-trunc</code>：表示显示完整的信息；</p>
</li>
<li><p><code>-l</code>：显示最近创建的一个容器，无论是否运行；</p>
</li>
<li><p><code>-n 数值</code>：显示最近创建的“数值”个容器，无论是否运行。如，-n 3，表示显示最近创建的3个容器。</p>
<p>  <img src="./Image-do8.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>容器的进入与退出：</p>
<ul>
<li>进入容器：<ul>
<li><code>docker run [选项] 镜像名</code>：创建容器，并首次进入容器；</li>
<li><code>docker attach 容器ID/容器别名</code>：进入容器后，退出来，不关闭容器，后面再进入容器进行其他操作。但如果当多个窗口同时使用该命令进入该容器时，所有的窗口都会同步显示。如果有一个窗口阻塞了，那么其他窗口也无法再进行操作，该命令不太适合于生产环境，平时自己开发应用时可以使用该命令；</li>
<li><code>docker exec -it 容器ID/容器别名 /bin/bash</code>：不进入容器，但是希望执行某些操作，且结果返回当前终端。选项如下：<ul>
<li><code>-i</code>：即使没有附加也保持STDIN打开，一般-it一起使用，相当于进入该容器的shell环境进行操作；</li>
<li><code>-t</code>：分配一个伪终端；</li>
<li><code>-d</code>：以分离模式在容器中执行命令，程序后台运行，结果不会反馈到当前终端。</li>
</ul>
</li>
</ul>
</li>
<li>退出容器：<ul>
<li><code>exit</code>：在容器中，直接输入该命令，不仅退出容器，还关闭了容器；</li>
<li><code>Ctrl + P + Q</code>：在容器中，按该快捷键，只退出容器，不关闭容器。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>docker start/restart 容器ID/容器别名....</code>：启动/重启一个或多个容器；</p>
</li>
<li><p>容器的停止与删除：</p>
<ul>
<li>停止容器：<ul>
<li><code>docker stop 容器ID或别名</code>：停止一个运行中的容器(正常关闭)；</li>
<li><code>docker kill 容器ID或别名</code>：停止一个运行中的容器(强制关闭)。</li>
</ul>
</li>
<li>删除容器：<ul>
<li><code>docker rm 容器ID或别名</code>：删除一个已停止的容器；</li>
<li><code>docker rm -f 容器ID或别名</code>：删除一个运行中的容器；</li>
<li><code>docker rm -f $(docker ps -a -q)或者docker ps -a -q | xargs docker rm</code>：删除多个容器。</li>
</ul>
</li>
</ul>
</li>
<li><p>容器日志：</p>
<ul>
<li><code>docker logs [选项] 容器ID/容器别名</code>：查看容器日志；选项如下：<ul>
<li><code>-f</code>：实时跟踪日志输出；</li>
<li><code>-t</code>：显示时间戳，就是什么时间做了什么操作；</li>
<li><code>--tail=n</code>：仅列出最新n条容器日志；</li>
<li><code>--since</code>：从某段时间之后开始的日志。</li>
</ul>
</li>
</ul>
</li>
<li><p>容器进程：</p>
<ul>
<li><code>docker top 容器ID/容器别名</code>：查看容器进程信息。</li>
</ul>
</li>
<li><p>容器内部细节：</p>
<ul>
<li><code>docker inspect 容器ID/容器别名</code>：以JSOM串的形式查看容器内部细节。</li>
</ul>
</li>
<li><p>容器数据拷贝：</p>
<ul>
<li><code>docker cp 容器ID/容器别名:容器中的文件路径 宿主机的存放路径</code>：从容器中拷贝数据到宿主机。</li>
</ul>
</li>
<li><p>从容器创建一个新的镜像：</p>
<ul>
<li><code>docker commit [选项] 容器ID/容器名 命名空间:版本号</code>：将当前正在运行的容器，经过修改后，可以得到一个根据你要求修改的容器，然后可以把该容器作为一个镜像进行提交。选项如下：<ul>
<li><code>-a</code>：提交的镜像的作者；</li>
<li><code>-c</code>：使用Dockerfile指令来创建镜像；</li>
<li><code>-m</code>：提交镜像时的说明文字；</li>
<li><code>-p</code>：在commit时，将容器暂停。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-2-Docker镜像原理"><a href="#NO2-2-Docker镜像原理" class="headerlink" title="NO2.2 Docker镜像原理"></a>NO2.2 Docker镜像原理</h3><p>有想过镜像到底是一个什么东西吗？</p>
<ul>
<li>镜像是什么？我们说镜像其实是将软件和软件运行所需的各种环境都打包了的独立软件包，但在底层，镜像是一个UnionFS(联合文件系统)，也就是说，根据一个基础镜像，然后每一次对基础镜像的修改都会叠加。</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-3-Docker容器数据卷"><a href="#NO2-3-Docker容器数据卷" class="headerlink" title="NO2.3  Docker容器数据卷"></a>NO2.3  Docker容器数据卷</h3><p>容器数据卷，说白了，就是用来持久化保存容器产生的数据而使用的这么个东西。</p>
<ul>
<li><p>容器数据卷：</p>
<ul>
<li><p>定义：用来保存容器所产生的的数据，但又独立于容器之外的这么一个文件或目录；</p>
</li>
<li><p>作用：</p>
<ul>
<li>保存容器中的数据；</li>
<li>容器间的数据共享。</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>数据卷可以在容器之间共享和重用数据；</li>
<li>卷的更改可以直接生效；</li>
<li>数据卷的更改不会包含在镜像的更新中；</li>
<li>数据卷的生命周期一直持续到没有容器使用它为止。</li>
</ul>
</li>
<li><p>基本语法格式：</p>
<ul>
<li><p>方式一：直接通过命令挂载。</p>
<ul>
<li><p><code>docker run -it -v 宿主机绝对路径目录:容器内目录:[权限选项] --privileged=true 镜像名</code>：将指定的宿主机路径和容器内的路径进行相关联的意思；privileged=true则表示给予权限。选项如下；</p>
<ul>
<li><code>ro</code>：表示read only。如果加了该选项，那么容器和宿主机之间相互共享的目录，容器是只可读不可以写入，而宿主机可读可写；如果没有权限选项，那么容器和宿主机之间都两边可以读写操作；</li>
</ul>
</li>
<li><p>可以使用docker inspect 容器ID/容器别名命令，查看是否挂载成功。<strong><code>注意：如果指定的目录不存在，那么系统会自动创建并挂载上；容器停止后，主机修改挂载目录中的数据，容器再次开启后，数据会同步。</code></strong></p>
<p>  <img src="./Image-do9.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
<li><p>方式二：使用DockerFile添加。</p>
<ul>
<li><p>即在自定义的目录下创建一个文件，并在文件中写入Volume指令(如下所示)：指令内容主要是在容器内部的自定义路径中创建一个或多个容器卷来与宿主机进行共享。DockerFile内容如下：</p>
  <pre><code class="hljs java">FROM  镜像名  <span class="hljs-comment">//表示该镜像基于哪个镜像</span>

VOLUME [<span class="hljs-string">"/容器卷1路径"</span>,<span class="hljs-string">"/容器卷2的路径"</span>....] --privileged=<span class="hljs-keyword">true</span>    <span class="hljs-comment">//定义匿名数据卷，后面的privileged=true，表示权限通过的意思</span>

CMD echo <span class="hljs-string">"success build"</span>  <span class="hljs-comment">//用于运行某些指令，这里是打印success build这句话</span>
CMD /bin/bash  <span class="hljs-comment">//生成一个伪终端给用户</span>

注意*：--privileged=<span class="hljs-keyword">true</span>选项，一般出现cannot open directory:Permission denied异常时(即权限不够)才使用，一般不会遇到。*</code></pre>
</li>
<li><p>构建DockerFile文件，即通过该文件生成一个镜像的意思；使用命令：<code>docker build -t 命名空间/镜像名 -f 指定的DockerFile文件的路径</code>；</p>
<p>  <img src="./Image-do10.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
<li><p>镜像生成后，只要运行该镜像并生成容器，这样容器内部指定的目录下就会生成容器卷；那么生成的容器卷和宿主机的哪个文件建立共享关联呢，可以使用<code>docker inspect 容器ID/容器别名</code>命令查看。</p>
<p>  <img src="./Image-do11.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>数据卷容器</p>
<ul>
<li><p>定义：其实就是在生成容器的时候，添加一个父容器，表示我当前生成的容器，是继承自某个容器的(其实主要是类似共享同一个数据空间)，这样就能够形成一个数据共享的空间；</p>
</li>
<li><p>基本语法格式：</p>
  <pre><code class="hljs java">docker run -it - -name 父容器名 镜像名  <span class="hljs-comment">//根据镜像生成一个容器，该镜像必须是包含了创建容器卷操作的镜像，就如同上面使用DockerFile构建容器卷一样</span>

docker run -it - -name 子容器<span class="hljs-number">1</span> --volumes -from 父容器名 镜像名
docker run -it - -name 子容器<span class="hljs-number">2</span> --volumes -from 父容器名 镜像名
....

注意：此时，已经根据同一个镜像生成了<span class="hljs-number">3</span>个容器，父容器、子容器<span class="hljs-number">1</span>、子容器<span class="hljs-number">2</span>；此时删掉父容器，子容器<span class="hljs-number">1</span>和<span class="hljs-number">2</span>，任意一个往容器卷里面修改数据，<span class="hljs-number">2</span>和<span class="hljs-number">3</span>都各自还能共享数据，同理，只要继承了任意一个该数据空间中的容器，那么都能加入到该数据空间中来，哪个容器删除，都不影响其他容器之间的数据共享，因为它们都还在同一个数据空间中，只要不是所有的容器都删除了，那么该数据空间(也就是容器卷空间)就会消失，也就是说只要还有一个容器在该数据空间中，那么该数据空间就不会消失。</code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-4-DockerFile"><a href="#NO2-4-DockerFile" class="headerlink" title="NO2.4 DockerFile"></a>NO2.4 DockerFile</h3><p>DockerFile就是一个文件，只不过该文件的作用是用来构建镜像的。</p>
<ul>
<li><p>DockerFile：</p>
<ul>
<li><p>定义：就是用来构建镜像的文件；</p>
</li>
<li><p>作用：构建镜像；</p>
</li>
<li><p>基础知识：</p>
<ul>
<li>每条保留字指令都必须为大写字母，且后面要跟至少一个参数；</li>
<li>指令按照从上到下的顺序执行；</li>
<li>#表示注释；</li>
<li>每条指令都会创建一个新的镜像层，并对镜像进行提交。</li>
</ul>
</li>
<li><p>基本语法格式：</p>
<ul>
<li><p>编写DockerFile；DockerFile中的保留字指令及其功能如下；<strong><code>注意：Docker Hub中99%的镜像都是通过base镜像(即scratch)的基础上构建出来的</code></strong>。</p>
<ul>
<li><p><code>FROM</code>：表示基础镜像，即当前要构建的镜像是基于哪个镜像；</p>
</li>
<li><p><code>MAINTRAINER</code>：镜像维护者和其邮箱地址；</p>
</li>
<li><p><code>RUN</code>：表示后面跟着的命令行命令是需要执行的；</p>
</li>
<li><p><code>EXPOSE</code>：声明一个端口号，即对外暴露的访问端口号；</p>
</li>
<li><p><code>WORKDIR</code>：指定工作目录，即该镜像生成容器后，进入容器内部时所在的初始目录；</p>
</li>
<li><p><code>ENV</code>：设置一个环境变量，即设置该变量之后，后面的指令就可以使用这个环境变量；如果想引用环境变量，使用“$环境变量名”格式即可；</p>
</li>
<li><p><code>ADD</code>：除了有复制功能之外，如果被复制的文件是gzip、bzip2以及xz的情况下，会自动复制并解压到目标路径；</p>
</li>
<li><p><code>COPY</code>：作用和ADD一致，是复制指令，就是从上下文目录中复制文件或者目录到容器里的指定路径，但仅仅只做复制操作；有两种写法：</p>
<ul>
<li>COPY src dest；</li>
<li>COPY [“src”,”dest”]。</li>
</ul>
</li>
<li><p><code>VOLUME</code>：定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到这里指的的匿名卷；</p>
</li>
<li><p><code>CMD</code>：指定容器启动时要运行的命令。可以有多个CMD命令，但是只有最后一个生效。另外CMD命令会被docker run命令中的参数所覆盖。我们常常会看到echo “xxx….”，表示输出一段话，和Java的println()功能一致；</p>
</li>
<li><p><code>ENTRYPOINT</code>：和CMD的作用相同，即执行该保留字之后命令，但是不会被docker run命令中的参数所覆盖；即该命令后面的参数会被追加到docker run命令后面去；</p>
</li>
<li><p><code>ONBUILD</code>：用于延迟构建指令。意思就是说本次构建并不执行这里的命令，只有当别的镜像继承了该镜像后，并在子镜像构建的时候，才会执行这里的命令。</p>
<p>  例如：</p>
  <pre><code class="hljs java"><span class="hljs-comment">//必须要指定基础镜像</span>
FROM xxx

<span class="hljs-comment">//维护者和维护者的邮箱信息</span>
MAINTAINER docker_user docker_user<span class="hljs-meta">@email</span>.com

<span class="hljs-comment">//镜像操作指令</span>
RUN echo <span class="hljs-string">"check success!!!"</span>

<span class="hljs-comment">//容器启动时要执行的指令</span>
CMD /usr/sbin/nginx</code></pre>
</li>
</ul>
</li>
<li><p><code>docker build -f 指定的DockerFile文件路径 -t 新镜像的名称:版本号</code>：根据DockerFile构建镜像；</p>
</li>
<li><p>运行镜像，并生成容器。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%89%A9%E5%B1%95%E8%AF%BE%E7%A8%8B/">扩展课程</a>
                    
                      <a class="hover-with-bg" href="/categories/%E6%89%A9%E5%B1%95%E8%AF%BE%E7%A8%8B/%E5%BA%94%E7%94%A8%E5%AE%B9%E5%99%A8%E5%B9%B3%E5%8F%B0/">应用容器平台</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/docker/">docker</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%BA%94%E7%94%A8%E5%AE%B9%E5%99%A8/">应用容器</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/06/26/C%E8%AF%AD%E8%A8%80--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                        <span class="hidden-mobile">C语言--学习笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <script type="text/javascript">
    function loadUtterances() {
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.defer = false
      s.setAttribute('repo', 'dyf955/dyf955.github.io');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('theme', 'github-light');
      s.setAttribute('crossorigin', 'anonymous');
      var e = document.getElementsByTagName('script')[0];
      e.parentNode.insertBefore(s, e);
    }
    createObserver(loadUtterances, 'comments')
  </script>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Docker--学习笔记&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
