<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="o一行瑠璃o">
  <meta name="keywords" content="学习笔记,Java,C">
  <title>01.C语言--学习笔记 - 知晓天空之蓝的人啊</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Hello World</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                目录
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/indexbg/sun.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-06-26 18:03">
      2020年6月26日 晚上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      23.3k 字
    </span>
  

  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="C语言–学习笔记-包含C语言视频、C-Primer-Plus书籍"><a href="#C语言–学习笔记-包含C语言视频、C-Primer-Plus书籍" class="headerlink" title="C语言–学习笔记(包含C语言视频、C Primer Plus书籍)"></a>C语言–学习笔记(包含C语言视频、C Primer Plus书籍)</h1><h2 id="Lesson1-C语言概述"><a href="#Lesson1-C语言概述" class="headerlink" title="Lesson1 C语言概述"></a>Lesson1 C语言概述</h2><h3 id="NO1-1-C语言简介"><a href="#NO1-1-C语言简介" class="headerlink" title="NO1.1 C语言简介"></a>NO1.1 C语言简介</h3><p>1972年，贝尔实验室的丹尼斯·里奇(Dennis Ritch)和肯·汤普逊(Ken Thompson)在开发UNIX操作系统时设计了C语言，而C语言是在B语言的基础上进行设计的。</p>
<ul>
<li>C语言的特点：运行的高效性(C语言程序紧凑、运行速度很快)、可移植性(移植到别的平台时，几乎不用改什么代码)、强大而灵活(如，UNIX大部分是用C写的)等等。</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>C语言的应用范围很广：游戏开发、嵌入式软件开发、操作系统等等。</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO1-2-语言标准"><a href="#NO1-2-语言标准" class="headerlink" title="NO1.2 语言标准"></a>NO1.2 语言标准</h3><p>美国国家标准协会(ANSI)于1983年组建了一个委员会，开发了一套新标准，并于1989年正式公布。</p>
<ul>
<li>ANSI C标准定义了C语言和C标准库。国际标准化组织于1990年采用了这套C标准(ISO C)。ISO C和ANSI C是完全相同的标准。ANSI/ISO标准的最终版本通常叫作C89或C90。1994年，发布了C99标准。而在2011年12月8日，发布了C11标准。</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO1-3-C语言的编程机制"><a href="#NO1-3-C语言的编程机制" class="headerlink" title="NO1.3 C语言的编程机制"></a>NO1.3 C语言的编程机制</h3><p>C编程的基本策略是：用程序把源代码文件转换为可执行文件(其中包含可直接运行的机器语言代码)。</p>
<ul>
<li><p>编程机制：</p>
<ul>
<li><p>用C语言编写程序时，编写的内容被储存在文本文件中，该文件被称为源代码文件；</p>
</li>
<li><p>编译器把源代码转换成中间代码，可因为中间文件有多种形式，我们在这里描述的是最普遍的一种形式，即把源代码转换为机器语言代码，虽然此时目标代码文件里包含了机器语言代码，但仍然不是一个完整的程序，所以还不能直接运行；</p>
</li>
<li><p>目标代码文件缺失启动代码，启动代码充当着程序和操作系统之间的接口，系统不一样，需要的启动代码也是不一样的；</p>
</li>
<li><p>目标代码还缺少库函数，几乎所有的C程序都要使用C标准库中的函数；</p>
</li>
<li><p>最后，链接器把你编写的目标代码、系统的标准启动代码和库代码这三部分合并成一个文件，即可执行文件。对于库代码，链接器只会把程序中要用到的库函数代码提取出来。</p>
<p>  <img src="./Image-c1.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO1-4-VS2019的安装和第一个C程序"><a href="#NO1-4-VS2019的安装和第一个C程序" class="headerlink" title="NO1.4 VS2019的安装和第一个C程序"></a>NO1.4 VS2019的安装和第一个C程序</h3><p>目前主流的C语言集成开发环境，有Visual Studio 2019等等，这里是从VS2019。</p>
<ul>
<li><p>我们到VS2019官网去下载最新版本的即可。<strong><code>注意：常用的注释快捷键为ctrl+k+c，取消注释的快捷键为ctrl+k+u。</code></strong></p>
<p>  <img src="./Image-c2.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <code>说明：一般，Community版本就够我们个人使用了，其他两个版本需要购买并激活才能使用。</code></p>
<p>  <img src="./Image-c3.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <code>说明：下载后，选择自己要安装的版本即可。</code></p>
<p>  <img src="./Image-c4.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <code>说明：一般选择图中的Windows平台开发和C++的桌面开发就可以了，其他的默认即可，不需要改动什么。</code></p>
<p>  <img src="./Image-c5.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <code>说明：中间的下载缓存里，那个“安装完成后保留下载缓存”选项一定要打勾，否则会出BUG。</code></p>
<p>  <img src="./Image-c6.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <code>说明：下载完成后，打开VS2019，选择创建新项目。</code></p>
<p>  <img src="./Image-c7.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <code>说明：选择Windows桌面向导。</code></p>
<p>  <img src="./Image-c8.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <code>说明：添加项目名称，以及项目的工作空间，最后点击创建。</code></p>
<p>  <img src="./Image-c9.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <code>说明：选择控制台应用程序，并勾选功空项目即可。</code></p>
<p>  <img src="./Image-c10.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <img src="./Image-c11.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <img src="./Image-c12.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <img src="./Image-c13.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <code>说明：点击工具，选择选项，分别在文本编辑器、命令窗口、输出窗口中将字体根据自己的偏好设置一下就可以了。</code></p>
<p>  <img src="./Image-c14.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <code>说明：在右侧窗口，找到源文件，右键添加，选择新建项。</code></p>
<p>  <img src="./Image-c15.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <code>说明：在弹出的对话框中，选择C++文件，在起名的时候，使用.c后缀名即可，就可以成功创建C文件了。注意：使用快捷键Ctrl+s保存文件内容，使用Ctrl+F5运行文件。</code></p>
<p>  <img src="./Image-c16.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <code>说明：如果出现错误，勾选“不再显示次对话框”，并点击否。</code></p>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>第一个简单的C程序。</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;   //#include这是预处理指令，该行告诉编译器把stdio.h中的内容都输入到该行所在的位置，相当于粘贴复制操作；所有C编译器软件都提供了stdio.h文件，该文件提供键盘输入和屏幕输出的函数(如，printf_s()函数等)，所以这个文件是标准的输入/输出头文件</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;   <span class="hljs-comment">//main函数总是第一个被调用的函数，函数是C程序的基本模块；void表示main()函数不带任何参数</span>

    <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;   <span class="hljs-comment">//声明一个变量，但是要注意变量名称不能太长，C99的标准允许使用更长的变量名，但编译器只能识别前63个字符，超出就识别不了了；变量名不能以数字开头，但可以用小写字母、大写字母、数字和下划线来命名</span>

    printf_s(<span class="hljs-string">"这是我使用VS2019创建的第一个C文件，hello world!!!!\n"</span>);   <span class="hljs-comment">//printf_s()是一个函数；“\n”表示换行的意思</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//返回值，就是将0返回给系统</span>
&#125;

<span class="hljs-comment">//----------------------------------</span>

一个简单的C语言程序基本语法格式：

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
    
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;

    语句
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="Lesson2-C语言基础"><a href="#Lesson2-C语言基础" class="headerlink" title="Lesson2 C语言基础"></a>Lesson2 C语言基础</h2><h3 id="NO2-1-转义字符"><a href="#NO2-1-转义字符" class="headerlink" title="NO2.1 转义字符"></a>NO2.1 转义字符</h3><p>转义字符一般以“\”开头，目的是为了转义“\”后面跟的符号。</p>
<ul>
<li>常用转义字符：<ul>
<li><code>\t</code>：表示水平制表，说白了就是让输出的代码有个间隔的意思。<code>如，printf_s(&quot;你\t好\t啊&quot;)，原本输出结果：你好啊；现在输出：你    好    啊，中间多了空格</code>；</li>
<li><code>\n</code>：表示换行的意思。<code>如，printf_s(&quot;你好\n啊&quot;)，原本输出：你好啊；现在输出：“你好”两个字占一行，“啊”字又占了一行</code>；</li>
<li><code>\\</code>：表示输出一个“\”。<code>如，printf_s(&quot;你好\\\啊&quot;)，原本输出：你好啊；现在输出：你好\啊</code>；</li>
<li><code>\&quot;</code>：表示输出一个“””。<code>如，printf_s(&quot;你好\&quot;啊&quot;)，原本输出：你好啊；现在输出：你好&quot;啊</code>；</li>
<li><code>\&#39;</code>：表示输出一个“’”。<code>如，printf_s(&quot;你好\\&#39;啊&quot;)，原本输出：你好啊；现在输出：你好&#39;啊</code>；</li>
<li><code>\r</code>：表示将光标移动到本行的开头。<code>如，printf_s(&quot;你好\r啊&quot;)，原本输出：你好啊；现在输出：啊好，也就是原本输出到你好，然后又回到本行开头打印”啊“，所以”啊“把”你“字覆盖了</code>。</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-2-注释、语句、表达式"><a href="#NO2-2-注释、语句、表达式" class="headerlink" title="NO2.2 注释、语句、表达式"></a>NO2.2 注释、语句、表达式</h3><p>用于解释说明代码的文字就叫做注释。注释也可以用于代码，但是注释的代码不会被编译器执行。</p>
<ul>
<li><p>注释分两种：</p>
<ul>
<li><p>单行注释：</p>
<ul>
<li>基本语法格式：<code>//需要注释的文字</code>。<code>如，//这是单行注释</code>；</li>
</ul>
</li>
<li><p>多行注释：</p>
<ul>
<li>基本语法格式：<code>/* 需要注释的文字 */</code>。<code>如，/*这里是多行注释*/</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>表达式和语句：</p>
<ul>
<li><p>表达式：由运算符和运算对象组成。运算对象可以是常量、也可以是变量；每个表达式都有一个值；最简单的表达式是一个单独的运算对象。<code>如，6、-4等等</code>；</p>
</li>
<li><p>语句：是C程序的基本构建块。一条语句相当于一条完整的指令。语句一般以分号结尾。最简单的语句是空语句：<code>;</code>，也就是一个分号。</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-number">8</span>;
<span class="hljs-number">3</span>+<span class="hljs-number">4</span>;

<span class="hljs-comment">//以上这些都是语句，但不算真正有效的语句，因为什么也没做</span></code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-3-标准库"><a href="#NO2-3-标准库" class="headerlink" title="NO2.3 标准库"></a>NO2.3 标准库</h3><p>标准库其实就是一些写好了的函数所组成的文件。</p>
<ul>
<li>C语言中常用的标准库有：<ul>
<li>&lt;asset.h&gt;：设定插入点；</li>
<li>&lt;ctype.h&gt;：字符处理；</li>
<li>&lt;errno.h&gt;：定义错误码；</li>
<li>&lt;float.h&gt;：浮点数处理；</li>
<li>&lt;limits.h&gt;：定义各种数据类型最值常量；</li>
<li>&lt;locale.h&gt;：定义本地化函数；</li>
<li>&lt;math.h&gt;：定义数学函数；</li>
<li>&lt;stdlib.h&gt;：定义杂项函数及内存分配函数；</li>
<li>&lt;stdio.h&gt;：定义输入／输出函数；</li>
<li>&lt;string.h&gt;：字符串处理；</li>
<li>&lt;time.h&gt;：定义关于时间的函数；</li>
<li>….等等。</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-4-变量和常量"><a href="#NO2-4-变量和常量" class="headerlink" title="NO2.4 变量和常量"></a>NO2.4 变量和常量</h3><p>C语言中需要用东西来承载数据。</p>
<ul>
<li><p>变量和常量：</p>
<ul>
<li><p>变量(variable)：</p>
<ul>
<li><p>定义：就是在程序运行过程中，内部存储的值，随时可以被改变的一段内存地址空间；</p>
</li>
<li><p>基本语法基本语法格式：<code>数据类型 变量名 = 数据值</code>。<strong><code>注意：变量必须先声明，再使用；在同一个程序中，变量名不允许相同，不能使用C语言的的关键字；变量名只能用字母或下划线开头，其它字母可以是字母、数组和下划线(除了下划线，不允许有其他特殊字符)。</code></strong></p>
<p>  例如：</p>
  <pre><code class="hljs c">include&lt;stdio.h&gt;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;
    ...
    <span class="hljs-keyword">int</span> num = <span class="hljs-number">8</span>;  <span class="hljs-comment">//声明一个int类型的变量num</span>

    <span class="hljs-keyword">char</span> c = <span class="hljs-string">'a'</span>;  <span class="hljs-comment">//声明一个char类型的变量c</span>

    ...
&#125;</code></pre>
</li>
</ul>
</li>
<li><p>常量(constant)：</p>
<ul>
<li><p>定义：就是在程序运行过程中，所表示的值，无法被改变的量；</p>
</li>
<li><p>基本语法基本语法格式，有两种：</p>
<ul>
<li><p>使用C预处理器声明常量(即程序在进行预编译处理时就生效)：只要在程序的顶部，添加代码：<code>#define 大写常量名 值</code>，推荐使用该方式声明常量；如果想要取消定义的常量，并重新定义常量，使用：<code>undef 大写的常量名</code>，就可以重新定义常量的值了；<strong><code>注意：定义字符常量用单引号，定义字符串常量用双引号；该方式定义常量只是简单的替换。</code></strong></p>
</li>
<li><p>使用const修饰变量(即在程序编译、运行时才生效)：<code>const 变量名 = 值</code>，一旦被第一次赋值之后，那么该变量就变为只读，不能再更改值，也就变成常量了。</p>
<p>  例如：</p>
  <pre><code class="hljs c">include&lt;stdio.h&gt;

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AGE 8  <span class="hljs-comment">//定义了一个常量AGE，值为8，这样程序中所用的同名常量都会被替换成指定的值</span></span>
    
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> AGE  <span class="hljs-comment">//取消定义AGE常量</span></span>
    
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AGE 10  <span class="hljs-comment">//重新定义AGE常量</span></span>

#define NAME 'JOHN'   //定义了一个字符常量

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  ADDRESS <span class="hljs-meta-string">"CHINA"</span>   <span class="hljs-comment">//定义了一个字符串常量</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;
    ...

	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;  <span class="hljs-comment">//使用关键字const声明int类型的常量</span>
    ...
&#125;</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>limits.h头文件中和float.h头文件中，提供了一些整数类型和浮点数类型使用的常量；(了解即可)</p>
<p>  <img src="./Image-c17.png" srcset="/img/loading.gif" alt="Image"> </p>
<p>  <img src="./Image-c18.png" srcset="/img/loading.gif" alt="Image"> </p>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>位、字节和字的关系。<ul>
<li>位(bit)：最小的存储单元，可以储存0或1；</li>
<li>字节(byte)：是常用的计算机存储单位。对于几乎所有的机器，1个字节 = 8位，即1 byte = 8 bit，这是字节的标准定义；</li>
<li>字(word)：是设计计算机时给定的自然存储单位。不同位系统中，字所占的位数也不同：<ul>
<li>在16位的系统中(比如8086微机)，1字(word) = 2字节(byte) = 16(bit)；</li>
<li>在32位的系统中(比如win32)，1字(word) = 4字节(byte) = 32(bit)；</li>
<li>在64位的系统中(比如win64)，1字(word) = 8字节(byte) = 64(bit)。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-5-数据类型"><a href="#NO2-5-数据类型" class="headerlink" title="NO2.5 数据类型"></a>NO2.5 数据类型</h3><p>C语言让程序员针对不同情况选择不同的数据类型。</p>
<ul>
<li>C语言中的数据类型主要分为以下几种：<ul>
<li>基本类型：它们是算数类型，包括整数类型和浮点类型；</li>
<li>枚举类型：它们是算数类型，被用来定义在程序中只能赋予其一定的离散整数值的变量；</li>
<li>void类型：void表明没有可用的值；</li>
<li>派生类型：包括：指针类型、数组类型、结构类型、共用体类型和函数类型。</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>整型(以32位或64位系统为标准，不含小数点和指数的数称为整数)。<strong><code>注意：signed表示有符号的类型，unsigned表示无符号类型，优先考虑使用无符号类型的数据类型；当超出了数据类型的最大值，那么重新从最小值开始计算。如，int num = 2147483647 + 1，num的结果为-2147483648，而不是2147483648，因为结果已经超出了int的最大范围，就重新回到int最小值开始算，其他数据类型也是同理。</code></strong><ul>
<li>char：1个字节，范围是0~255，很奇怪为什么char是整型的一种是吗？那是因为在ASCII码表中，所有的字符都可以转为整型，且char也可以是字符；ASCII表中，字符0对应的十进制为48，’A’为65，’a’为97；</li>
<li>unsigned char：1个字节，范围是0~255；</li>
<li>signed char：1个字节，范围是-128~127；</li>
<li>short(也叫short int、signed short、signed short int)：2个字节，范围是-32768~32767；</li>
<li>unsigned short(也叫unsigned short int)：2个字节，范围是0~65535；</li>
<li>int(也叫signed、signed int)：4个字节，范围是-2147483648~2147483647；推荐使用int；</li>
<li>unsigned int(也叫unsigned)：4个字节，范围是0~4294967295，只能用于非负值；</li>
<li>long(也叫long int、signed long、signed long int)：4个字节，范围是-2147483648~2147483647；使用后缀l或L表名是long类型，推荐使用L；</li>
<li>unsigned long(也叫unsigned long int)：4个字节，范围是0~4294967295；</li>
<li>long long(也叫long long int、signed long long、signed long long int)：8个字节，范围为-9223372036854775808~9223372036854775807；</li>
<li>unsigned long long：8个字节，范围是0~18446744073709551615。</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>浮点类型。<strong><code>注意：浮点型常量，可以没有小数点或指数部分，但是不能同时省略两者，如2e5、19.88等等；也可以没有小数部分或整数部分，但是不能同时省略两者，如，3.e16、.45e-16等等。</code></strong><ul>
<li>float：4个字节，范围是1.2E-38~3.4E+38，精度为6位小数。如，33.123456；使用f或F后缀，声明浮点型是float类型；</li>
<li>double：8个字节，范围是2.3E-308~1.7E+308，精度为15位小数。默认情况下，创建的浮点型都是double类型的；输出时，默认保留小数点后面6位；</li>
<li>long double：精度比double更高，但是C中只保证是15位小数。</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>布尔类型(<code>即C99添加的_Bool类型</code>)。<strong><code>注意：头文件&lt;stdbool.h&gt;中定义了用bool来表示C99添加的_Bool类型。</code></strong><ul>
<li>true：可用1表示true；</li>
<li>false：可用0表示false。</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>复数类型和虚数类型。<ul>
<li>复数类型：<ul>
<li>float_Complex；</li>
<li>double_Complex；</li>
<li>long double _Complex。</li>
</ul>
</li>
<li>虚数类型：<ul>
<li>float_Imaginary；</li>
<li>double_Imaginary；</li>
<li>long double _Imaginary。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-6-数据类型转换"><a href="#NO2-6-数据类型转换" class="headerlink" title="NO2.6 数据类型转换"></a>NO2.6 数据类型转换</h3><p>C语言中如果使用不同类型进行运算，会进行数据类型的转换。</p>
<ul>
<li><p>数据类型转换分为两种：</p>
<ul>
<li><p>自动类型转换：在表达式中，精度小的数据类型会被自动转为精度大的数据类型。<code>如，一般char和short都会被自动转成int</code>；</p>
<ul>
<li><p>基本语法格式：代码工具会自己识别并进行自动类转换；</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-keyword">char</span> a = <span class="hljs-string">'a'</span>;
<span class="hljs-keyword">int</span> b = a;  <span class="hljs-comment">//这里自动将char转换成了int</span></code></pre>
</li>
</ul>
</li>
<li><p>强制类型转换：即表达式中，精度大的数据类型要转为精度小的数据类型，就需要使用强制数据类型转换；</p>
<ul>
<li><p>基本语法格式：<code>(数据类型) 需要强制类型转换的值</code>。</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-keyword">long</span> a=<span class="hljs-number">100</span>;
<span class="hljs-keyword">int</span> b = (<span class="hljs-keyword">int</span>)a;  <span class="hljs-comment">//这里将long类型的变量a强制转换成了int类型的变量</span></code></pre>

<p>  <img src="./Image-c19.png" srcset="/img/loading.gif" alt="Image"><br>  <strong><code>注意：当表达式中有多个不同数据类型的操作数进行运算时，会自动转为精度最大的那个数据类型，再进行运算。</code></strong></p>
</li>
</ul>
<p>&nbsp;</p>
</li>
</ul>
</li>
<li><p>数据类型的级别从高至低依次是：long double –&gt; double –&gt; float –&gt; unsigned long long  –&gt; long long  –&gt; unsigned long  –&gt; long  –&gt; unsigned int –&gt; int。之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int。</p>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>当作为函数的参数进行传递时，char和short会被转换成int，float会被转换成double。</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-7-获取地址值：-amp-运算符"><a href="#NO2-7-获取地址值：-amp-运算符" class="headerlink" title="NO2.7 获取地址值：&amp;运算符"></a>NO2.7 获取地址值：&amp;运算符</h3><p>在C语言中，&amp;运算符有多种作用。</p>
<ul>
<li>&amp;运算符的作用：<ul>
<li>取地址：用于变量前面；<ul>
<li>基本语法基本语法格式：<code>&amp;变量名</code>。<code>如，int a，&amp;a就表示变量a在内存中的地址值</code>；</li>
</ul>
</li>
<li>与操作符：用于二进制位的与运算，两个操作数的二进制，对位都为1，则与运算的值为1，否则为0。</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-8-指针入门"><a href="#NO2-8-指针入门" class="headerlink" title="NO2.8 指针入门"></a>NO2.8 指针入门</h3><p>指针：其实就是内存地址；而指针变量，则是能够存储指针的变量，说白了指针变量存储的是地址值。</p>
<ul>
<li><p>指针变量：用来存储指针的变量。和普通变量的定义差不多，只不过要在变量名前多加一个“<code>*</code>”号即可，通常在星号和变量名之间空一格，但是星号与数据类型之间的空格可有可无。<strong><code>注意：指针变量前面的类型，跟其里面要存放的地址值所指向的数据的类型一致；如果在初始化指针变量的时候不确定值，那么可以先赋值一个NULL，赋值为NULL的指针称为空指针，NULL常量定义在&lt;stdio.h&gt;文件中：#define NULL 0。</code></strong></p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-keyword">int</span> a;
<span class="hljs-comment">//int* p = &amp;a;  //*号与数据类型的之间的空格可有可无，都可以的</span>
<span class="hljs-keyword">int</span>* p = &amp;a;  <span class="hljs-comment">//这里定义了一个int类型的指针变量p(因为里面存放的int类型的变量a的地址值)，然后将变量a的地址值赋值给了指针变量p</span></code></pre>

</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>“*”号的使用：</p>
<ul>
<li><p>放在变量前面可以声明这是一个指针变量；</p>
</li>
<li><p>“*”号还可以用在指针变量前面，将指针变量里内存地址取出来，然后将这个地址值所指向的值取出来，此时星号和指针变量之间不空格。</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;

    <span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>;  <span class="hljs-comment">//定义一个普通的变量1，是int类型的</span>

    <span class="hljs-keyword">int</span>* bz;  <span class="hljs-comment">//定义一个指针变量bz，也是int类型的，用于存储变量b内存地址</span>

    bz = &amp;b;  <span class="hljs-comment">//获取变量b的内存地址，并赋值给指针变量bz</span>

    printf_s(<span class="hljs-string">"%d\n"</span>,bz);  <span class="hljs-comment">//打印指针变量，结果为变量b的内存地址</span>

    printf_s(<span class="hljs-string">"%d"</span>, *bz);  <span class="hljs-comment">//打印解指针变量，也就是指针变量bz的值(也就是内存地址)所指向的值，结果为1</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-9-值传递和地址传递"><a href="#NO2-9-值传递和地址传递" class="headerlink" title="NO2.9 值传递和地址传递"></a>NO2.9 值传递和地址传递</h3><p>C语言中参数的传递，分为两种：一是值传递，也就是说传递的是值；二是地址传递，说白了传递的是一个地址值。</p>
<ul>
<li>值传递的数据类型有：<ul>
<li>基本数据类型：整型类型、小数类型、字符类型；</li>
<li>结构体类型(你可以理解为Java语言中的类)；</li>
<li>共用体类型。</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>地址传递的数据类型：<ul>
<li>指针；</li>
<li>数组。</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-10-运算符"><a href="#NO2-10-运算符" class="headerlink" title="NO2.10 运算符"></a>NO2.10 运算符</h3><p>C的常用运算符类型包括：算术运算符、赋值运算符、关系运算符、逻辑运算符、位运算符、三元运算符以及其他运算符等等。<strong><code>注意：运算符优先级：有括号先括号，然后正负号，之后先乘除、后加减，最后赋值；即括号&gt;正负号&gt;乘除&gt;加减&gt;赋值。</code></strong></p>
<ul>
<li>算数运算符：<ul>
<li>加法运算符：<code>+</code>；<ul>
<li>基本语法格式：<code>值 + 值</code>，这里的值可以是常量，也可以是变量。<code>如，1+1、a+1(前提这里a要记得先赋值再使用，且是数值类型)</code>；</li>
</ul>
</li>
<li>减法运算符：-；<ul>
<li>基本语法格式：<code>值 - 值</code>，这里的值可以是常量，也可以是变量。<code>如，5-3、a-1(前提这里a要记得先赋值再使用，且是数值类型)</code>；<strong><code>注意：“-”除了当作减号之外，还可以当作负号使用，如，-12、-a等等。</code></strong></li>
</ul>
</li>
<li>乘法运算符：<code>*</code>；<ul>
<li>基本语法格式：<code>值 * 值</code>，这里的值可以是常量，也可以是变量。<code>如，52、a3(前提这里a要记得先赋值再使用，且是数值类型)</code>；</li>
</ul>
</li>
<li>除法运算符：<code>/</code>；<ul>
<li>基本语法格式：<code>值 / 值</code>，这里的值可以是常量，也可以是变量。<code>如，5/2、a/3(前提这里a要记得先赋值再使用，且是数值类型)</code>；<strong><code>注意：两个操作数都是整数，则结果为整数；若有一个操作数为浮点数，则结果为浮点数。如，5/2 = 2、5.0/2 = 2.5等等。</code></strong></li>
</ul>
</li>
<li>求模运算符(也叫取余运算符)：<code>%</code>；<ul>
<li>基本语法格式：<code>值 % 值</code>，这里的值可以是常量，也可以是变量。<code>如，5%2、a%2(前提这里a要记得先赋值再使用，且是数值类型)</code>。<strong><code>注意：其实取模运算可以看做是：a % b = a - a / b  b。</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>赋值运算符：</p>
<ul>
<li><p>赋值运算符：=；这是赋值运算符，而不是等于号；</p>
<ul>
<li>基本语法格式：<code>变量名 = 值</code>。<code>如，int num = 1，表示把1赋值给num</code>；</li>
</ul>
</li>
<li><p>其他赋值运算符：<code>+=、-=、*=、/=、%=</code>。+=运算符就是将值相加后又赋值，其他运算符同理。</p>
<ul>
<li><p>基本语法格式：<code>值 +=或-=或*=或/= 值</code>。</p>
<p>  例如：</p>
  <pre><code class="hljs c">num += <span class="hljs-number">20</span> 与 num = num + <span class="hljs-number">20</span> 相同

num -= <span class="hljs-number">2</span> 与  num =  num - <span class="hljs-number">2</span> 相同

num = <span class="hljs-number">2</span> 与  num =  num  <span class="hljs-number">2</span> 相同

num /= <span class="hljs-number">2.5</span> 与  num =  num / <span class="hljs-number">2.5</span> 相同

num %= <span class="hljs-number">3</span> 与  num =  num % <span class="hljs-number">3</span> 相同</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>关系运算符(也称为比较运算符)；<strong><code>注意：C99提供了stdbool.h头文件，该头文件规定bool成为_Bool的别名，且把true和false分别定义为1和0；关系运算符常常和关系表达式一起使用，而关系表达式的值，要么为true，要么为false(即0或1，所以就有了0是false，1是true转换)。</code></strong></p>
<p>  <img src="./Image-c20.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <img src="./Image-c21.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;

    <span class="hljs-keyword">int</span> num = <span class="hljs-number">3</span>;

    <span class="hljs-keyword">while</span> (num) &#123;
        printf_s(<span class="hljs-string">"%d\n"</span>, num);
        num--;
    &#125;
&#125;

说明：只要num的值不为<span class="hljs-number">0</span>，即不为<span class="hljs-literal">false</span>，那么<span class="hljs-keyword">while</span>会一直循环，直到num的值为<span class="hljs-number">0</span>，也就是<span class="hljs-literal">false</span>。</code></pre>

</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>逻辑运算符：</p>
<ul>
<li><p>如下图所示；<strong><code>注意：!运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相同，只比圆括号的优先级低。另外iso646.h头文件中，可用英文单词代替逻辑运算符，分别是and、or、not。</code></strong></p>
<p>  <img src="./Image-c22.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <img src="./Image-c23.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <code>说明：当且仅当exp1和exp2都为真时，exp1 &amp;&amp; exp2才为真； 如果exp1或exp2为真，则exp1 || exp2为真； 如果exp1为假，则!exp1为真；如果exp1为真，则!exp1为假。</code></p>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>位运算符：</p>
<ul>
<li><p>&amp;(位与运算)、|(位或运算)、^(位异或运算)、~(按位取反运算)、&lt;&lt;(左移运算)、&gt;&gt;(右移运算)这些运算都是使用操作数的二进制补码进行运算的。</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-number">3</span>的二进制：<span class="hljs-number">0x11</span>
<span class="hljs-number">4</span>的二进制：<span class="hljs-number">0x100</span>

    <span class="hljs-number">3</span> &amp; <span class="hljs-number">4</span> (&amp;位与运算：有<span class="hljs-number">0</span>则<span class="hljs-number">0</span>，两<span class="hljs-number">1</span>为<span class="hljs-number">1</span>)：
   <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000011</span> --<span class="hljs-number">-3</span>的二进制补码
&amp;  <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000100</span> --<span class="hljs-number">-4</span>的二进制补码
-----------------------------------------
   <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> 结果为<span class="hljs-number">0</span>

    <span class="hljs-number">3</span> | <span class="hljs-number">4</span> (|位或运算：有<span class="hljs-number">1</span>则<span class="hljs-number">1</span>，两<span class="hljs-number">0</span>为<span class="hljs-number">0</span>)：
   <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000011</span> --<span class="hljs-number">-3</span>的二进制补码
|  <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000100</span> --<span class="hljs-number">-4</span>的二进制补码
-----------------------------------------
   <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000111</span> 结果为<span class="hljs-number">7</span>

    <span class="hljs-number">3</span> ^ <span class="hljs-number">4</span> (^位异或运算：相同则<span class="hljs-number">0</span>，不同则<span class="hljs-number">1</span>)：
   <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000011</span> --<span class="hljs-number">-3</span>的二进制补码
^  <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000100</span> --<span class="hljs-number">-4</span>的二进制补码
-----------------------------------------
   <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000111</span> 结果为<span class="hljs-number">7</span>

    ~ <span class="hljs-number">3</span> (~按位取反运算：<span class="hljs-number">0</span>变<span class="hljs-number">1</span>，<span class="hljs-number">1</span>变<span class="hljs-number">0</span>)：
~  <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000011</span> --<span class="hljs-number">-3</span>的二进制补码
-----------------------------------------
   <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111100</span>

补码：<span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111100</span>
反码：<span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111011</span>
原码：<span class="hljs-number">10000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000100</span> ---结果为<span class="hljs-number">-4</span>

<span class="hljs-comment">//-----------------------------------------------------------</span>

<span class="hljs-number">10</span> &lt;&lt; <span class="hljs-number">2</span> = <span class="hljs-number">40</span>
<span class="hljs-number">10</span> &gt;&gt; <span class="hljs-number">2</span> = <span class="hljs-number">2</span>
<span class="hljs-number">-1</span> &gt;&gt; <span class="hljs-number">2</span> = <span class="hljs-number">-1</span>
说明：
正数的原反补都是一样的，所以可以直接乘以或除以n个<span class="hljs-number">2</span>，即&lt;&lt;<span class="hljs-number">2</span>表示乘以两个<span class="hljs-number">2</span>，&gt;&gt;<span class="hljs-number">2</span>表示除以两个<span class="hljs-number">2</span>；也可以转成原码后进行左移或右移位数操作；负数则需要转换成补码后再进行运行，&lt;&lt;n表示二进制补码向左移动n位，位数不够的地方补<span class="hljs-number">0</span>；&gt;&gt;n则是向右移动n位，符号位补<span class="hljs-number">1</span>，其他补<span class="hljs-number">0</span>。</code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>三元运算符：</p>
<ul>
<li><p>基本语法格式：<code>判断表达式?表达式1:表达式2</code>，判断表达式如果符合条件就取表达式1，否则就取表达式2。</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-number">1</span>+<span class="hljs-number">1</span>&gt;<span class="hljs-number">3</span> ? <span class="hljs-number">1</span>:<span class="hljs-number">2</span>  <span class="hljs-comment">//结果为2</span></code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>其他运算符：</p>
<ul>
<li><p>sizeof运算符：返回一个对象或类型所占内存字节数，返回的是size_t类型(其实就是unsigned int)，即无符号整数。</p>
<ul>
<li>基本语法格式：<code>sizeof(数据类型或对象)</code>。<code>如：char ch[10]，sizeof(ch) = 10，返回的是size_t类型的值，也就是字符数组ch所占内存的字节数</code>。</li>
</ul>
</li>
<li><p>自增和自减运算符：<code>++和--</code>，作用是对自身的值进行加1或减1，分两种使用情况：</p>
<ul>
<li><p>单独使用情况下，自增或自减运算符放在值的前面或后面都一样；</p>
</li>
<li><p>与其他运算符一起使用，++a(出现在值前面)和a++(出现在值后面)，前者先自增再作运算，后者是先运算后赋值；自减和自增一样，只是不是增加而是减少。</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;
printf_s(<span class="hljs-string">"%d"</span>,a++);
printf_s(<span class="hljs-string">"%d"</span>,++a);

<span class="hljs-comment">//上面两者的效果都是一样的</span>

<span class="hljs-comment">//--------------------------------------</span>

<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (++a &lt; <span class="hljs-number">3</span>)&#123;  <span class="hljs-comment">//先自增，后与3进行比较</span>
	...
&#125;

<span class="hljs-keyword">while</span> (a++ &lt; <span class="hljs-number">3</span>)&#123;  <span class="hljs-comment">//先与3进行比较，后自增</span>
	...
&#125;</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-11-标识符"><a href="#NO2-11-标识符" class="headerlink" title="NO2.11 标识符"></a>NO2.11 标识符</h3><p>所谓标识符，可以简单理解为取名字，即给变量、函数、常量等等取的名字都成为标识符。</p>
<ul>
<li>标识符命名规则：<ul>
<li>由26个英文字母的大小写、0~9、_或$组成；</li>
<li>不可以以数字开头；</li>
<li>不可以是C语言中的关键字(即在C中有特殊含义的名称)和保留字，但能包含关键字于其中；</li>
<li>不允许包含空格；</li>
<li>区分大小写，长度无限制；</li>
<li>尽量遵循驼峰命名法。<code>如，myName、getNumOfNumber等等</code>。</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>所有宏定义(即define)、枚举常数、常量全用大写字母命名，用下划线_分割单词，且记得初始化变量后再使用。<code>如，#define AGE 8、const double FREE_MONEY = 100.1等等</code>。</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>C语言的关键字和保留字，如下图所示：</p>
<p>  <img src="./Image-c24.png" srcset="/img/loading.gif" alt="Image"><br>  <code>说明：粗斜体是C11新增的关键字。</code></p>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-12-printf-和scanf-，以及C语言的转换说明"><a href="#NO2-12-printf-和scanf-，以及C语言的转换说明" class="headerlink" title="NO2.12 printf()和scanf()，以及C语言的转换说明"></a>NO2.12 printf()和scanf()，以及C语言的转换说明</h3><p>printf()函数和scanf()函数能让用户可以与程序交流。<strong><code>注意：printf_s()和scanf_s()是printf()和scanf()的更安全的写法....微软公司整的。</code></strong></p>
<ul>
<li><p>printf_s()和scanf_s()函数，称为输入/输出函数，简称I/O函数。</p>
<ul>
<li><p>printf_s()：</p>
<ul>
<li><p>定义：该函数用于向用户输出信息；</p>
</li>
<li><p>函数的调用方式：<code>printf_s(转换说明字符串,待打印项1,待打印项2,...)</code>。<strong><code>注意：转换说明字符串中的转换说明一定要与后面的每个待打印项相匹配，否则会报错；另外printf_s()函数是有返回值的，返回值为打印的字符的个数，一般不常使用。</code></strong></p>
<p>  例如：</p>
  <pre><code class="hljs c">printf_s(<span class="hljs-string">"i am %s"</span>,<span class="hljs-string">"john"</span>)

printf_s(<span class="hljs-string">"it is %d%%"</span>,<span class="hljs-number">12</span>)  <span class="hljs-comment">//这里%d后面使用了两个%%，是因为我想输出12%，所以要使用另一个%来转义前一个%，就成了%%</span></code></pre></li>
</ul>
</li>
<li><p>scanf_s()：</p>
<ul>
<li><p>定义：该函数用于获取用户的输入；</p>
</li>
<li><p>函数的调用方式：<code>scanf_s(&quot;%用户的输入所属的数据类型&quot;,用于接收用户输入的变量名)</code>。<strong><code>注意：如果用scanf_s()读取基本变量类型的值，在变量名前要加上一个“&amp;”；如果把字符串读入到字符数组，则变量名前面不需要加“&amp;”。</code></strong></p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-keyword">char</span> arr[<span class="hljs-number">10</span>];  <span class="hljs-comment">//声明一个字符数组</span>

scanf_s(<span class="hljs-string">"%s"</span>,arr);  <span class="hljs-comment">//接收用户输入的字符串，并将该字符串放入字符数组中，C中没有用于专门接收字符串的数据类型，只能用字符数组接收</span></code></pre>


</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>转换说明：</p>
<ul>
<li><p>定义：用来说明输入输出时的基本语法格式。</p>
</li>
<li><p>转换说明的意义：把给定的值转换成某种我们要求的形式并打印出来。常用的C语言中转换说明，如下图所示；另外还可以打印八进制、十进制等等。</p>
<ul>
<li><p>变量或常量的八进制、十进制、十六进制的显示。</p>
<ul>
<li><p>以八进制显示数值：使用“%o”，如果要显示进制的标识符号的话要使用“%#o”，其实就是八进制数值前面加个标识符号0。如，0123、046等等，都是八进制数；</p>
</li>
<li><p>以十进制显示数值：使用“%d”。如，15、20等等都是十进制数，我们常用的数字就是十进制数；</p>
</li>
<li><p>以十六进制显示数值：使用“%x”，如果要显示进制的标识符号的话使用“%#x”或“%#X”，这两个前缀的区别是“0x”和“0X”，都表示十六进制。</p>
<p>  <img src="./Image-c25.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-meta">#includ <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;
    <span class="hljs-keyword">int</span> x = <span class="hljs-number">100</span>;
    printf_s(<span class="hljs-string">"dec = %d; octal = %o; hex = %x\n"</span>, x, x, x);
    printf_s(<span class="hljs-string">"dec = %d; octal = %#o; hex = %#x\n"</span>, x, x, x);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

以上输出结果为：
dec = <span class="hljs-number">100</span>; octal = <span class="hljs-number">144</span>; hex = <span class="hljs-number">64</span>
dec = <span class="hljs-number">100</span>; octal = <span class="hljs-number">0144</span>; hex = <span class="hljs-number">0x64</span></code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>使用字段宽度“*”，这个符号表示，让上下文来指定字符宽度，什么意思呢，就是让程序里的某个变量来指定字符宽度，那么啥又是字符宽度呢，说白了就是要展示给你看的字符的间隔而已。</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;

    <span class="hljs-keyword">int</span> <span class="hljs-built_in">width</span> = <span class="hljs-number">9</span>;  <span class="hljs-comment">//字段宽度我们用width来表示</span>
    <span class="hljs-keyword">int</span> res;

    scanf_s(<span class="hljs-string">"%d"</span>,&amp;res);  <span class="hljs-comment">//获取用户输入</span>

    printf_s(<span class="hljs-string">"%*d%*d"</span>,<span class="hljs-built_in">width</span>,res,<span class="hljs-built_in">width</span>,res);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

说明：%*d中，%d表示转换说明，*表示字符宽度；如果转换说明是%*d,那么参数列表中应包含*和d对应的值，而d从用户输入中获取，并赋值给了res；字段宽度，我们使用了<span class="hljs-built_in">width</span>变量的值(也就是<span class="hljs-number">9</span>)，所以输出结果：		<span class="hljs-number">1</span>		<span class="hljs-number">1</span>。</code></pre>

</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-13-C语言中的进制"><a href="#NO2-13-C语言中的进制" class="headerlink" title="NO2.13 C语言中的进制"></a>NO2.13 C语言中的进制</h3><p>C语言中常用的进制有：二进制、八进制、十进制、十六进制。</p>
<ul>
<li>进制：<ul>
<li>定义：即一个数的表示。可以有二进制、八进制、十进制、十六进制等等；</li>
<li>常用进制：<ul>
<li>二进制：由0和1组成，满2进1，C中没有能标识二进制的方法；</li>
<li>八进制：由0-7组成，满8进1，C中以数字0开头表示八进制；</li>
<li>十进制：由0-9组成，满10进；</li>
<li>十六进制：由0-7、a-f(或A-F，表示10-15)组成。C中以0x或0X开头表示十六进制。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>进制转换：</p>
<ul>
<li><p>在学习常用进制转换之前，我们先来学习一些传说中的8421码：</p>
<ul>
<li><p>8421码：表示每个二进制位上的值对应十进制中的值。其实用于二进制和十进制的快速转换。如下所示：</p>
  <pre><code class="hljs c">二进制	<span class="hljs-number">1</span>	<span class="hljs-number">1</span>	<span class="hljs-number">1</span>	<span class="hljs-number">1</span>	<span class="hljs-number">1</span>	<span class="hljs-number">1</span>	<span class="hljs-number">1</span>	<span class="hljs-number">1</span>
十进制	<span class="hljs-number">128</span>  <span class="hljs-number">64</span>  <span class="hljs-number">32</span>  <span class="hljs-number">16</span>	<span class="hljs-number">8</span>	<span class="hljs-number">4</span>	<span class="hljs-number">2</span>	<span class="hljs-number">1</span>`</code></pre>
</li>
</ul>
</li>
<li><p>二进制转八进制、十进制、十六进制：aaa</p>
<ul>
<li><p>二进制转八进制：三位归并法：每三位一组，不够位数的左边添0，求出每个三位的二进制值，最后结果拼接即可；注意：该方法同样适用于八进制转二进制，只需逆向将一个八进制拆成三位的二进制即可，前提是需要明白8421码的转换；</p>
</li>
<li><p>其他进制转十进制(包括二进制转十进制)：每一位上的数据值进制(二进制乘以二，八进制乘以八，十六进制乘以十六)^从右往左且幂从0开始；</p>
</li>
<li><p>二进制转十六进制：四位归并法：每四位一组，不够位数的左边添0，求出每个四位的二进制值，最后结果拼接即可。注意：该方法同样适用于十六进制转二进制，只需逆向将一个十六进制拆成四位的二进制即可，前提是需要明白8421码的转换。</p>
<p> 例如：</p>
 <pre><code class="hljs c">二进制转换成十进制：

二进制数<span class="hljs-number">01110101</span>
<span class="hljs-number">0</span>        <span class="hljs-number">1</span>        <span class="hljs-number">1</span>        <span class="hljs-number">1</span>        <span class="hljs-number">0</span>        <span class="hljs-number">1</span>        <span class="hljs-number">0</span>        <span class="hljs-number">1</span>
<span class="hljs-number">02</span>^<span class="hljs-number">7</span>   <span class="hljs-number">12</span>^<span class="hljs-number">6</span>     <span class="hljs-number">12</span>^<span class="hljs-number">5</span>      <span class="hljs-number">12</span>^<span class="hljs-number">4</span>    <span class="hljs-number">02</span>^<span class="hljs-number">3</span>     <span class="hljs-number">12</span>^<span class="hljs-number">2</span>     <span class="hljs-number">02</span>^<span class="hljs-number">1</span>      <span class="hljs-number">2</span>^<span class="hljs-number">0</span>=<span class="hljs-number">1</span>
<span class="hljs-number">0</span>       <span class="hljs-number">64</span>       <span class="hljs-number">32</span>        <span class="hljs-number">16</span>       <span class="hljs-number">0</span>       <span class="hljs-number">4</span>         <span class="hljs-number">0</span>        <span class="hljs-number">1</span>

把所有的结果相加，得到最后的结果<span class="hljs-number">117</span>。其他进制转十进制只需要将<span class="hljs-number">2</span>换成<span class="hljs-number">8</span>、<span class="hljs-number">16</span>即可
    
<span class="hljs-comment">//------------------------------------------------------------------</span>
    
二进制<span class="hljs-number">0b1100110</span>转八进制：
<span class="hljs-number">001</span> <span class="hljs-number">100</span> <span class="hljs-number">110</span>
<span class="hljs-number">1</span>   <span class="hljs-number">4</span>   <span class="hljs-number">6</span>   = <span class="hljs-number">0146</span>

<span class="hljs-comment">//------------------------------------------------------------------    </span>
    
二进制<span class="hljs-number">0b1100110</span>转十六进制：
<span class="hljs-number">0110</span> <span class="hljs-number">0110</span>
<span class="hljs-number">6</span>    <span class="hljs-number">6</span>    = <span class="hljs-number">0x66</span></code></pre>
</li>
</ul>
</li>
<li><p>八进制转二进制、十进制、十六进制：</p>
<ul>
<li>八进制转二进制：采用8421码，即一个八进制位转换为3个二进制位；<strong><code>注意：这里不懂8421码的话，可以找一些视频来看，比较简单。</code></strong></li>
<li>其他进制转十进制(包括八进制转十进制)：每一位上的数据值进制(二进制乘以二，八进制乘以八，十六进制乘以十六)^从右往左且幂从0开始；</li>
<li>八进制转十六进制：先转成二进制或十进制，再转成十六进制即可。</li>
</ul>
</li>
<li><p>十进制转其他进制：直接用这个数除以进制数(二进制除以二，八进制除以八，十六进制除以十六)，直到商为0，取余数反转即可；</p>
</li>
<li><p>十六进制转二进制、八进制、十进制：</p>
<ul>
<li>十六进制转二进制：采用8421码，即一个十六进制位转换为4个二进制位；</li>
<li>十六进制转八进制：先转成二进制或十进制，再转成八进制即可；</li>
<li>十六进制转十进制：其他进制转十进制(包括十六进制转十进制)：每一位上的数据值进制(二进制乘以二，八进制乘以八，十六进制乘以十六)^从右往左且幂从0开始。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-14-原码、反码、补码"><a href="#NO2-14-原码、反码、补码" class="headerlink" title="NO2.14 原码、反码、补码"></a>NO2.14 原码、反码、补码</h3><p>计算机中所有的数据运算都采用补码进行的。对于有符号的数(即负数)而言，二进制的的最高位为符号位：0表示正数、1表示负数。</p>
<ul>
<li>正数的原、反、补码都是一样的，即正数的二进制既是原码，又是反码和补码。</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>负数：</p>
<ul>
<li><p>原码：就是二进制本身，但符号位用0或1分别表示正数或负数；</p>
</li>
<li><p>反码：符号位不变，其他位取反(0变1,1变0)；</p>
</li>
<li><p>补码：在反码的基础上末位加1。</p>
<p>  例如：</p>
  <pre><code class="hljs c">+<span class="hljs-number">7</span> 和 <span class="hljs-number">-7</span>
二进制为：<span class="hljs-number">00000111</span>
+<span class="hljs-number">7</span> 的原码为<span class="hljs-number">00000111</span>
<span class="hljs-number">-7</span> 的原码则为<span class="hljs-number">10000111</span>

<span class="hljs-comment">//------------------------------------------------------------------</span>

+<span class="hljs-number">7</span> 的原码为<span class="hljs-number">00000111</span>，反码也是<span class="hljs-number">00000111</span>
<span class="hljs-number">-7</span> 的原码为<span class="hljs-number">10000111</span>，反码则是<span class="hljs-number">11111000</span>

<span class="hljs-comment">//------------------------------------------------------------------</span>

+<span class="hljs-number">7</span> 的原码为<span class="hljs-number">00000111</span>，反码也是<span class="hljs-number">00000111</span>，补码仍然为<span class="hljs-number">00000111</span>
<span class="hljs-number">-7</span> 的原码为<span class="hljs-number">10000111</span>，反码则是<span class="hljs-number">11111000</span>，补码变成<span class="hljs-number">11111001</span></code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-15-程序流程控制"><a href="#NO2-15-程序流程控制" class="headerlink" title="NO2.15 程序流程控制"></a>NO2.15 程序流程控制</h3><p>C语言中的程序流程控制：即用来控制程序的流程走向。包括三大流程控制：顺序控制、分支控制、循环控制。</p>
<ul>
<li><p>顺序控制：即程序代码从上到下，逐行顺序执行，中间没有任何判断和跳转。</p>
<ul>
<li><p>基本语法格式：</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;  <span class="hljs-comment">//先执行这个</span>
    <span class="hljs-keyword">int</span> age = <span class="hljs-number">2</span>;  <span class="hljs-comment">//再执行这个</span>
&#125;</code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>分支控制：即让程序代码有选择的执行，但只会执行其中的一种分支。<strong><code>注意：分支可以相互嵌套，但最多不要嵌套超过3层，否则代码可读性会大大降低。</code></strong>分支控制主要分为：</p>
<ul>
<li><p>单分支：即if语句，只有一个选择分支，符合条件则执行分支里的语句体，否则就跳过不执行，继续往下执行；</p>
<ul>
<li><p>基本语法格式：</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-keyword">if</span>(条件表达式)&#123;  <span class="hljs-comment">//条件表达式中只返回true或false，前者进入分支并执行语句体，后者不进入分支执行语句体，即跳过不执行</span>
    需要执行的语句体
&#125;

如：
<span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span>

<span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">0</span>)&#123;
    printf_s(<span class="hljs-string">"a大于0哦"</span>);
&#125;

输出结果为：a大于<span class="hljs-number">0</span>哦</code></pre>
</li>
</ul>
</li>
<li><p>双分支：即if-else语句，用于两种情况的选择，即符合与不符合条件的情况，将执行不同的语句体；</p>
<ul>
<li><p>基本语法格式：</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-keyword">if</span>(条件表达式)&#123;  <span class="hljs-comment">//为true走这里</span>
    需要执行的语句体<span class="hljs-number">1</span>
&#125; <span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">//为false时走这里</span>
    需要执行的语句体<span class="hljs-number">2</span>
&#125;

如：
<span class="hljs-keyword">int</span> a = <span class="hljs-number">-2</span>;

<span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">0</span>)&#123;
    printf_s(<span class="hljs-string">"a大于0哦"</span>);
&#125;<span class="hljs-keyword">else</span> &#123;
    printf_s(<span class="hljs-string">"a小于0哦"</span>);
&#125;

输出结果为：a小于<span class="hljs-number">0</span>哦</code></pre>
</li>
</ul>
</li>
<li><p>多分支：即if-else if-else语句，用于多种情况的的选择；</p>
<ul>
<li><p>基本语法格式：</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-keyword">if</span>(条件表达式<span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">//符合条件1就进入这里</span>
    需要执行的语句体<span class="hljs-number">1</span>
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件表达式<span class="hljs-number">2</span>)&#123;  <span class="hljs-comment">//符合条件2就进入这里</span>
    需要执行的语句体<span class="hljs-number">2</span>
&#125; ....&#123;
    ....
&#125;<span class="hljs-keyword">else</span>&#123;
    上面两种都不符合，就会执行这里
&#125;

如：
<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;

<span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">0</span>)&#123;
    printf_s(<span class="hljs-string">"a大于0哦"</span>);
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a = <span class="hljs-number">0</span>)&#123;
    printf_s(<span class="hljs-string">"a等于0哦"</span>);
&#125; <span class="hljs-keyword">else</span> &#123;
    printf_s(<span class="hljs-string">"a小于0哦"</span>);
&#125;

输出结果为：a等于<span class="hljs-number">0</span>哦</code></pre>
</li>
</ul>
</li>
<li><p>其他分支：即switch语句，用于匹配多重选择的情况。</p>
<ul>
<li><p>基本语法格式：</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-keyword">switch</span>(整数值)&#123;  <span class="hljs-comment">//这里的整数值也可以由一个表达式产生，也可以是枚举类型。如1+1，'a'等等</span>

    <span class="hljs-keyword">case</span> 常量值<span class="hljs-number">1</span>:  <span class="hljs-comment">//switch中的表达式产生的值，如果与这里的值1匹配成功的话，那么就会执行限免的语句体1</span>
        需要执行的语句体<span class="hljs-number">1</span>
        <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//表示中断，意思就是分支程序执行到这里，那么分支就执行完毕了，可以跳出分支，进行分支外的代码执行</span>

    <span class="hljs-keyword">case</span> 常量值<span class="hljs-number">2</span>:
        需要执行的语句体<span class="hljs-number">2</span>
        <span class="hljs-keyword">break</span>;

    ....
    <span class="hljs-keyword">default</span>:
        都不符合时，才执行的语句体
&#125;</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>循环控制：即让程序的代码能够实现循环的执行。<strong><code>注意：循环也可以嵌套使用，但是只建议嵌套循环不超过3层，否则代码的可读性就会变差。</code></strong>可以分为：</p>
<ul>
<li><p>for循环：一般用于有次数限制的条件循环；</p>
<ul>
<li><p>基本语法格式：</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-keyword">for</span>(初始化语句;循环条件表达式;控制条件语句)&#123;
    循环体
&#125;

如：
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>; i++)&#123;
    printf_s(<span class="hljs-string">"i的值为：%d\n"</span>,i);
&#125;

<span class="hljs-comment">//还可以有逗哥初始化语句和控制条件语句，有多个时，用,隔开即可，但是要注意无论是初始化语句只能定义同一种数据类型</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>，j=<span class="hljs-number">1</span>;i &lt; <span class="hljs-number">5</span>; i++，j++)&#123;
    printf_s(<span class="hljs-string">"i的值为：%d\n"</span>,i);
    printf_s(<span class="hljs-string">"j的值为：%d\n"</span>,j);
&#125;</code></pre>
</li>
</ul>
</li>
<li><p>while循环：一般用于不清楚循环次数时而使用的；</p>
<ul>
<li><p>基本语法格式：</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-keyword">while</span>(条件表达式)&#123;  <span class="hljs-comment">//表达式用来判断是否能够进入循环；当表达式不成立时，则不再进入循环</span>
    循环体
&#125;

如：
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;

    <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span>(num &lt; <span class="hljs-number">5</span>)&#123;  <span class="hljs-comment">//循环的入口，当表达式num&lt;5成立时，进入循环</span>

        printf_s(<span class="hljs-string">"num的值为：%d\n"</span>,num);

        num++;
    &#125;
&#125;</code></pre>
</li>
</ul>
</li>
<li><p>do-while循环：该循环和while循环差不多，不同的地方总是会先执行一次；</p>
<ul>
<li><p>基本语法格式：</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-keyword">do</span>&#123;
    循环体
&#125; <span class="hljs-keyword">while</span> (判断表达式)


注意：该循环与<span class="hljs-keyword">while</span>表示的意义差不多，但是这种循环，是先执行一次，后判断。

如：
<span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>
<span class="hljs-keyword">do</span>&#123;
    num++;
&#125;<span class="hljs-keyword">while</span>(num &lt; <span class="hljs-number">3</span>)</code></pre>
</li>
</ul>
</li>
<li><p>goto语句：作用是跳转到某一行代码去执行。嗯….这个不建议使用，其实continue和break就是goto的特殊形式，使用这两个就够用了。</p>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-16-循环辅助：continue和break"><a href="#NO2-16-循环辅助：continue和break" class="headerlink" title="NO2.16 循环辅助：continue和break"></a>NO2.16 循环辅助：continue和break</h3><p>continue和break使用频率很高，各种循环语句里面都有它们的身影。</p>
<ul>
<li><p>continue：一般用于循环体内；执行到continue时，作用是跳过本次循环，continue后面的代码就不会再执行；如果有嵌套循环，则跳过有continue的那一层循环，并进行下一次循环。<strong><code>注意：continue不能单独跟switch和if，但是如果if外层有循环，则可以正常使用。</code></strong></p>
<ul>
<li><p>基本语法格式</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;num &lt; <span class="hljs-number">10</span>;num++)&#123;

    <span class="hljs-keyword">if</span>( num == <span class="hljs-number">3</span>)&#123;
        <span class="hljs-keyword">continue</span>;
    &#125;
    printf_s(<span class="hljs-string">"%d"</span>,num);
&#125;</code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>break：一般用于循环体内；执行到break时，直接结束循环；如果有嵌套循环，则结束有break的那一层循环。</p>
<ul>
<li><p>基本语法格式</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++)&#123;

    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">3</span>)&#123;
        <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//当执行到i等于3时，那么就会跳出当前的for循环，也就是停止for循环</span>
    &#125;
    printf_s(<span class="hljs-string">"%d',i);</span>
<span class="hljs-string">&#125;</span>
<span class="hljs-string">             </span>
<span class="hljs-string">拓展：return的使用</span>
<span class="hljs-string">一、return关键字的使用和break差不多，都有终止程序循环的作用，但不同的是，return不仅仅用于循环中，更常用于有返回值的函数中。</span>
<span class="hljs-string"></span>
<span class="hljs-string">如：</span>
<span class="hljs-string">int main()&#123;</span>
<span class="hljs-string"></span>
<span class="hljs-string">    ....省略了其他代码</span>
<span class="hljs-string">    return 0;  //这里的return就是运用在函数中，即main函数</span>
<span class="hljs-string">&#125;</span></code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-17-枚举类型"><a href="#NO2-17-枚举类型" class="headerlink" title="NO2.17 枚举类型"></a>NO2.17 枚举类型</h3><p>在实际编程中，有些数据的取值往往是有限的，只能是非常少量的整数，并且最好为每个值都取一个名字，以方便在后续代码中使用。如，一个星期只有七天，一年只有十二个月，一个班每周有六门课程等。</p>
<ul>
<li><p>枚举：</p>
<ul>
<li><p>定义：枚举是一组常量的集合；<strong><code>注意：C语言中枚举类型是被当作int或unsigned int类型来处理的。</code></strong></p>
</li>
<li><p>创建方式：enum 枚举名{枚举元素1、枚举元素2、枚举元素3….}。<strong><code>注意：如果枚举中的第一个元素没有赋值的话，默认值为0，后面的值按顺序在前一个值的基础上加1；如果中途某个元素又给了值，那么从这个值开始后面元素的值会依次加1。如，enum WEEK={MON、TUE=5、WED}，那么MON的值为0，而WED的值在TUE的基础上加1，即WED=6。</code></strong></p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-comment">//enum XINGQI &#123;MON=1,TUE=2,WED=3&#125; day2;  //还可以使用这种方式定义枚举和枚举变量</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
       <span class="hljs-keyword">enum</span> XINGQI &#123;MON=<span class="hljs-number">1</span>,TUE=<span class="hljs-number">2</span>,WED=<span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">//定义了一个枚举类型</span>
       <span class="hljs-keyword">enum</span> XINGQI day = MON;  <span class="hljs-comment">//定义了一个枚举变量，用于接收枚举中的值</span>
       printf_s(<span class="hljs-string">"%d"</span>,day);
       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">//-------------------------------</span>

<span class="hljs-comment">//枚举遍历</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-keyword">enum</span> XINGQI &#123;MON=<span class="hljs-number">1</span>,TUE,WED&#125; day2;  <span class="hljs-comment">//如果TUE、WED不赋值的话，会自动按照顺序赋值，即TUE=2、WED=3</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    <span class="hljs-keyword">for</span>(day2 = MON;day &lt;= WED;day2++)&#123;  <span class="hljs-comment">//这里day++会给予警告，但是能够运行</span>
        printf_s(<span class="hljs-string">"%d"</span>,day2);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-18-函数"><a href="#NO2-18-函数" class="headerlink" title="NO2.18 函数"></a>NO2.18 函数</h3><p>函数是能够完成特定任务的一个独立程序代码单元。</p>
<ul>
<li>函数类型主要分为两种：<ul>
<li>void函数：即没有返回值的函数，就称为void函数；</li>
<li>E 函数：指的是，如果返回值是E类型，那么该函数就称为E类型函数。<code>如，int count(int a,int b)，该函数返回int类型的值，那么该函数是int类型函数</code>。</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>函数原型：</p>
<ul>
<li><p>定义：就是对函数的定义；</p>
</li>
<li><p>基本语法格式：</p>
<p>  例如：</p>
  <pre><code class="hljs c">返回值类型 函数名(参数类型 变量名,....);  <span class="hljs-comment">//后面的“....”表示，可以有多个参数，也可以没有一个参数</span>

如：
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;  <span class="hljs-comment">//先声明一个新的函数，告诉系统，等会我们要使用这个函数</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;

    printf_s(<span class="hljs-string">"hello,baby!"</span>);
    test();  <span class="hljs-comment">//然后，使用该函数</span>
    printf_s(<span class="hljs-string">"hi,darling!"</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;  <span class="hljs-comment">//通过函数原型来定义要使用的test函数，其实就是和Java中的函数定义一样的</span>

    printf_s(<span class="hljs-string">"double!"</span>);
&#125;</code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>形参和实参：<ul>
<li>形参：即形式参数，用于定义函数时而使用的参数，告诉C，函数值要传入一个什么类型的参数；</li>
<li>实参：即实际参数，实际调用该函数时，传入函数的参数，那么这个值就称为实参。<code>如，定义一个函数：void count(int number)，number就是形参，调用函数：count(5)，那么这个5就是实参</code>。</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>头文件：</p>
<ul>
<li><p>定义：简单讲就是包含了一些功能性函数的声明、数据接口声明的一个文件，即将变量、处理函数抽取放到一个专门的文件中而已。在程序中，头文件的后缀主要是“.h”，也就是说函数声明写在了以“.h”结尾的头文件中。<strong><code>注意：一般自定义的头文件和源文件名称都是相同的。</code></strong></p>
</li>
<li><p>作用：头文件对程序编译执行而言，它仅仅在预编译时将其内容在#include的地方展开一下，说白了就是将头文件中的内容复制粘贴到你写的程序中，但是复制粘贴不方便，也不安全，所以采用了头文件；</p>
</li>
<li><p>自定义头文件的方式有两种；<strong><code>注意：#include&lt;...&gt;是调用标准头文件库的用法，自己写的头文件，调用时一般用#include&quot;....&quot;，而不用#include&lt;....&gt;，自定义头文件一般和项目文件放在一起，即同目录下即可。</code></strong></p>
<ul>
<li><p>第一种：函数的声明和实现都写在“.h”头文件中；</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-comment">//创建一个头文件，后缀以“.h”结尾即可，名称可以自定义</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123;
       <span class="hljs-keyword">return</span> num1 + num2;
&#125;;

<span class="hljs-comment">//-----------------------------------------------</span>

<span class="hljs-comment">//在需要引用的程序中引入你自己定义的头文件即可</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"myheadfile.h"</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;

       <span class="hljs-keyword">int</span> res = getSum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
       printf_s(<span class="hljs-string">"%d"</span>, res);
       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
</li>
<li><p>第二种：函数的声明写在“.h”头文件中，函数的实现写在“.c”或“.cpp”文件中。<strong><code>注意：VS2019中，无法使用第二种，又或许是我的方式不对？</code></strong></p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-comment">//创建一个头文件，后缀以“.h”结尾即可，名称可以自定义，内容写上函数的声明</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1,<span class="hljs-keyword">int</span> num2)</span></span>;

<span class="hljs-comment">//-----------------------------------------------</span>

<span class="hljs-comment">//创建一个源文件，后缀以“.c”或“.cpp”结尾即可，名称可以自定义，但最好和自定义的“.h”头文件名称一致，方便辨认；内容写上头文件中声明的函数的具体实现</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">""</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1,<span class="hljs-keyword">int</span> num2)</span></span>&#123;
    <span class="hljs-keyword">return</span> num1 + num2;
&#125;

<span class="hljs-comment">//-----------------------------------------------</span>

<span class="hljs-comment">//在需要引用的程序中引入自己写的头文件即可</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"myheadfile.h"</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;

       <span class="hljs-keyword">int</span> res = getSum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
       printf_s(<span class="hljs-string">"%d"</span>, res);
       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>函数的递归调用：所谓递归调用，就是函数自己调用自己的意思，不需要想的太复杂。我们将放在return之前的递归调用，称为尾递归。</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>;  <span class="hljs-comment">//声明函数原型</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;

    <span class="hljs-keyword">int</span> res = count(<span class="hljs-number">12</span>);  <span class="hljs-comment">//调用函数</span>
    printf_s(<span class="hljs-string">"结果是：%d\n"</span>,res);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>&#123;
    <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">10</span>)&#123;
        num--;
        <span class="hljs-keyword">return</span> count(num);
    &#125;<span class="hljs-keyword">else</span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;
    &#125;
&#125;</code></pre>

</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>变量的作用域：所谓变量的作用域，就是指变量的有效范围。可分为：</p>
<ul>
<li><p>局部变量：</p>
<ul>
<li>作用域：定义在函数或代码块内部。即该类型变量的有效范围在函数或代码块内部。</li>
<li>存储区域：局部变量保存在栈中，函数被调用时才会为其分配存储单元。<code>如，形式参数就是局部变量</code>；<strong><code>注意：局部变量系统不会帮忙初始化，也就是说必须初始化才能用</code></strong></li>
</ul>
</li>
<li><p>全局变量：</p>
<ul>
<li><p>作用域：即定义在函数外部的变量。该类型变量的有限范围是在整个程序中。</p>
</li>
<li><p>存储区域：全局变量保存在内存中的全局存储区中，占用静态的存储单元。<strong><code>注意：全局变量系统会帮忙初始化；int类型默认是0、char类型默认是&#39;\0&#39;、float和double类型默认是0.0，指针类型默认是NULL。当局部变量和全局变量同名时，根据就近原则，会使用局部变量的值；但要注意，同一作用域中，不能出现同名变量。</code></strong></p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-keyword">int</span> a;  <span class="hljs-comment">//这就是全局变量，没赋值，但是系统会给我们初始化，默认是0</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;

    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>  <span class="hljs-comment">//这是局部变量，只用于man函数内部</span>
    printf_s(<span class="hljs-string">"结果是：%d\n"</span>,a);  <span class="hljs-comment">//这里会输出最近的变量，即a=10</span>

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++)&#123;
         <span class="hljs-keyword">int</span> j = <span class="hljs-number">0.5</span>;  <span class="hljs-comment">//这也是局部变量</span>
        printf_s(<span class="hljs-string">"%d"</span>,i+j);
    &#125;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-19-static关键字"><a href="#NO2-19-static关键字" class="headerlink" title="NO2.19 static关键字"></a>NO2.19 static关键字</h3><p>static关键字，意为静态的意思，可以修饰变量和函数。</p>
<ul>
<li><p>static修饰：</p>
<ul>
<li><p>修饰变量，分为两种：</p>
<ul>
<li><p>基本语法格式：<code>static 数据类型 变量名 = 值</code>；</p>
</li>
<li><p>修饰局部变量：静态局部变量如果没有初始化值，那么系统会根据不同的数据类型为静态局部变量初始化值；静态局部变量存储于内存的静态存储区，只会被初始化一次；</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;

    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;  <span class="hljs-comment">//这是普通局部变量</span>
    printf_s(<span class="hljs-string">"结果是：%d\n"</span>,a);  <span class="hljs-comment">//这里会输出10</span>
    a++;
    printf_s(<span class="hljs-string">"结果是：%d\n"</span>,a);  <span class="hljs-comment">//这里会输出11</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a2; <span class="hljs-comment">//这是静态局部变量</span>
    printf_s(<span class="hljs-string">"结果是：%d\n"</span>,a2);  <span class="hljs-comment">//这里会输出0</span>
    a2++;
    printf_s(<span class="hljs-string">"结果是：%d\n"</span>,a2);  <span class="hljs-comment">//这里会输出1</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">3</span>;i++) &#123;
        f1();
    &#125;

    print_f(<span class="hljs-string">"----------------------------\n"</span>)

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">3</span>;i++) &#123;
        f2();
    &#125;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

输出结果：
结果是：<span class="hljs-number">10</span>  <span class="hljs-comment">//开始第一次调用函数</span>
结果是：<span class="hljs-number">11</span>
结果是：<span class="hljs-number">10</span>  <span class="hljs-comment">//开始第二次调用函数，当再次调用函数时，a的值又被重新初始化为10了</span>
结果是：<span class="hljs-number">11</span>
---------------------------

结果是：<span class="hljs-number">0</span>  <span class="hljs-comment">//静态局部变量a2并没有被赋值，所以系统初始化了a的值为0</span>
结果是：<span class="hljs-number">1</span>
结果是：<span class="hljs-number">1</span>  <span class="hljs-comment">//第二次调用函数时，静态局部变量并没有重新初始化为0，因为静态局部变量只会被初始化一次</span>
结果是：<span class="hljs-number">2</span></code></pre>
</li>
<li><p>修饰全局变量：静态全局变量会被私有化，即静态全局变量只能用在本文件当中，其他文件无法通过extern引用该静态全局变量。</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-comment">//test1.c文件中</span>
<span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;  <span class="hljs-comment">//定义了一个普通的全局变量</span>

<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a2 = <span class="hljs-number">10</span>;  <span class="hljs-comment">//如果使用了静态全局变量，则该变量只能用于test1.c文件中，无法被其他文件使用extern引用</span>

<span class="hljs-comment">//-----------------------------------</span>

<span class="hljs-comment">//test2.c文件中</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> a;  <span class="hljs-comment">//通过extern引用test1.c文件中的变量a</span>

<span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> a2;  <span class="hljs-comment">//通过extern引用test1.c文件中的变量a2</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;

    print_s(<span class="hljs-string">"a的结果是：%d\n"</span>,a);  <span class="hljs-comment">//这里会输出10</span>

    print_s(<span class="hljs-string">"a2的结果是：%d\n"</span>,a2;  <span class="hljs-comment">//这里会报错，即无法解析a2这个变量</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
</li>
</ul>
</li>
<li><p>修饰函数：</p>
<ul>
<li><p>基本语法格式：<code>static 返回值类型 函数名(形参列表){....}</code>；</p>
</li>
<li><p>static修饰函数：与静态全局变量类似，静态函数只属于本文件，无法被其他文件用extern所引用；即哪个文件声明了静态函数，那么就只能被哪个文件调用，其他文件无法调用。反过来。普通函数可以被extern关键字所引用。</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-comment">//test1.c文件中</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;  <span class="hljs-comment">//普通函数</span>

    printf_s(<span class="hljs-string">"这里是f1函数"</span>);

&#125;

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;  <span class="hljs-comment">//静态函数</span>

    printf_s(<span class="hljs-string">"这里是f2函数"</span>);
&#125;

<span class="hljs-comment">//-----------------------------------</span>

<span class="hljs-comment">//test2.c文件中</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;  <span class="hljs-comment">//通过extern引用test1.c文件中的函数f1</span>

<span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;  <span class="hljs-comment">//通过extern引用test1.c文件中的函数f2</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;

     f1();  <span class="hljs-comment">//成功输出：这里是f1函数</span>
     f2();  <span class="hljs-comment">//报错：无法解析的外部符号，即静态函数只能在声明了它的那个文件中使用</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-20-字符串和数组"><a href="#NO2-20-字符串和数组" class="headerlink" title="NO2.20 字符串和数组"></a>NO2.20 字符串和数组</h3><p>C语言中没有存储字符串的变量类型。</p>
<ul>
<li><p>字符串：</p>
<ul>
<li><p>定义：是一个或多个字符的序列，属于派生类型。如，”dyf is climbing”、”be warm”等等，这些都是字符串；<strong><code>注意：如果创建的是字面量字符串，系统依然会默认给该字符串的最后添加一个&#39;\0&#39;。</code></strong></p>
</li>
<li><p>数据类型：C语言没有专门用于存储字符串的数据类型，字符串都被存储在char类型的数组中。<strong><code>注意：C中的字符串一定以空字符串结束，所以数组一般要多留一个位置给这个空字符串。字符串其实就是一个字符数组，如果函数的返回值是一个char*，即一个字符型的指针变量，那么一般就是返回一个字符串的意思，极少数有返回一个地址值。</code></strong></p>
</li>
<li><p>字符和字符串的区别：</p>
<ul>
<li><p>字符是基本类型，字符串是派生类型；</p>
</li>
<li><p>字符串的末尾有都有一个空字符：’\0’，而字符没有。</p>
<p>  <img src="./Image-c27.png" srcset="/img/loading.gif" alt="Image"><br>  <code>说明：上图中末尾的字符\0，这是用于标记字符串的结束而使用的空字符，它是非打印字符，其ASCII码值等价于0。</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>数组：</p>
<ul>
<li><p>定义：数组是同类型的数据元素的有序序列，简单讲就是同一类型的数据元素的一个有序的集合。如，要么都是int，或者都是long….等等；</p>
</li>
<li><p>数组的创建方式：要使用数组，必须先创建数组，常用的几种方式如下；<strong><code>注意：用const修饰数组，表示只让用户查看数组中有哪些元素，但并不允许修改。如，const int nums[5]，表明了该数组只能用于查看有哪些元素，不允许用户修改数组的值；数组中每个元素的内存地址都是连续分布的，即第一个元素的地址值加上数据类型占用的字节大小等于第二个元素的地址，后面的以此类推；数组索引从0开始；字符数组如果只初始化了部分空间，那么剩下的空间都将被赋值为&#39;\0&#39;。</code></strong></p>
<ul>
<li>方式一：<code>数据类型 数组名称[size]</code>。用该方式创建的数组，包括，指定了的数据类型、数组名称，以及数组的容量(即size)；</li>
<li>方式二：<code>数据类型 数组名称[size] = {元素1,元素2,元素3,....}</code>。用该方式创建的数组，包括指定了的数据类型、数组名称，以及数组的容量(也可以不指定size大小，系统会根据已有的元素推断数组的size)，并且数组中的元素也已经确定，就是{}中的元素；</li>
<li>方式三：<code>数据类型 数组名称[size] = {[索引值]=值,....}</code>。用该方式创建的数组，给数组中指定索引的位置赋了值，这是C99引入的新特性，之前是不允许这样的，之前的规定：必须对要赋值元素之前的所有元素都赋值，才能给指定位置的元素赋值。<code>如，char nums[5] = {[0]=&#39;b&#39;,[4]=&#39;a&#39;}</code>。<strong><code>注意：如果指定赋值的索引有多个值，那么会将其他多出来的值，赋给指定索引后面的索引。如，char nums[3]={[0]=&#39;a&#39;,&#39;b&#39;,&#39;c&#39;}。</code></strong></li>
</ul>
</li>
<li><p>数组与指针的关系：数组名可以认为是一个指针常量，它指向数组的第0个元素的地址。即数组名的地址值==数组[0]的地址值，也就是说数组名的地址值和数组第一个元素的地址值是相同的。<code>如，int num[2]，那么&amp;num==&amp;(num[0])，且(&amp;num)+1==&amp;(num[1])</code>。</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;

    printf_s(<span class="hljs-string">"name?"</span>);

    <span class="hljs-keyword">char</span> name[<span class="hljs-number">40</span>];  <span class="hljs-comment">//创建一个字符数组</span>

    scanf_s(<span class="hljs-string">"%s"</span>,name);  <span class="hljs-comment">//获取用户输入一个字符串，并将该字符串存入名为name的字符数组</span>

    printf_s(<span class="hljs-string">"hello, %s"</span>,name);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

注意：<span class="hljs-keyword">char</span> str[] =&#123;<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>&#125;和<span class="hljs-keyword">char</span> str2[<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>&#125;的区别
一、<span class="hljs-keyword">char</span> str[] =&#123;<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>&#125;，该字符数组根据后面拥有的元素来推断数组的大小，所以大小为<span class="hljs-number">3</span>，但是如果以字符串的转换说明输出的话，会出现乱码，因为该字符串中没有足够的位置添加空字符<span class="hljs-string">'\0'</span>；

二、<span class="hljs-keyword">char</span> str2[<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>&#125;，该字符数组大小为<span class="hljs-number">3</span>，且只占用了两个空间，在以字符串转换说明(即以<span class="hljs-string">"%s"</span>)输出时，不会报错，因为有空间添加空字符<span class="hljs-string">'\0'</span>，所以能够正常输出。

<span class="hljs-comment">//============================================================    </span>
    
拓展：全局数组和局部数组的初始化(这里以整型数组为例，即<span class="hljs-keyword">int</span> arr[])
一、未初始化：
    <span class="hljs-number">1.</span>全局数组，被编译器初始化为<span class="hljs-number">0</span>；
    <span class="hljs-number">2.</span>局部数组，为随机数。

二、部分初始化：不论是全局数组还是局部数组，没有被初始化的部分，都会被初始化为<span class="hljs-number">0</span>。

<span class="hljs-comment">//============================================================    </span>
    
拓展：“*”、指针变量、数组的使用
一、<span class="hljs-keyword">int</span> arr[<span class="hljs-number">10</span>]，<span class="hljs-keyword">int</span>*  ar = &amp;arr，那么，*(ar + <span class="hljs-number">2</span>)，表示arr数组的第三个元素的值；

二、arr + <span class="hljs-number">2</span>，表示arr数组的第一个元素的地址值加<span class="hljs-number">2</span>，即数组第三个元素的地址值。</code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>二维数组：<ul>
<li>定义：即数组的每个元素是一个一维数组(一维数组就是普通的数组)，这样的数组，我们称为二维数组。多维数组，以此类推。</li>
<li>二维数组的基本语法格式：<code>数据类型 数组名[size1][size2]</code>，其中size1表示，二维数组中有多少个一维数组，size2则表示每个一维数组中有多少个元素。<code>如，int nums[2][3]，表示这个二维数组中有2个一维数组元素，而每个一维数组中都有3个元素</code>。<strong><code>注意：其实二维数组的创建基本语法格式和一维数组差不多，这里只介绍了一种，还可以直接添加元素到数组中：int nums[2][2]={ {1,2},{3,4} }。</code></strong></li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-21-C语言中的常用函数"><a href="#NO2-21-C语言中的常用函数" class="headerlink" title="NO2.21 C语言中的常用函数"></a>NO2.21 C语言中的常用函数</h3><p>函数是C程序中的主体。</p>
<ul>
<li><p>字符串函数：<strong><code>注意：这一类函数主要对字符串进行操作，存在于string.h头文件中，所以使用时需要引用头文件string.h头文件。</code></strong></p>
<ul>
<li><p>strlen(str)：用于表示字符串中的字符长度(包括空格和标点符号，但不会把用于结束的空字符算进去)。</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;  //引入strlen()函数所在的头文件，该头文件还包含了其他与字符串相关的函数</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;

    <span class="hljs-keyword">char</span> name[<span class="hljs-number">40</span>] = &#123;<span class="hljs-string">"abc"</span>&#125;;

    printf_s(<span class="hljs-string">"数组的长度是：%d\n"</span>, <span class="hljs-keyword">sizeof</span>(name));  <span class="hljs-comment">//sizeof()表达式用于获取字符数组的大小，前面声明了开了40个字节，那么这里的结果就是40</span>

    printf_s(<span class="hljs-string">"你名字的长度是：%d"</span>,<span class="hljs-built_in">strlen</span>(name));  <span class="hljs-comment">//strlen()表达式用于获取字符串的长度，但是不会把空字符(即\0)算进去，返回的结果为3</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

拓展：<span class="hljs-keyword">sizeof</span>
一、<span class="hljs-keyword">sizeof</span>是C语言的一种单目操作符。<span class="hljs-keyword">sizeof</span>操作符以字节形式给出了其操作数的存储大小。<span class="hljs-keyword">sizeof</span>的返回值是<span class="hljs-keyword">size_t</span>，在<span class="hljs-number">64</span>位机器下，被定义为<span class="hljs-keyword">long</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>；

二、用途：
    <span class="hljs-number">1.</span>用于数据类型：使用形式为<span class="hljs-keyword">sizeof</span>(type)。表示这个类型占内存多少字节；
    <span class="hljs-number">2.</span>用于变量：使用形式为<span class="hljs-keyword">sizeof</span>(var)或<span class="hljs-keyword">sizeof</span> var。表示常量、变量在内存中占用的字节数。</code></pre>
</li>
<li><p>strcpy_s(str,len,newStr)：将newStr复制到str中，str中的值会被覆盖掉；其中len表示将newStr复制到str时，创建的一个缓冲区的大小，一般的做法就是将len的大小定为newStr的长度加1，即strlen(newStr)+1，为什么要加1？是因为字符串中包含了空字符来表示字符串的结尾，所以需要在字符串本身长度的基础上多加1才能够将这个需要被复制的字符串放入缓冲区中；如果len小于或等于了newStr，那么程序会报错。</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;

    <span class="hljs-keyword">char</span> str[<span class="hljs-number">20</span>] = &#123;<span class="hljs-string">"abc"</span>&#125;;

    strcpy_s(str , <span class="hljs-number">6</span>,<span class="hljs-string">"ddddd"</span>);  <span class="hljs-comment">//正常运行，最后的输出结果为：ddddd</span>

    strcpy_s(str , <span class="hljs-number">4</span>,<span class="hljs-string">"ddddd"</span>);  <span class="hljs-comment">//报错，程序崩溃</span>
    strcpy_s(str , <span class="hljs-number">5</span>,<span class="hljs-string">"ddddd"</span>);  <span class="hljs-comment">//报错，程序崩溃</span>

    printf_s(<span class="hljs-string">"%s"</span>,str);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
</li>
<li><p>strcat_s(str,len,newStr)：将newStr追加到str中，并不会覆盖str的原有内容，只是做一个追加操作。len表示str的大小，即str数组的大小，一般len设置为sizeof(str)；添加len参数的原因是因为要确保新添加的newStr追加到str后，str的长度不会溢出，保证了程序的安全，这样也方便开发工具做一个检查。<strong><code>注意：len也可以超出str字符数组的长度，但是这样做会出现奇奇怪怪的结果。</code></strong></p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    <span class="hljs-keyword">char</span> str[<span class="hljs-number">5</span>] = &#123;<span class="hljs-string">"abc"</span>&#125;;

    strcat_s(str, <span class="hljs-number">5</span>, <span class="hljs-string">"dd"</span>);  <span class="hljs-comment">//报错，程序崩溃，因为"abcdd"总共需要占用6个字节(即"dd\0"，因为还有个空字符表示字符串结尾)</span>

    strcat_s(str, <span class="hljs-number">5</span> , <span class="hljs-string">"d"</span>);  <span class="hljs-comment">//正常运行，输出结果为：abcd</span>

    printf_s(<span class="hljs-string">"%s"</span>,str);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">//-----------------------------------</span>

<span class="hljs-comment">//以下是len长度超出str长度的结果</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
       <span class="hljs-keyword">char</span> str[<span class="hljs-number">5</span>] = &#123;<span class="hljs-string">"abc"</span>&#125;;

       strcat_s(str, <span class="hljs-number">10</span>, <span class="hljs-string">"ddd"</span>);  <span class="hljs-comment">//如果我将len的值设置为10</span>

       printf_s(<span class="hljs-string">"%s\n"</span>,str);  <span class="hljs-comment">//输出结果为：abcddd</span>
       printf_s(<span class="hljs-string">"%d\n"</span>, <span class="hljs-keyword">sizeof</span>(str));  <span class="hljs-comment">//字符数组的大小还是5</span>
       printf_s(<span class="hljs-string">"%d\n"</span>, <span class="hljs-built_in">strlen</span>(str));  <span class="hljs-comment">//拼接后占用了6个字节大小的空间</span>
       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

注意：这里并没有报错，但是要明白，字符数组str只在内存中开辟了<span class="hljs-number">5</span>个字节大小的空间，那么该数组中也就只能存储<span class="hljs-number">4</span>个字节大小的数据(因为还要包括一个空字符的占用空间)，且已经放入了abc，即说明最多只能再放入一个数据，但是上面却显示输出了abcddd，那么为什么上面没有报错呢？那是因为数组中多出的两个元素占用了不该占用的别的内存的空间来满足自己的需要。在添加了ddd这个字符串之后，字符长度变为了<span class="hljs-number">6</span>，原本数组只能放<span class="hljs-number">4</span>个字符数据的，如今却放进去了<span class="hljs-number">6</span>个，就只能说明，多出的两个字符数据，占用了不该占用的其他内存空间，这是很危险的，假如别的内存空间中有数据，你占用了，就会出现不可预估的错误，所以一般才会将len的长度大小设置为<span class="hljs-keyword">sizeof</span>(str)，即数组本身的大小。</code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>日期函数：这一类函数主要对日期和时间进行操作，存在于time.h头文件中，所以使用时需要引用头文件time.h头文件。</p>
<ul>
<li><p>time(time_t seconds)：该函数用于获取自格林威治时间1970年1月1日00:00凌晨至现在所经过的秒数，如果seconds不为空，那么获取的秒数也会存储在time_t类型的指针变量seconds中；其中time_t类型其实就是long int类型，简单讲time函数的参数要传入一个long int类型的指针变量；</p>
</li>
<li><p>ctime_s()：将传入的时间转换成字符串基本语法格式：星期几 月份 天数 时:分:秒 年份；</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;

       <span class="hljs-keyword">time_t</span> myTime;  <span class="hljs-comment">//定义一个time_t类型的变量myTime</span>
       <span class="hljs-keyword">time_t</span>  a= &amp;myTime;  <span class="hljs-comment">//获取myTime的地址值，并存入time_t类型的指针变量a中</span>
       time(a);  <span class="hljs-comment">//调用函数获取到目前为止的时间秒数</span>
       printf_s(<span class="hljs-string">"%u"</span>, myTime/<span class="hljs-number">60</span>/<span class="hljs-number">60</span>/<span class="hljs-number">24</span>/<span class="hljs-number">365</span>);  <span class="hljs-comment">//将秒数转化成年数，结果为距今50年</span>

       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>数学函数：时间不够，暂时还未补充，有时间会补充上的。</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-22-预处理命令"><a href="#NO2-22-预处理命令" class="headerlink" title="NO2.22 预处理命令"></a>NO2.22 预处理命令</h3><p>使用库函数之前，应该用#include引入对应的头文件。</p>
<ul>
<li><p>预处理命令：</p>
<ul>
<li><p>定义：在编译之前对源文件进行简单加工的过程就称为预处理。C语言中的预处理命令主要以#号开头。预处理命令要放在所有函数之外，而且一般放在源文件前面。预处理命令由预处理程序完成；</p>
</li>
<li><p>作用：使得程序便于阅读，修改、移植和调试，也有利于模块化程序的设计。C语言提供了许多预处理功能。如，宏定义、文件包含、条件编译等的。</p>
</li>
<li><p>C语言常见的预处理命令：</p>
<ul>
<li><p>#：空指令，无任何效果，可以用来注释；</p>
</li>
<li><p>#include：包含一个源代码文件，即头文件。<code>如，#include&lt;stdio.h&gt;</code>；</p>
</li>
<li><p>#define：宏定义命令，即用一个标识符来表示一个数值(不局限于整数，也可以是字符串、字符、表达式等等)，并对程序中所有同样的标识符做替换，这种替换称为宏替换；宏定义分为两种：</p>
<ul>
<li>无参宏定义：<ul>
<li>基本语法格式：<code>#define 宏名 值</code>。<code>如，#define AGE 10，如果程序中还出现了AGE，那么都将会被替换成10</code>；</li>
</ul>
</li>
<li>带参宏定义：<ul>
<li>基本语法格式：<code>#define 宏名(参数1,参数2,...,参数n) 值</code>。<code>如，#define MAX(a,b) ((a)&gt;(b)?(a) : (b))，那么程序中的int c=MAX(5,3)，会被替换成int c=((5)&gt;(3)?(5) : (3))</code>。<strong><code>注意：带参宏定义尽量多用小括号。</code></strong></li>
</ul>
</li>
</ul>
</li>
<li><p>#undef：取消已定义的宏；</p>
</li>
<li><p>#if：如果给定条件为真，则编译下面代码；</p>
</li>
<li><p>#elif：如果#if条件不为真，那么当前条件就会为真，编译下面代码；</p>
</li>
<li><p>#ifdef：如果宏已经定义，则编译下面代码；</p>
</li>
<li><p>#ifndef：如果宏没有定义，则编译下面代码；</p>
</li>
<li><p>#endif：结束#if…到…#elif条件编译快。</p>
  <pre><code class="hljs c">拓展：宏定义和<span class="hljs-keyword">typedef</span>的区别
一、宏定义只是简单的值替换，由预处理器进行处理；而<span class="hljs-keyword">typedef</span>则是给原有的数据类型起一个新的名字，基本语法格式为：<span class="hljs-keyword">typedef</span> 原数据类型 新的类型名，且<span class="hljs-keyword">typedef</span>是在由编译器在编译阶段才进行处理。如，<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> INT32，表示给<span class="hljs-keyword">int</span>类型起了一个新名字为INT32。
   
    
拓展：带参宏定义和函教调用的区别。
一、调用发生的时间：
    <span class="hljs-number">1.</span>在源程序进行编译之前，即预处理阶段进行宏替换；
    <span class="hljs-number">2.</span>函数调用则发生在程序运行期间。

二、参数类型检查：
    <span class="hljs-number">1.</span>函数参数类型检查严格。程序在编译阶段，需要检查实参与形参个数是否相等及类型是否匹配或兼容，若参数个数不相同或类型不兼容，则会编译不通过；
    <span class="hljs-number">2.</span>在预处理阶段，对带参宏调用中的参数不做检查。即宏定义时不需要指定参数类型，既可以认为这是宏的优点，即适用于多种数据类型，又可以认为这是宏的一个缺点，即类型不安全。故在宏调用时，需要程序设计者自行确保宏调用参数的类型正确。

三、参数是否需要空间：
    <span class="hljs-number">1.</span>函数调用时，需要为形参分配空间，并把实参的值复制一份赋给形参分配的空间中。
    <span class="hljs-number">2.</span>宏替换，仅是简单的文本替换，且替换完就把宏名对应标识符删除掉，即不需要分配空间。

四、执行速度：
    <span class="hljs-number">1.</span>函数在编译阶段需要检查参数个数是否相同、类型等是否匹配等多个语法，且函数在运行阶段参数需入栈和出栈操作，速度相对较慢；
    <span class="hljs-number">2.</span>宏替换仅是简单文本替换，不做任何语法或逻辑检查。

五、代码长度：
    <span class="hljs-number">1.</span>由于宏替换是文本替换，即如果需替换的文本较长，则替换后会影响代码长度；
    <span class="hljs-number">2.</span>函数不会影响代码长度。故使用较频繁且代码量较小的功能，一般采用宏定义的形式，比采用函数形式更合适。</code></pre>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-23-VS2019的DEBUG调试"><a href="#NO2-23-VS2019的DEBUG调试" class="headerlink" title="NO2.23 VS2019的DEBUG调试"></a>NO2.23 VS2019的DEBUG调试</h3><p>debug模式，是我们常用来调试程序而使用的，简单讲就是查看程序是否有问题。</p>
<ul>
<li><p>VS2019中的debug模式的使用：</p>
<ul>
<li><p>首先，在需要断点(你想要查看的语句)的程序语句行号前双击即可，这样就可以打上断点了。<strong><code>注意：一般都是断点都是打在函数第一行有效的语句上。</code></strong></p>
</li>
<li><p>然后，按F5，开始调试，进入debug模式的页面，按F10可以每一行每一行的查看和执行程序的语句。</p>
<p>  <img src="./Image-c28.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <img src="./Image-c29.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <img src="./Image-c30.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-24-指针变量和指针数组"><a href="#NO2-24-指针变量和指针数组" class="headerlink" title="NO2.24 指针变量和指针数组"></a>NO2.24 指针变量和指针数组</h3><p>指针其实就是地址值；指针变量存储的是地址值。</p>
<ul>
<li><p>指针变量的使用：</p>
<ul>
<li><p>赋值：即可以把地址赋给指针变量；</p>
</li>
<li><p>解引用：与*运算符一起使用，给出指针变量中存放的地址所指向的变量对应的值；<strong><code>注意：*无法用在字符串字面量前面来解引用。如，char* str =&quot;abc&quot;，那么*str就会报错，因为字符串本身就比较特殊，即字符串本身是字符数组，而数组本身就是指针变量，所以使用转换说明“%s”输入字符串时，不需要在str前面加上*号来解引用。</code></strong></p>
</li>
<li><p>取址：与&amp;运算符一起使用，给出指针变量本身的地址值，然后赋值给另一个指针变量；</p>
</li>
<li><p>指针变量与整数相加：即地址值与整数相加，得出初始地址与整数相加的结果地址值；</p>
</li>
<li><p>递增指针变量：一般用在数组上，地址值指向下一个数组元素的地址上；</p>
</li>
<li><p>递减指针变量：一般用在数组上，地址值指向上一个数组元素的地址上；</p>
</li>
<li><p>指针变量求差：一般用在数组上，地址值相减，得出两个元素之间的距离；</p>
</li>
<li><p>指针变量比较：比较的是两个指针中地址所指向的值。</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-comment">//指针变量自增与自减</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;

    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;
    <span class="hljs-keyword">int</span>* arrp = &amp;arr;

    arrp++;  <span class="hljs-comment">//appr原本指向arr[0]的地址值，指针变量自增后，指向了a[1]的地址值</span>
    printf_s(<span class="hljs-string">"%d\n"</span>, *arrp);  <span class="hljs-comment">//与arr[1]元素的值相同</span>
    printf_s(<span class="hljs-string">"%d\n"</span>, arr[<span class="hljs-number">1</span>]);

    arrp--;  <span class="hljs-comment">//指针变量自减</span>
    printf_s(<span class="hljs-string">"%d"</span>, *arrp);  <span class="hljs-comment">//与arr[0]元素的值相同</span>
    printf_s(<span class="hljs-string">"%d\n"</span>, arr[<span class="hljs-number">0</span>]);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">//------------------------------</span>

<span class="hljs-comment">//指针变量求差</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;

       <span class="hljs-keyword">int</span> arr[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;
       <span class="hljs-keyword">int</span> arrp = &amp;arr;

       printf_s(<span class="hljs-string">"%p\n"</span>, &amp;(arr[<span class="hljs-number">1</span>])-arrp);  <span class="hljs-comment">//输出结果为0000000001</span>
       printf_s(<span class="hljs-string">"%d\n"</span>, &amp;(arr[<span class="hljs-number">1</span>]) - arrp);  <span class="hljs-comment">//输出结果为1</span>

       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>指针数组：</p>
<ul>
<li><p>定义：即数组中存储的元素都是指向同一数据类型的指针变量；</p>
</li>
<li><p>基本语法格式：<code>数据类型* 数组名[size]或数据类型 *  数组名[size]，两者均可</code>。<code>如，int * ptr[5]与int* ptr[5]相同</code>。<strong><code>注意：多重指针的实质是：使用一个指针变量a来存放另一个指针变量b本身的地址，而b存放的则是另一个变量的地址值。</code></strong></p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
<span class="hljs-keyword">int</span>* ap = &amp;a;

<span class="hljs-keyword">int</span>** app = &amp;ap;  <span class="hljs-comment">//这就是多重指针，指向的是指针变量ap的地址，而指针变量ap存放的是变量a的地址值，说白了多重指针就是一个指针变量的多层嵌套</span></code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-25-函数指针和回调函数"><a href="#NO2-25-函数指针和回调函数" class="headerlink" title="NO2.25 函数指针和回调函数"></a>NO2.25 函数指针和回调函数</h3><p>代码中如果有函数的定义，那么系统也会在栈空间分配一块内存给这个函数，即这段存储空间的首地址称为这个函数的地址；函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。</p>
<ul>
<li><p>函数指针：</p>
<ul>
<li><p>定义：指向函数地址的指针变量就称为函数指针变量，也成为函数指针；</p>
</li>
<li><p>基本语法格式：<code>函数返回值类型 (* 指针变量名) (函数参数列表)</code>。其中，“函数返回值类型”表示该指针变量指向的函数具有什么返回值类型，“函数参数列表”表示该指针变量指向的函数具有什么参数列表。这个参数列表中可以只写形参的数据类型，也可以带上形参名。我们看到，函数指针的定义就是将“函数声明”中的“函数名”改成“(* 指针变量名)”。<strong><code>注意：函数指针中的()不可以省略。</code></strong></p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>;   <span class="hljs-comment">//声明一个函数</span>
<span class="hljs-keyword">int</span> (*p) (<span class="hljs-keyword">int</span> x);  <span class="hljs-comment">//定义一个函数指针</span>
p = Func;          <span class="hljs-comment">//将Func函数的首地址赋给指针变量p</span>

<span class="hljs-comment">//------------------------------------------------------</span>

<span class="hljs-comment">//函数的调用</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>;  <span class="hljs-comment">//声明了一个函数</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;  <span class="hljs-comment">//函数的实现</span>
       <span class="hljs-keyword">return</span> a + b;
&#125;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;

       <span class="hljs-keyword">int</span> (*ptr) (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) = getSum;  <span class="hljs-comment">//声明了一个函数指针ptr，并将getSum函数赋值给了该函数指针ptr；函数指针还可以写成int (*ptr) (int ,int)，即省略形参名，但必须写形参数据类型</span>

       <span class="hljs-keyword">int</span> res = (*ptr) (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">//通过调用函数指针来调用函数</span>
       printf_s(<span class="hljs-string">"%d"</span>,res);

       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>回调函数：就是将函数指针当作一个参数传入别人的函数中，这样别就可以通过函数指针调用你的函数了。<strong><code>注意：函数指针作为参数进行传递时，如果函数指针中带有参数，那么需要将参数取出来，也当做参数进行传递。</code></strong></p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSumA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> (*ptr) ())</span></span>;  <span class="hljs-comment">//声明了一个函数getSumA，其参数要传入一个函数指针变量，该函数指针中带有参数，所以将参数a、b取出来，也当做getSumA的参数进行传递，也就是说，这个函数指针变量原先是这样的：int (*ptr) (int a,int b)</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSumA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> (*ptr) ())</span> </span>&#123;  <span class="hljs-comment">//getSumA函数的实现</span>
       <span class="hljs-keyword">return</span> ptr (a, b);  <span class="hljs-comment">//实际调用的是ptr这个函数指针，而我定义ptr这个函数指针其实就是getSumB的函数指针</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSumB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;  <span class="hljs-comment">//又声明了一个函数getSumB</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSumB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;  <span class="hljs-comment">//getSumB函数的实现</span>
       <span class="hljs-keyword">return</span> a + b;
&#125;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;

       <span class="hljs-keyword">int</span> (*p) (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) = getSumB;  <span class="hljs-comment">//为getSumB创建了一个函数指针</span>

       <span class="hljs-keyword">int</span> res = getSumA(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,p);  <span class="hljs-comment">//调用getSumA</span>

       printf_s(<span class="hljs-string">"%d"</span>,res);

       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;



输出结果为：<span class="hljs-number">3</span></code></pre>

</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-26-C程序的不同数据的内存分配"><a href="#NO2-26-C程序的不同数据的内存分配" class="headerlink" title="NO2.26 C程序的不同数据的内存分配"></a>NO2.26 C程序的不同数据的内存分配</h3><p>C程序中，针对不同的数据，存放的位置也不一样。</p>
<ul>
<li>在C/C++中内存分为5个区，分别为栈区、堆区、全局/静态存储区、常量存储区、代码区。按内存分配类型划分为：<ul>
<li>静态内存分配：编译时分配。包括：全局变量、静态全局变量、静态局部变量这三种；</li>
<li>动态内存分配：运行时分配。包括：<ul>
<li>栈(stack)：局部变量；</li>
<li>堆(heap)：C语言中用到的临时数据被动态的分配在内存中。需要时随时开辟，不需要时及时释放。<code>如，malloc或calloc、realloc、free函数)</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>栈区、堆区、全局/静态存储区、常量存储区、代码区的详细介绍：<ul>
<li>栈区(stack)：<ul>
<li>定义：指那些由编译器在需要的时候分配，不需要时自动清除的变量所在的储存区。<code>如，函数执行时，函数的形参以及函数内的局部变量分配在栈区，函数运行结束后，形参和局部变量自动释放</code>；</li>
<li>优缺点：栈内存分配效率高但是分配的内存空间有限。</li>
</ul>
</li>
<li>堆区(heap)：<ul>
<li>定义：指那些由程序员手动分配或释放的储存区；</li>
<li>优缺点：如果程序员不释放这块内存，内存将一直被占用，直到程序运行结束由系统自动收回。C语言中使用malloc，free申请和释放空间。</li>
</ul>
</li>
<li>静态储存区(static)：<ul>
<li>定义：存储全局变量和静态变量(包括静态局部变量、静态全局变量)的内存区域；</li>
<li>优缺点：这块空间当程序运行结束后由系统释放。</li>
</ul>
</li>
<li>常量储存区(const)：<ul>
<li>定义：常量字符串就是储存在这里的。<code>如，“ABC”字符串就储存在常量区，但储存在常量区的只读不可写</code>。另外const修饰的全局变量也储存在常量区，const修饰的局部变量依然在栈上。</li>
</ul>
</li>
<li>程序代码区：<ul>
<li>定义：存放源程序的二进制代码。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>堆与栈的对比：<ul>
<li>申请方式：<ul>
<li>栈由编译器管理；</li>
<li>堆的分配和释放由程序员管理。</li>
</ul>
</li>
<li>申请大小：<ul>
<li>栈是向低地址生长的数据结构，是一块连续的内存，能从栈中获得的内存较小，编译期间确定大小；</li>
<li>堆是向高地址生长的数据结构，是一个不连续的储存空间，，内存获取比较灵活，也较大。</li>
</ul>
</li>
<li>栈与堆中的储存内容：<ul>
<li>栈：在函数调用时，第一个进栈的是主函数中的最后一条指令的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量(静态变量是不入栈的)，当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点开始运行；</li>
<li>堆：一般是在堆的头部用一个字节存放堆的大小，堆中的具体内容由程序员安排。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>动态内存分配使用的函数。<strong><code>注意：下面的四个函数是放在stdlib.h头文件中。下面参数中的size_t其实就是在32位架构中被普遍定义为：unsigned int，而在64位架构中被普遍定义为：unsigned long；C99标准中，定义了void为无类型指针，即只表示一个地址，不指向任何具体的对象，说白了，void就指向一个纯地址值，且该地址不指向任何数据；堆内存，尽量不要分配大量的小内存块，且分配的内存用过后尽快释放。</code></strong><ul>
<li>malloc函数：<ul>
<li>函数原型：void  * malloc (size_ t size)；</li>
<li>功能：<ul>
<li>开辟一块size大小的连续堆内存；</li>
<li>size表示堆上所开辟内存的大小，单位是字节数；</li>
<li>函数返回值是一个指针，指向刚刚开辟的内存中第一个字节的地址；</li>
<li>如果开辟内存失败，返回一个空指针，即返回值为NULL；</li>
<li>当内存不再使用时，应使用free()函数将内存块释放；</li>
<li>使用时必须包含头文件&lt;stdlib.h&gt;或&lt;malloc.h&gt;。</li>
</ul>
</li>
</ul>
</li>
<li>calloc函数：<ul>
<li>函数原型：void  calloc(size_ t n, size t size)；</li>
<li>功能：<ul>
<li>在内存的动态存储区中分配n个长度为size的连续空间，即分配nsize大小的堆内存空间，该函数开辟的空间一般比较大；</li>
<li>函数返回一个指向分配空间的起始地址的地址；</li>
<li>如果分配不成功，返回NULL；</li>
<li>当内存不再使用时，应使用free()函数将内存块释放；</li>
<li>使用时必须包含头文件&lt;stdlib.h&gt;或&lt;malloc.h&gt;。</li>
</ul>
</li>
</ul>
</li>
<li>realloc函数：<ul>
<li>函数原型：void  realloc(void  mem_address, size_ t newsize)；</li>
<li>功能：<ul>
<li>为已有内存(即使用malloc或calloc函数开辟的空间)重新分配新的内存大小(可大、可小)；</li>
<li>先判断当前的指针是否有足够的连续空间，如果有，扩大mem_address指向的地址，并且将mem_ address返回；如果空间不够，先按照newsize指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来mem_address所指内存区域(注意：原来指针是自动释放，不需要使用free)，同时返回新分配的内存区域的首地址。即重新分配存储器块的地址；</li>
<li>如果重新分配成功则返回指向被分配内存的指针；</li>
<li>如果分配不成功，返回NULL；</li>
<li>当内存不再使用时，应使用free()函数将内存块释放；</li>
<li>使用时必须包含头文件&lt;stdlib.h&gt;或&lt;malloc.h&gt;。</li>
</ul>
</li>
</ul>
</li>
<li>free函数：<ul>
<li>函数原型： void free (void ptr)，ptr为要释放的内存指针；</li>
<li>free()：释放指针变量在堆区上的内存空间，不能释放栈上的内存空间，free要与malloc(calloc、realloc)成对使用。注意：如果malloc(calloc、realloc) 比 free 多， 会造成内存泄漏；如果malloc(calloc、realloc) 比 free 少，会造成二次删除， 破坏内存，导致程序崩溃。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-27-结构体和共用体"><a href="#NO2-27-结构体和共用体" class="headerlink" title="NO2.27 结构体和共用体"></a>NO2.27 结构体和共用体</h3><p>在C语言中，可以使用结构体(Struct)来存放一组不同类型的数据，即结构体中存放的数据，可以是不同数据类型的意思。</p>
<ul>
<li><p>结构体：</p>
<ul>
<li><p>定义：就是把其他各种数据类型组合起来，构成另一个新的数据类型以方便使用，说白了就是用来存放不同类型数据的另一个数据类型而已；这些成员会占用不同的内存，且不会互相影响；</p>
<ul>
<li><p>基本语法格式：</p>
<p>  例如：</p>
<pre><code><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名&#123;</span>  <span class="hljs-comment">//结构体面一般首字母大写。如，Cat、Student等等</span>

    结构体所包含的变量或数组或指针或结构体等等

&#125;;

如：
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>&#123;</span>

    <span class="hljs-keyword">char</span> name;  <span class="hljs-comment">//姓名</span>
    <span class="hljs-keyword">int</span> num;  <span class="hljs-comment">//学号</span>
    <span class="hljs-keyword">int</span> age;  <span class="hljs-comment">//年龄</span>
    <span class="hljs-keyword">char</span> group;  <span class="hljs-comment">//所在学习小组</span>
    <span class="hljs-keyword">float</span> score;  <span class="hljs-comment">//成绩</span>
&#125;</code></pre></code></pre></li>
<li><p>结构体变量：既然结构体是一种数据类型，那么就可以用它来定义变量；</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名&#123;</span>

    结构体所包含的变量或数组或指针或结构体等等

&#125; 结构体变量名<span class="hljs-number">1</span>, 结构体变量名<span class="hljs-number">2.</span>...;  <span class="hljs-comment">//定义结构体的同时，还创建了结构体变量</span>

注意：还可以使用匿名结构体方式创建结构体变量
<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>  
    结构体所包含的变量或数组或指针或结构体等等
&#125; 结构体变量名<span class="hljs-number">1</span>, 结构体变量名<span class="hljs-number">2.</span>...;  <span class="hljs-comment">//定义结构体的同时，还创建了结构体变量</span>
注意：此时创建的结构体是没有名称的，只能使用上面的方式创建，要是还想再使用，必须重新创建
    
<span class="hljs-comment">//-----------------------------------------</span>
    
<span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名 结构体变量名;</span>  <span class="hljs-comment">//该方式要求结构体已经创建好，否则会报错   </span>

如：
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">st1</span>;</span>  <span class="hljs-comment">//定义了一个Student类型的变量st1</span></code></pre>

<ul>
<li><p>结构体变量，能够调用自己结构体内所用于的成员；</p>
<p>  例如：</p>
  <pre><code class="hljs c">结构体变量.成员名称

如：
st1.name
st1.age</code></pre>
</li>
<li><p>结构体变量内的成员也能够被赋值。</p>
<p>  例如：</p>
  <pre><code class="hljs c">方式一赋值：    
结构体变量.成员名称 = 值
    
<span class="hljs-comment">//-----------------------</span>

方式二赋值：    
struct 结构体名&#123;

    结构体所包含的变量或数组或指针或结构体等等

&#125; 结构体变量名<span class="hljs-number">1</span> = &#123;值<span class="hljs-number">1</span>,值<span class="hljs-number">2.</span>...&#125;, 结构体变量名<span class="hljs-number">2</span>= &#123;值<span class="hljs-number">1</span>,值<span class="hljs-number">2.</span>...&#125;....;</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>共用体：</p>
<ul>
<li><p>定义：和结构体很类似，也是用于存储其他数据类型的一个数据类型，但和结构体不同的是，共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员；共用体占用的内存等于最长的成员占用的内存；共用体也成为联合或联合体；共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉；</p>
<ul>
<li><p>基本语法格式：</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-keyword">union</span> 共用体名&#123;
    成员列表
&#125;;

如：
<span class="hljs-keyword">union</span> stu&#123;
    <span class="hljs-keyword">char</span> name;  <span class="hljs-comment">//char占用1个字节</span>
    <span class="hljs-keyword">int</span> age;  <span class="hljs-comment">//int类型占用4个字节，所以该共用体占用的内存为4，即以最长数据类型占用的内存为共用体的占用内存</span>
&#125;</code></pre>
</li>
<li><p>共用体变量也可以创建变量；</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-keyword">union</span> 共用体名&#123;
    成员列表
&#125;  共用体变量<span class="hljs-number">1</span>,共用体变量<span class="hljs-number">2.</span>...;  <span class="hljs-comment">//这里定义了共用体的同时还定义了共用体变量</span>

注意：还可以使用匿名结构体方式创建共用体变量
<span class="hljs-keyword">union</span> &#123;  
    结构体所包含的变量或数组或指针或结构体等等
&#125; 共用体变量名<span class="hljs-number">1</span>, 共用体变量名<span class="hljs-number">2.</span>...;  <span class="hljs-comment">//定义共用体的同时，还创建了结构体变量</span>
此时创建的共用体是没有名称的，只能使用上面的方式创建，要是还想再使用，必须重新创建
    
<span class="hljs-comment">//-------------------------------------------</span>
  
<span class="hljs-keyword">union</span> 共用体名 共用体变量名;</code></pre>
</li>
<li><p>共用体变量的成员也能够被赋值；</p>
<p>  例如：</p>
  <pre><code class="hljs c">结共用体变量.成员名称 = 值</code></pre>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-28-文件处理"><a href="#NO2-28-文件处理" class="headerlink" title="NO2.28 文件处理"></a>NO2.28 文件处理</h3><p>在操作系统中，为了统一对各种硬件的操作，简化接口，不同的硬件设备也都被看成一个文件。对这些文件的操作，等同于对磁盘上普通文件的操作。<code>如，通常把显示器称为标准输出文件，printf就是向这个文件输出数据；通常把键盘称为标准输入文件，scanf就是从这个文件读取数据等等</code>。</p>
<ul>
<li><p>按照文件数据流的走向可分为：</p>
<ul>
<li><p>输入流：数据从文件复制到内存的过程。也称为读文件；<strong><code>注意：EOF：指的是end of file，表示文件末尾，且在头文件stdio.h中已经定义好了EOF的值为-1。getchar()和scanf_s()函数检测到文件结尾时，这两个函数都返回EOF，所以C中使用EOF来当做I/O的结尾条件。</code></strong></p>
</li>
<li><p>输出流：从内存保存到文件的过程。也称为写文件。</p>
<p>  <img src="./Image-c31.png" srcset="/img/loading.gif" alt="Image"></p>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>C语言常见的其他输入和输出函数：</p>
<ul>
<li><p>getchar()和putchar()函数：</p>
<ul>
<li><p>int getchar(void)：用于获得用户输入的字符，等价于scanf_s(“%c”,&amp;ch)；</p>
</li>
<li><p>int putchar(int c)：输出放入函数中的字符，即putchar(‘字符’)，等价于printf_s(“%c”,ch)。<strong><code>注意：getchar()和putchar()函数这两个函数在stdio.h头文件中。</code></strong></p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>
<span class="hljs-function"></span>&#123;
     <span class="hljs-keyword">char</span> c = getchar();  <span class="hljs-comment">//等价于scanf_s("%c",&amp;c);</span>

    <span class="hljs-built_in">putchar</span>(c);  <span class="hljs-comment">//等价于printf_s("%c", c);</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
</li>
</ul>
</li>
<li><p>gets_s()和puts()函数：</p>
<ul>
<li><p>char gets(char s,size_t size)：读取输入的字符串，直至接收到换行符或EOF时停止，其中size为允许输入的长度，一般长度为字符数组s的长度减1。读入成功时，返回接收读取结果的字符数组的首地址，读入发生错误或遇到EOF返回NULL；</p>
</li>
<li><p>int puts(const char s)：输出字符串并换行。该函数只能输出字符串，不能输出其他类型数值；执行成功返回非负数，执行失败返回EOF。</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;

       <span class="hljs-keyword">char</span> arr[<span class="hljs-number">3</span>];
       gets_s(arr, <span class="hljs-keyword">sizeof</span>(arr) - <span class="hljs-number">1</span>);  <span class="hljs-comment">//如果输入的arr超出了后面的size的话，那么会报错</span>

       <span class="hljs-built_in">puts</span>(arr);

       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>


</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>操作文件的正确流程为：打开文件 –&gt; 读写文件 –&gt; 关闭文件。文件在进行读写操作之前要先打开，使用完毕要关闭。打开文件和关闭文件的函数如下：<ul>
<li>errno_t fopen(FILE p,char filename, char mode)函数：用于打开文件。函数中的filename字符串参数，表示要打开的文件的文件名(包括文件路径)，如果文件名存在就是打开文件，不存在该文件名就创建一个新文件，以该文件名命名并打开。该函数在&lt;stdio.h&gt;头文件中；mode字符串参数表示要以什么权限打开文件。<strong><code>注意：如果文件打开失败会返回非0，成功返回0。</code></strong>具体权限如下所示：<ul>
<li><code>&quot;r&quot;</code>：以“只读”方式打开文件。只允许读取，不允许写入。文件必须存在，否则打开失败；</li>
<li><code>&quot;w&quot;</code>：以“写入”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容(相当于删除原文件，再创建一个新文件)；</li>
<li><code>&quot;a&quot;</code>：以“追加”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾(文件原有的内容保留)；</li>
<li><code>&quot;r+&quot;</code>：以“读写”方式打开文件。既可以读取也可以写入，也就是随意更新文件。文件必须存在，否则打开失败；</li>
<li><code>&quot;w+&quot;</code>：以“写入/更新”方式打开文件，相当于w和r+叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容(相当于删除原文件，再创建一个新文件)；</li>
<li><code>&quot;a+&quot;</code>：以“追加/更新”方式打开文件，相当于a和r+叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾(文件原有的内容保留)。</li>
<li><code>&quot;t&quot;</code>：表示文本文件。如果不写，默认为”t”；<strong><code>注意：该选项一般放在上面读写权限的后面。</code></strong></li>
<li><code>&quot;b&quot;</code>：表示二进制文件。<strong><code>注意：如果打开的是二进制文件，那么一定要加“b”；该选项一般放在上面读写权限的后面，如，a+b、r+b等等。</code></strong></li>
</ul>
</li>
<li>int fclose(FILE fp)函数：文件一旦使用完毕，应该用fclose()函数把文件关闭，以释放相关资源，避免数据丢失。文件正常关闭时，fclose()的返回值为0，如果返回非零值则表示有错误发生。</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>读写文件相关的函数：</p>
<ul>
<li><p>读写一个字符：</p>
<ul>
<li>int fgetc (FILE fp)函数：从指定的文件中读取一个字符。参数fp为文件指针。fgetc()读取成功时返回读取到的字符，读取到文件末尾或读取失败时返回EOF。</li>
<li>int fputc(int ch, FILE fp )函数：向指定的文件中写入一个字符。参数ch为要写入的字符，参数fp为文件指针。fputc()写入成功时返回写入的字符，失败时返回 EOF，返回值类型为int也是为了容纳这个负数。</li>
</ul>
</li>
<li><p>读写一个字符串：</p>
<ul>
<li>char fgets(char str, int n, FILE fp )：从指定的文件中读取一个字符串，并保存到字符数组中。参数str为字符数组，参数n为要读取的字符数目，参数fp为文件指针。读取成功时返回字符数组首地址，也即str；读取失败时返回 NULL；如果开始读取时文件内部指针已经指向了文件末尾，那么将读取不到任何字符，也返回NULL。</li>
<li>int fputs(char str, FILE fp )：向指定的文件写入一个字符串。参数str为要写入的字符串，参数fp为文件指针。写入成功返回非负数，失败返回EOF。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="NO2-29-缓冲I-O和无缓冲I-O"><a href="#NO2-29-缓冲I-O和无缓冲I-O" class="headerlink" title="NO2.29 缓冲I/O和无缓冲I/O"></a>NO2.29 缓冲I/O和无缓冲I/O</h3><p>C中输入分为缓冲输入和无缓冲输入两种。</p>
<ul>
<li>缓冲I/O：通俗的理解为当用户输入之后，直到按回车键为止，期间用户输入的内容会存放在一个缓冲区里面。首先，把若干字符作为一个块进行传输比逐个发送这些字符节约时间。其次，如果用户打错字符，可以直接通过键盘修正错误。当最后按下Enter键时，传输的是正确的输入。缓冲分为两类：完全缓冲I/O和行缓冲I/O。<strong><code>注意：ANSI C和后续的C标准都规定输入是缓冲的。</code></strong><ul>
<li>完全缓冲I/O：指的是当缓冲区被填满时才刷新缓冲区，通常出现在文件输入中。缓冲区的大小取决于系统，常见的大小是512字节和4096字节；</li>
<li>行缓冲I/O：指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区。行缓冲函数有getchar()和scanf_s()。</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ul>
<li><p>无缓冲I/O：说白了，就是你输入什么，它都能立马给你执行函数后面的内容。看电脑是否支持无缓冲I/O，如果支持，那么编译器添加&lt;conio.h&gt;这个头文件后，有两个无缓冲的函数：_getche()函数和_getch()函数，前者会回显用户的输入到屏幕上，而后者不会回显用户的输入到屏幕上。</p>
<p>  例如：</p>
  <pre><code class="hljs c"><span class="hljs-comment">//测试_getche()函数和_getch()函数，代码如下</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;conio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;

	<span class="hljs-keyword">char</span> ch;

	<span class="hljs-keyword">while</span> ((ch = _getche()) != <span class="hljs-string">'8'</span>) &#123;
    	<span class="hljs-built_in">putchar</span>(<span class="hljs-string">'t'</span>);
	&#125;

	/<span class="hljs-keyword">while</span> ((ch = _getch()) != <span class="hljs-string">'8'</span>) &#123;
    	<span class="hljs-built_in">putchar</span>(<span class="hljs-string">'t'</span>);
	&#125;/

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<p>  <img src="./Image-c32.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <code>说明：测试_getche()函数，分别输入1、2、3，返回如上结果，有回显用户的输入。</code></p>
<p>  <img src="./Image-c33.png" srcset="/img/loading.gif" alt="Image"></p>
<p>  <code>说明：测试_getch()函数，分别输入1、2、3，返回如上结果，没有回显用户的输入。</code></p>
</li>
</ul>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/1-%EB%8C%80%ED%95%99%EA%B5%90-%EC%9D%BC-%ED%95%99%EB%85%84/">1.대학교 일 학년</a>
                    
                      <a class="hover-with-bg" href="/categories/1-%EB%8C%80%ED%95%99%EA%B5%90-%EC%9D%BC-%ED%95%99%EB%85%84/02-C%E8%AF%AD%E8%A8%80/">02.C语言</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%A4%A7%E4%B8%80%E8%AF%BE%E7%A8%8B/">大一课程</a>
                    
                      <a class="hover-with-bg" href="/tags/C%E8%AF%AD%E8%A8%80/">C语言</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/06/28/Docker--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">01.Docker--学习笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                        <span class="hidden-mobile">01.计算机科学导论--学习笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "01.C语言--学习笔记&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
